<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ohmyhsy</title>
  
  <subtitle>庸人自扰</subtitle>
  <link href="https://8bytes.top/atom.xml" rel="self"/>
  
  <link href="https://8bytes.top/"/>
  <updated>2022-06-27T14:59:38.348Z</updated>
  <id>https://8bytes.top/</id>
  
  <author>
    <name>Box</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hstring</title>
    <link href="https://8bytes.top/2022/06/23/hstring/"/>
    <id>https://8bytes.top/2022/06/23/hstring/</id>
    <published>2022-06-23T13:36:16.000Z</published>
    <updated>2022-06-27T14:59:38.348Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>有了基本的构造函数、拷贝函数、析构函数<br>可以自己试着写个丐版的string。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><ol><li>hstring str(“哈哈哈”);   &#x2F;&#x2F;构造函数</li><li>hstring strA(str);      &#x2F;&#x2F;拷贝函数</li></ol><pre><code class="cpp">#pragma onceclass hstring&#123;public:    hstring()&#123;    &#125;    hstring(const hstring &amp;hs)&#123;    &#125;    ~hstring()&#123;    &#125;&#125;;</code></pre><p>大概框架就是这样，但是要注意，套string就没意思了。<br>char或者char*的话要注意内存分配的事。</p><p>想了下大概是char*比较合适，毕竟初始化的时候鬼知道这个字符串多长。<br>然后提到长度，还要写个成员变量，和成员函数去统计出这个长度。</p><hr><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><pre><code class="cpp">#pragma onceclass hstring&#123;private:    char *c_str;    unsigned int len;    unsigned int Length(const char *hs)&#123;        while (hs[this-&gt;len++]);        return this-&gt;len;    &#125;public:    hstring()&#123;        this-&gt;len = 0;    &#125;    hstring(const char* hs)&#123;        c_str = new char[Length(hs)];        for (int i = 0; i &lt; this-&gt;len; i++)&#123;            c_str[i] = hs[i];        &#125;    &#125;    char *toShow()&#123;        return c_str;    &#125;    unsigned int toLength()&#123;        return this-&gt;len;    &#125;    ~hstring()&#123;        delete[] c_str;    &#125;&#125;;</code></pre><pre><code class="cpp">#include&lt;iostream&gt;#include&quot;hstring.h&quot;int main()&#123;    hstring str(&quot;hahah&quot;);    std::cout &lt;&lt; str.toShow() &lt;&lt; std::endl;    return 0;&#125;</code></pre><p>因为没涉及到重载，只能通过成员函数先打印将就一下了。</p><img src="/2022/06/23/hstring/000.png" class=""><p>结果也是ok的，至于那个toLength是因为我记得string好像也有个调用可以显示长度的方法，就干脆放在public下面调用得了。<br>至于len本质上是存放长度肯定不希望被其他人调用就放在私有里面，然后Length的话，本质上跟sizeof有点相似，它会计算字符串结尾的<code>\0</code>，想要strlen的效果就让返回值-1就行了。</p><img src="/2022/06/23/hstring/001.png" class=""><p>至于中文占2个字节的问题先不考虑。</p><img src="/2022/06/23/hstring/002.png" class=""><p>到这里构造没啥事了，下面就是拷贝的问题。</p><hr><h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><p>拷贝就难在没有[]重载运算。hstring是自己定义的类。<br>你要想让<code>hstring strA(str);</code> 还要注意不能让两个地址相同，不然前面的被释放了，后面的就无效了。</p><pre><code class="cpp">hstring(const hstring &amp;hs)&#123;    c_str = hs;&#125;</code></pre><p>这样肯定行不通，c_str是char*类型，hs是hstirng类型的，强转上逻辑也不对，因为没有调出hs.c_str这种东西。</p><p>使用列表传递的话，就要再次调用toShow函数，但是这里的hs是const类型，所以toShow也要加上const</p><pre><code class="cpp">hstring(const hstring &amp;hs):hstring(hs.toShow())&#123;    //c_str = hs;&#125;char *toShow() const&#123;    return c_str;&#125;</code></pre><p>这样编译是通过了，但是要看看效果。</p><img src="/2022/06/23/hstring/003.png" class=""><p>看到效果ok。</p><hr><h2 id="印证"><a href="#印证" class="headerlink" title="印证"></a>印证</h2><p>最后无非就是印证销毁的时候strA还是不是正常的。<br>这个讲道理是不好印证的，因为str先声明的，strA后声明的，你也没办法指定它执行析构函数，这个还是由编译器认的。</p><p>所以顺序上没法印证，那就只能通过改变str，查看strA的结果还是否相同，去印证是不是一个内存地址。</p><pre><code class="cpp">void toRemake(const char *hs)&#123;    delete[] c_str;    c_str = new char[Length(hs)];    for (int i = 0; i &lt; this-&gt;len; i++)&#123;        c_str[i] = hs[i];    &#125;&#125;</code></pre><p>还是老样子传递const char*, 然后先释放原有的内存，因为不能保证c_str是否之前分配过了，然后在赋予新的内存。老样子循环抄写hs，这里用不用memcpy都随便。</p><img src="/2022/06/23/hstring/004.png" class=""><p>效果不同，说明strA和str使用的不是同一个内存。</p><hr><h2 id="完整的hstring-h"><a href="#完整的hstring-h" class="headerlink" title="完整的hstring.h"></a>完整的hstring.h</h2><pre><code class="cpp">#pragma once#include&lt;iostream&gt;class hstring&#123;private:    char *c_str;    unsigned int len=0;    unsigned int Length(const char *hs)&#123;        while (hs[this-&gt;len++]);        return this-&gt;len;    &#125;public:    hstring()&#123;    &#125;    hstring(const char* hs)&#123;        c_str = new char[Length(hs)];        for (int i = 0; i &lt; this-&gt;len; i++)&#123;            c_str[i] = hs[i];        &#125;    &#125;    hstring(const hstring &amp;hs):hstring(hs.toShow())&#123;        //c_str = hs;    &#125;    char *toShow() const&#123;        return c_str;    &#125;    unsigned int toLength()&#123;        return this-&gt;len;    &#125;    void toRemake(const char *hs)&#123;        delete[] c_str;        c_str = new char[Length(hs)];        for (int i = 0; i &lt; this-&gt;len; i++)&#123;            c_str[i] = hs[i];        &#125;    &#125;    ~hstring()&#123;        delete[] c_str;    &#125;&#125;;</code></pre><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>优化空间肯定还有的，重载就是一个点。<br>还有就是功能上还是丐版阶段。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;有了基本的构造函数、拷贝函数、析构函数&lt;br&gt;可以自己试着写个丐版的string。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://8bytes.top/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>析构函数</title>
    <link href="https://8bytes.top/2022/06/23/destructor/"/>
    <id>https://8bytes.top/2022/06/23/destructor/</id>
    <published>2022-06-23T12:55:23.000Z</published>
    <updated>2022-06-27T13:32:00.505Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>构造函数是在类对象创建时就调用，一般的用途就是初始化对象。<br>而析构函数相反，它是在类的对象结束生命周期才自动执行，一般就是清理之类的，最常见就是释放掉new的空间</p><span id="more"></span><p>格式也挺特殊，是在类名前加一个<code>~</code><br>全称：<code>~类名()&#123;&#125;</code></p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>析构函数名也应与类名相同，只是在函数名前面加一个位取反符<del>，例如</del>stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。——百度</p><p>这个析构主要就是应对动态分配的内存，需要手动销毁，因为其它的成员变量该结束编译器会自动处理掉。</p><pre><code class="cpp">#include&lt;iostream&gt;class Box&#123;public:    Box()&#123;        std::cout &lt;&lt; &quot;默认构造函数执行&quot; &lt;&lt; std::endl;    &#125;    ~Box()&#123;        std::cout &lt;&lt; &quot;析构函数执行&quot; &lt;&lt; std::endl;    &#125;&#125;;int main()&#123;    Box box;    return 0;&#125;</code></pre><img src="/2022/06/23/destructor/000.png" class=""><p>看到实例化一个类的时候他就会顺序执行构造函数和析构函数。</p><p>这样可能不够直观，因为就之创建了一个类，可以简单在main函数里输出点什么。</p><pre><code class="cpp">int main()&#123;    Box box;    std::cout &lt;&lt; &quot;hhhh&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;hhhh&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;hhhh&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;hhhh&quot; &lt;&lt; std::endl;    return 0;&#125;</code></pre><img src="/2022/06/23/destructor/001.png" class=""><p>也就是说当这个程序即将结束时，它会自动调用类中的析构函数，释放掉该释放的东西，当然这里因为还没动态分配只是做个示范。</p><pre><code class="cpp">class Box&#123;public:    int *ch;    Box()&#123;        ch = new int[100];        std::cout &lt;&lt; &quot;默认构造函数执行&quot; &lt;&lt; std::endl;    &#125;    ~Box()&#123;        delete[] ch;        std::cout &lt;&lt; &quot;析构函数执行&quot; &lt;&lt; std::endl;    &#125;&#125;;</code></pre><p>当类中声明了一个指针，然后在构造函数里动态分配内存，如果析构函数不执行delete。那么内存就会一直堆积下去。</p><p>因为虽然对象会自动释放，但是它释放的都是存在栈中的内存，这里的指针ch会释放，但是分配给它的100*4的内存不会主动释放。这块内存在正常情况下就不能被访问了。</p><p>然后前面构造函数有个default关键字保留，析构也能用。</p><pre><code class="cpp">class Box&#123;public:    Box()&#123;        std::cout &lt;&lt; &quot;默认构造函数执行&quot; &lt;&lt; std::endl;    &#125;    ~Box() = default;&#125;;</code></pre><p>当然效果都差不多，如果函数里要写东西自然就不用这种方式。</p><blockquote><p>再次重复：&#x3D;default 是c++11的特性，目的就是会自动生成函数体，在不需要写内容的时候效率更高。</p></blockquote><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>析构函数雀食没啥好讲的。</p><p>学到此处就是知道编译器会自动对类生成构造函数、副本构造函数、析构函数。</p><p>副本构造或者拷贝构造叫法都差不多~</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;构造函数是在类对象创建时就调用，一般的用途就是初始化对象。&lt;br&gt;而析构函数相反，它是在类的对象结束生命周期才自动执行，一般就是清理之类的，最常见就是释放掉new的空间&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://8bytes.top/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>构造函数+1</title>
    <link href="https://8bytes.top/2022/06/23/Constructor1/"/>
    <id>https://8bytes.top/2022/06/23/Constructor1/</id>
    <published>2022-06-23T06:34:17.000Z</published>
    <updated>2022-06-27T12:55:52.224Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>继续了解构造函数</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h2><p>构造函数最直接的就是初始化成员变量</p><pre><code class="cpp">#pragma onceclass Hack&#123;public:    int hp;    int mp;    Hack(int hp,int mp)&#123;        this-&gt;hp = hp;        this-&gt;mp = mp;    &#125;&#125;;</code></pre><p>除了在函数里面初始化，还可以使用列表方式</p><pre><code class="cpp">#pragma onceclass Hack&#123;public:    int hp;    int mp;    Hack(int _hp, int _mp) :hp&#123; _hp &#125;,mp&#123;_mp&#125;&#123;        &#125;&#125;;</code></pre><p><strong>列表初始化的话就不能用this指针了，所以你要手动去区分开形参和成员变量，就是不要起一个名字</strong></p><p>那么说这两种都是初始化的方法，谁更好<br>答案是列表更好</p><ol><li>效率高</li><li>在某些情况下只能用列表初始化</li></ol><pre><code class="cpp">#pragma onceclass Hack&#123;public:    int hp=100;    int mp=200;    Hack(int _hp, int _mp)&#123;                std::cout &lt;&lt; hp &lt;&lt; &quot; &quot; &lt;&lt; mp &lt;&lt; std::endl;        this-&gt;hp = _hp;        this-&gt;mp = _mp;        std::cout &lt;&lt; hp &lt;&lt; &quot; &quot; &lt;&lt; mp &lt;&lt; std::endl;    &#125;&#125;;</code></pre><p>当hp和mp有初始值，我们去看看执行的效果</p><img src="/2022/06/23/Constructor1/000.png" class=""><p>可以看到先打印初始值在打印修改后的值<br>说明构造函数需要跳转需要空间。</p><p>再看看列表的情况。</p><pre><code class="cpp">#pragma once#include&lt;iostream&gt;class Hack&#123;public:    int hp=100;    int mp=200;    Hack(int _hp, int _mp):hp&#123; _hp &#125;,mp&#123;_mp&#125;&#123;            std::cout &lt;&lt; hp &lt;&lt; &quot; &quot; &lt;&lt; mp &lt;&lt; std::endl;        std::cout &lt;&lt; hp &lt;&lt; &quot; &quot; &lt;&lt; mp &lt;&lt; std::endl;    &#125;&#125;;</code></pre><img src="/2022/06/23/Constructor1/001.png" class=""><p>看到都是实例化对象时候的值。<br>说明列表的方法实现是在执行函数之前完成的。</p><blockquote><p>说明列表初始化的效率比传统在构造函数里初始化要快<br>至于某些情况要到继承的时候才知道</p></blockquote><p>有优势就有劣势，在劣势方面，因为成员变量是顺序初始化，他没有等函数入栈前去看默认的值，但是如果调用的是未初始化的然后用来赋值就会造成问题</p><pre><code class="cpp">#pragma once#include&lt;iostream&gt;class Hack&#123;public:    int h;    int hp=100;    int mp=200;        Hack(int _hp, int _mp) :hp&#123; _hp &#125;, mp&#123; _mp &#125;, h&#123; mp * 3 &#125;&#123;                std::cout &lt;&lt; hp &lt;&lt; &quot; &quot; &lt;&lt; mp &lt;&lt; &quot; &quot; &lt;&lt; h &lt;&lt; std::endl;        std::cout &lt;&lt; hp &lt;&lt; &quot; &quot; &lt;&lt; mp &lt;&lt; &quot; &quot; &lt;&lt; h &lt;&lt; std::endl;    &#125;&#125;;</code></pre><img src="/2022/06/23/Constructor1/002.png" class=""><p>会发现h肯定不会这么大。说明传递的时候mp的值不正常。</p><p>原理就是，传参是从右往左传递，h声明的比mp早，mp还没完成初始化是个随机值，如果h声明在mp之下，那值就正常了。</p><img src="/2022/06/23/Constructor1/003.png" class=""><p>只不过这种方式只是治标不治本，因为成员变量一多，没人回去顾及这些顺序问题，</p><p><strong>所以列表初始化的顺序是从右往左的，传统构造函数内初始化是因为调用函数之前，成员变量都已经完成了各自的初始化</strong></p><hr><h2 id="委托构造"><a href="#委托构造" class="headerlink" title="委托构造"></a>委托构造</h2><pre><code class="cpp">#pragma once#include&lt;iostream&gt;class Hack&#123;public:        int hp=100;    int mp=200;    int h;    Hack(int _h, int _hp):Hack(_h) &#123;                std::cout &lt;&lt; h &lt;&lt; &quot; &quot; &lt;&lt; hp &lt;&lt; std::endl;        std::cout &lt;&lt; h &lt;&lt; &quot; &quot; &lt;&lt; hp &lt;&lt; std::endl;    &#125;    Hack(int _h) :h&#123; _h &#125;&#123;        std::cout &lt;&lt; &quot;hack _h&quot; &lt;&lt; std::endl;    &#125;&#125;;</code></pre><img src="/2022/06/23/Constructor1/004.png" class=""><p>会发现他先执行了<code>_h</code>的构造函数。</p><p><strong>委托构造函数只能用一个，且使用了委托构造之后不能再用列表初始化的方式了</strong></p><hr><h2 id="副本构造函数"><a href="#副本构造函数" class="headerlink" title="副本构造函数"></a>副本构造函数</h2><p>之前也用到过</p><pre><code class="cpp">Hack ha;Hack hc(ha);</code></pre><p>其实就是一种拷贝的操作，编译器也同样为类指定了一个默认的副本构造函数，当然也可以手动指定。</p><img src="/2022/06/23/Constructor1/005.png" class=""><p>看到这种右值引用的类型是我们没有写过的，这就是编译器自动产生的副本构造。</p><p>手写起来也不难</p><pre><code class="cpp">Hack(Hack &amp;hack)&#123;    this-&gt;hp = hack.hp;    this-&gt;mp = hack.mp;    this-&gt;h = hack.h;&#125;</code></pre><p>如果秉持不想改变这个传递的hack对象，也可以加上<code>const</code>。取决于个人严谨程度，毕竟只是为了拷贝，万一被修改了也怪麻烦的。</p><p>然后就是利用列表的形式：</p><pre><code class="cpp">Hack(Hack &amp;hack) :hp&#123; hack.hp &#125;, mp&#123; hack.mp &#125;, h&#123; hack.h &#125;&#123;&#125;</code></pre><p>活学活用。</p><blockquote><p>虽然&#x3D;也是会默认调用副本构造，但是第二次在使用&#x3D;意义不同，因为第一次才是真正的构造这个类，第二次只是修改或者替换。</p></blockquote><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>同类型的类，在构造函数里是可以访问私有成员的。<br>构造函数目的就是初始化构造一个类。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;继续了解构造函数&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://8bytes.top/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>构造函数</title>
    <link href="https://8bytes.top/2022/06/23/Constructor/"/>
    <id>https://8bytes.top/2022/06/23/Constructor/</id>
    <published>2022-06-23T04:37:37.000Z</published>
    <updated>2022-06-27T06:32:52.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>构造函数也是类的成员函数，但是比较特殊。<br>类一共有两个特殊的函数，一个是构造函数，另一个是析构函数。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><pre><code class="cpp">#pragma onceclass Hack&#123;public:    int hp;    int mp;&#125;;</code></pre><pre><code class="cpp">int main()&#123;    Hack ha&#123;100,200&#125;;&#125;</code></pre><p>在成员变量都为public属性时，可以通过这种方式顺序初始化。</p><img src="/2022/06/23/Constructor/000.png" class=""><p>打印一下看到值是正确被赋予了。</p><p>但是如果有个成员是私有的，那么这种顺序就被打乱了</p><pre><code class="cpp">#pragma onceclass Hack&#123;public:    int hp;private:    int mp;&#125;;</code></pre><pre><code class="cpp">int main()&#123;    Hack ha&#123; 100,200 &#125;; //error&#125;</code></pre><p>1是不匹配，2是设置的参数超了。</p><p>归根结底就是类型没有对上，那么新建个类，然后给指定的参数赋值，在拷贝给这个类。</p><pre><code class="cpp">int main()&#123;    Hack ha;    ha.hp = 100;    Hack hc = ha;&#125;</code></pre><p>这种方法是可行的，因为这样的拷贝就是只带上hp的值。</p><img src="/2022/06/23/Constructor/001.png" class=""><p>打印出来也是行得通，但是这个私有的mp是肯定没法操作。</p><hr><h2 id="setter和getter"><a href="#setter和getter" class="headerlink" title="setter和getter"></a>setter和getter</h2><p>其实接触c++面向对象的时候前面上学学过一点java的。<br>就有两种方法，一种是传参 初始化私有的成员变量，一种是返回这个私有变量的值。</p><p>手写也不难</p><pre><code class="cpp">#pragma onceclass Hack&#123;public:    int hp;    void SetMp(int mp)&#123;        this-&gt;mp = mp;    &#125;    int GetMp()&#123;        return mp;    &#125;private:    int mp;&#125;;</code></pre><img src="/2022/06/23/Constructor/002.png" class=""><p>的的确确是能够达到这种效果的。</p><hr><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>如果每次都要先创建一个被拷贝的类，还有疯狂调用set和get方法，显得很麻烦。</p><p>所以就要说一下这个特殊的构造函数。</p><ol><li>它属于成员函数在public:下</li><li>构造函数自动调用，且没有返回值</li><li>构造函数跟类同名</li><li>每个类至少有一个构造函数</li></ol><p>所以说很特殊，但是很高级~</p><pre><code class="cpp">#pragma once#include&lt;iostream&gt;class Hack&#123;public:    int hp;    void SetMp(int mp)&#123;        this-&gt;mp = mp;    &#125;    int GetMp()&#123;        return mp;    &#125;    Hack()&#123;        std::cout &lt;&lt; &quot;构造函数&quot; &lt;&lt; std::endl;        hp = 100;        mp = 200;    &#125;private:    int mp;&#125;;</code></pre><img src="/2022/06/23/Constructor/003.png" class=""><p>看到在实例化对象的时候和在打印参数值之前，肯定是调用了构造函数的，因为我们在构造函数里面也加了一条打印。</p><p>还有就是构造函数不止一个，说明它也可以重载</p><pre><code class="cpp">Hack(int hp, int mp)&#123;    this-&gt;hp = hp;    this-&gt;mp = mp;&#125;</code></pre><p><strong>这里继续强调，形参名如果养成良好习惯就不要跟成员变量重复，除非你像我一样习惯用this指针去分开，否则就是一种无用行为，形参&#x3D;形参编译器都傻了</strong></p><p>为了区分也加个cout</p><pre><code class="cpp">Hack(int hp, int mp)&#123;    std::cout &lt;&lt; &quot;构造函数1&quot; &lt;&lt; std::endl;    this-&gt;hp = hp;    this-&gt;mp = mp;&#125;</code></pre><img src="/2022/06/23/Constructor/004.png" class=""><p>可以看到效果很妙。</p><p>重载嘛，把类的对象当参数也ok，因为之前是用<code>=</code>号去赋值</p><pre><code class="cpp">Hack(Hack&amp; H)&#123;    std::cout &lt;&lt; &quot;构造函数2&quot; &lt;&lt; std::endl;    this-&gt;hp = H.hp;    this-&gt;mp = H.mp;&#125;</code></pre><img src="/2022/06/23/Constructor/005.png" class=""><hr><h2 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h2><p>这个就很好理解，就是你没有主动写，那么编译器自动给它加上一个<code>类名()&#123;&#125;</code><br>这个默认构造函数，无参数无返回值，就是空的放在那里。</p><pre><code class="cpp">class Box&#123;public:    int hp;    int mp;    //Box()&#123;&#125; 在没有定义构造函数的时候，默认存在的就是这样的。&#125;;</code></pre><hr><h2 id="default"><a href="#default" class="headerlink" title="default"></a>default</h2><p>前面说到只要定义过构造函数，就不会出现默认构造函数，但有的时候可能还需要一个默认构造函数<br>就可以用到default关键字去声明。</p><p><code>类名()&#123;&#125;</code> 默认构造函数<br><code>类名()=default;</code>用关键字定义默认构造函数</p><p>当我们注释掉之前写的构造函数</p><pre><code class="cpp">/*Hack()&#123;    std::cout &lt;&lt; &quot;构造函数&quot; &lt;&lt; std::endl;    hp = 100;    mp = 200;&#125;*/</code></pre><p>这个时候你再去创建一个类的对象就会报错了</p><img src="/2022/06/23/Constructor/006.png" class=""><p>解决的方法就是给它留个默认构造函数或者指定</p><pre><code class="cpp">Hack()&#123;&#125;Hack() = default;</code></pre><p>当然这两种方法只能存在一个，否则也是定义冲突。</p><p>这两种孰优孰劣要看默认构造函数里面是否要存放什么比如初始化，如果要就选前者，如果不需要就选后者。</p><hr><h2 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h2><blockquote><p>被explicit关键字修饰的构造函数会被禁止类型转换</p></blockquote><pre><code class="cpp">bool toMax(Hack hack)&#123;    return hack.GetMp() &gt; this-&gt;mp;&#125;Hack(int mp)&#123;    this-&gt;mp = mp;&#125;</code></pre><img src="/2022/06/23/Constructor/007.png" class=""><p>布尔值，返回就是0或者1，这个很直观。</p><img src="/2022/06/23/Constructor/008.png" class=""><p>逻辑上也一点问题没有。</p><p>但是有个神奇的地方。</p><img src="/2022/06/23/Constructor/009.png" class=""><p>你会发现，我toMax函数明明参数是Hack类型的，居然放数字也成功了</p><p>其实本质上就是编译器偷偷转换了，因为我们有个构造函数就是让传值赋给mp的。<br>你在调用<code>std::cout &lt;&lt; ha.toMax(900) &lt;&lt; std::endl;</code><br>他就会先把这个900传进给一个临时的hack对象，然后再用这个临时的对象去和ha作比较。</p><p>那么说去掉这个构造函数就行，也确实是一个办法，但是有的时候我这个构造函数存在有他的道理，我只是不希望他被拿来做转换运算了。就可以使用explicit这个关键字</p><pre><code class="cpp">explicit Hack(int mp)&#123;    this-&gt;mp = mp;&#125;</code></pre><img src="/2022/06/23/Constructor/010.png" class=""><p>调用的地方就会发生报错了，无法转换。</p><p>这个在后面可以规避掉很多问题。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>未完结待续。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;构造函数也是类的成员函数，但是比较特殊。&lt;br&gt;类一共有两个特殊的函数，一个是构造函数，另一个是析构函数。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://8bytes.top/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>const类</title>
    <link href="https://8bytes.top/2022/06/22/const/"/>
    <id>https://8bytes.top/2022/06/22/const/</id>
    <published>2022-06-22T14:22:58.000Z</published>
    <updated>2022-06-27T04:30:36.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>const肤浅的时候就是定义常量，跟<code>#define</code>类似。<br>但是当实例化的类被限定为const类型的时候，又是一个搞怪点</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><pre><code class="cpp">//Hack.h#pragma onceclass Hack&#123;public:    int hp;    int mp;    int lv;&#125;;</code></pre><pre><code class="cpp">#include&lt;iostream&gt;#include&quot;Hack.h&quot;int main()&#123;    const Hack hc;    hc.hp = 100;    //error    return 0;&#125;</code></pre><p>因为实例化的类被限定为了const，所以它也无法修改成员。</p><p>当然要修改一个const对象的时候，可以用指针+强转去逆它。</p><pre><code class="cpp">const Hack *HCP = &amp;hc;HCP-&gt;hp = 100;</code></pre><blockquote><p>这种方式仍然是不可取的，因为指针也被const修饰了，所以它也无法修改成员。<br>还好前面指针还有印象，知道怎么玩</p></blockquote><pre><code class="cpp">Hack *HCP = (Hack*) &amp;hc;HCP-&gt;hp = 100;</code></pre><p>然后打印一下hc.hp发现的确被修改了</p><img src="/2022/06/22/const/000.png" class=""><p>当然这种方法有效，虽然还不知道有没有危害。</p><hr><h2 id="const的成员函数"><a href="#const的成员函数" class="headerlink" title="const的成员函数"></a>const的成员函数</h2><p>当const修饰过的类后，这个类同时也直接无法访问成员函数了。</p><pre><code class="cpp">#pragma onceclass Hack&#123;public:    int hp;    int mp;    int lv;    int test()&#123;        return hp;    &#125;&#125;;</code></pre><img src="/2022/06/22/const/001.png" class=""><p>然后就有一种方式可以将函数也修饰成const类型。</p><pre><code class="cpp">#pragma once#include&lt;iostream&gt;class Hack&#123;public:    int hp;    int mp;    int lv;    int test() const&#123;        return hp;    &#125;&#125;;</code></pre><p>然后调用是能调用了，但是一看好像被优化成内联函数了</p><img src="/2022/06/22/const/002.png" class=""><p>感觉有点怪异，找了个正常实例化的类的对象访问看看。</p><img src="/2022/06/22/const/003.png" class=""><p>看到结果都是一样的内联的函数，想了想可能是因为函数是不像成员变量没生成一个就要重新划分内存，函数是可以放在代码区，等待调用的，而且这个函数正好也简单，被编译器优化了也有可能。毕竟内联就是替换简单的方法。</p><p><strong>而且不知道为啥，函数还必须是有返回值的，void类型的函数好像没有用</strong></p><blockquote><p>至于const为什么不加前面，那是因为前面代表返回值类型，const在前面，哪有返回一个什么const类型的值的道理。</p></blockquote><hr><p>所以const成员就不能被改变了，在这个规则下，const对象只能调用const函数。<br>且this指针会自适应成const，也就是说直接修改，或者在函数里修改，或者通过this指针修改均无法生效。</p><blockquote><p>骚操作可以…比如我上面那种强转指针哈哈，但是先基于逻辑上来讲是不能被修改的。</p></blockquote><hr><p>不过万一真的有需求要用const类。。。那么在一些常规的成员函数上就可能要尽量加上const，以保证const类对象能调用。</p><p>或者就是重载。</p><pre><code class="cpp">#pragma once#include&lt;iostream&gt;class Hack&#123;public:    int hp;    int mp;    int lv;    int test() const&#123;        return hp;    &#125;    int test()&#123;        return hp;    &#125;&#125;;</code></pre><img src="/2022/06/22/const/004.png" class=""><img src="/2022/06/22/const/005.png" class=""><p>可以看到const类对象和正常构造的对象所调用的test是不一样的。</p><p>然后就是不同方法写在不同的地方就行了。虽然在没用到之前很鸡肋，要重复copy代码。</p><hr><h2 id="指针强转"><a href="#指针强转" class="headerlink" title="指针强转"></a>指针强转</h2><p>然后就是之前说的通过强转指针改变</p><pre><code class="c">(Hack*)&amp;ha;</code></pre><p>这种方式是C语言风格的强转</p><pre><code class="cpp">const_cast&lt;Hack*&gt;(&amp;ha);</code></pre><p>c++的风格。。额感觉可能还是习惯C语言风格的。</p><p>反正都是那个味，效果都一样，只是正常逻辑下不期望有另类修改途径。</p><hr><h2 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h2><p>被mutable修饰的成员变量可以被const成员函数修改~</p><p>这个就感觉稍微滑稽了一点，也就累加的时候玩玩</p><img src="/2022/06/22/const/006.png" class=""><p>当正常声明的成员变量，是肯定无法再const的函数下修改的。</p><p>但是加上mutable之后就行了。</p><img src="/2022/06/22/const/007.png" class=""><blockquote><p>表面上看着有点抽风，都让const成员无法修改了，还加个mutable玩<br>不过真到需要被修改的地方感觉也是debug的时候。</p></blockquote><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>const类还挺鸡肋~</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;const肤浅的时候就是定义常量，跟&lt;code&gt;#define&lt;/code&gt;类似。&lt;br&gt;但是当实例化的类被限定为const类型的时候，又是一个搞怪点&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://8bytes.top/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>成员函数</title>
    <link href="https://8bytes.top/2022/06/22/member/"/>
    <id>https://8bytes.top/2022/06/22/member/</id>
    <published>2022-06-22T12:01:09.000Z</published>
    <updated>2022-06-26T14:21:20.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><pre><code class="cpp">class ROLE&#123;public:    int hp;             //成员变量    int mp;             //成员变量    void Init()&#123;        //成员函数        hpadd = 3;    &#125;private:    int hpadd;          //成员变量&#125;;</code></pre><span id="more"></span><blockquote><p>谁的成员，无非就是要知道作用域在哪里。</p></blockquote><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>与常规函数不同</p><pre><code class="cpp">#include&lt;iostream&gt;int add(int a,int b)&#123;    return a + b;&#125;int main()&#123;    return 0;&#125;</code></pre><p>这个时候函数add是全局函数，搁哪调用都没问题。<br>相反的，类中的成员函数，就只能被这个类调用。</p><pre><code class="cpp">class Box&#123;public:    void test()&#123;        std::cout &lt;&lt; &quot;hello Box\n&quot;;    &#125;&#125;;void test()&#123;    std::cout &lt;&lt; &quot;hello ::\n&quot;;&#125;</code></pre><p>这种时候在主函数中调用test()想都不用想调用的是外面的全局函数</p><img src="/2022/06/22/member/000.png" class=""><p><code>::</code>之前说过前面没有东西时就代表全局作用域，那么要调用Box的test就要<code>Box::test();</code><br>不过由于没有实例化，所以没意义，顶多在外面修改函数</p><pre><code class="cpp">class Box&#123;public:    void test();&#125;;void test()&#123;    std::cout &lt;&lt; &quot;hello ::\n&quot;;&#125;void Box::test()&#123;    std::cout &lt;&lt; &quot;hello ::Box\n&quot;;&#125;int main()&#123;    test();    Box b;    b.test();    return 0;&#125;</code></pre><img src="/2022/06/22/member/001.png" class=""><p><strong>注意box类中的函数，定义要通过Box::写在外面的话，那么类中的函数只能是声明，否则会报错已有主体</strong><br>这里就是想在外面写，所以去掉了类中的函数主体。</p><hr><h2 id="成员函数的大小"><a href="#成员函数的大小" class="headerlink" title="成员函数的大小"></a>成员函数的大小</h2><p>可能这种写法刚从c风格过渡而来时会不习惯，但是一般类中的成员初始化或者函数定义都是写在外面的。</p><p>结构体的内存占用存在对齐情况，2 4 8的倍数，这是板上钉钉的事实。<br>但是类的内存占用呢，变量没办法，声明了就有，但是成员函数，不是每个对象都需要，它的内存占用该怎么办</p><pre><code class="cpp">class Box&#123;public:    int a;    int b;    void test();&#125;;int main()&#123;    std::cout &lt;&lt; sizeof(Box);    return 0;    &#125;</code></pre><img src="/2022/06/22/member/002.png" class=""><p>发现他在统计类的内存大小的时候，忽略掉了函数？</p><p>如果是以为没定义的话其实也陷进去了。</p><pre><code class="cpp">class Box&#123;public:    int a;    int b;    void test()&#123;        std::cout &lt;&lt; &quot;hello \n&quot;;    &#125;&#125;;</code></pre><img src="/2022/06/22/member/003.png" class=""><p>发现还是忽略的。</p><p><strong>但是要注意：虽然统计类的大小时不计函数，但是函数本质上还是有占用的</strong></p><p>对象的大小按照数据成员所占空间之和算，和结构体类似。但是类中的函数，是类通用的，所以不算做对象的占用，因此成员函数也不存在对象的内存空间。换言之就可能在调用时才跳转到代码区什么的找到函数的地址。</p><hr><h2 id="空类的大小"><a href="#空类的大小" class="headerlink" title="空类的大小"></a>空类的大小</h2><p>然后就是另一个有意思的地方。当类是空的时候它的占用会是0吗</p><blockquote><p>ps: C++的空类是指这个类不带任何数据，即类中没有非静态(non-static)数据成员变量，没有虚函数(virtual function)，也没有虚基类(virtual base class)。 </p></blockquote><pre><code class="cpp">class hack&#123;&#125;;</code></pre><img src="/2022/06/22/member/004.png" class=""><p>可以看到结果是1.</p><p>其实也是因为<code>C++标准规定，凡是一个独立的(非附属)对象都必须具有非零大小。</code></p><p>不然这个类创建多个对象的时候，这几个不同的对象的内存地址是一样的不是很荒唐吗</p><pre><code class="cpp">hack h1, h2;std::cout &lt;&lt; &amp;h1 &lt;&lt; std::endl;std::cout &lt;&lt; &amp;h2 &lt;&lt; std::endl;</code></pre><img src="/2022/06/22/member/005.png" class=""><p>切成release模式才会相邻，debug可能还有啥没优化的挡着了。</p><hr><h2 id="构建class文件"><a href="#构建class文件" class="headerlink" title="构建class文件"></a>构建class文件</h2><p>vs的操作流程吧，因为类可能单独写在一个文件[一个源文件+一个头文件]里</p><img src="/2022/06/22/member/006.png" class=""><img src="/2022/06/22/member/007.png" class=""><p>就会得到一个源文件和一个头文件，这里Class类名以Hack举例</p><pre><code class="cpp">//Hack.cpp#include &quot;Hack.h&quot;</code></pre><pre><code class="cpp">//Hack.h#pragma onceclass Hack&#123;&#125;;</code></pre><p>然后可以用main.cpp 引入Hack的头文件，这样就能访问类。</p><pre><code class="cpp">#pragma onceclass Hack&#123;public:    int hp;    int mp;    void test();&#125;;</code></pre><pre><code class="cpp">#include&lt;iostream&gt;#include &quot;Hack.h&quot;void Hack::test()&#123;    std::cout &lt;&lt; &quot;test&quot; &lt;&lt; std::endl;&#125;</code></pre><blockquote><p>这样函数的定义部分也可在源文件操作。除了内联函数以外，我们尽量将内联函数写在头文件中，毕竟这个内联的简易的话它是直接拿来替换的，没必要让他翻几个文件再替换。</p></blockquote><hr><h2 id="重写原则"><a href="#重写原则" class="headerlink" title="重写原则"></a>重写原则</h2><p>因为函数可以只先声明，而后定义，所以最后参考的是定义部分</p><pre><code class="cpp">#pragma onceclass Hack&#123;public:    int hp;    int mp;    void test();    int add(int a,int b,int c);&#125;;</code></pre><pre><code class="cpp">#include&lt;iostream&gt;#include &quot;Hack.h&quot;void Hack::test()&#123;    std::cout &lt;&lt; &quot;test&quot; &lt;&lt; std::endl;&#125;int Hack::add(int a,int b,int c = 3)&#123;    //假如声明的时候已经给c做了默认值，那么此处在定义默认值就会报错    return hp + mp;&#125;</code></pre><p>其实本质上是要注意默认参数的情况，虽然我们形参习惯放于函数声明的部分。<br>但是默认参数其实也可以放在声明的地方。</p><p>当默认参数放在声明部分时，定义的时候就不可以再重复出现默认参数了，否则会产生错误。</p><p>所以原则上：</p><ol><li>当定义和声明分开时，参数的默认值就尽量放在声明</li><li>定义和声明不分开的时候，就老老实实放着就行了。</li></ol><hr><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><pre><code class="cpp">#include&lt;iostream&gt;#include &quot;Hack.h&quot;void Hack::test()&#123;    this-&gt;hp = 200;    this-&gt;mp = 300;    std::cout &lt;&lt; &quot;test&quot; &lt;&lt; std::endl;&#125;</code></pre><p>如果只在此处初始化的话其实跟<code>hp=200;</code>差别不大。</p><p>但是this的意义肯定不在于此，不然早就被废弃了。</p><blockquote><p>this指针是一个自动生成、自动隐藏的成员，当一个对象被实例化时，this指针自动指向对象的首地址</p></blockquote><p>比如说比较两个对象的某个参数，然后返回指针。</p><pre><code class="cpp">#pragma onceclass Hack&#123;public:    int hp;    int mp;    int lv;    Hack *Hmax(Hack *ha);&#125;;</code></pre><pre><code class="cpp">#include&lt;iostream&gt;#include &quot;Hack.h&quot;Hack* Hack::Hmax(Hack *ha)&#123;    return ha-&gt;lv &gt; lv ? ha : this;&#125;</code></pre><p>如果说没有this指针，就不好确定比较的对象的地址。</p><pre><code class="cpp">int main()&#123;    Hack ha;    Hack hc;    hc.Hmax(&amp;hc);&#125;</code></pre><p>这样返回的还是一个指针，我们可以去接受它做其它有意义的事情。</p><hr><p>还有就是比如说传值初始化的时候this可以区分出来</p><pre><code class="cpp">void Hack::setHp(int hp)&#123;    hp = hp;&#125;</code></pre><p>当形参名没有考究，跟类的成员名一样的时候，其实就给编译器整活了。但是你加上this的话就一目了然</p><pre><code class="cpp">void Hack::setHp(int hp)&#123;    this-&gt;hp = hp;&#125;</code></pre><hr><p>this还有一种套娃用法。</p><pre><code class="cpp">#pragma onceclass Hack&#123;public:    int hp;    int mp;    int lv;    Hack &amp;setHp(int hp);    Hack &amp;setMp(int mp);    Hack &amp;setLv(int lv);&#125;;</code></pre><pre><code class="cpp">#include&lt;iostream&gt;#include &quot;Hack.h&quot;Hack&amp; Hack::setHp(int hp)&#123;    this-&gt;hp = hp;    return *this;&#125;Hack &amp;Hack::setMp(int mp)&#123;    this-&gt;mp = mp;    return *this;&#125;Hack &amp;Hack::setLv(int lv)&#123;    this-&gt;lv = lv;    return *this;&#125;</code></pre><pre><code class="cpp">int main()&#123;    Hack ha;    ha.setHp(200).setMp(300).setLv(1);&#125;</code></pre><p>会发现可以连起来用。因为它的返回值是this指针，所以当ha开始调用的时候，只要后面的参数也返回的this指针就可以一直套娃套下去。这一种就像类的连续初始化版~</p><p>当然还是要归功于引用这一特性，如果没有引用，就没法返回一个解引用之后还原成this的指针。<br>不能返回指针，而是返回类的话，是会存在大量的内存消耗的一个问题。<br>就跟结构体那会提到的类似，返回一个结构体和返回一个结构体指针肯定是不一样的，返回结构体指针还原出本身，和新建临时对象返回。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>熟悉下定义类的成员函数定义方式，和this指针的巧妙运用。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;class ROLE&amp;#123;
public:
    int hp;             //成员变量
    int mp;             //成员变量

    void Init()&amp;#123;        //成员函数
        hpadd = 3;
    &amp;#125;
private:
    int hpadd;          //成员变量
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://8bytes.top/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>面向对象</title>
    <link href="https://8bytes.top/2022/06/22/oop/"/>
    <id>https://8bytes.top/2022/06/22/oop/</id>
    <published>2022-06-22T08:45:56.000Z</published>
    <updated>2022-06-26T05:58:59.190Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>面向过程的语法基本复习完了，能记多少全凭天意。<br>然后就是c++面向对象的特性了，主要是从class类的角度。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>OOP(Object Oriented Programming)即面向对象编程。本质上还是一种思想，通过编程中的事物抽象成对象编程。<br>与此相关的名词还有OOD(面向对象设计)、OOA(面向对象分析)等。</p><hr><p>学c++的时候就知道它兼容c语言特性，所以外界的声音就是c++不单单是面向对象的语言。<br>像java、c#可能就是纯面向对象语言的代表了。</p><p>不过毕竟是一种思想抽象，所以也不能百分之百说就是面向对象好，面向对象不好。还是要取决于使用场景。</p><hr><h2 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h2><pre><code class="cpp">#include&lt;iostream&gt;struct NPC&#123;    int hp;    int mp;    char *name;&#125;;struct MONSTER&#123;    int hp;    int mp;    char *name;    int damage;    unsigned price;&#125;;struct ROLE&#123;    int hp;    int mp;    char *name;    int damage;    unsigned diamond;    char *id;&#125;;bool Act(ROLE &amp;acter, ROLE &amp;beacter)&#123;    beacter.hp -= acter.damage;    return beacter.hp &gt; 0;&#125;int main()&#123;    return 0;&#125;</code></pre><p>看面向过程的时候，结构体定义这种人物，函数定义行为或者进行的操作，比如砍了他一下扣多少血之类的。<code>ROLE zs,ls。 Act(zs,ls)</code></p><blockquote><p>当然稍大的项目，使用c++开发的话，就不会完成使用面向对象的思想，面向过程固然有用武之处</p></blockquote><hr><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装就是可以把已有的事物封装成类，这种类可以让指定的属性被外人看到，也可以设置一些不能被外人多看到的属性。<br>换做代码：</p><pre><code class="cpp">class box&#123;public:    box();    ~box();private://protected:&#125;;</code></pre><blockquote><p>有公有的区域，也有私有的区域。</p></blockquote><hr><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承就是让一个类的对象可以获取另一个类的对象的属性。能够按照一定的等级划分。<br>被继承的类可以称为“基类”、“父类”。<br>通过继承创建的类一般被称为“子类”、“派生类”的说法。</p><pre><code class="cpp">class&lt;派生类名&gt;:&lt;继承方式&gt;&lt;基类名&gt;&#123;    &lt;派生类新定义成员&gt;&#125;;//例如：class box&#123;public:    box();    ~box();private:&#125;;class box1:public box&#123;&#125;;</code></pre><hr><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>是对一个类的实例在相同方法，不同情形下有不同的表现。<br>多态是在继承的基础上实现。</p><blockquote><p>后面在拆开解</p></blockquote><hr><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><pre><code class="cpp">class 类名&#123;    public:     //公有对象    private:    //私有对象&#125;</code></pre><p>在封装继承多态的时候举例了代码，定义一个类的模板就是如此。</p><pre><code class="cpp">struct 结构体名称&#123;    //成员...&#125;;</code></pre><p>其实从结构体和类来比较，大致上有相似的感觉，只不过类还能划分对象，还有一些高级的功能。<br>而且虽然结构体也能塞函数，但是不太好，毕竟设计的目的就是为了涵盖一些变量。</p><pre><code class="cpp">class ROLE&#123;    int hp;    int mp;    int damagel    int diamond;&#125;;int main()&#123;    ROLE zs;&#125;</code></pre><blockquote><p>在没有定义<code>public:</code>的时候，类的成员都是私有的，未公开。像结构体默认就是公有的。</p></blockquote><pre><code class="cpp">class ROLE&#123;public:    int hp;    int mp;    int damage;    int diamond;&#125;;int main()&#123;    ROLE zs&#123;100,200,100,100&#125;;&#125;</code></pre><blockquote><p>这样才能合理初始化。</p></blockquote><p>一个角色除了基础属性外，还会有回复的能力</p><pre><code class="cpp">class ROLE&#123;public:    int hp;    int mp;    int damage;    int diamond;private:    int hpadd;    void Init()&#123;        hpadd = 3;    &#125;&#125;;</code></pre><p>当然这种每秒回多少，我们肯定不希望被其他人访问修改。所以将这个变量放入<code>private:</code>中。<br>不过每次初始化要调用的函数放到里面的话不利于调用。</p><pre><code class="cpp">class ROLE&#123;public:    int hp;    int mp;    int damage;    int diamond;    void Init()&#123;        hpadd = 3;    &#125;private:    int hpadd;    &#125;;</code></pre><p>这样一来，每次创建一个对象，都可以通过<code>对象.Init();</code>去初始化这个hpadd。</p><p>然后就是关于对象定义的问题，公有变量都存在public中，但是它可以多次定义：</p><pre><code class="cpp">class ROLE&#123;public:    int hp;    int mp;private:    int hpadd;public:    int damage;    int diamond;&#125;;</code></pre><p>因为还是处于<code>public:</code>下所以还是能够被外部访问，但是不是很建议这么写，太麻烦了。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>简单过一遍封装继承多态的概念，和class创建的方式。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;面向过程的语法基本复习完了，能记多少全凭天意。&lt;br&gt;然后就是c++面向对象的特性了，主要是从class类的角度。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://8bytes.top/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>ohheheheh</title>
    <link href="https://8bytes.top/2022/06/21/text007/"/>
    <id>https://8bytes.top/2022/06/21/text007/</id>
    <published>2022-06-21T15:21:36.000Z</published>
    <updated>2022-06-21T15:27:12.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最后一个暑假"><a href="#最后一个暑假" class="headerlink" title="最后一个暑假"></a>最后一个暑假</h1><span id="more"></span><p>《蒙古草原，天气晴》</p><hr><p>节奏太快，慢生活不适应</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;最后一个暑假&quot;&gt;&lt;a href=&quot;#最后一个暑假&quot; class=&quot;headerlink&quot; title=&quot;最后一个暑假&quot;&gt;&lt;/a&gt;最后一个暑假&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>assert</title>
    <link href="https://8bytes.top/2022/06/18/assert/"/>
    <id>https://8bytes.top/2022/06/18/assert/</id>
    <published>2022-06-18T07:31:29.000Z</published>
    <updated>2022-06-25T08:45:00.866Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>assert, 翻译可能是断言，本质是个宏定义，不是函数<br>在C++中要使用assert需要将头文件&lt;cassert&gt;引入，虽然cassert本质上引用的是&lt;assert.h&gt;</p><span id="more"></span><p>它的作用在其他语言中是一样的，就是说如果他里面的条件返回错误，代码会终止运行并且将源文件以及错误的代码和行号都输出出来。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cassert&gt;int main()&#123;    assert(false);    return 0;&#125;</code></pre><img src="/2022/06/18/assert/000.png" class=""><p>弹出的类似这样。</p><p>像一些特殊场景我们想要输入的时候不为0，以便参与下一次运算。当然debug模式和release模式情况可能稍有不同，因为release模式下会自动屏蔽掉assert的功能。<br>但是通过assert在debug下直接弹出一个警告框效果也不错。</p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;cassert&gt;int main()&#123;    int x;    std::cout &lt;&lt; &quot;请输入一个数:&quot;;    std::cin &gt;&gt; x;    assert(x);    std::cout &lt;&lt; 1000 / x;    return 0;&#125;</code></pre><img src="/2022/06/18/assert/001.png" class=""><p>这其实跟try一个异常有些许类似。</p><p>重试的话就是重新运行，忽略的话下面的cout还是有问题会打断。结束就是结束运行了。</p><blockquote><p>应用场景远不止仅限于此。</p></blockquote><hr><p>屏蔽assert的话，可以定义一个宏。<br><code>#define NDEBUG</code></p><p>但是宏定义需要在引入头文件&lt;cassert&gt;之前。否则按顺序展开的话不起作用。<br>用这个的原因也是因为有的时候不需要去看这个异常，一般这种都是为了debug调试用的。</p><img src="/2022/06/18/assert/002.png" class=""><p>转到定义后，可以看到其实也是利用了一些编译器提供好的功能</p><hr><h2 id="static-assert"><a href="#static-assert" class="headerlink" title="static_assert"></a>static_assert</h2><p>static_assert 用于编译时检查条件<br><code>static_assert(bool表达式，”错误信息“);</code></p><p>c++17的新语法中：<br><code>static_assert(bool表达式);</code><br>与assert不同，static_assert主要是用来在编译时检查重要的条件<br>因此检查的bool表达式中，只能用于</p><blockquote><p>static_assert不需要头文件cassert</p></blockquote><pre><code class="cpp">static_assert(0, &quot;this is 0&quot;);</code></pre><img src="/2022/06/18/assert/003.png" class=""><p><strong>注意，表达式的位置必须是常量或者表达式</strong></p><p>如果想用它判断编译环境，比如x86还是x64 可以用之前预定义的宏</p><pre><code class="cpp">static_assert(_WIN32, &quot;this is 0&quot;);</code></pre><p>像这种情况，我们处于x86模式编译自然会通过。如果改成<code>_WIN64</code>的话</p><pre><code class="cpp">static_assert(_WIN64, &quot;this is 0&quot;);</code></pre><p>在x86下，会提示未定义：</p><img src="/2022/06/18/assert/004.png" class=""><p>改成x64运行就没问题了。</p><p>当然这个属于msvc的预定义宏，想要更直观的，也可以通过sizeof看指针的大小去判断环境</p><pre><code class="cpp">static_assert(sizeof(int*)==4, &quot;it&#39;s not 4&quot;);</code></pre><p>在x86下 指针大小是四字节所以没问题<br>如果是x64下 指针大小占用八字节 所以会报错。</p><img src="/2022/06/18/assert/005.png" class=""><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>那么相比较之下，<code>static_assert</code>似乎还好用点，也不用引用头文件就能调用，而且debug的时候不一定需要这种弹窗效果，能产生报错信息不错了。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;assert, 翻译可能是断言，本质是个宏定义，不是函数&lt;br&gt;在C++中要使用assert需要将头文件&amp;lt;cassert&amp;gt;引入，虽然cassert本质上引用的是&amp;lt;assert.h&amp;gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="compiler" scheme="https://8bytes.top/tags/compiler/"/>
    
  </entry>
  
  <entry>
    <title>debug</title>
    <link href="https://8bytes.top/2022/06/18/debug/"/>
    <id>https://8bytes.top/2022/06/18/debug/</id>
    <published>2022-06-18T05:55:01.000Z</published>
    <updated>2022-06-24T07:24:47.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对于编写好的程序，或多或少可能存在bug和错误，简单语法上的问题编译器能够直接给出提示，而对于逻辑上出现的错误，编译器是不能直接发现的。所以就有了debug调试的过程。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>为了方便调试，我们希望在编程风格上</p><ol><li>模块化</li><li>使用有意义的变量名和函数名</li><li>控制缩进，首尾呼应</li><li>良好的注释习惯</li></ol><pre><code class="c">inculde 《stido.h》int mian()&#123;    print(&quot;hello world&quot;);    retrunt 0;&#125;</code></pre><p>像这种。。字面上的错误都算是语法问题，编译器一下子就能找到问题，人眼也能看到。。这种其实就不算什么bug</p><p>而逻辑错误：</p><pre><code class="cpp">int ch[][3]=&#123;    &#123;1,2,3&#125;,    &#123;4,5,7&#125;,    &#123;8,9,10&#125;,&#125;</code></pre><p>这一种由程序生成后，看到其实不是按照预期结果从1-9的，在其中一个地方发生了什么导致跳过了，这种问题他不影响运行，但是与我们预期结果不符合，就可以说是一种逻辑错误。</p><hr><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><pre><code class="cpp">int add(int a,int b)&#123;    return a+b;&#125;</code></pre><p>一些重复性的功能用函数解决，这就是模块化，他可以减少重复操作导致的代码量。</p><hr><h2 id="有意义的名称"><a href="#有意义的名称" class="headerlink" title="有意义的名称"></a>有意义的名称</h2><pre><code class="cpp">int a,b,c;int num,sum,add;</code></pre><p>做测试可能随便一点，但是如果看到这个变量名或者函数名我就能猜到它是干什么的。那么对于团队协作会提升很大效率。</p><hr><h2 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h2><pre><code class="cpp">if(true)    if(true)else</code></pre><p>像这种情况，if和else不对齐，或者乱对齐，无法准确的表达出意思就会让人很反感。<br>如果说else的内容是要给第二个if对齐，你这样写就很不合理。</p><hr><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><pre><code class="cpp">int add(int x,int b); //这是一个求两个数之和的函数</code></pre><p>虽然这个函数名比较简单通过形参也知道大概就是求和的，那么增加一行注释会有更直观的感想。</p><hr><h2 id="调试器"><a href="#调试器" class="headerlink" title="调试器"></a>调试器</h2><p>如果用过mingw，应该知道有gcc&#x2F;g++ 和调试工具 gdb<br>用过黑苹果 所以知道一个 clang，调试器是啥不知道，就观望了一下<br>然后vs2019这种ide 用的都是微软自己弄的，应该也是叫msvcdbg吧好像。</p><p>原理都差不多，应该是在基础上增加了什么功能，毕竟最常见就是打断点分析</p><img src="/2022/06/18/debug/000.png" class=""><p>打完断点后运行的时候程序就会停在断点处，这个时候ide就会多了值和内存什么的分析。</p><img src="/2022/06/18/debug/001.png" class=""><img src="/2022/06/18/debug/002.png" class=""><p>逐语句就是单步递增往下走。他进入函数之后也是一步步调试</p><p>而逐过程则稍微有点区别</p><img src="/2022/06/18/debug/004.png" class=""><p>它的作用就是跑到函数的时候不进去单步走直接执行完这个函数</p><p>还有个跳出<img src="/2022/06/18/debug/005.png" class=""><br>顾名思义也就是跳出某个函数</p><blockquote><p>且断点不只是在程序跑之前设置，跑的时候也可以设置。</p></blockquote><p>反汇编就很直接，可以从打断点的语句后面右击直接转到反汇编</p><img src="/2022/06/18/debug/003.png" class=""><p>也可以调试-窗口-反汇编，都行怎么习惯怎么来。<br>反汇编就更偏底层了，正常的调试可能还是源文件页面调。</p><p><strong>感觉这个调试不好讲，有时间还是看视频理解吧</strong></p><hr><h2 id="其他调试器"><a href="#其他调试器" class="headerlink" title="其他调试器"></a>其他调试器</h2><p>这些个可能都是干坏事用的，比如</p><ol><li>0llyDbg</li><li>x96Dbg</li><li>WinDbg</li></ol><p>比如~歪瓜，会检索一些属性之类的。</p><hr><h2 id="ifdef"><a href="#ifdef" class="headerlink" title="ifdef"></a>ifdef</h2><p>预处理指令可以根据定义宏去考虑要不要输出调试信息。<br>跟之前用法类似，就不演示了。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>debug不好操作，估计还是得录视频会好操作表示点。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;对于编写好的程序，或多或少可能存在bug和错误，简单语法上的问题编译器能够直接给出提示，而对于逻辑上出现的错误，编译器是不能直接发现的。所以就有了debug调试的过程。&lt;/p&gt;</summary>
    
    
    
    
    <category term="compiler" scheme="https://8bytes.top/tags/compiler/"/>
    
  </entry>
  
  <entry>
    <title>预定义宏</title>
    <link href="https://8bytes.top/2022/06/17/Predefined/"/>
    <id>https://8bytes.top/2022/06/17/Predefined/</id>
    <published>2022-06-17T13:47:07.000Z</published>
    <updated>2022-06-24T05:53:52.140Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在.c和.cpp混用的时候，注意到了它们在处理函数的时候有所不同<br>然后通过<code>#ifndef _cplusplus</code>去规避。那么这个<code>_cplusplus</code>就是c++的预定义宏</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="func"><a href="#func" class="headerlink" title="func"></a>func</h2><p><code>__func__</code><br>编译器支持iso c99和iso c++11指定的预定义标识符<br>它的作用就是代表函数的名称</p><pre><code class="cpp">#include&lt;iostream&gt;void hhh()&#123;    std::cout &lt;&lt; __func__ &lt;&lt; &quot;\n&quot;;&#125;int main()&#123;    std::cout &lt;&lt; __func__ &lt;&lt; &quot;\n&quot;;    hhh();    return 0;&#125;</code></pre><img src="/2022/06/17/Predefined/000.png" class=""><p>这种替换成函数名的操作，适用于debug的时候给函数做标记，看看是卡在哪个函数了。</p><hr><h2 id="标准预定义宏"><a href="#标准预定义宏" class="headerlink" title="标准预定义宏"></a>标准预定义宏</h2><table><thead><tr><th>宏</th><th>说明</th></tr></thead><tbody><tr><td><code>__DATE__</code></td><td>源文件的编译器日期</td></tr><tr><td><code>__TIME__</code></td><td>当前转换单元的转换时间</td></tr><tr><td><code>__FILE__</code></td><td>源文件的名称</td></tr><tr><td><code>__LINE__</code></td><td>当前的行号</td></tr><tr><td><code>__cplusplus</code></td><td>当翻译单元为c++时，__cplusplus定义为一个整数文本，否则未定义。</td></tr></tbody></table><blockquote><p>编译器支持iso c99和iso c++11指定的预定义标识符<br>老样子都是这个标准开始。</p></blockquote><pre><code class="cpp">std::cout &lt;&lt; __func__ &lt;&lt; &quot;\n&quot;;std::cout &lt;&lt; __DATE__ &lt;&lt; &quot;\n&quot;;std::cout &lt;&lt; __TIME__ &lt;&lt; &quot;\n&quot;;std::cout &lt;&lt; __FILE__ &lt;&lt; &quot;\n&quot;;std::cout &lt;&lt; __cplusplus &lt;&lt; &quot;\n&quot;;</code></pre><p>可以自己打印玩玩：<img src="/2022/06/17/Predefined/001.png" class=""></p><p>这里的cplusplus按照设计应该是输出当前所使用的c++标准，比如年和月，但这里可能没做什么处理，都是197711.<br>不过也够区分c和c++了。</p><hr><h2 id="msvc预定义宏"><a href="#msvc预定义宏" class="headerlink" title="msvc预定义宏"></a>msvc预定义宏</h2><table><thead><tr><th>宏</th><th>说明</th></tr></thead><tbody><tr><td><code>_CHAR_UNSIGNED</code></td><td>如果char类型为无符号，则该定义为1，否则未定义</td></tr><tr><td><code>__COUNTER__</code></td><td>从0开始，每次使用都会递增1</td></tr><tr><td><code>_DEBUG</code></td><td>如果设置了&#x2F;lDd&#x2F;mDd&#x2F;mTd 则该定义为1，否则未定义</td></tr><tr><td><code>__FUNCTION__</code></td><td>函数名称 不含修饰符</td></tr><tr><td><code>__FUNCDNAME__</code></td><td>函数名称 包含修饰符</td></tr><tr><td><code>__FUNCSIG__</code></td><td>包含了函数签名的函数名</td></tr><tr><td><code>_WIN32</code></td><td>当编译为32位ARM、64位ARM、X86或X64定义为1，否则未定义</td></tr><tr><td><code>_WIN64</code></td><td>当编译为64位ARM或者X64定义为1，否则未定义</td></tr><tr><td><code>__TIMESTAMP__</code></td><td>最后一次源代码修改时间和日期</td></tr></tbody></table><p>除了c++标准预定义的宏，一些大的ide也会在编译器内置一些预定义宏，就拿vs来说。</p><hr><h3 id="CHAR-UNSIGNED"><a href="#CHAR-UNSIGNED" class="headerlink" title="_CHAR_UNSIGNED"></a>_CHAR_UNSIGNED</h3><pre><code class="cpp">int main()&#123;#ifdef _CHAR_UNSIGNED    std::cout &lt;&lt; &quot;unsigned char\n&quot;;#endif     return 0;&#125;</code></pre><img src="/2022/06/17/Predefined/002.png" class=""><p>能看到没有设置无符号的char时他是灰色的不起作用。<br>判断字符有无符号，同样可以实现两种不同的效果。</p><hr><h3 id="COUNTER"><a href="#COUNTER" class="headerlink" title="__COUNTER__"></a>__COUNTER__</h3><pre><code class="cpp">int main()&#123;    __COUNTER__;    std::cout &lt;&lt; __COUNTER__ &lt;&lt; std::endl;    std::cout &lt;&lt; __COUNTER__ &lt;&lt; std::endl;    std::cout &lt;&lt; __COUNTER__ &lt;&lt; std::endl;    std::cout &lt;&lt; __COUNTER__ &lt;&lt; std::endl;&#125;</code></pre><p>像这种出现几次就会从0开始累计的，早的时候可能都还要设置一个变量累加，既然有预定义的宏直接用也不是不行。<br>但是也要注意只能在vs类的ide上才有效。</p><hr><h3 id="DEBUG"><a href="#DEBUG" class="headerlink" title="_DEBUG"></a>_DEBUG</h3><p>debug的场景可能比较多。因为咋样都要调试，可以在里面设置显示一些调试信息。</p><pre><code class="cpp">#ifdef _DEBUG    std::cout &lt;&lt; &quot;debug&quot;;#endif // _DEBUG</code></pre><img src="/2022/06/17/Predefined/003.png" class=""><p>明眼人就知道，这个debug就跟你项目上面设置的有关。如果是release模式，debug就失效了。</p><hr><h3 id="后面几个"><a href="#后面几个" class="headerlink" title="后面几个"></a>后面几个</h3><p>不常用。。自己随便试试就行了。</p><pre><code class="cpp">    std::cout &lt;&lt; __FUNCTION__ &lt;&lt; std::endl;    std::cout &lt;&lt; __FUNCDNAME__ &lt;&lt; std::endl;    std::cout &lt;&lt; __FUNCSIG__ &lt;&lt; std::endl;</code></pre><img src="/2022/06/17/Predefined/004.png" class=""><pre><code class="cpp">void hhh()&#123;    std::cout &lt;&lt; __func__ &lt;&lt; &quot;\n&quot;;    std::cout &lt;&lt; __FUNCTION__ &lt;&lt; std::endl;    std::cout &lt;&lt; __FUNCDNAME__ &lt;&lt; std::endl;    std::cout &lt;&lt; __FUNCSIG__ &lt;&lt; std::endl;&#125;</code></pre><p>可能main函数不明显</p><img src="/2022/06/17/Predefined/005.png" class=""><p>_WIN32 和 _WIN64 属于架构问题。<br>在vs ide上能指定x86和x64，_WIN64才是只有当项目是x64编译的时候才为1。</p><p>__TIMESTAMP__ 显示的比较全，年月日 小时分钟秒 星期几都会显示。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p><strong>除了标准预定义的宏可以通用，其他的编译器自己预定义的没有可移植性，所以用的时候要注意</strong></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在.c和.cpp混用的时候，注意到了它们在处理函数的时候有所不同&lt;br&gt;然后通过&lt;code&gt;#ifndef _cplusplus&lt;/code&gt;去规避。那么这个&lt;code&gt;_cplusplus&lt;/code&gt;就是c++的预定义宏&lt;/p&gt;</summary>
    
    
    
    
    <category term="compiler" scheme="https://8bytes.top/tags/compiler/"/>
    
  </entry>
  
  <entry>
    <title>预处理指令逻辑</title>
    <link href="https://8bytes.top/2022/06/17/preprocessing/"/>
    <id>https://8bytes.top/2022/06/17/preprocessing/</id>
    <published>2022-06-17T13:03:19.000Z</published>
    <updated>2022-06-23T13:44:27.499Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>预处理：</p><pre><code class="cpp">#pragma once#define xxx#ifdef xxx#else #endif</code></pre><span id="more"></span><p>诸如此类命令。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="ifdef"><a href="#ifdef" class="headerlink" title="ifdef"></a>ifdef</h2><p>一般都出现在头文件。主要是为了防止重复。</p><pre><code class="cpp">#ifdef _HH_#endif</code></pre><p>像这样在头文件定义后，除非源文件有<code>#define _HH_</code>不然里面的内容是无效的。</p><pre><code class="cpp">#ifdef _HH_    ...#else    ...#endif</code></pre><p>然后if与else配套传统，如果不存在，就还有一种结果。</p><hr><h2 id="ifndef"><a href="#ifndef" class="headerlink" title="ifndef"></a>ifndef</h2><p>最早可能用过这种，#ifndef是<code>&quot;if not defined&quot;</code>的简写。</p><p>在特殊场合多次包含中，可能会这么用</p><pre><code class="cpp">#ifndef _HH_#define _HH_...#else#endif</code></pre><p>该段代码意思是：如果_HH_没有被定义，则重定义_HH_，即执行语句2、语句3;如果_HH_已经被定义，则直接跳过语句2、语句3，直接执行语句4…</p><p>当然这种处理方式就可以不用老实呆在头文件里，你可以放到源文件去处理一些事情</p><pre><code class="cpp">#ifdef UNICODEwchar_t a;#elsechar a;#endif;</code></pre><p>像这种提前预定义编码环境的时候就可以规范一下格式</p><img src="/2022/06/17/preprocessing/000.png" class=""><img src="/2022/06/17/preprocessing/001.png" class=""><p>二者的区别就在于项目属性里更改使用的字符环境是能看到#ifdef反馈的高亮情况。</p><hr><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><pre><code class="cpp">#define VERSION 2#if VERSION==2    void up();#else    void down();#endif</code></pre><p>预处理的if虽然也能使用逻辑运算符，但是跟常规if相比，他毕竟是预处理的指令，不会被编译。<br>使用这种好处自然是针对项目开发时，没必要废弃旧版本，就有些人用老的，那么有些功能的实现就可能依赖老版本环境。</p><hr><h2 id="elif"><a href="#elif" class="headerlink" title="elif"></a>elif</h2><p>这个跟上面的if配套的，就是elseif一样的操作</p><pre><code class="cpp">#define VERSION 2#if VERSION==1    void up();#elif VERSION==2    void stop();#else    void down();#endif</code></pre><p>实际上也就是更精确控制，但是绝大部分下应该用不了这么多。<br>除此之外就是既然可以使用基本的逻辑表达式，所以相对的基本的加减去改变自然也行得通</p><pre><code class="cpp">#define VERSION 2#if VERSION==1+2 // #if VERSION==1 || VERSION==3 。&amp;&amp;自然没问题    void up();#elif VERSION==2    void stop();#else    void down();#endif</code></pre><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>预处理用的不多，但是要知道能配套使用，且配套使用的时候要形成闭环，不然又是个逻辑鬼才。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;预处理：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;#pragma once
#define xxx
#ifdef xxx
#else 
#endif
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="compiler" scheme="https://8bytes.top/tags/compiler/"/>
    
  </entry>
  
  <entry>
    <title>namespace</title>
    <link href="https://8bytes.top/2022/06/17/namespace/"/>
    <id>https://8bytes.top/2022/06/17/namespace/</id>
    <published>2022-06-17T09:04:09.000Z</published>
    <updated>2022-06-23T13:02:16.729Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>常用。</p><pre><code class="cpp">using namespace std;</code></pre><p>std就是一个命名空间。</p><span id="more"></span><p>当然最终感觉还是为了便于管理。</p><pre><code class="cpp">namespace hack&#123;    int ....&#125;</code></pre><p>把需要用到的函数和变量或者结构体之类的塞到一个命名空间中，这样下次调用起来就很方便：<code>hack::...</code></p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><pre><code class="cpp">#include&lt;iostream&gt;namespace hack&#123;    int value;&#125;using namespace hack;int main()&#123;    value = 200;    return 0;&#125;</code></pre><p>这里因为解锁了hack空间，所以里面的变量可以直接调用，但是这样不好的事如果别处有同样定义的变量还是会冲突的。<br>这也是为什么大部分人其实一开始不会直接<code>using namespace std;</code>因为std里面有很多的变量啊之类的，就怕你词穷冲突了。解决的办法就是用到啥using一下：<code>using std::cout;</code>。<br><strong>良好的代码习惯固然重要，但是后期团队协作还是要看整体风格</strong></p><hr><h2 id="全局命名空间"><a href="#全局命名空间" class="headerlink" title="全局命名空间"></a>全局命名空间</h2><p>就是说具有链接或者外部属性的对象，只要不存在于定义的命名空间内，就默认定义在全局命名空间中。在全局命名空间中的访问不需要额外指定，除非局部的变量重复了，就需要用到全局命名空间指定。</p><pre><code class="cpp">int a;int main()&#123;    int a = 100;    ::a = 200;    return 0;&#125;</code></pre><img src="/2022/06/17/namespace/000.png" class=""><p>能够看到两个a的值是不同的。</p><p>当然这个链接或外部属性是什么意思的，就是全局变量，且非静态的。<br>像main函数之内的<code>int a;</code>就是局部的，他就不会存在于全局命名空间。</p><blockquote><p>::前面没东西就是全局</p></blockquote><hr><h2 id="命名空间拓展"><a href="#命名空间拓展" class="headerlink" title="命名空间拓展"></a>命名空间拓展</h2><p>在标准头文件中<code>&lt;iostream&gt;</code>是最常使用的头文件，其中std命名空间自然在其中。<br>当引用其它头文件，比如<code>&lt;string&gt;</code>的时候，它也需要从std命名空间中使用。</p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;string&gt;int main()&#123;    std::string str = &quot;12334&quot;;        return 0;&#125;</code></pre><p>这说明命名空间是可以拓展的，而且拓展的方法也很简单，在写一个<code>namespace std</code>的操作即可</p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;string&gt;namespace hack&#123;    int value;&#125;using namespace hack;int a;namespace hack&#123;    float height;&#125;int main()&#123;    //...    return 0;&#125;</code></pre><img src="/2022/06/17/namespace/001.png" class=""><p>可以看到分开写的命名空间hack各自有一个成员，但是调用的时候是统一的。</p><hr><h2 id="命名空间的声明"><a href="#命名空间的声明" class="headerlink" title="命名空间的声明"></a>命名空间的声明</h2><pre><code class="cpp">namespace hack&#123;    int value;&#125;</code></pre><p>对于变量，这种情况我们默认就当成定义了，因为即便没有初始化也有可能分配到一个垃圾值。或者被优化掉。<br>声明一个变量之前提到过加上extern</p><pre><code class="cpp">namespace hack&#123;    extern int value;&#125;</code></pre><pre><code class="cpp">#pragma onceextern int value;void test()&#123;    ::value;&#125;</code></pre><p>这样的value还是处于全局命名空间。</p><pre><code class="cpp">//main.cpp#include&quot;main.h&quot;int hack::value = 200;</code></pre><pre><code class="cpp">//main.h#pragma oncenamespace hack&#123;    extern int value;&#125;</code></pre><p>照例输出一下：<img src="/2022/06/17/namespace/002.png" class=""></p><p>并且函数也是同样的</p><pre><code class="cpp">#pragma oncenamespace hack&#123;    extern int value;    void test();&#125;</code></pre><pre><code class="cpp">#include&lt;iostream&gt;#include&quot;main.h&quot;int a;namespace hack&#123;    float height=25.25;&#125;int hack::value = 200;void hack::test()&#123;    std::cout &lt;&lt; hack::height;&#125;int main()&#123;    hack::test();    return 0;&#125;</code></pre><p>输出一下：<img src="/2022/06/17/namespace/003.png" class=""></p><p><strong>所以声明和定义选择上跟源文件和头文件、源文件和源文件之间的联系是一样的</strong></p><hr><h2 id="命名空间的嵌套"><a href="#命名空间的嵌套" class="headerlink" title="命名空间的嵌套"></a>命名空间的嵌套</h2><p>函数能套娃，命名空间也能套娃</p><pre><code class="cpp">namespace hack&#123;    float height=25.25;        namespace hackbar&#123;        int hack_he;    &#125;&#125;int main()&#123;    hack::hackbar::hack_he;    return 0;&#125;</code></pre><p><strong>多套几层也没啥事，反正能够通过<code>::</code>访问到。</strong></p><hr><h2 id="未命名的命名空间"><a href="#未命名的命名空间" class="headerlink" title="未命名的命名空间"></a>未命名的命名空间</h2><pre><code class="cpp">namespace &#123;&#125;</code></pre><p>未命名的命名空间中的声明一律为内部连接属性，包括用extern声明的内容，且未命名的命名空间只在本转换单元有效。</p><p>一个函数不能同时出现在多个源文件当中，因为在编译的时候会发生重复定义。<br>按照C语言当时的习惯就是使用static或者inline之类的，当然c++之后是不期望这么用的。</p><pre><code class="cpp">namespace&#123;    void hhh()&#123;        std::cout &lt;&lt; &quot;hhh\n&quot;;    &#125;&#125;int main()&#123;    hhh();    return 0;&#125;</code></pre><pre><code class="cpp">void hhh()&#123;&#125;</code></pre><p>这种情况下，hhh函数不会发生报错，因为它存在于未命名命名空间中，具有内部连接属性，跟外部不冲突。</p><p>而且即使不同源文件都出现：</p><pre><code class="cpp">namespace&#123;    void hhh()&#123;        std::cout &lt;&lt; &quot;hhh\n&quot;;    &#125;&#125;</code></pre><p>也不会像之前的命名空间会自然拓展，未命名命名空间是完全独立的。</p><hr><h2 id="命名空间别名"><a href="#命名空间别名" class="headerlink" title="命名空间别名"></a>命名空间别名</h2><p>之前给结构体哪些创建别名都是通过<code>typedef</code><br>命名空间有自己起别名的方式<code>namespace a = xxx::xxx</code>之类的</p><pre><code class="cpp">namespace hack&#123;    float height=25.25;        namespace hackbar&#123;        int hack_he;    &#125;&#125;namespace a = hack::hackbar;</code></pre><p>那么下次调用hackbar的参数，就可以直接从<code>a::hack_he</code>了。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>c++特性，还是要好好了解的，毕竟后面还有类。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;常用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;using namespace std;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;std就是一个命名空间。&lt;/p&gt;</summary>
    
    
    
    
    <category term="compiler" scheme="https://8bytes.top/tags/compiler/"/>
    
  </entry>
  
  <entry>
    <title>define</title>
    <link href="https://8bytes.top/2022/06/16/define/"/>
    <id>https://8bytes.top/2022/06/16/define/</id>
    <published>2022-06-16T14:12:47.000Z</published>
    <updated>2022-06-23T09:03:25.143Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>#define 通常用作定义常量<br>如<code>#define Pi 3.14</code></p><span id="more"></span><p>甚至替换类型之类的操作<code>#define 整型 int</code><br>以至于当时无聊的时候还真有人用define去写中文编程语言</p><pre><code class="cpp">#include&lt;iostream&gt;#define 整数 int#define 输出 std::cout int main()&#123;    整数 a = 100;    输出 &lt;&lt; a;&#125;</code></pre><img src="/2022/06/16/define/000.png" class=""><p>也是能跑的，但是玩归玩</p><blockquote><p>宏定义的名称也与变量名称规则一致，不允许数字开头</p></blockquote><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="正经情况"><a href="#正经情况" class="headerlink" title="正经情况"></a>正经情况</h2><p>实际上嘛，常量除了define还有个const<br>#define定义在头上可能是因为更直观吧，像windows api里面就有一堆#define</p><pre><code class="cpp">#define SCREEN_WIDTH 1980const int screen_width&#123;1980&#125;;</code></pre><p>c时期define用的多，c++可能更多的用const，但是因为先学c在学c++，所以习惯是潜移默化的。<br>const定义的好处就是类型检测，限定类型肯定更加严谨。<br>而#define则相对无脑替换，你可以用它做一些非正常逻辑的事。比如<code>#define true false</code>，真就是真真假假假假真真。<br>而且有一种情况下，#define会出事，就是只定义了要替换的名，而不定义要替换成什么。<code>#define x</code>，你没有东西要替换</p><pre><code class="cpp">#define xint main()&#123;    int x a = 2500;    std::cout &lt;&lt; a;&#125;</code></pre><blockquote><p>要注意不能是int xa，因为这是一个独立的存在，int x a，x才会被宏替换</p></blockquote><p>但是这种在特定情况下有特殊意义：</p><pre><code class="cpp">#define _in_#define _out_int add(_in_ int a,_in_ int b)&#123;    return a + b;&#125;</code></pre><blockquote><p>这种情况下，无非就是像注释一样告诉你这个参数是要输入的。<br>不过这里值得一提的是jetbrains的软件很早就做了提示形参的功能。<br>虽然vs2022 在后面版本也支持了类似的功能。<br>但是这种方法在早期编写的时候的确带来了很大帮助。</p></blockquote><hr><h2 id="undef"><a href="#undef" class="headerlink" title="undef"></a>undef</h2><p>之前玩头文件的时候知道防重复除了<code>#pragma once</code>,还有个<code>#ifdef DEBUG  #endif</code>，表示从define标记的地方开始到结束。<br>然后这里还有个undef，是表示取消define。</p><pre><code class="cpp">#include&lt;iostream&gt;#define _Test_int main()&#123;    int _Test_ a = 100;#undef _Test_    int _Test_ b = 200;    return 0;&#125;</code></pre><img src="/2022/06/16/define/001.png" class=""><p>看到当undef掉<code>_Test_</code>的时候，无法再次使用这个宏。</p><p>由于编译特性是自上而下，逐条编译，所以就导致了即使这个undef写在其他函数或者地方，即使没有调用一样也已经删掉这个宏了。</p><pre><code class="cpp">#include&lt;iostream&gt;#define _Test_void hh()&#123;#undef _Test_    std::cout &lt;&lt; &quot;hello\n&quot;;&#125;int main()&#123;    int _Test_ a = 100;#undef _Test_    int _Test_ b = 200;    return 0;&#125;</code></pre><img src="/2022/06/16/define/002.png" class=""><p>所以说有的是bug都是人为的哈哈哈。。</p><hr><h2 id="复杂的宏"><a href="#复杂的宏" class="headerlink" title="复杂的宏"></a>复杂的宏</h2><p>简单的常量替换已经没啥问题了，宏还有更厉害的就是可以设计表达式</p><pre><code class="cpp">#define SUM(x,y) x+y#define AVE(x,y) (x+y)/2#define ToBig(x,y) (x &gt; y ? x : y)</code></pre><p>这种表达式就比函数又更骚了。但是他不同于函数，函数要入栈，又要入参，又要保持栈平衡。<br>在预编译的时候就会展开头文件替换所有的宏。</p><p>其次在动态开辟的时候，每次都要手动释放delete。那么也同样可以通过宏去干掉。</p><pre><code class="cpp">#define DeNullPtr(x) delete[] x;x=nullptr;...int main()&#123;    int *a = new int[100];    DeNullPtr(a);&#125;</code></pre><p>同样是没问题的。<img src="/2022/06/16/define/003.png" class=""><br>地址是0是因为nullptr的结果。<br>换个角度也其实挺像内联的，</p><hr><p><strong># 可以将一个标识符参数字符串化</strong></p><pre><code class="cpp">#define SHOW(x) std::cout &lt;&lt; #xSHOW(1234fg); //=&gt; std::cout &lt;&lt; &quot;1234fg&quot;;</code></pre><p><strong>## 可以连结两个标识符</strong></p><pre><code class="cpp">#define T1(x,y) void x##y()&#123;std::cout &lt;&lt; #y;&#125;T1(test, 01)</code></pre><p>这样就会生成一个函数</p><img src="/2022/06/16/define/004.png" class=""><p>看到两个井号连结在了一起，将x和y当作函数名，然后输出y即可。<br>实际上肯定也能调用显示：<img src="/2022/06/16/define/005.png" class=""><br>输出01是因为宏定义的时候输出的y部分，要想输出test也可以输出x即可。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>define的骚操作取决于程序员有多骚了可以说是。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;#define 通常用作定义常量&lt;br&gt;如&lt;code&gt;#define Pi 3.14&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="compiler" scheme="https://8bytes.top/tags/compiler/"/>
    
  </entry>
  
  <entry>
    <title>text006</title>
    <link href="https://8bytes.top/2022/06/16/text006/"/>
    <id>https://8bytes.top/2022/06/16/text006/</id>
    <published>2022-06-16T05:52:21.000Z</published>
    <updated>2022-06-17T05:56:17.941Z</updated>
    
    <content type="html"><![CDATA[<h1 id="麻了，居然被一只不知名虫子弄过敏了"><a href="#麻了，居然被一只不知名虫子弄过敏了" class="headerlink" title="麻了，居然被一只不知名虫子弄过敏了"></a>麻了，居然被一只不知名虫子弄过敏了</h1><span id="more"></span><p>痒的很。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;麻了，居然被一只不知名虫子弄过敏了&quot;&gt;&lt;a href=&quot;#麻了，居然被一只不知名虫子弄过敏了&quot; class=&quot;headerlink&quot; title=&quot;麻了，居然被一只不知名虫子弄过敏了&quot;&gt;&lt;/a&gt;麻了，居然被一只不知名虫子弄过敏了&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>ODR</title>
    <link href="https://8bytes.top/2022/06/15/ODR/"/>
    <id>https://8bytes.top/2022/06/15/ODR/</id>
    <published>2022-06-15T15:16:55.000Z</published>
    <updated>2022-06-22T14:13:20.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>全称为<code>One Definition Rule</code>，可以说是单定义原则或者规则<br>是为c++的语法规则，这个规则指出变量只能有一次定义。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>回顾编译的四大过程。预处理，编译，汇编，链接。<br>预处理 就是替换所有的宏定义，展开include的头文件，去掉注释和一些无关的。[由.c&#x2F;.cpp 到 .i]<br>编译 就是将高级语言的代码转换成机器语言的过程，主要进行语法之类的分析，优化成汇编。 [由.i 到 .s]<br>汇编 就是将源文件翻译成二进制，Windows会转换成.obj文件，类unix的为.o文件。 [.o文件时机器码所以纯文本无法正常显示]<br>链接 就是将.o文件和库文件绑定到一起，最终形成所谓的可执行程序。</p><p>这里的编译器用的visual studio了。<br>抽象上，.c&#x2F;.cpp + include&lt;.h&gt; 合并后称为转换单元<br>然后转换成.obj之类的，因为是windows平台。<br>最后链接成可执行程序.exe<br>当一切顺利时，自然不会有问题。语法上的编译器在编译器之前就能给出错误和警告。</p><pre><code class="cpp">#include&lt;iostream&gt;void test()&#123;    std::cout &lt;&lt; &quot;hhh&quot; &lt;&lt; std::endl;&#125;int main() &#123;    test();    return 0;&#125;</code></pre><p>主函数调用了一个函数，这个函数在编译的时候会先取一个别名，然后再去替换内存地址。如果不存在就会看到一个lnk类型的报错：</p><pre><code class="cpp">#include&lt;iostream&gt;void test()&#123;    std::cout &lt;&lt; &quot;hhh&quot; &lt;&lt; std::endl;&#125;extern void hh();int main() &#123;    test();    hh();    return 0;&#125;</code></pre><p>可以看到hh函数其实没有定义过，也未在其他文件有过声明，我们直接调用就会</p><img src="/2022/06/15/ODR/000.png" class=""><p>也就是link链接的时候发生的错误。<br>如果这个函数没有被调用其实就不会报错了。</p><hr><h2 id="未定义行为"><a href="#未定义行为" class="headerlink" title="未定义行为"></a>未定义行为</h2><p>c++标准未作规定的行为被称为未定义行为，未定义行为的结果是不确定的，具体表现在不同编译器之间。</p><ol><li>c &#x3D; 2*a++ + ++a*6</li><li>int x &#x3D; -25602; x &#x3D; x &gt;&gt; 2;</li></ol><p>拿1来说，a++是规定好的语法，x + a++的话是规定好了，先算x+a，再让a++; 这种简单的复合运算通过提前规定好而规避错误。但是人总是闲的蛋疼，就会整出一些无理由的题，这些题目不能百分之百的给你一个完美的解。<br>而例1的写法，谁能知道先算a++还是++a呢，如果++a先被计算了，那么前面的值肯定偏大了。抛开被优化了之后，有些可能交给寄存器处理了，所以意义不同了。</p><p>例2 纠结之处在于 负数有符号位，补0和1的时候结果大不相同，所以位运算尽量交给正数。</p><hr><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>那么ODR的体现就在于程序中定义的每个对象都有自己的规则。<br>在c++20中 任何变量、函数、类、枚举、模板在每个转换单元中都只允许有一个定义；<br>在c++17中非inline的函数或者变量在程序中有且只有一个定义；</p><p>什么叫定义和声明应该不用多做赘述</p><pre><code class="cpp">void test();void test();void test();void test();void test()&#123;    std::cout &lt;&lt; &quot;hello&quot; &lt;&lt; std::endl;&#125;</code></pre><p>像这种多个声明但是只有一个定义就没什么事，否则编译器就会给出报错。</p><img src="/2022/06/15/ODR/001.png" class=""><pre><code class="cpp">static int a = 250;const int a = 250;inline int a = 250; //c++17</code></pre><p>以上几个在一个项目里多个源文件重复定义了才不会报错，因为它们都有各自的内存空间。</p><hr><h2 id="链接属性"><a href="#链接属性" class="headerlink" title="链接属性"></a>链接属性</h2><p>之前看到过报错信息，函数在链接的时候的名字，c语言是直接在函数名前加了一个_，而c++ 因为有重载，所以要把类型参数等信息表现出来。</p><p>链接属性：</p><ol><li>内部链接属性：就是说这个名称只在本转换单元有效</li><li>外部链接属性：就是说这个名称在其他的转换单元中也有效</li><li>无链接属性：就是说这个名称只在作用域内访问</li></ol><p>这些个点在函数和变量上都能有所表现。</p><pre><code class="cpp">static hhh()&#123;&#125;const int h = 100;static int a = 200;int main()&#123;...&#125;</code></pre><blockquote><p>静态的函数，肯定是内部链接属性，他无法被其他文件调用<br>静态变量或者const常量，也同样是内部连接属性，在其他文件定义相同名称的并不影响编译</p></blockquote><pre><code class="cpp">int x = 100;hhh()&#123;&#125;int main()&#123;...&#125;</code></pre><blockquote><p>这种正常的全局函数或者变量就具有外部链接属性，在本质上他其实在编译的时候就加上了extern，作为外部声明。<br>所以一个const变量，也可以通过extern 被外部所发现。但是还是少用吧。</p></blockquote><p>如果就是希望这个变量或者函数没有外部属性，最常见就是static限定。<br>但是c++后期标准不推荐使用static，而是推荐一个未命名空间。<br>当然标准是一代一代继承的，不可能直接否定掉以前的办法。</p><hr><h3 id="inline和static"><a href="#inline和static" class="headerlink" title="inline和static"></a>inline和static</h3><p>在c++17之后才出现的inline 变量的写法。<br>先前的static 变量和函数都是没有问题的。<br>所以要特别注意下，开发的时候规定项目语法标准，免得有争议。</p><pre><code class="cpp">//main.cpp#include&lt;iostream&gt;inline int a = 350;void test();int main()&#123;    std::cout &lt;&lt; a &lt;&lt; &quot;\n&quot;;    test();&#125;</code></pre><pre><code class="cpp">//test.cpp#include&lt;iostream&gt;inline int a = 1000;void test()&#123;    std::cout &lt;&lt; a &lt;&lt; &quot;\n&quot;;&#125;</code></pre><p>在这种情况下，inline的a还能不一样吗？</p><img src="/2022/06/15/ODR/002.png" class=""><p>看到a的值都是main.cpp中定义的。</p><pre><code class="cpp">//test.cppp#include&lt;iostream&gt;inline int a = 1000;static int b = 2000;void test()&#123;    std::cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; &quot;\n&quot;;&#125;</code></pre><pre><code class="cpp">//main.cpp#include&lt;iostream&gt;inline int a = 350;static int b = 250;void test();int main() &#123;    std::cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; &quot;\n&quot;;    test();    return 0;&#125;</code></pre><p>再看static的情况</p><img src="/2022/06/15/ODR/003.png" class=""><p><strong>说明inline仍然是外部链接属性，static才是内部链接属性</strong><br>也就是为什么之前c++17提到非inline的才只有一个定义。</p><p>避免的方式也有，就是写进头文件，因为一般定义头文件的时候都会有<code>#pragma once</code>这种防重的，这样的话就不会管其他地方定义的是什么样的，只看头文件里面就好了。</p><p>变量已是如此，函数当然亦是如此~</p><pre><code class="cpp">//test.cpp#include&lt;iostream&gt;inline int a = 1000;static int b = 2000;static void Test()&#123;    std::cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; &quot;\n&quot;;&#125;void testp()&#123;    Test();&#125;</code></pre><pre><code class="cpp">#include&lt;iostream&gt;inline int a = 350;static int b = 250;void testp();static void Test()&#123;    std::cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; &quot;\n&quot;;&#125;int main() &#123;    std::cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; &quot;\n&quot;;    testp();    Test();    return 0;&#125;</code></pre><img src="/2022/06/15/ODR/004.png" class=""><p>能够看到main.cpp的static void Test写法跟test.cpp没啥差别，但是两个函数作用在不同的文件。<br>也就说明了static的变量或函数都有不同的内存分配。</p><p>函数改成inline结果也不用多想，就会按照main.cpp的来了</p><img src="/2022/06/15/ODR/005.png" class=""><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>倒也不是啥大事，一些编译器和语法标准的问题。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;全称为&lt;code&gt;One Definition Rule&lt;/code&gt;，可以说是单定义原则或者规则&lt;br&gt;是为c++的语法规则，这个规则指出变量只能有一次定义。&lt;/p&gt;</summary>
    
    
    
    
    <category term="compiler" scheme="https://8bytes.top/tags/compiler/"/>
    
  </entry>
  
  <entry>
    <title>递归函数</title>
    <link href="https://8bytes.top/2022/06/14/function12/"/>
    <id>https://8bytes.top/2022/06/14/function12/</id>
    <published>2022-06-14T15:48:23.000Z</published>
    <updated>2022-06-21T15:13:25.209Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>递归主要是应对与数学场景吧。<br>简单来说就是函数 直接或间接的调用了自己，那么这个函数就可以说时递归函数<br><strong>内联函数不能作为递归函数</strong></p><span id="more"></span><pre><code class="cpp">void hhh()&#123;    if(...)        hhh();    else        ...;&#125;</code></pre><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>接触最早的递归函数应该是阶乘了。<br>n! &#x3D; 1 x 2 x 3 x 4 x…(n-1) x n</p><p>按照函数的操作，就是传递一个参数，每次乘以这个参数-1，当参数&#x3D;&#x3D;1的时候就返回参数就行了。</p><pre><code class="cpp">int func(int x)&#123;    if (x == 1) return x;    return x * func(x - 1);&#125;</code></pre><p>假设x&#x3D;10</p><blockquote><p>10 x func(9)<br>9 x func(8)<br>8 x func(7)<br>7 x func(6)<br>6 x func(5)<br>…<br>2 x 1 &#x2F;&#x2F; x&#x3D;&#x3D;1,return x;所以不进函数了。</p></blockquote><p><strong>递归函数用的时候一定要能结束。。。不然堆栈溢出程序也没法跑</strong></p><p>当然你说这种操作用for循环其实还更快，都不用反复入栈了。但递归在可阅读性和逻辑上总归有益处。<br>要相信能活下来的总归有道理，而且设计一个递归函数难度也不小。</p><hr><p>抛开函数调用自己，如果函数反复调用其他函数或者多个函数。</p><pre><code class="cpp">int func0()&#123;    ...&#125;int func1()&#123;    ...&#125;int func2()&#123;    func1();....&#125;//示意模板而已</code></pre><p>函数之间调用进行递归，更需要注意安全。且也要保证能够被解读。不如还不如for循环。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>递归更加适用于树形结构的情况。<br>一个良好的递归函数，我们期望它每一次都更接近答案，并且能够在特定情况下终止处理。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;递归主要是应对与数学场景吧。&lt;br&gt;简单来说就是函数 直接或间接的调用了自己，那么这个函数就可以说时递归函数&lt;br&gt;&lt;strong&gt;内联函数不能作为递归函数&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://8bytes.top/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>函数调用约定</title>
    <link href="https://8bytes.top/2022/06/14/function11/"/>
    <id>https://8bytes.top/2022/06/14/function11/</id>
    <published>2022-06-14T14:48:23.000Z</published>
    <updated>2022-06-21T03:45:05.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>函数调用和被调用之间肯定要规定，如何传递参数，如何恢复栈平衡的问题。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>程序运行最开始，main函数肯定是第一个入栈的，其他的函数被调用时相继入栈。</p><hr><h2 id="cdecl"><a href="#cdecl" class="headerlink" title="_cdecl"></a>_cdecl</h2><pre><code class="cpp">#include&lt;iostream&gt;int add(int a, int b);int main()&#123;    add(1, 2);    return 0;&#125;</code></pre><p>编译自然报错，但是我们看报错信息</p><img src="/2022/06/14/function11/000.png" class=""><p>之前说到过C语言处理函数在.obj文件下都是加一个<code>_</code><br>而c++因为有重载的功能所以还多了参数，除此之外就是<code>_cdecl</code></p><p><code>_cdecl</code>的参数入栈 <code>从右到左</code></p><img src="/2022/06/14/function11/001.png" class=""><p>堆栈平衡：谁调用谁平衡</p><img src="/2022/06/14/function11/003.png" class=""><p>所以这种方式能够支持不定量参数。 不定量详情看function1吧，好像写在那里了。</p><blockquote><p>虽然不定量，但是毕竟是从右边开始传递，所以不会出现丢三落四的情况。</p></blockquote><hr><h2 id="stdcall"><a href="#stdcall" class="headerlink" title="_stdcall"></a>_stdcall</h2><p>因为一般都是_cdecl 所以这玩意比较少见，但是反正能指定。</p><pre><code class="cpp">#include&lt;iostream&gt;int _stdcall add(int a, int b)&#123;    return a + b;&#125;int main()&#123;    add(1, 2);    return 0;&#125;</code></pre><p><code>_stdcall</code>的参数入栈顺序同为 从右往左<br>堆栈平衡：由函数自己恢复栈平衡</p><img src="/2022/06/14/function11/002.png" class=""><p>特色就是windows编程中WINAPI CALLBACK都是<code>_stdcall</code>的宏<br>并且生成的函数名会加下划线，后面跟@和参数尺寸</p><img src="/2022/06/14/function11/004.png" class=""><hr><h2 id="fastcall"><a href="#fastcall" class="headerlink" title="_fastcall"></a>_fastcall</h2><p>fast看着就想快速</p><pre><code class="cpp">#include&lt;iostream&gt;int _fastcall add(int a, int b)&#123;    return a + b;&#125;int main()&#123;    add(1, 2);    return 0;&#125;</code></pre><p>它的特点就是第一个参数由ecx寄存器传递，第二个参数由dex寄存器传递<br>剩余参数仍然按照入栈顺序 从右到左依次入栈</p><img src="/2022/06/14/function11/005.png" class=""><p>可以看到俩参数没有通过push指令压入栈中，而是mov给寄存器。</p><p>堆栈平衡：由函数自己恢复栈平衡</p><img src="/2022/06/14/function11/006.png" class=""><p>因为有俩寄存器调用了，所以相对而言会比较快。</p><blockquote><p>当多个形参，比如三个时，add(1,2,3);<br>3先被push入栈，2和1分别交给寄存器<br>恢复栈平衡的时候ret 4。 就是只压入了一个3，所以要释放掉。</p></blockquote><hr><h2 id="其他调用"><a href="#其他调用" class="headerlink" title="其他调用"></a>其他调用</h2><p>_thiscall 是用于c++中类的访问，用到类的底层时再看<br>naked call是一个常用的约定，一般也就是实验模式驱动开发</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>有特殊需求的时候自然会指定函数的调用方式。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;函数调用和被调用之间肯定要规定，如何传递参数，如何恢复栈平衡的问题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://8bytes.top/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>text005</title>
    <link href="https://8bytes.top/2022/06/13/text005/"/>
    <id>https://8bytes.top/2022/06/13/text005/</id>
    <published>2022-06-12T18:52:39.000Z</published>
    <updated>2022-06-17T06:15:25.757Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阴雨绵绵心情复杂"><a href="#阴雨绵绵心情复杂" class="headerlink" title="阴雨绵绵心情复杂"></a>阴雨绵绵心情复杂</h1><span id="more"></span><p>还得是没过期的感冒灵和胃药！</p><img src="/2022/06/13/text005/000.jpg" class="">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;阴雨绵绵心情复杂&quot;&gt;&lt;a href=&quot;#阴雨绵绵心情复杂&quot; class=&quot;headerlink&quot; title=&quot;阴雨绵绵心情复杂&quot;&gt;&lt;/a&gt;阴雨绵绵心情复杂&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>vs2022自定义模板</title>
    <link href="https://8bytes.top/2022/06/12/myproject/"/>
    <id>https://8bytes.top/2022/06/12/myproject/</id>
    <published>2022-06-12T11:52:28.000Z</published>
    <updated>2022-06-21T15:14:23.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>搞了丐版sdk之后，还可以搞个自己所谓的项目类型。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><p>模板自然是指可以省去一些基本操作，比如每次新建项目都要新建一个源文件，然后写代码</p><pre><code class="cpp">#include&lt;iostream&gt;int main()&#123;    return 0;&#125;</code></pre><p>之类的操作。<br>创建一个项目模板的好处是除了文件模板，还对项目有额外引用库什么的选项一并设置好。</p><p>这里用项目模板举例就直接套上个sdk项目的了</p><img src="/2022/06/12/myproject/000.png" class=""><img src="/2022/06/12/myproject/001.png" class=""><p>下一步就完事</p><img src="/2022/06/12/myproject/002.png" class=""><p>至于要不要图标什么的自己选就行，然后输出位置可以默认也可以自己操作，但是不了解的情况下就先用默认的。</p><p>完成之后会打开那个文件夹能看到一个lowskd.zip的文件</p><blockquote><p>这里手快了名字敲反了罪过。。</p></blockquote><p>然后新建项目就能看到多了一个选项是自建的</p><img src="/2022/06/12/myproject/003.png" class=""><p>然后顺着这个类型新建项目</p><img src="/2022/06/12/myproject/004.png" class=""><p>发现文件默认就在了。并且库的路径也存在属性中</p><img src="/2022/06/12/myproject/005.png" class=""><hr><h2 id="模板文件"><a href="#模板文件" class="headerlink" title="模板文件"></a>模板文件</h2><pre><code class="cpp">#include&lt;iostream&gt;int main()&#123;    return 0;&#125;</code></pre><p>每次新建其实都要输入这个。</p><p>那么在建模板的时候就看到了其实可以对文件也进行操作。<br>老样子在项目里选择导出模板</p><img src="/2022/06/12/myproject/006.png" class=""><p>选择导出项</p><img src="/2022/06/12/myproject/007.png" class=""><p>选择源文件里面的这个文件</p><img src="/2022/06/12/myproject/008.png" class=""><p>老样子要改的地方改一下。名字的话为了更贴切可以用main，因为新建类型文件的时候</p><img src="/2022/06/12/myproject/009.png" class=""><hr><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>有两个地方要删除，不然好像还是会存在</p><ol><li>C:\Users\用户名\Documents\Visual Studio 2022\My Exported Templates</li><li><ol><li>C:\Users\用户名\Documents\Visual Studio 2022\Templates\ItemTemplates  &#x2F;&#x2F;这个属于项</li><li>C:\Users\用户名\Documents\Visual Studio 2022\Templates\ProjectTemplates   &#x2F;&#x2F;这个属于项目</li></ol></li></ol><p>好像是2022变多了，网上搜的17和19 第二个地方其实是一个，不过问题不大，看到那个新建的.zip干掉就行了。</p><p>要是在细点，其实应该在分类，因为这俩文件夹里面有不同类型的语种，我们这些zip其实应该放到各自的里面。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>不过这玩意总归先敲敲熟，熟了自然摸鱼。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;搞了丐版sdk之后，还可以搞个自己所谓的项目类型。&lt;/p&gt;</summary>
    
    
    
    
    <category term="visual studio 2022" scheme="https://8bytes.top/tags/visual-studio-2022/"/>
    
  </entry>
  
</feed>
