<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ohmyhsy</title>
  
  <subtitle>8bytes-code</subtitle>
  <link href="https://8bytes.top/atom.xml" rel="self"/>
  
  <link href="https://8bytes.top/"/>
  <updated>2022-09-16T14:02:02.340Z</updated>
  <id>https://8bytes.top/</id>
  
  <author>
    <name>Box</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>给爪机上点科技</title>
    <link href="https://8bytes.top/2022/09/16/phoneTest/"/>
    <id>https://8bytes.top/2022/09/16/phoneTest/</id>
    <published>2022-09-16T12:22:58.000Z</published>
    <updated>2022-09-16T14:02:02.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="u1s1，爪机配火龙三八夏天真的遭不住"><a href="#u1s1，爪机配火龙三八夏天真的遭不住" class="headerlink" title="u1s1，爪机配火龙三八夏天真的遭不住"></a>u1s1，爪机配火龙三八夏天真的遭不住</h1><p>原本打算root掉，但是有些数据懒得备份了，重新下和导入导出太费时间。</p><ul><li>phone：Xiaomi 11u</li><li>system：miui 13</li><li>12+256&#x2F;意义不大</li></ul><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><ol><li>火龙三八发热量惊人。。手机温度一高就卡起来掉帧还掉电</li><li>相机也是个坑，过热会打不开，有的时候打开黑屏</li></ol><p>sou不了啊，root虽然看上去效果好但是懒得弄</p><p>之前都酷安上看到shizuku+小黑屋的方法，可以稍微减少点负担。</p><blockquote><p>ps：如果没有科学上网，软件就只能自己酷安慢慢找包了</p></blockquote><hr><h2 id="shizuku"><a href="#shizuku" class="headerlink" title="shizuku"></a>shizuku</h2><p><a href="https://shizuku.rikka.app/zh-hans/guide/setup/">文档戳此处</a></p><p>我所使用的时无线调试启动<br><strong>注意：没有root的手机只能用无线调试或者电脑连接adb，这两种方法在手机重启后均会失效</strong></p><p>具体的跟着步骤来就行</p><p>还有一点下面的常见问题有写，就是输入配对码的时候直接提示失败，需要你去修改一下</p><pre><code>通过无线调试启动：点击“输入配对码”后立刻提示失败MIUI（小米）在系统设置的“通知管理”-“通知显示设置”将通知样式切换为“原生样式”。</code></pre><p><strong>同时锁定后台，允许自启动，省电策略选择无设置，不然没法提权</strong></p><p>最后样式类似这样</p><img src="/2022/09/16/phoneTest/000.jpg" class=""><p>已授权一个应用是后面要说的小黑屋</p><hr><h2 id="小黑屋"><a href="#小黑屋" class="headerlink" title="小黑屋"></a>小黑屋</h2><p>同样的下载没有科学上网的前提大概率还是上酷安找包好了。</p><p>小黑屋没有什么需要搞的，因为弄完shizuku基本都配置好了，记得在shizuku给小黑屋权限，不然没法冻结app。</p><p>详细的列表也还是建议b站或者酷安参考，因为我也只参考了一部分</p><img src="/2022/09/16/phoneTest/001.jpg" class=""><hr><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>平常发热是没这么高了，而且内存全部清空的时候剩余内存也比之前多，说明有些系统组件是真的没啥用，硬堆叠。。。</p><p>省电具体感知要看情况了，至少目前这两天没有感觉明显掉帧吧。<br>而且我后台还挂着一个zeep life，就是小米运动改版，毕竟连这个手环。所以相对而言也还是再跑电。</p><p>只要别烫别乱掉帧咋样都行。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>并非教程，只是简单记录，教程不如b站搜看视频来的直接~</p><p><a href="https://www.bilibili.com/">哔哩哔哩</a><br><a href="https://www.baidu.com/">百度</a><br><a href="https://cn.bing.com/">bing</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;u1s1，爪机配火龙三八夏天真的遭不住&quot;&gt;&lt;a href=&quot;#u1s1，爪机配火龙三八夏天真的遭不住&quot; class=&quot;headerlink&quot; title=&quot;u1s1，爪机配火龙三八夏天真的遭不住&quot;&gt;&lt;/a&gt;u1s1，爪机配火龙三八夏天真的遭不住&lt;/h1&gt;&lt;p&gt;原本打算root掉，但是有些数据懒得备份了，重新下和导入导出太费时间。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;phone：Xiaomi 11u&lt;/li&gt;
&lt;li&gt;system：miui 13&lt;/li&gt;
&lt;li&gt;12+256&amp;#x2F;意义不大&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="phone" scheme="https://8bytes.top/tags/phone/"/>
    
  </entry>
  
  <entry>
    <title>远控问题集</title>
    <link href="https://8bytes.top/2022/09/15/%E8%BF%9C%E6%8E%A7%E9%97%AE%E9%A2%98%E9%9B%86/"/>
    <id>https://8bytes.top/2022/09/15/%E8%BF%9C%E6%8E%A7%E9%97%AE%E9%A2%98%E9%9B%86/</id>
    <published>2022-09-15T12:24:52.000Z</published>
    <updated>2022-09-16T14:09:46.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="记录远控所产生的bug"><a href="#记录远控所产生的bug" class="headerlink" title="记录远控所产生的bug"></a>记录远控所产生的bug</h1><p style="font-size:12px; text-align:right;">—— 记录我的尴尬</p><span id="more"></span><hr><h1 id="问题集"><a href="#问题集" class="headerlink" title="问题集"></a>问题集</h1><h2 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h2><p>关于远控服务端客户端联调时</p><h3 id="情景"><a href="#情景" class="headerlink" title="情景"></a>情景</h3><img src="/2022/09/15/%E8%BF%9C%E6%8E%A7%E9%97%AE%E9%A2%98%E9%9B%86/002.png" class=""><p>需要通过查看文件信息按钮，响应之后应该是在下面的框中显示出此电脑的磁盘信息</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>并没有显示，而是弹出了一个命令处理失败。显然是<code>SendCommandPacket</code>函数出了问题</p><h3 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h3><p>经过debug之后发现<code>int cmd = pClient-&gt;DealCommand();</code>,返回值cmd值不正常<br>单步到<code>DealCommand时</code>发现<code>size_t len = recv(m_sock, buffer, BUFFER_SIZE - index, 0);</code>，此时len的返回值是0，这说明服务端可能发包存在问题。</p><h3 id="快速定位"><a href="#快速定位" class="headerlink" title="快速定位"></a>快速定位</h3><p>原来是<code>MakeDriverInfo()</code>函数中，之前测试的时候注释掉了<code>CServerSocket::getInstance()-&gt;Send(pack);</code>因为没有发包，所以自然得不到任何数据。</p><h3 id="小意外又来了-修补"><a href="#小意外又来了-修补" class="headerlink" title="小意外又来了+修补"></a>小意外又来了+修补</h3><p>修改完之后还是提示命令处理失败，继续回溯<br>发现在<code>DealCommand函数中</code>运行到这步的时候</p><img src="/2022/09/15/%E8%BF%9C%E6%8E%A7%E9%97%AE%E9%A2%98%E9%9B%86/000.png" class=""><img src="/2022/09/15/%E8%BF%9C%E6%8E%A7%E9%97%AE%E9%A2%98%E9%9B%86/001.png" class=""><p>len和index明明是有值的，但是一经过<code>m_packet = CPacket((BYTE*)buffer, len);</code>,len就变成0了，奶奶的，只好从CPacket设计找起。。。</p><p>然后就是一个尴尬的问题</p><pre><code class="cpp">CPacket(const BYTE* pData, size_t&amp; nSize) &#123;        size_t i = 0;        for (; i &lt; nSize; i++) &#123;            if (*(WORD*)(pData + i) == 0xFEFF) &#123;                sHead = *(WORD*)(pData + i);                //i+=2 避免空包时读到后面的数据                i += 2;                break;            &#125;        &#125;        //此处长度参考包的设计        if ((i + 4 + 2 + 2) &gt; nSize) &#123;    //包数据可能不全，或者包头未能全部接收到            nSize = 0;            return;        &#125;        nLength = *(WORD*)(pData + i); i += 4;        if (nLength + i &gt; nSize) &#123;        //包未完全接受，解析失败就返回            nSize = 0;            return;        &#125;        sCmd = *(WORD*)(pData + i);  i += 2;        if (nLength &gt; 4) &#123;            strData.resize(nLength - sCmd - 2 - 2);            memcpy((void*)strData.c_str(), pData + i, nLength - 4);            i += nLength - 4;        &#125;        sSum = *(WORD*)(pData + i); i += 2;        WORD sum = 0;        for (size_t j = 0; j &lt; strData.size(); j++) &#123;            sum += BYTE(strData[j]) &amp; 0xFF;        &#125;        if (sum == sSum) &#123;            nSize = i;    //head length...            return;        &#125;        //nSize = 0;    &#125;</code></pre><p>我抄代码的时候居然不记得底下有个<code>nSize=0</code>，tmd，难怪每次包收到了之后len变成0了。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>抄代码要仔细。。注释和不注释要看清楚。</p><hr><h2 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h2><h3 id="情景-1"><a href="#情景-1" class="headerlink" title="情景"></a>情景</h3><p>接上文，按下按钮之后可以显示出磁盘了，但是少了一个盘</p><img src="/2022/09/15/%E8%BF%9C%E6%8E%A7%E9%97%AE%E9%A2%98%E9%9B%86/003.png" class=""><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>记得之前测试的时候都是好好的，而且老师虽然收到的盘是全的，打印出来的又不全，算是两个小问题</p><h3 id="debug-1"><a href="#debug-1" class="headerlink" title="debug"></a>debug</h3><p>直接打断点到<code>MakeDriverInfo</code>上<br>经过循环可以看到</p><img src="/2022/09/15/%E8%BF%9C%E6%8E%A7%E9%97%AE%E9%A2%98%E9%9B%86/004.png" class=""><p>此时result的值是完全没有问题的。</p><img src="/2022/09/15/%E8%BF%9C%E6%8E%A7%E9%97%AE%E9%A2%98%E9%9B%86/005.png" class=""><img src="/2022/09/15/%E8%BF%9C%E6%8E%A7%E9%97%AE%E9%A2%98%E9%9B%86/006.png" class=""><img src="/2022/09/15/%E8%BF%9C%E6%8E%A7%E9%97%AE%E9%A2%98%E9%9B%86/007.png" class=""><img src="/2022/09/15/%E8%BF%9C%E6%8E%A7%E9%97%AE%E9%A2%98%E9%9B%86/008.png" class=""><p>到这里为止，服务端肯定没发错。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;记录远控所产生的bug&quot;&gt;&lt;a href=&quot;#记录远控所产生的bug&quot; class=&quot;headerlink&quot; title=&quot;记录远控所产生的bug&quot;&gt;&lt;/a&gt;记录远控所产生的bug&lt;/h1&gt;&lt;p style=&quot;font-size:12px; text-align:right;&quot;&gt;—— 记录我的尴尬&lt;/p&gt;</summary>
    
    
    
    
    <category term="RemoteControl" scheme="https://8bytes.top/tags/RemoteControl/"/>
    
  </entry>
  
  <entry>
    <title>text021</title>
    <link href="https://8bytes.top/2022/09/10/text021/"/>
    <id>https://8bytes.top/2022/09/10/text021/</id>
    <published>2022-09-10T10:49:15.000Z</published>
    <updated>2022-09-10T10:52:17.442Z</updated>
    
    <content type="html"><![CDATA[<h1 id="卒"><a href="#卒" class="headerlink" title="卒"></a>卒</h1><p>花了半天时间想修改一下用git按分支上传，奈何实力不够，只能重头选择<code>hexo d</code></p><span id="more"></span><hr><p>太失败了，主要基于git的应用太少了，在不确定两个分支都从主分支签出之后，改动一个分支合并给主分支是否会对另一个分支造成影响。毕竟写了水文挺多的，不太适合做实验。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;卒&quot;&gt;&lt;a href=&quot;#卒&quot; class=&quot;headerlink&quot; title=&quot;卒&quot;&gt;&lt;/a&gt;卒&lt;/h1&gt;&lt;p&gt;花了半天时间想修改一下用git按分支上传，奈何实力不够，只能重头选择&lt;code&gt;hexo d&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>text020</title>
    <link href="https://8bytes.top/2022/09/10/text020/"/>
    <id>https://8bytes.top/2022/09/10/text020/</id>
    <published>2022-09-09T16:11:59.000Z</published>
    <updated>2022-09-09T16:13:32.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中秋"><a href="#中秋" class="headerlink" title="中秋~"></a>中秋~</h1><p>最近确实没什么好写了，抄抄项目先，虽然很多东西都不能理解，但是设计思路很新颖，抄几遍再说！</p><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;中秋&quot;&gt;&lt;a href=&quot;#中秋&quot; class=&quot;headerlink&quot; title=&quot;中秋~&quot;&gt;&lt;/a&gt;中秋~&lt;/h1&gt;&lt;p&gt;最近确实没什么好写了，抄抄项目先，虽然很多东西都不能理解，但是设计思路很新颖，抄几遍再说！&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>text019</title>
    <link href="https://8bytes.top/2022/09/05/text019/"/>
    <id>https://8bytes.top/2022/09/05/text019/</id>
    <published>2022-09-05T09:21:11.000Z</published>
    <updated>2022-09-05T09:23:11.786Z</updated>
    
    <content type="html"><![CDATA[<h1 id="上课"><a href="#上课" class="headerlink" title="上课~"></a>上课~</h1><span id="more"></span><hr><ul><li>周六刚到整理休整睡大觉<ul><li>所幸小王八没挂，坚挺</li></ul></li><li>周日小搓一顿，只是味道没有之前好了</li><li>台风天周一停课妙哉</li></ul><p>最后抓紧学习，要打工了！</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;上课&quot;&gt;&lt;a href=&quot;#上课&quot; class=&quot;headerlink&quot; title=&quot;上课~&quot;&gt;&lt;/a&gt;上课~&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>text018</title>
    <link href="https://8bytes.top/2022/08/31/text018/"/>
    <id>https://8bytes.top/2022/08/31/text018/</id>
    <published>2022-08-31T11:11:36.000Z</published>
    <updated>2022-08-31T11:12:46.555Z</updated>
    
    <content type="html"><![CDATA[<h1 id="临近开学"><a href="#临近开学" class="headerlink" title="临近开学"></a>临近开学</h1><span id="more"></span><hr><ul><li>驾照未完成，心情实属复杂。。。</li><li>而且也是最后一学期了，咱就是说，这回逃避不了社会的毒打了。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;临近开学&quot;&gt;&lt;a href=&quot;#临近开学&quot; class=&quot;headerlink&quot; title=&quot;临近开学&quot;&gt;&lt;/a&gt;临近开学&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>UB未定义行为</title>
    <link href="https://8bytes.top/2022/08/24/undefinedbehaviour/"/>
    <id>https://8bytes.top/2022/08/24/undefinedbehaviour/</id>
    <published>2022-08-24T15:17:13.000Z</published>
    <updated>2022-08-25T07:30:35.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>额。。惭愧，今天在群里听到UB，我还以为是啥咋没听过。</p><p>UB:<code>undefined behaviour</code>，简称：<code>未定义行为</code>。<br>不过u1s1啊。undefined，这个经常见，所以一听就知道，组合词确实是我孤陋寡闻了。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><img src="/2022/08/24/undefinedbehaviour/000.png" class=""><p>这是当时群里的题</p><p>不过借此，也可以适当进一步了解未定义行为。</p><p>首先，未定义行为怎么来的？也不合适，应该是先考虑定义。<br>所谓的语言标准，自然有自己的标准委员会提出，也就是c++ iso的说法，即c++11、c++14巴拉巴拉的，除去这一层，不同的编译器也可能自己做了优化，又多了一层定义。那么这层定义就比较搞了，因为相同的代码在不同编译器下就很有可能出问题。所以尽量不要再这上面钻牛角尖。</p><blockquote><p>未定义行为：可以说是语言标准没有规定，编译器自行决定的行为，而且在不同的编译器上有时会有不同的结果。</p></blockquote><hr><h2 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h2><p>就是很无聊的++问题</p><pre><code class="cpp">int i = 0;i = i++;</code></pre><p>在我们的印象里，后置递增，先操作后自增。即<code>i=i; i++</code><br>但是还有一种恶心的情况，<code>i++; i=i </code></p><p>当然这里能想到后者就完犊子了，肯定是先赋值后递增，所以i&#x3D;1</p><p>然后就来了</p><pre><code class="cpp">int i = 0;int j = 0;i = i+++j;</code></pre><p>问？正常情况下你觉得是<code>i=(i++)+j</code>还是<code>i=i+(++j)</code></p><p>让我们瞅瞅vs的反汇编</p><pre><code class="shell">00007FF72C6A1E22  mov         eax,dword ptr [j]  00007FF72C6A1E25  mov         ecx,dword ptr [i]  00007FF72C6A1E28  add         ecx,eax  00007FF72C6A1E2A  mov         eax,ecx  00007FF72C6A1E2C  mov         dword ptr [i],eax  00007FF72C6A1E2F  mov         eax,dword ptr [i]  00007FF72C6A1E32  inc         eax  00007FF72C6A1E34  mov         dword ptr [i],eax </code></pre><blockquote><p>汇编指令inc 是让操作数+1</p></blockquote><p>首先把j的值传给eax，把i的值传给ecx，然后ecx+eax，再把ecx的值传给eax，也就是i+j，<br>然后把eax的值传回给变量i，变量i的值又传给eax，然后eax 完成inc，也就是自增，最后再把eax的值传回变量i。也就是后面的自增。</p><p>显然在vs中，<code>i = (i++)+j</code>。</p><p><strong>tips：这里其实也有个小坑，就是运算符优先级，他会优先处理掉高等级的，所以在有的时候你不要去让编译器考虑优先级，你应该加括号自己先预演好优先级</strong></p><p>还有一种吊炸天的问题</p><pre><code class="cpp">int i = 0;int j = 0;i = i+++++j;std::cout &lt;&lt; i;</code></pre><p>你说是<code>i+ (++(++j))</code>还是<code>i++ + ++j</code><br>很无厘头啊，虽然现在的vs会要求你有格式控制，一整串他是不认账的。</p><p>但是你要放在试卷上，就是铁nt行为。</p><p>像已知的，gcc、msvc、clang他们的支持就有区别了。<br>这种无厘头的说实在没有必要太纠结，开发这么写要给打死。<br>也别只拿vs的反汇编说话，虽然能给出一个答案，但是不管从什么角度而言这种题目都很反人类。</p><hr><h2 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h2><p>标准定义，常量是在初始化也可以说定义后是不能被修改的</p><pre><code class="cpp">const int a = 1;int *b = (int*)&amp;a;*b = 2;</code></pre><p>那么a的值？</p><p>在iso硬性规定常量不能被修改，因为常量被当成右值了。<br>当我们强制转换成整型指针然后取他的地址。就变相的控制了</p><p>很显然这也是未定义行为，不过有些时候还真有这么用的，但是不太好。毕竟万一常量释放了，这个指针又不知道搞哪去了。</p><hr><h2 id="例三"><a href="#例三" class="headerlink" title="例三"></a>例三</h2><p>就是重复释放</p><pre><code class="cpp">int *p = new int;delete p;delete p;</code></pre><p>编译器不会报错，但不能保证会不会出现别的结果。</p><hr><h2 id="总而言之"><a href="#总而言之" class="headerlink" title="总而言之"></a>总而言之</h2><p>我所知道的都是比较浅薄的，百度一搜都有很多高端的东西，像是容器+算法然后整的活。可能这才是真正的程序员吧，还要翻阅文献什么的确实太顶了。。<br>严格意义上，未定义行为不算一个详细的知识体系，你不可能记住所有的未定义行为吧。。。毕竟是叫未定义啊，有些指不定还是你整的活。</p><p>常见的反正就是那么几种</p><ol><li>有符号类型赋值的时候超出范围</li><li>函数体之间忘记初始化之类的</li><li>算术表达式写的不好就会产生未定义的结果</li><li>数学性质除以0</li><li>经典溢出，有的时候溢出是不一定会报错的</li></ol><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>坦白的说，还不够深入了解<br>但是一码归一码，像这种未定义行为可能还是因为c&#x2F;c++比较自由<br>还得努力学啊~~~感觉自己就是废物</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;额。。惭愧，今天在群里听到UB，我还以为是啥咋没听过。&lt;/p&gt;
&lt;p&gt;UB:&lt;code&gt;undefined behaviour&lt;/code&gt;，简称：&lt;code&gt;未定义行为&lt;/code&gt;。&lt;br&gt;不过u1s1啊。undefined，这个经常见，所以一听就知道，组合词确实是我孤陋寡闻了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://8bytes.top/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>text017</title>
    <link href="https://8bytes.top/2022/08/20/text017/"/>
    <id>https://8bytes.top/2022/08/20/text017/</id>
    <published>2022-08-20T14:09:41.000Z</published>
    <updated>2022-08-21T09:57:10.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="哎。"><a href="#哎。" class="headerlink" title="哎。"></a>哎。</h1><span id="more"></span><p>没话说，这辈子没这么无语，时间周期长却无所事事。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;哎。&quot;&gt;&lt;a href=&quot;#哎。&quot; class=&quot;headerlink&quot; title=&quot;哎。&quot;&gt;&lt;/a&gt;哎。&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>没搞头的ssd跑分</title>
    <link href="https://8bytes.top/2022/08/20/ssdTest/"/>
    <id>https://8bytes.top/2022/08/20/ssdTest/</id>
    <published>2022-08-20T09:02:32.000Z</published>
    <updated>2022-09-09T15:06:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="随便测测反正娱乐"><a href="#随便测测反正娱乐" class="headerlink" title="随便测测反正娱乐"></a>随便测测反正娱乐</h1><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>主流两个软件</p><ul><li>AS SSD Benchmark</li><li>CrystalDiskMark</li></ul><p>但是u1s1前者的成绩比较渣，后者的还比较符合厂家给出的理论最大上限。</p><img src="/2022/08/20/ssdTest/asssd01.png" class=""><img src="/2022/08/20/ssdTest/cdm02.png" class=""><blockquote><p>以pm9a1来说，pice4.0*4，厂家给出的数据，<br>1tb的容量，r：7000mb&#x2F;s，w：5100mb&#x2F;s</p></blockquote><p>其实感觉也得考虑几个问题</p><ol><li>温度影响，简单安装的硬盘，也没搞铜片或者石墨烯，温度高了也有可能造成性能损耗</li><li>已有容量，感觉空盘切没分盘的时候可能效果最好</li><li>系统，win10和win11，win11感觉还是不完善。。win10也有点要搞事情的感觉</li><li>软件，就上面两个而言就能看出区别</li></ol><p>虽然我们也不得而知两个软件是靠什么得出这个数据，而且本身就是看一看。。实际感知到了一定程度并没有这么敏感。</p><p>搜了一下，有个说法挺有意思，但仅供参考<br>首先就是进制问题，硬盘厂家采用的是10进制啊，而计算机底层是二进制。<br>1tb 本来应该是 1024g，但是通过厂家的设计，变成了9xx多个g。<br>这也导致，这两个软件有一个要使用二进制去算成绩，肯定比十进制要低。</p><p>所以。。谁高谁低，谁用十进制谁用二进制或许可窥一斑</p><p>另一种4k对齐的说法和缓冲区，但是鬼晓得。。咱也不探讨这么深，就是说简单看看，不然到手看到as ssd的速度我都想退货了md。</p><p><strong>注意：不是专业的，仅为娱乐发言</strong></p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>所以实际上极值咱也别追求了，损耗能在5%-10%左右就很好了。虽然心理预期总归不舒服。<br>有异常，建议先搜这个硬盘型号，看看是否也有人遇到，除此之外如果是升级完系统突然掉速可回退，固件版本带来的影响目前没感受到。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;随便测测反正娱乐&quot;&gt;&lt;a href=&quot;#随便测测反正娱乐&quot; class=&quot;headerlink&quot; title=&quot;随便测测反正娱乐&quot;&gt;&lt;/a&gt;随便测测反正娱乐&lt;/h1&gt;</summary>
    
    
    
    
    <category term="NoteBook" scheme="https://8bytes.top/tags/NoteBook/"/>
    
  </entry>
  
  <entry>
    <title>小王八git版本控制工具</title>
    <link href="https://8bytes.top/2022/08/18/TortoiseGit/"/>
    <id>https://8bytes.top/2022/08/18/TortoiseGit/</id>
    <published>2022-08-18T14:07:23.000Z</published>
    <updated>2022-09-10T11:34:17.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>需要科学。</p><ul><li><a href="https://tortoisegit.org/download/">下载地址</a></li></ul><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><img src="/2022/08/18/TortoiseGit/000.png" class=""><p>一般都是选x64了，虽然也有不少应用还是这个x86，但是记得配套就行，上面是git本体，下面是语言包</p><p><strong>温馨提示，最好先下个git for windows，我因为早下了所以好像没提示</strong></p><hr><h2 id="vs配置"><a href="#vs配置" class="headerlink" title="vs配置"></a>vs配置</h2><p>然后就是visual studio的配置，一般也不做啥调整<br>打开工具-选项-源代码管理</p><img src="/2022/08/18/TortoiseGit/001.png" class=""><p>默认都是git，问题不大，自己看下是不是。</p><p>然后再工具那边打开源代码管理的几个按钮<br>右击顶栏很多按钮那一条，弹出这个，选中源代码管理即可</p><img src="/2022/08/18/TortoiseGit/002.png" class=""><p>选中之后，能看到多了一些，基础就大概这样了</p><img src="/2022/08/18/TortoiseGit/003.png" class=""><hr><h2 id="gitee-x2F-github创建仓库"><a href="#gitee-x2F-github创建仓库" class="headerlink" title="gitee&#x2F;github创建仓库"></a>gitee&#x2F;github创建仓库</h2><p>gitee嘛国内的不用科学，但是之前出了一档子破事好像都要审核了，我也没怎么用。<br>这里用的github，问题不大，懂得都懂。</p><p>简单介绍</p><img src="/2022/08/18/TortoiseGit/004.png" class=""><p>然后create之后就能看到</p><img src="/2022/08/18/TortoiseGit/005.png" class=""><blockquote><p>没必要去翻我的哈。。自己学习用的</p></blockquote><p>那么仓库建好了，就要用源代码管理工具去操作了。</p><p>首先看仓库的code按钮</p><img src="/2022/08/18/TortoiseGit/006.png" class=""><p>有三种clone方式，第一种https，这个应该不陌生的吧大部分人，就是web协议，http的基础上加入ssl证书验证。第二种比较常用，ssh，为啥这么说呢。。之前瞎搞linux的时候，就常用就是直接clone到文件夹，然后去执行.&#x2F;install.sh脚本哈哈哈。第三种带了个cli，估计就是client，github的客户端了应该是。</p><p>小乌龟添加的方式差不多也用ssh，所以copy这个ssh给的链接。<br>然后找个地方建个空的文件夹，因为要clone进去，文件夹的名字和仓库名倒是没要求要一样，我这是为了好区分。</p><img src="/2022/08/18/TortoiseGit/007.png" class=""><p>然后在此处右击</p><img src="/2022/08/18/TortoiseGit/008.png" class=""><p>点击这个克隆</p><img src="/2022/08/18/TortoiseGit/009.png" class=""><p>我们把url填入其中</p><img src="/2022/08/18/TortoiseGit/010.png" class=""><p>github复制的url不需要做什么改动，除此之外小微调一下</p><img src="/2022/08/18/TortoiseGit/011.png" class=""><img src="/2022/08/18/TortoiseGit/012.png" class=""><p>然后点击是的时候大概率会报错，<code>server sent :publickey</code>，大致意思就是你没有设置publickey，我是用hexo搭博客上传到github的，用的就是git的客户端。自然是设置过这个publickey的</p><p>首先打开tortoisegit的settings，找到网络，看下面的ssh客户端，原先那个我懒得再配一个给github了，反正我git用的多，直接用git的ssh就行了。<br><strong>如果你没有用过git for windows，那么我推荐你去下一个！</strong></p><blockquote><p>操作也不难，我学过linux，一般都是用git bash。<br>请前往我创建博客的文章，找到在用户目录下打开.ssh和用git bash设置github用户名+创建邮箱那几个地方。<br>如若不然，只得您自行寻找给小乌龟git的ssh客户端新建一个sshkey的凭证</p></blockquote><img src="/2022/08/18/TortoiseGit/014.png" class=""><p>设置完成后，重新clone。</p><img src="/2022/08/18/TortoiseGit/013.png" class=""><p>就没问题了，文件也clone到本地磁盘了。</p><img src="/2022/08/18/TortoiseGit/015.png" class=""><p>打开也没啥，就一个readme.md的自述文件，<code>.git</code>是隐藏文件，主要还是记录了git的信息。</p><hr><h3 id="日志信息"><a href="#日志信息" class="headerlink" title="日志信息"></a>日志信息</h3><p>右击这个clone的文件夹</p><img src="/2022/08/18/TortoiseGit/016.png" class=""><p>在旁边能找到显示日志信息的选项打开</p><img src="/2022/08/18/TortoiseGit/017.png" class=""><p>信息可以说还是很全面的。</p><p>日志可以很好的看出代码的改动，是谁改的，什么时候改的。而且防止删除源代码，在你不是这个库的创建者下，无权删除整个仓库，你顶多删掉你更新的那一块，不至于让整个项目从零开始。</p><hr><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>在github创建的时候仓库就是空的，除了一个自述文件。<br>那么最开始就配置的vs不能浪费，通过vs创建项目，然后上传一举多得。</p><img src="/2022/08/18/TortoiseGit/018.png" class=""><p><strong>注意路径是你之前clone的项目路径</strong></p><img src="/2022/08/18/TortoiseGit/019.png" class=""><p>然后这里把MFC标头勾选，点击确定项目就创建好了。</p><img src="/2022/08/18/TortoiseGit/020.png" class=""><p>创建好保存一下，先关闭vs。<br>然后转到文件夹，会看到我们这个新建的项目文件前面没有绿色的勾。<br>其实也就是因为他还没上传到仓库。</p><img src="/2022/08/18/TortoiseGit/021.png" class=""><p>右击这个文件选择提交到-&gt;</p><img src="/2022/08/18/TortoiseGit/022.png" class=""><p>大致跟着来，但是注意，不要全选文件上传，有个文件是没啥价值的。</p><blockquote><p>.vs目录是用来存储当前用户在解决方案中的工作配置，具体包括VS关闭前最后的窗口布局、最后打开的选项卡&#x2F;操作记录&#x2F;文件文档、某些自定义配置&#x2F;开发环境、调试断点等这类设置信息和状态。直接删掉没有任何问题。<br>相当于说每台电脑生成项目的时候这个.vs都不一样，所以没有必要上传他，而且这个文件很占内存。</p></blockquote><p>我们可以右击手动设置忽略掉这个文件夹</p><img src="/2022/08/18/TortoiseGit/023.png" class=""><img src="/2022/08/18/TortoiseGit/024.png" class=""><p>注意不要收养选递归，不然有的时候出现重名啥的会被直接忽略。</p><p>除了这个<code>.vs</code>文件夹，还有一个文件也是不大需要的，</p><img src="/2022/08/18/TortoiseGit/025.png" class=""><p>可以看到是user，就是用户，那么每个用户生成的肯定也不一样。</p><img src="/2022/08/18/TortoiseGit/026.png" class=""><p>这个也不需要，忽略掉</p><hr><h2 id="小乌龟提交和推送"><a href="#小乌龟提交和推送" class="headerlink" title="小乌龟提交和推送"></a>小乌龟提交和推送</h2><img src="/2022/08/18/TortoiseGit/027.png" class=""><p>当你点击提交的时候，他还没有直接上传到仓库，而是生成缓存，只有点击推送了才是真的上传到仓库。</p><img src="/2022/08/18/TortoiseGit/028.png" class=""><p>做这些分层的工作，自然是为了更加安全的，有意义的，符合逻辑的上传。因为改多了突然一激灵想到那有问题，就可以重新来了。</p><img src="/2022/08/18/TortoiseGit/029.png" class=""><p>点击推送，就完事了。</p><img src="/2022/08/18/TortoiseGit/030.png" class=""><p>推送完成后能看到这个项目文件夹也多了绿色勾选。</p><p>亦可以通过日志，看到我们的更改信息</p><img src="/2022/08/18/TortoiseGit/031.png" class=""><p>vs重新打开的时候其实也能看到</p><img src="/2022/08/18/TortoiseGit/032.png" class=""><hr><h2 id="vs提交和推送"><a href="#vs提交和推送" class="headerlink" title="vs提交和推送"></a>vs提交和推送</h2><p>有一点是我们创建项目没有做的，就是生成解决方案<br>因为这个是我们编译后的产物，别人只需要拿到源码自己编译就行了。</p><p>所以我们在vs中先生成解决方案，然后到文件夹里面挨个忽略掉</p><img src="/2022/08/18/TortoiseGit/033.png" class=""><p>这里多个x64是手残了，没把项目的x64改成x86，老实说一般都还是x86比较多。</p><p>除了外面的debug文件夹，两个项目里面都有debug和x64，需要手动忽略，方法跟之前的一样。</p><img src="/2022/08/18/TortoiseGit/034.png" class=""><p>回过头来，当vs这些文件都出现蓝色的锁，就表示它们已经上传到仓库了。<br>当我们修改过其中一个地方，这个文件的蓝色锁就变成红色了。</p><img src="/2022/08/18/TortoiseGit/035.png" class=""><p>当有文件改动的时候，git插件就要干活了</p><img src="/2022/08/18/TortoiseGit/036.png" class=""><p>能看到多了一个提交和撤销。</p><p>这里选提交，点击全部暂存，看到.sln记得忽略掉。</p><img src="/2022/08/18/TortoiseGit/039.png" class=""><p>然后就是点击全部提交，会显示一个本地创建</p><img src="/2022/08/18/TortoiseGit/037.png" class=""><p>完成之后点击同步，然后再点击旁边的推送。</p><img src="/2022/08/18/TortoiseGit/040.png" class=""><p>最后也可以在日志中看到我们这次通过vs的提交</p><img src="/2022/08/18/TortoiseGit/038.png" class=""><p>其次在输出里面切换到git，我们也能看到流程</p><img src="/2022/08/18/TortoiseGit/041.png" class=""><p>此外github的仓库自然也能看到推送的情况</p><img src="/2022/08/18/TortoiseGit/042.png" class=""><hr><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>我们目前的操作，都是推送给main分支，也就是覆盖性的操作。<br>当然如果每次都覆盖，有一天新版本挂了想要恢复到某一结点就是不可能的事了。</p><p>所以仓库还有一个分支的选项。</p><img src="/2022/08/18/TortoiseGit/043.png" class=""><p>可以通过git更改的页，去选中那三个点，然后选择创建分支</p><p>显然分支的存在带来了很大的便捷性，毕竟一个项目会衍生出不同的情况，在许多个方案之间反复横跳，我们就可以通过分支去跟着横跳达到需求。</p><p>用vs切换分支不难，直接在git更改里面，这个框选里面选择就行</p><img src="/2022/08/18/TortoiseGit/045.png" class=""><p>还有就是命令行的情况，因为装了git for windows，所以有个git bash的产物，都是以linux命令行的形式玩的挺好用的。</p><img src="/2022/08/18/TortoiseGit/044.png" class=""><p>首先就是查看分支，和切换分支，不过分支是啥其实路径都明明白白了。</p><p>然后我们修改分支，在代码里加一句注释，等会上传完切换分支看看效果</p><img src="/2022/08/18/TortoiseGit/046.png" class=""><p>在github里面很自然的看出了两个分支，而新增的分支，多了一个我们刚才上传的localtest。</p><img src="/2022/08/18/TortoiseGit/047.png" class=""><img src="/2022/08/18/TortoiseGit/048.png" class=""><p>ok，重点时刻</p><img src="/2022/08/18/TortoiseGit/049.png" class=""><p>当我们在vs的git更改里面，签回main分支，会发现那句注释不见了。<br>切回到local_branch的时候注释又出来了</p><img src="/2022/08/18/TortoiseGit/050.png" class=""><p>这就是分支的力量。</p><p><strong>默认情况下创建的仓库，主分支一般都叫main或者master，目前新仓库的默认主分支都叫main了，老的可能还是master，具体原因可以百度好像是master这个词多义性。而主分支只有在新分支开发的功能完全ok的情况下才会合并一次，直接在主分支上操作的风险略高，且不利于团队发现问题。而且大部分情况下，功能也不会只有一个，多个人同时写尽量都创建分支</strong></p><p>附：百度来的一些分支命名</p><ol><li>git主分支(master)。它是自动建立，用于发布重大版本更新。</li><li>git开发主分支(develop)。日常开发在此分支上进行。</li><li>git临时性分支：主要是应对日常开发中的遇到的版本问题的。<ol><li>功能（feature）分支：它是为了开发某种特定功能，从Develop分支上面分出来的。开发完成后，要再并入Develop。可以采用feature-*的形式命名。</li><li>预发布（release）分支：指发布正式版本之前（即合并到Master分支之前），我们可能需要有一个预发布的版本进行测试。预发布分支是从Develop分支上面分出来的，预发布结束以后，必须合并进Develop和Master分支。它的命名，可以采用release-*的形式。</li><li>修补bug（hotfix）分支：软件正式发布以后，难免会出现bug。这时就需要创建一个分支，进行bug修补。修补bug分支是从Master分支上面分出来的。修补结束以后，再合并进Master和Develop分支。它的命名，可以采用hotfix-*的</li></ol></li></ol><p>用git bash操作也差不多的。无非就是图形化和命令行</p><img src="/2022/08/18/TortoiseGit/051.png" class=""><img src="/2022/08/18/TortoiseGit/052.png" class=""><p>这里提示了一下，因为我改动了哈哈</p><p>附：git的命令</p><pre><code class="bash">#查看分支列表git branch#创建新分支git branch 新分支名称#切换分支git checkout 分支名称#快速创建分支并切换git checkout -b 分支名称#合并分支的时候，若目前在c分支，先切换到要合并的分支git checkout name，然后合并git merge c#删除分支git branch -d 分支名称#合并冲突还不是很理解，先空着</code></pre><hr><h2 id="项目分析"><a href="#项目分析" class="headerlink" title="项目分析"></a>项目分析</h2><ul><li>需求分析<ul><li>市场需求</li><li>估值</li></ul></li><li>技术分析<ul><li>技术栈涉及多少</li><li>时效</li></ul></li></ul><p>反正要考虑的挺多的，一个项目能不能立项要看需求，但是有的时候有需求没有用，没有资金筹备，项目上不了线，终归是胎死腹中。</p><p>还有感人的产品锦鲤，毕竟需求不可能是固定的。</p><hr><h2 id="附：git命令行操作"><a href="#附：git命令行操作" class="headerlink" title="附：git命令行操作"></a>附：git命令行操作</h2><p>网上copy的也就看看先，具体要用到哪些还不确定：</p><h3 id="一、-创建test分支提交步骤"><a href="#一、-创建test分支提交步骤" class="headerlink" title="一、 创建test分支提交步骤"></a>一、 创建test分支提交步骤</h3><ol><li><p>列出所有分支</p><blockquote><p>git branch -a</p></blockquote></li><li><p>创建test分支</p><blockquote><p>git branch test</p></blockquote></li><li><p>切换到test分支:</p><blockquote><p>git checkout test</p></blockquote></li><li><p>添加add修改:</p><blockquote><p>git add .</p></blockquote></li><li><p>添加commit注释</p><blockquote><p>git commit -m “第一次提交代码”</p></blockquote></li><li><p>提交到服务器</p><blockquote><p>git push origin test</p></blockquote></li></ol><h3 id="二、将test分支合并到master本地分支"><a href="#二、将test分支合并到master本地分支" class="headerlink" title="二、将test分支合并到master本地分支"></a>二、将test分支合并到master本地分支</h3><ol><li><p>创建test分支</p><blockquote><p>git branch test</p></blockquote></li><li><p>切换到test分支</p><blockquote><p>git checkout test</p></blockquote></li><li><p>在test分支添加一个readme.txt文件</p><blockquote><p>touch readme.txt<br>git add readme.txt</p></blockquote></li><li><p>提交commit本地文件</p><blockquote><p>git commit -m “增加readme.txt”</p></blockquote></li><li><p>切换到master分支</p><blockquote><p>git checkout master</p></blockquote></li><li><p>把test分支合并到master分支</p><blockquote><p>git merge test</p></blockquote></li><li><p>提交master分支到服务器</p><blockquote><p>git push origin master</p></blockquote></li><li><p>删除test分支</p><blockquote><p>git branch -d test</p></blockquote></li></ol><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>未完结~待续</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;需要科学。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://tortoisegit.org/download/&quot;&gt;下载地址&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="git" scheme="https://8bytes.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>多个对话框关联</title>
    <link href="https://8bytes.top/2022/08/03/nDialog/"/>
    <id>https://8bytes.top/2022/08/03/nDialog/</id>
    <published>2022-08-02T17:29:01.000Z</published>
    <updated>2022-08-10T07:05:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>倒也没啥特别，效果是类似于一个问卷调查。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>直接在前面项目上改动了</p><img src="/2022/08/03/nDialog/000.png" class=""><p>点击这个按钮，自然是弹出新的对话框，所以要新建资源<br>右击资源视图中该项目的Dialog，选择添加资源</p><img src="/2022/08/03/nDialog/001.png" class=""><p>这个对话框类型后面仨就是大小之间有差异。</p><p>然后就是拖控件，其中这些radio单选框啥啥啥的，以前html做表单的时候用的感觉都差不多吧，不算太陌生。</p><img src="/2022/08/03/nDialog/002.png" class=""><p>样式完成之后要新建类和这个对话框关联</p><img src="/2022/08/03/nDialog/003.png" class=""><p><strong>这里要注意命名的时候要和Dialog里的一样，只不过我这个vs2022对话框id不知道为啥没显示，正常应该是会根据类名在前面加上IDD_，这也是为什么上面创建类名是这个样，但好在源文件头文件是随便的</strong></p><img src="/2022/08/03/nDialog/004.png" class=""><p>创建完之后可以看到类向导这里这个类关联的资源就是刚才新建的对话框</p><p>类和对话框关联之后，就要给这些控件添加变量。</p><p>单选框的特性就是只能选中一个，那么这个变量首先为值类型，其次类型为BOOL。创建三个又太麻烦，所以新建一个之后直接改成数组</p><pre><code class="cpp">public:    // 单选框的值    BOOL m_lang[3];</code></pre><p>在源文件中自然免不了修改了</p><pre><code class="cpp">// PROP01.cpp: 实现文件//#include &quot;pch.h&quot;#include &quot;RunningButton.h&quot;#include &quot;afxdialogex.h&quot;#include &quot;PROP01.h&quot;// PROP_01 对话框IMPLEMENT_DYNAMIC(PROP_01, CPropertyPage)PROP_01::PROP_01()    : CPropertyPage(IDD_PROP_01)&#123;    memset(m_lang, 0, sizeof(m_lang));&#125;PROP_01::~PROP_01()&#123;&#125;void PROP_01::DoDataExchange(CDataExchange* pDX)&#123;    CPropertyPage::DoDataExchange(pDX);    DDX_Radio(pDX, IDC_RADIO_CPP, m_lang[0]);    DDX_Radio(pDX, IDC_RADIO_JAVA, m_lang[1]);    DDX_Radio(pDX, IDC_RADIO_PYTHON, m_lang[2]);&#125;BEGIN_MESSAGE_MAP(PROP_01, CPropertyPage)END_MESSAGE_MAP()// PROP_01 消息处理程序</code></pre><p>在c&#x2F;c++中布尔值本质就是0和1的表示，虽然TRUE真意是非0的值。<br><code>memset(m_lang, 0, sizeof(m_lang));</code>那么初始化的时候直接给这个数组全部写0，也就是表示FALSE，完成初始化的操作。</p><p>至于<code>DDX_Radio(pDX, IDC_RADIO_CPP, m_lang[0]);</code>，就可以通过数组依次绑定。</p><img src="/2022/08/03/nDialog/005.png" class=""><p>这个里面应是得有几个公司的名字才对，由于这个类是我们新建的，还没有初始化的地方。<br>所以要重写InitDialog</p><p>老样子类视图选中然后属性里面找到重写选项，往下滑找到<code>OnInitDialog</code>，点击后面add即可。</p><pre><code class="cpp">BOOL PROP_01::OnInitDialog()&#123;    CPropertyPage::OnInitDialog();    // TODO:  在此添加额外的初始化    return TRUE;  // return TRUE unless you set the focus to a control                  // 异常: OCX 属性页应返回 FALSE&#125;</code></pre><p>获取控件最快的就是用指针。</p><p><code>CListBox* pListBox = (CListBox*)GetDlgItem(IDC_LIST_COMPANY);</code><br>因为这个控件是我们拖得，所以我们很清楚它是什么类型，但是别人不一定清楚。<br>而且GetDlgItem的返回类型是CWnd，但是好在CListBox是它的子类。所以直接强制转换一下。<br>获取完成后，就可以通过指针给他增加点字符串</p><pre><code class="cpp">BOOL PROP_01::OnInitDialog()&#123;    CPropertyPage::OnInitDialog();    // TODO:  在此添加额外的初始化    CListBox* pListBox = (CListBox*)GetDlgItem(IDC_LIST_COMPANY);    if( pListBox )&#123;        pListBox-&gt;AddString(_T(&quot;阿里巴巴&quot;));        pListBox-&gt;AddString(_T(&quot;华为&quot;));        pListBox-&gt;AddString(_T(&quot;腾讯&quot;));        pListBox-&gt;AddString(_T(&quot;百度&quot;));        pListBox-&gt;AddString(_T(&quot;京东&quot;));    &#125;    return TRUE;  // return TRUE unless you set the focus to a control                  // 异常: OCX 属性页应返回 FALSE&#125;</code></pre><p>这样这个对话框就ok了</p><hr><img src="/2022/08/03/nDialog/006.png" class=""><p>再次创建新的对话框，拖动check box组合一下</p><p>同样的给这个对话框创建一个类，步骤也是从类向导开始，注意命名规范。</p><p>最后就是复选框添加变量，跟radio差不多的路数</p><pre><code class="cpp">//...public:    // 技能选项    BOOL m_skill[4];&#125;;</code></pre><p>然后在源文件同样通过memset写0，和后面的绑定</p><pre><code class="cpp">PROP_02::PROP_02()    : CPropertyPage(IDD_PROP_02)&#123;    memset(m_skill, 0, sizeof(m_skill));&#125;PROP_02::~PROP_02()&#123;&#125;void PROP_02::DoDataExchange(CDataExchange* pDX)&#123;    CPropertyPage::DoDataExchange(pDX);    DDX_Check(pDX, IDC_CHECK1, m_skill[0]);        //网络编程    DDX_Check(pDX, IDC_CHECK2, m_skill[1]);        //MFC    DDX_Check(pDX, IDC_CHECK3, m_skill[2]);        //操作系统    DDX_Check(pDX, IDC_CHECK4, m_skill[3]);        //数据结构&#125;</code></pre><p>这么一来这个对话框界面也就ok了。</p><p>可能稍微为了好看就要注意一下这几个对话框大小</p><img src="/2022/08/03/nDialog/007.png" class=""><p>选中这个dialog的时候vs的下面会显示，手动调整一下</p><hr><img src="/2022/08/03/nDialog/008.png" class=""><p>至于这个也不做多解释了，创建的路数都一样。</p><p>唯一需要注意的是这个下拉多选的控件是<code>combo box</code></p><img src="/2022/08/03/nDialog/009.png" class=""><p>数据使用分号分割，注意要英语符合。</p><hr><p>最后三个对话框都创建好了，自然需要关联起来。</p><img src="/2022/08/03/nDialog/010.png" class=""><p>对这个项目创建一个MFC类。</p><pre><code class="cpp">CMyProSheet(UINT nIDCaption, CWnd* pParentWnd = nullptr, UINT iSelectPage = 0);CMyProSheet(LPCTSTR pszCaption, CWnd* pParentWnd = nullptr, UINT iSelectPage = 0);</code></pre><p>这两个构造函数可以看到就头不一样，UINT也就是unsigned int，下面那个也就是字符串<br>不过既然有俩了，那有啥改动就尽量都保持一样</p><p>然后添加一下我们三个对话框类</p><pre><code class="cpp">public:    PROP_01 m_prop1;    PROP_02 m_prop2;    PROP_03 m_prop3;</code></pre><p>在源文件中构造的时候添加这三个页</p><pre><code class="cpp">CMyProSheet::CMyProSheet(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)    :CPropertySheet(nIDCaption, pParentWnd, iSelectPage)&#123;    AddPage(&amp;m_prop1);    AddPage(&amp;m_prop2);    AddPage(&amp;m_prop3);&#125;CMyProSheet::CMyProSheet(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)    :CPropertySheet(pszCaption, pParentWnd, iSelectPage)&#123;    AddPage(&amp;m_prop1);    AddPage(&amp;m_prop2);    AddPage(&amp;m_prop3);&#125;</code></pre><p>那么这几个页是组合到一起了。剩下就是写那个按钮事件了。</p><p>额尴尬，跑的时候有个问题，就是单选按钮没有组，然后抛出异常了</p><img src="/2022/08/03/nDialog/011.png" class=""><p>修改一下</p><pre><code class="cpp">PROP_01::PROP_01()    : CPropertyPage(IDD_PROP_01)    , m_lang(-1)&#123;&#125;PROP_01::~PROP_01()&#123;&#125;void PROP_01::DoDataExchange(CDataExchange* pDX)&#123;    CPropertyPage::DoDataExchange(pDX);    DDX_Radio(pDX, IDC_RADIO_CPP, m_lang);&#125;</code></pre><p>修改完之后跑起来就ok了</p><img src="/2022/08/03/nDialog/012.png" class=""><img src="/2022/08/03/nDialog/013.png" class=""><img src="/2022/08/03/nDialog/014.png" class=""><p>因为设置的大小差不多，比较和谐。</p><hr><p>稍微有心的可能会注意到，那个帮助不一定需要，按照前面重载按钮类的示例，这边也就能重写</p><pre><code class="cpp">BOOL PROP_01::OnSetActive()&#123;    // TODO: 在此添加专用代码和/或调用基类    ((CPropertySheet*)GetParent())-&gt;SetWizardButtons(PSWIZB_NEXT);    ((CPropertySheet*)GetParent())-&gt;GetDlgItem(IDHELP)-&gt;ShowWindow(SW_HIDE);    return CPropertyPage::OnSetActive();&#125;</code></pre><pre><code class="cpp">BOOL PROP_02::OnSetActive()&#123;    // TODO: 在此添加专用代码和/或调用基类    ((CPropertySheet*)GetParent())-&gt;SetWizardButtons(PSWIZB_NEXT | PSWIZB_BACK);    return CPropertyPage::OnSetActive();&#125;</code></pre><pre><code class="cpp">BOOL PROP_03::OnSetActive()&#123;    // TODO: 在此添加专用代码和/或调用基类    ((CPropertySheet*)GetParent())-&gt;SetWizardButtons(PSWIZB_BACK | PSWIZB_FINISH);    return CPropertyPage::OnSetActive();&#125;</code></pre><p>第一个对话框，只显示下一步，上一步无法点击，并且隐藏帮助按钮<br>第二个对话框则上下都可行<br>第三个对话框只能向上一步和完成。</p><img src="/2022/08/03/nDialog/015.png" class=""><img src="/2022/08/03/nDialog/016.png" class=""><img src="/2022/08/03/nDialog/017.png" class=""><hr><p>说到底还是个半成品，还有很多能优化的地方。<br>比如校验，目前这个即便不选择，也可以直接next。</p><p>所以要重写两个next，最后一个因为变成完成了，所以要重写的是finish</p><pre><code class="cpp">LRESULT PROP_01::OnWizardNext()&#123;    // TODO: 在此添加专用代码和/或调用基类    UpdateData();    if( m_lang == -1 )&#123;        MessageBox(_T(&quot;请选择开发语言!&quot;), _T(&quot;开发语言未选择&quot;), MB_OK | MB_ICONERROR);        return -1;    &#125;    if( m_company.GetLength() == 0 )&#123;        MessageBox(_T(&quot;请选择公司!&quot;), _T(&quot;公司未选择&quot;), MB_OK | MB_ICONERROR);        return -1;    &#125;    return CPropertyPage::OnWizardNext();&#125;</code></pre><pre><code class="cpp">LRESULT PROP_02::OnWizardNext()&#123;    // TODO: 在此添加专用代码和/或调用基类    UpdateData();    if( (m_skill[0] + m_skill[1] + m_skill[2] + m_skill[3]) == 0 )&#123;        MessageBox(_T(&quot;请选择技能!&quot;), _T(&quot;技能未选择&quot;), MB_OK | MB_ICONERROR);        return -1;    &#125;    return CPropertyPage::OnWizardNext();&#125;</code></pre><pre><code class="cpp">BOOL PROP_03::OnWizardFinish()&#123;    // TODO: 在此添加专用代码和/或调用基类    UpdateData();    if( m_money.GetLength() &lt;= 0 )&#123;        MessageBox(_T(&quot;请选择薪资!&quot;), _T(&quot;薪资未选择&quot;), MB_OK | MB_ICONERROR);        return -1;    &#125;    return CPropertyPage::OnWizardFinish();&#125;</code></pre><p><strong>记得获取前肯定要更新一下数据</strong></p><p>这套流程结束了之后，还要给用户一个反馈。</p><p>也只能加载打开按钮的地方</p><pre><code class="cpp">void CRunningButtonDlg::OnBnClickedBtnQuery()&#123;    // TODO: 在此添加控件通知处理程序代码    CMyProSheet dlg(_T(&quot;职业调查&quot;), this);    dlg.SetWizardMode();    if( ID_WIZFINISH == dlg.DoModal() )&#123;        CString strMsg = _T(&quot;您的选择是: &quot;);        switch( dlg.m_prop1.m_lang )&#123;            case 0:                strMsg += _T(&quot;开发语言: C++&quot;);                break;            case 1:                strMsg += _T(&quot;开发语言: Java&quot;);                break;            case 2:                strMsg += _T(&quot;开发语言: Python&quot;);                break;            default:                break;        &#125;        strMsg += _T(&quot;您的公司是: &quot;) + dlg.m_prop1.m_company;        strMsg += _T(&quot;您的技能有：&quot;);        CString strSkill[4] = &#123;            _T(&quot;网络编程&quot;), _T(&quot;MFC&quot;), _T(&quot;操作系统&quot;), _T(&quot;数据结构&quot;)        &#125;;        for( int i = 0; i &lt; 4; i++ )&#123;            if( dlg.m_prop2.m_skill[i] )&#123;                strMsg += strSkill[i] + _T(&quot;,&quot;);            &#125;        &#125;        strMsg += _T(&quot;您的薪资范围选择是：&quot;) + dlg.m_prop3.m_money;        MessageBox(strMsg, _T(&quot;最终选择&quot;));    &#125;&#125;</code></pre><img src="/2022/08/03/nDialog/018.png" class=""><p>选择完之后就是这样的显示。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><img src="/2022/08/03/nDialog/019.png" class=""><p>主体对话框是RunningButtonDlg，通过按钮控件，显示出CMyPropSheet。然后写好的三个页与其关联。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;倒也没啥特别，效果是类似于一个问卷调查。&lt;/p&gt;</summary>
    
    
    
    
    <category term="MFC" scheme="https://8bytes.top/tags/MFC/"/>
    
  </entry>
  
  <entry>
    <title>丐版逃跑按钮</title>
    <link href="https://8bytes.top/2022/08/02/escapeButton/"/>
    <id>https://8bytes.top/2022/08/02/escapeButton/</id>
    <published>2022-08-02T15:19:24.000Z</published>
    <updated>2022-08-09T06:22:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>就是窗口上有个按钮，然后鼠标过去按钮就移动。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>新建MFC项目<br>选中基于对话框<br>用户界面的东西基本用不到<br>高级功能打印也用不到<br>其它都正常创建</p><hr><blockquote><p>核心思想跟网上流传的网页版本可能有区别吧，这个原理就是两个按钮，当发现鼠标要触碰到这个按钮就隐藏这个，启用另一个。</p></blockquote><hr><p>首先就是拖俩button控件</p><img src="/2022/08/02/escapeButton/000.png" class=""><p>然后将左边的按钮属性中  可见 这一属性设为FALSE</p><img src="/2022/08/02/escapeButton/001.png" class=""><p>那么跑起来的效果就是这样的，看不到左边</p><img src="/2022/08/02/escapeButton/002.png" class=""><p>然后给这两个控件添加变量,[过程不做演示了，mfc用多了就习惯了]</p><pre><code class="cpp">public:    CButton m_btn_right;    CButton m_btn_left;</code></pre><p>对于对话框而言，能第一时间想到触碰按钮的消息，也就是跟鼠标移动有关的。<br>那么显然是有这么一个消息的<code>OnMouseMove</code></p><p>添加完之后</p><pre><code class="cpp">void CRunningButtonDlg::OnMouseMove(UINT nFlags, CPoint point)&#123;    // TODO: 在此添加消息处理程序代码和/或调用默认值    CRect left, right;    m_btn_right.GetWindowRect(right);    if(right.PtInRect(point) == TRUE)&#123;        m_btn_right.ShowWindow(SW_HIDE);        m_btn_left.ShowWindow(SW_SHOW);    &#125;    CDialogEx::OnMouseMove(nFlags, point);&#125;</code></pre><p>原理也简单，就是当鼠标移动到这个控件上的时候，就隐藏right按钮，显示left按钮。</p><p>不过在实际run的时候会发现并没有起作用。<br>遇事不决可以添加调试的代码</p><pre><code class="cpp">void CRunningButtonDlg::OnMouseMove(UINT nFlags, CPoint point)&#123;    // TODO: 在此添加消息处理程序代码和/或调用默认值    CRect left, right;    m_btn_right.GetWindowRect(right);    if(right.PtInRect(point) == TRUE)&#123;        m_btn_right.ShowWindow(SW_HIDE);        m_btn_left.ShowWindow(SW_SHOW);    &#125;    TRACE(&quot;%s(%d):%s %d %d\n&quot;, __FILE__, __LINE__,        __FUNCTION__, point.x, point.y);    CDialogEx::OnMouseMove(nFlags, point);&#125;</code></pre><img src="/2022/08/02/escapeButton/003.png" class=""><p>可以看到只要鼠标是在这个对话框上移动，xy就会不断发生变化，但是当鼠标进入控件的时候，xy就不会输出了。</p><p>原因在于这个消息被按钮控件接收了，判断那里就没法用了，所以对话框无法知道这个鼠标到哪了<br>所以通过鼠标移动消息无法实现这个效果。</p><hr><p>解决方式需要重载这个按钮类。</p><p>右击资源视图的项目，选择类向导，在添加类的箭头点击选择MFC类，基类选择为CButton就行，其它的头文件和源文件命名方式看个人习惯吧。</p><p>新建完之后照例打开类视图选择这个新建的类，然后在属性中找到消息，继续选择<code>MouseMove</code></p><pre><code class="cpp">void CMyButton::OnMouseMove(UINT nFlags, CPoint point)&#123;    // TODO: 在此添加消息处理程序代码和/或调用默认值    ShowWindow(SW_HIDE);    if(m_pButton != NULL)&#123;        m_pButton-&gt;ShowWindow(SW_SHOW);    &#125;    CButton::OnMouseMove(nFlags, point);&#125;</code></pre><p>然后修改RunningButtonDlg.h</p><pre><code class="cpp">#include &quot;CMyButton.h&quot;//...public:    CMyButton m_btn_right;    CMyButton m_btn_left;</code></pre><p>将这个按钮改为我们重载之后的按钮类型。</p><p>最后在RunningButtonDlg.cpp中初始化的地方关联这两个按钮</p><pre><code class="cpp">BOOL CRunningButtonDlg::OnInitDialog()&#123;    CDialogEx::OnInitDialog();    // 设置此对话框的图标。  当应用程序主窗口不是对话框时，框架将自动    //  执行此操作    SetIcon(m_hIcon, TRUE);            // 设置大图标    SetIcon(m_hIcon, FALSE);        // 设置小图标    // TODO: 在此添加额外的初始化代码    m_btn_left.m_pButton = &amp;m_btn_right;    m_btn_right.m_pButton = &amp;m_btn_left;    return TRUE;  // 除非将焦点设置到控件，否则返回 TRUE&#125;</code></pre><blockquote><p>对话框中的OnMouseMove可以注释掉了</p></blockquote><p>至此效果就完成了。</p><img src="/2022/08/02/escapeButton/004.png" class=""><img src="/2022/08/02/escapeButton/005.png" class=""><p>鼠标移动到其中一个按钮，就会立马hide，然后另一个show。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>重载button类，是因为之前的<code>OnMouseMove</code>是基于对话框的，那么控件和对话框之间其实有一个z轴，不是一个平级的关系，所以在对话框中写鼠标移动，当鼠标进入到控件的时候，这个消息则是控件捕捉到的，跟对话框就没了关系。</p><p>而重载button类之后，我们鼠标移动的消息是发生在button上，自然就跟对话框没啥关系，所以当鼠标要滑动到其中一个按钮的时候就会立刻响应我们消息中的代码隐藏自身，启用另一个。</p><p>也是因为这种特性，所以是点不到这个按钮了。</p><p>即便是给按钮加选中之后弹出消息</p><pre><code class="cpp">void CRunningButtonDlg::OnBnClickedBtnRight()&#123;    // TODO: 在此添加控件通知处理程序代码    MessageBox(_T(&quot;恭喜你点到了&quot;),_T(&quot;成功!&quot;));&#125;</code></pre><p>因为俩按钮效果一样，函数就不多写一个了，在列表里关联的时候让左边的按钮也关联这个函数消息就行了</p><pre><code class="cpp">BEGIN_MESSAGE_MAP(CRunningButtonDlg, CDialogEx)    ON_WM_PAINT()    ON_WM_QUERYDRAGICON()    ON_WM_MOUSEMOVE()    ON_BN_CLICKED(IDC_BTN_RIGHT, &amp;CRunningButtonDlg::OnBnClickedBtnRight)    ON_BN_CLICKED(IDC_BTN_LEFT, &amp;CRunningButtonDlg::OnBnClickedBtnRight)END_MESSAGE_MAP()</code></pre><p>不过这一步做不做都一样反正点击不到这个按钮，除非你注释掉重载按钮的鼠标移动消息</p><img src="/2022/08/02/escapeButton/006.png" class="">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;就是窗口上有个按钮，然后鼠标过去按钮就移动。&lt;/p&gt;</summary>
    
    
    
    
    <category term="MFC" scheme="https://8bytes.top/tags/MFC/"/>
    
  </entry>
  
  <entry>
    <title>text016</title>
    <link href="https://8bytes.top/2022/08/01/text016/"/>
    <id>https://8bytes.top/2022/08/01/text016/</id>
    <published>2022-08-01T12:39:53.000Z</published>
    <updated>2022-09-16T14:12:03.176Z</updated>
    
    <content type="html"><![CDATA[<h1 id="日常水，新增收藏界面"><a href="#日常水，新增收藏界面" class="headerlink" title="日常水，新增收藏界面"></a>日常水，新增收藏界面</h1><p style="font-size:14px; text-align:right;">—— 由于收藏界面的样式需求其实跟主题自带的friends页面类似，所以直接套用。</p><span id="more"></span><hr><h1 id="还是套娃好用"><a href="#还是套娃好用" class="headerlink" title="还是套娃好用"></a>还是套娃好用</h1><p><code>hexo n page collect</code>先创建新页</p><p>然后在<code>source/_data/</code>新建一个collect.json</p><p>json的格式跟friends用的一样的，直接搬过来。</p><p>然后就是显示问题，上述两步操作完之后，主页也没有显示collect<br>需要在<code>_config.yml</code>里面找到<code>aomori_menu:</code>也就是这个主题的菜单，然后照着前面的样子添加即可。</p><p>这一步之后，主页是显示collect菜单了，但是点进去没有内容，原因在于，主题并没有<code>layout: collect</code>这么一个样式，你直接用friends的话内容也是friends.json的内容，所以要去themes目录下找到这个主题目录修改。</p><p>翻了一下，寻找跟已有样式相关的文件夹，首先肯定是找到<code>layout</code>文件夹，然后翻到<code>page</code>下发现了需要的。<code>thems/aomori/layout/_partial/page/</code><br>反正是要抄friends的，就直接新建一个collect.ejs文件，然后copy一下friends的内容。<br>不过仔细看一下代码也会发现一点问题</p><pre><code class="javascript">&lt;% site.data.collect.forEach((items) =&gt; &#123; %&gt;    &lt;div class=&quot;friends-category&quot;&gt;        &lt;div class=&quot;friends-category-title&quot;&gt;            &lt;%= items.category %&gt;        &lt;/div&gt;        &lt;div class=&quot;friends-category-inner clearfix&quot;&gt;            &lt;% items.data.forEach((item) =&gt; &#123; %&gt;                &lt;a href=&quot;&lt;%= item.url %&gt;&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt; &lt;%= item.name %&gt; &lt;/a&gt;            &lt;% &#125;) %&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;% &#125;) %&gt;&lt;% if (post.content)&#123; %&gt;&lt;article  id=&quot;&lt;%= post.layout %&gt;-&lt;%= post._id %&gt;&quot;  class=&quot;article article-type-&lt;%= post.layout %&gt;&quot;&gt;    &lt;div class=&quot;article-inner&quot;&gt;        &lt;div class=&quot;article-entry post-inner-html&quot;&gt;            &lt;%- post.content %&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/article&gt;&lt;% &#125; %&gt;    &lt;% if (post.comment )&#123; %&gt;&lt;%- partial(&#39;../post/comments&#39;) %&gt;&lt;% &#125; %&gt;</code></pre><p>首先site.data让我感觉像是取数据用的，然后其它的div的class样式虽然我不知道写在哪了，但是如果改成collect肯定不对的，在基于friends样式的需求下，那么class的东西就不做改动。<br>site.data这里我们修改成collect试一下</p><p>然后看到好像没效果。。。又找了一下，找到<code>themes/layout</code>下有一个page.js<br>里面有一些判断这个layout是否为什么的，那么想必就是关键了，直接copy一下</p><pre><code class="javascript">&lt;% if (page.layout === &#39;friends&#39;)&#123; %&gt;&lt;div class=&quot;&lt;%= page.layout %&gt;&quot;&gt;  &lt;%- partial(`_partial/page/$&#123;page.layout&#125;`, &#123;post: page, index: false&#125;) %&gt;&lt;/div&gt;&lt;% &#125; else if (page.layout === &#39;photography&#39;) &#123; %&gt;&lt;div class=&quot;&lt;%= page.layout %&gt;&quot;&gt;  &lt;%- partial(`_partial/page/$&#123;page.layout&#125;`, &#123;post: page, index: false&#125;) %&gt;&lt;/div&gt;&lt;% &#125; else if (page.layout === &#39;collect&#39;) &#123; %&gt;&lt;div class=&quot;&lt;%= page.layout %&gt;&quot;&gt;  &lt;%- partial(`_partial/page/$&#123;page.layout&#125;`, &#123;post: page, index: false&#125;) %&gt;&lt;/div&gt;&lt;% &#125; else &#123; %&gt;&lt;div class=&quot;&lt;%= page.layout %&gt;&quot;&gt;  &lt;%- partial(`_partial/page/default`, &#123;post: page, index: false&#125;) %&gt;&lt;/div&gt;&lt;% &#125; %&gt;</code></pre><p>如此一来，效果就达到了，而且上面的site.data猜测也是一样的，就是直接导出json里面的数据了，因为把这个换成friends就会发现内容都变成friends.json的内容。</p><p>hhhh。。。虽然对这些ejs什么的学都没学过，就瞎搞了。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;日常水，新增收藏界面&quot;&gt;&lt;a href=&quot;#日常水，新增收藏界面&quot; class=&quot;headerlink&quot; title=&quot;日常水，新增收藏界面&quot;&gt;&lt;/a&gt;日常水，新增收藏界面&lt;/h1&gt;&lt;p style=&quot;font-size:14px; text-align:right;&quot;&gt;—— 由于收藏界面的样式需求其实跟主题自带的friends页面类似，所以直接套用。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>text015</title>
    <link href="https://8bytes.top/2022/07/28/text015/"/>
    <id>https://8bytes.top/2022/07/28/text015/</id>
    <published>2022-07-28T04:38:46.000Z</published>
    <updated>2022-07-28T04:39:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="不容易啊！！！！！"><a href="#不容易啊！！！！！" class="headerlink" title="不容易啊！！！！！"></a>不容易啊！！！！！</h1><span id="more"></span><p>这倒霉的科二总算过了，今年转大运，八月科三保佑一次过啊~</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;不容易啊！！！！！&quot;&gt;&lt;a href=&quot;#不容易啊！！！！！&quot; class=&quot;headerlink&quot; title=&quot;不容易啊！！！！！&quot;&gt;&lt;/a&gt;不容易啊！！！！！&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>MFC</title>
    <link href="https://8bytes.top/2022/07/25/mfc01/"/>
    <id>https://8bytes.top/2022/07/25/mfc01/</id>
    <published>2022-07-25T04:36:44.000Z</published>
    <updated>2022-09-15T14:20:33.546Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>微软基础类库（英语：Microsoft Foundation Classes，简称MFC）是微软公司提供的一个类库（class libraries），以C++类的形式封装了Windows API，并且包含一个应用程序框架，以减少应用程序开发人员的工作量。其中包含大量Windows句柄封装类和很多Windows的内建控件和组件的封装类。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="MFC为何物"><a href="#MFC为何物" class="headerlink" title="MFC为何物"></a>MFC为何物</h2><p>传统手工业，需要很多人，然后手工去操作，对于厂家而言，人工费高，质量不确定。<br>而改用机器后，只需要投入材料，一天内的效应会大于人工，而且质量比较平均，当然不是所有的传统手工业都能被机器代替，只是部分。</p><p>这也就是普通c&#x2F;c++代码和api的区别，经过多次封装它自然就变得看起来简单，复用性高。</p><p>MFC既然是微软设计的，自然只适合在windows上做应用开发，像xp、win7、win10兼容性肯定没得说，毕竟也是个亲儿子。<br>不过目前的更新迭代之下，MFC的场景也会比较少，后面还有个跨平台的Qt。<br>虽然少，但是老公司的项目没有转型之前，大部分还是需要维护的。<br>可能外包比较多。</p><p>MFC的学习方式</p><ol><li>(1.c++多态、2.windows消息循环、3.msg loop)</li><li>查文档，不会就查，可以用vs的ide在函数上按f1跳转，也可以记网址</li></ol><p>安装：xxxx自己百度，vs的ide模块化其实看得很清楚了，就是吃内存。</p><blockquote><p>vs2022应该是C++ ATL for v143生成工具和c++ MFC for v143生成工具，都是x86和x64。</p></blockquote><p>MFC能做啥</p><ol><li>微软的基础框架</li><li>桌面应用</li><li>上位机</li><li>pc端的监控软件</li><li>修改注册表&#x2F;启动项等</li></ol><hr><h2 id="前身Win32"><a href="#前身Win32" class="headerlink" title="前身Win32"></a>前身Win32</h2><h3 id="1-窗口程序架构"><a href="#1-窗口程序架构" class="headerlink" title="1.窗口程序架构"></a>1.窗口程序架构</h3><pre><code class="cpp">int WinMain()&#123;    //设计窗口外观以及交互响应    RegisterClass(...)    //生产窗口    CreateWinodw(...)    //显示窗口    ShowWindow(...)    //刷新窗口    UpdateWindow(...)    //消息循环    while(GetMessage(...))&#123;        //消息转发        TranslateMessage(...);        //消息分发        DispatchMessage(...);    &#125;&#125;</code></pre><hr><h3 id="2-API和SDK"><a href="#2-API和SDK" class="headerlink" title="2.API和SDK"></a>2.API和SDK</h3><p>api全称(Application Program Interface) 应用程序编程接口<br>sdk全称(Software Development Kit) 也就是软件开发工具包，一般会包括API接口文档、示例文档、帮助文档、使用手册和相关工具。</p><hr><h3 id="3-窗口和句柄"><a href="#3-窗口和句柄" class="headerlink" title="3.窗口和句柄"></a>3.窗口和句柄</h3><p>窗口就是屏幕上的一片特定区域，可能存在等待接收用户的输入，显示程序的输出。可以包含标题栏、菜单栏、工具栏、空间等<br>句柄(handle)(资源的编号、二级指针)，窗口句柄、文件句柄、数据库连接句柄，本质都是指针<br>c++窗口类对象和窗口并不是一回事，二者的关系是c++窗口类内部定义了一个窗口句柄变量，保存了这个c++窗口类对象和相关的窗口句柄。当窗口销毁时，与之对应的c++窗口类对象销毁与否要看生命周期结束没。反之c++窗口类对象销毁时，与之相关的窗口肯定被销毁了。</p><hr><h3 id="4-消息循环"><a href="#4-消息循环" class="headerlink" title="4.消息循环"></a>4.消息循环</h3><img src="/2022/07/25/mfc01/000.png" class=""><p>银行这种，一般都是个人业务比较多。取个号要么机器上操作，要么去柜台。</p><img src="/2022/07/25/mfc01/001.png" class=""><p>对于windows系统而言，这种循环好看懂一些。</p><p>消息循环会引出一个<code>回调函数</code>。<br>就是说当出现特定事件的时候，都会交给回调函数处理。</p><hr><h3 id="5-变量命名约定"><a href="#5-变量命名约定" class="headerlink" title="5.变量命名约定"></a>5.变量命名约定</h3><table><thead><tr><th>前缀</th><th>含义</th><th>前缀</th><th>含义</th></tr></thead><tbody><tr><td>a</td><td>数组array</td><td>b</td><td>布尔值bool</td></tr><tr><td>by</td><td>无符号字符[字节]</td><td>c</td><td>字符[字节]</td></tr><tr><td>cb</td><td>字节计数</td><td>rgb</td><td>保存颜色值的长整型</td></tr><tr><td>cx，cy</td><td>短整型[计算x，y的长度]</td><td>dw</td><td>无符号长整型</td></tr><tr><td>fn</td><td>函数</td><td>h</td><td>句柄</td></tr><tr><td>i</td><td>整型</td><td>m_</td><td>类的数据成员member</td></tr><tr><td>n</td><td>短整型或整型</td><td>np</td><td>近指针</td></tr><tr><td>p</td><td>指针</td><td>l</td><td>长整型</td></tr><tr><td>lp</td><td>长指针</td><td>s</td><td>字符串string</td></tr><tr><td>sz</td><td>以0结尾的字符串</td><td>tm</td><td>正文大小</td></tr><tr><td>w</td><td>无符号整型</td><td>x，y</td><td>无符号整型[表示x，y的坐标]</td></tr></tbody></table><p>反正windows的产品基本都遵循这样的命名规范。</p><hr><h2 id="MFC程序开发流程"><a href="#MFC程序开发流程" class="headerlink" title="MFC程序开发流程"></a>MFC程序开发流程</h2><hr><h3 id="1-基于对话框的程序"><a href="#1-基于对话框的程序" class="headerlink" title="1.基于对话框的程序"></a>1.基于对话框的程序</h3><p>无菜单栏、工具栏，界面很简单，可使用此类型为对话框。</p><img src="/2022/07/25/mfc01/004.png" class=""><p>类似于计算器这种</p><hr><h3 id="2-基于文档-x2F-试图的程序"><a href="#2-基于文档-x2F-试图的程序" class="headerlink" title="2.基于文档&#x2F;试图的程序"></a>2.基于文档&#x2F;试图的程序</h3><p>标准的windows应用界面，包含菜单栏、工具栏、状态栏等。</p><img src="/2022/07/25/mfc01/005.png" class=""><p>最直观的就是vs的ide喽</p><hr><h3 id="3-MFC与win32开发的区别"><a href="#3-MFC与win32开发的区别" class="headerlink" title="3.MFC与win32开发的区别"></a>3.MFC与win32开发的区别</h3><ul><li>定制界面的区别(手写代码和拖放控件)</li><li>响应键鼠操作的区别(窗口处理函数和消息映射机制)</li></ul><p>win32可以开发纯命令行的程序，也就是windows所说的dos，在命令行里面gcc cmake之类的操作。<br>所以涉及到界面的开发自然而然的是选择MFC。</p><hr><h3 id="4-MFC消息映射机制"><a href="#4-MFC消息映射机制" class="headerlink" title="4.MFC消息映射机制"></a>4.MFC消息映射机制</h3><pre><code class="cpp">BEGIN_MESSAGE_MAP(CMFCApplication1Dlg, CDialogEx)    ON_WM_SYSCOMMAND()    ON_WM_PAINT()    ON_WM_QUERYDRAGICON()END_MESSAGE_MAP()</code></pre><p><code>BEGIN_MESSAGE_MAP</code>即为消息映射表<br>如果有特殊需求也可以进行自定义消息。虽然不能说自定义就一定能达到需求。</p><hr><h3 id="5-构建项目"><a href="#5-构建项目" class="headerlink" title="5.构建项目"></a>5.构建项目</h3><p>vs有默认的项目类型可选，是提高效率的首要之选，不是说不可以从空项目起手，而是节约基础配置的时间。</p><img src="/2022/07/25/mfc01/002.png" class=""><img src="/2022/07/25/mfc01/003.png" class=""><img src="/2022/07/25/mfc01/006.png" class=""><p>至于共享dll编译出来的exe体积肯定是比使用静态库的exe要小。</p><img src="/2022/07/25/mfc01/007.png" class=""><p>默认就共享得了。有需要在使用静态。<br>然后此处基于对话框开发，所以文档模板属性没啥可选的。</p><img src="/2022/07/25/mfc01/008.png" class=""><p>用户界面常用的最小化最大化是可以勾上的，标题名呢也可以在此就设置好。</p><img src="/2022/07/25/mfc01/009.png" class=""><p>这些也可以看着来。</p><p>最后的生成的类一般不做修改。也别闲着用中文，每个人的环境不同，编码有异，在你这能跑在别人那就可能乱码了。</p><p>创建完成之后</p><img src="/2022/07/25/mfc01/010.png" class=""><p>其实就能看到大致的模板了。</p><img src="/2022/07/25/mfc01/011.png" class=""><p>跟预览的效果是一样的。这种直接套模板的确省去了不少麻烦。</p><blockquote><p>其中拖动控件的精髓在工具箱里，属性里面直接选消息。</p></blockquote><hr><h2 id="画线"><a href="#画线" class="headerlink" title="画线"></a>画线</h2><ul><li>知识点<ul><li>屏幕坐标和客户端坐标</li><li>设备上下文</li><li>事件</li></ul></li><li>起点和终点<ul><li>如何捕捉这两点，如左键为起点右键为终点</li></ul></li></ul><p>这次选择基于单个文档，其它倒是不用太在意</p><p>在创建完项目后看到很多头文件和源文件的时候，可以通过菜单栏的视图找到类视图</p><img src="/2022/07/25/mfc01/012.png" class=""><p>能够主要看清有哪些类。</p><p>启动项目后可以看到这样一个模板</p><img src="/2022/07/25/mfc01/013.png" class=""><p>要自己一开始就写肯定是不行的，所以这就是项目模板的好处，可以帮你完成很多基础的操作。<br>至于实现部分，可以通过类视图的类名去得到大意。</p><p>至于画线部分，拆分为两个地方，起点就是我们鼠标左键按下确定第一个点，然后随便他怎么拖动到其他地方然后再点击一下，即为线的终点。</p><p>至于这些鼠标按下抬起的消息，可以通过类视图右击打开属性，找到消息，能看到有很多。</p><img src="/2022/07/25/mfc01/014.png" class=""><img src="/2022/07/25/mfc01/015.png" class=""><p>然后选择这俩</p><img src="/2022/07/25/mfc01/016.png" class=""><p>也就是left button up和left button up，按下和松开</p><p>至于形参，可以转到定义查看<br><code>typedef unsigned int        UINT;</code></p><pre><code class="cpp">class CPoint :    public tagPOINT&#123;public:// Constructors    // create an uninitialized point    CPoint() throw();    // create from two integers    CPoint(        _In_ int initX,        _In_ int initY) throw();    // create from another point    CPoint(_In_ POINT initPt) throw();    // create from a size    CPoint(_In_ SIZE initSize) throw();    // create from an LPARAM: x = LOWORD(dw) y = HIWORD(dw)    CPoint(_In_ LPARAM dwPoint) throw();// Operations// translate the point    void Offset(        _In_ int xOffset,        _In_ int yOffset) throw();    void Offset(_In_ POINT point) throw();    void Offset(_In_ SIZE size) throw();    void SetPoint(        _In_ int X,        _In_ int Y) throw();    BOOL operator==(_In_ POINT point) const throw();    BOOL operator!=(_In_ POINT point) const throw();    void operator+=(_In_ SIZE size) throw();    void operator-=(_In_ SIZE size) throw();    void operator+=(_In_ POINT point) throw();    void operator-=(_In_ POINT point) throw();// Operators returning CPoint values    CPoint operator+(_In_ SIZE size) const throw();    CPoint operator-(_In_ SIZE size) const throw();    CPoint operator-() const throw();    CPoint operator+(_In_ POINT point) const throw();// Operators returning CSize values    CSize operator-(_In_ POINT point) const throw();// Operators returning CRect values    CRect operator+(_In_ const RECT* lpRect) const throw();    CRect operator-(_In_ const RECT* lpRect) const throw();&#125;;</code></pre><p>一个是改了名的类型，一个则是类。</p><p>这个类中有两个字眼比较醒目，x和y。变相的能猜到肯定是记录了xy轴的坐标。<br>但是按住和松开肯定是会改变xy的，就需要自己定义两个变量去记录起始位置。</p><pre><code class="cpp">protected:    CPoint m_start;        //起始位置，用于绘制线条    CPoint m_stop;        //终止位置，用于绘制线条</code></pre><pre><code class="cpp">void CMFCPaintView::OnLButtonDown(UINT nFlags, CPoint point)&#123;    // TODO: 在此添加消息处理程序代码和/或调用默认值    m_start = point;    CView::OnLButtonDown(nFlags, point);&#125;void CMFCPaintView::OnLButtonUp(UINT nFlags, CPoint point)&#123;    // TODO: 在此添加消息处理程序代码和/或调用默认值    m_stop = point;    CView::OnLButtonUp(nFlags, point);&#125;</code></pre><p>在这打两个断点然后跑程序，随便点击一下，就能看到point的xy出现值了</p><img src="/2022/07/25/mfc01/017.png" class=""><p>然而坐标其实也有分别，像屏幕传统的都是1920*1080，说的就是x轴长1920，y轴长1080，而且比较有意思的是这个0，0坐标在屏幕的左上角。<br>屏幕坐标可称为screen point，而程序的坐标可称为client point。</p><p>有了这两个的区别，就可能导致获取到的xy坐标是有问题的。<br>除了基础的xy获取了之后，还要考虑这个信息会不会被其它消息所引用，有引用又得防着被修改了。</p><p>xy有了，那么要考虑绘制的问题。<br>要用到一个类<code>CDC</code><br>这里就不展示了，这个类的定义里面东西有点多。</p><p><code>// The device context</code>在注释中说明，这是一个设备的上下文<br>上下文：在画图中要绘制一些东西的时候，肯定会用到线条的粗细，线条的颜色，画图的大小，画图的大小状态比如最小化最大化和普通状态等许多参数信息，只有了解了所有的参数信息才能绘制出想要的东西。<br>为什么叫设备上下文：上述举例的上下文是属于窗口的上下文，而有其他的情况，你会把绘制的东西显示在显示器上，而不是单独的窗口。那么这种时候就需要获取到你这个屏幕的参数。</p><pre><code class="cpp">void CMFCPaintView::OnLButtonUp(UINT nFlags, CPoint point)&#123;    // TODO: 在此添加消息处理程序代码和/或调用默认值    m_stop = point;        //获取设备上下文    CDC *pDC = GetDC();    pDC-&gt;MoveTo(m_start);    CView::OnLButtonUp(nFlags, point);&#125;</code></pre><p>在c++中结构体和类基本功能相通，区别在于类有私有成员。所以传递类并没有太大关系。<br><code>pDC-&gt;MoveTo(m_start);</code><br>moveto 就是说移动到我们的这个点上。然后才可以进行绘制线条之类的。</p><pre><code class="cpp">void CMFCPaintView::OnLButtonUp(UINT nFlags, CPoint point)&#123;    // TODO: 在此添加消息处理程序代码和/或调用默认值    m_stop = point;        //获取设备上下文    CDC *pDC = GetDC();    pDC-&gt;MoveTo(m_start);    pDC-&gt;LineTo(m_stop);    ReleaseDC(pDC);    CView::OnLButtonUp(nFlags, point);&#125;</code></pre><p><code>pDC-&gt;LineTo(m_stop);</code>line就是线呗，从按下鼠标左键的点到松开的点直接绘制一条直线。<br>并且要记住<code>ReleaseDC(pDC);</code>，避免占用导致程序异常。</p><p>然后就可以run了</p><img src="/2022/07/25/mfc01/018.png" class=""><p>鼠标左键按下直到某个点松开即可绘制出线条。</p><p>多画几条也没事，不过有点踩坑点：就是重绘的问题，此处就是当最大化和最小化的时候线条就莫得了。</p><p>除此之外，每次都需要滑动才能绘制，可能有点low。</p><pre><code class="cpp">protected:    CPoint m_start;        //起始位置，用于绘制线条    CPoint m_stop;        //终止位置，用于绘制线条    BOOL m_status;        //绘制状态</code></pre><pre><code class="cpp">void CMFCPaintView::OnLButtonDown(UINT nFlags, CPoint point)&#123;    // TODO: 在此添加消息处理程序代码和/或调用默认值    m_start = point;    m_status = TRUE;    CView::OnLButtonDown(nFlags, point);&#125;void CMFCPaintView::OnLButtonUp(UINT nFlags, CPoint point)&#123;    // TODO: 在此添加消息处理程序代码和/或调用默认值    m_stop = point;        //获取设备上下文    CDC *pDC = GetDC();    pDC-&gt;MoveTo(m_start);    pDC-&gt;LineTo(m_stop);    ReleaseDC(pDC);    m_status = FALSE;    CView::OnLButtonUp(nFlags, point);&#125;</code></pre><p>然后新增消息，鼠标移动时。快捷操作就是类视图然后属性里面找到消息</p><pre><code class="cpp">void CMFCPaintView::OnMouseMove(UINT nFlags, CPoint point)&#123;    // TODO: 在此添加消息处理程序代码和/或调用默认值    if (m_status)&#123;        InvalidateRect(NULL);        //如果鼠标正在移动就进行操作        CDC *pDC = GetDC();        pDC-&gt;MoveTo(m_start);        pDC-&gt;LineTo(m_stop);        ReleaseDC(pDC);    &#125;    CView::OnMouseMove(nFlags, point);&#125;</code></pre><p>增加一个状态是为了考虑程序刚启动的时候鼠标可能就在绘制区域了，那么有可能m_start没能获取到值，那么后面的绘制就会出现一些问题。</p><p><strong>注：状态肯定要在构造函数里面初始化</strong></p><pre><code class="cpp">CMFCPaintView::CMFCPaintView() noexcept&#123;    // TODO: 在此处添加构造代码    m_status = FALSE;&#125;</code></pre><p><code>InvalidateRect(NULL);</code>的作用<br>加了这个之后虽然绘制的线条没有刷新了，但是会接住前面的鼠标释放的点。看似连贯但是效果不对。<br>而没加这个，则是无论画多少条线都只会显示最近一次画的，也就是传统说法被刷新了或者叫重绘。</p><p>为了保证安全，再多加一个当前点位的变量。</p><pre><code class="cpp">CMFCPaintView::CMFCPaintView() noexcept&#123;    // TODO: 在此处添加构造代码    m_status = FALSE;    m_start = &#123; 0,0 &#125;;    m_stop = &#123; 0,0 &#125;;    m_cur = &#123; 0,0 &#125;;&#125;</code></pre><p>反正构造函数不要浪费，避免不必要的错误，就都从0，0坐标开始初始化。</p><pre><code class="cpp">void CMFCPaintView::OnLButtonDown(UINT nFlags, CPoint point)&#123;    // TODO: 在此添加消息处理程序代码和/或调用默认值    m_start = point;    m_status = TRUE;    CView::OnLButtonDown(nFlags, point);&#125;void CMFCPaintView::OnLButtonUp(UINT nFlags, CPoint point)&#123;    // TODO: 在此添加消息处理程序代码和/或调用默认值    m_stop = point;        //获取设备上下文    CDC *pDC = GetDC();    pDC-&gt;MoveTo(m_start);    pDC-&gt;LineTo(m_stop);    ReleaseDC(pDC);    m_status = FALSE;    CView::OnLButtonUp(nFlags, point);&#125;</code></pre><p>按下和释放不需要怎么改动。</p><p>在鼠标移动消息中</p><pre><code class="cpp">void CMFCPaintView::OnMouseMove(UINT nFlags, CPoint point)&#123;    // TODO: 在此添加消息处理程序代码和/或调用默认值    if (m_status)&#123;        InvalidateRect(NULL);        m_cur = point;            //让m_cur = 当前的鼠标坐标。    &#125;    CView::OnMouseMove(nFlags, point);&#125;</code></pre><p>至于这个刷新，它会自动触发函数</p><pre><code class="cpp">void CMFCPaintView::OnDraw(CDC* pDC)&#123;    CMFCPaintDoc* pDoc = GetDocument();    ASSERT_VALID(pDoc);    if (!pDoc)        return;    // TODO: 在此处为本机数据添加绘制代码    if (m_status)&#123;        pDC-&gt;MoveTo(m_start);        pDC-&gt;LineTo(m_cur);    &#125; else&#123;        pDC-&gt;MoveTo(m_start);        pDC-&gt;LineTo(m_stop);    &#125;&#125;</code></pre><p>下面的绘图代码才是我们需要添加的，前面不用管，前面的就是相当于一个刷新白板的操作。<br>也就是我们之前提到过的，最大化和最小化的时候，之前画的线条就消失了，其实就是触发了重绘没有保存。</p><p><code>InvalidateRect</code>会调用<code>OnDraw</code>，在我们没有重写<code>OnDraw</code>的时候，默认操作就是重绘白板。</p><p>一个m_start和m_stop和m_cur只能完整的记录一条线。如果想要画多条，就要用到列表方式去控制。</p><hr><h2 id="画笔"><a href="#画笔" class="headerlink" title="画笔"></a>画笔</h2><p>之前的画线，它的粗细和颜色和形状都不能调整。所以可以尝试修改这些。</p><p>用画笔自然也要用它封装好的类，CPen</p><pre><code class="cpp">class CPen : public CGdiObject&#123;    DECLARE_DYNAMIC(CPen)public:    static CPen* PASCAL FromHandle(HPEN hPen);// Constructors    CPen();    CPen(int nPenStyle, int nWidth, COLORREF crColor);    CPen(int nPenStyle, int nWidth, const LOGBRUSH* pLogBrush,        int nStyleCount = 0, const DWORD* lpStyle = NULL);    BOOL CreatePen(int nPenStyle, int nWidth, COLORREF crColor);    BOOL CreatePen(int nPenStyle, int nWidth, const LOGBRUSH* pLogBrush,        int nStyleCount = 0, const DWORD* lpStyle = NULL);    BOOL CreatePenIndirect(LPLOGPEN lpLogPen);// Attributes    operator HPEN() const;    int GetLogPen(LOGPEN* pLogPen);    int GetExtLogPen(EXTLOGPEN* pLogPen);// Implementationpublic:    virtual ~CPen();#ifdef _DEBUG    virtual void Dump(CDumpContext&amp; dc) const;#endif&#125;;</code></pre><p>这里看到构造的时候有两个带参数了</p><pre><code class="cpp">CPen(int nPenStyle, int nWidth, COLORREF crColor);CPen(int nPenStyle, int nWidth, const LOGBRUSH* pLogBrush,    int nStyleCount = 0, const DWORD* lpStyle = NULL);</code></pre><p>刚学先用前者<br>style就是样式，那么具体有</p><ol><li>PS_SOLID    实线</li><li>PS_DASH    虚线</li><li>PS_DOT    点线</li><li>PS_DOTDASH    点划线</li></ol><p>转到定义之后注释其实也很详细的给出了样子</p><pre><code class="cpp">#define PS_SOLID            0#define PS_DASH             1       /* -------  */#define PS_DOT              2       /* .......  */#define PS_DASHDOT          3       /* _._._._  */#define PS_DASHDOTDOT       4       /* _.._.._  */</code></pre><p>width自然就是线宽了，一般的单位都是像素。传int就完事。<br>color颜色，表示起来就RGB(RED,GREE,BULR)按照ps那会的情况，数值应该是0-255，暂时没看这里能不能用十六进制的方式塞。</p><p>设置好了笔的属性，就该用这支笔去画。</p><pre><code class="cpp">void CMFCPaintView::OnDraw(CDC* pDC)&#123;    CMFCPaintDoc* pDoc = GetDocument();    ASSERT_VALID(pDoc);    if (!pDoc)        return;    // TODO: 在此处为本机数据添加绘制代码    CPen pen(PS_DASH, 3, RGB(255, 0, 0));    CPen *pPen = pDC-&gt;SelectObject(&amp;pen);        //要把这个笔加入设备上下文    if (m_status)&#123;        pDC-&gt;MoveTo(m_start);        pDC-&gt;LineTo(m_cur);    &#125; else&#123;        pDC-&gt;MoveTo(m_start);        pDC-&gt;LineTo(m_stop);    &#125;    //还原笔的属性是为了保证后面要画的时候不会还是这个类型    pDC-&gt;SelectObject(pPen);&#125;</code></pre><img src="/2022/07/25/mfc01/019.png" class=""><p>可以看到粗细和颜色是有变化了，但是样式好像没看出变化。<br>越来越粗的话肯定是看不出变化的。那么改小一点<br><code>CPen pen(PS_DASH, 1, RGB(255, 0, 0));</code></p><img src="/2022/07/25/mfc01/020.png" class=""><p>可以看到了虚线效果。。。嘶，还挺麻烦。只能用一个像素点才能看到效果。</p><hr><h3 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h3><p>这是一个调试的时候用的函数，可以在输出栏里面打印出一些需要的信息。</p><pre><code class="cpp">void CMFCPaintView::OnDraw(CDC* pDC)&#123;    CMFCPaintDoc* pDoc = GetDocument();    ASSERT_VALID(pDoc);    if (!pDoc)        return;    // TODO: 在此处为本机数据添加绘制代码    CPen pen(PS_DASH, 4, RGB(255, 0, 0));    CPen *pPen = pDC-&gt;SelectObject(&amp;pen);    LOGPEN logpen;    pPen-&gt;GetLogPen(&amp;logpen);    TRACE(&quot;\nstyle:%d width:%d color:%08X\n&quot;, logpen.lopnStyle, logpen.lopnWidth, logpen.lopnColor);    if (m_status)&#123;            pDC-&gt;MoveTo(m_start);        pDC-&gt;LineTo(m_cur);    &#125; else&#123;        pDC-&gt;MoveTo(m_start);        pDC-&gt;LineTo(m_stop);    &#125;    //还原笔的属性是为了保证后面要画的时候不会还是这个类型    pDC-&gt;SelectObject(pPen);&#125;</code></pre><img src="/2022/07/25/mfc01/021.png" class=""><p>毕竟有的时候单步调试比较累，如果能隐约猜到，可以尝试打印看看是否有问题。</p><hr><h2 id="画刷"><a href="#画刷" class="headerlink" title="画刷"></a>画刷</h2><p>用过画图其实应该知道，画笔毕竟画的是点阵练成的线，而画刷画出来的是实心的对象。<br>一个点绘，一个填充。</p><pre><code class="cpp">class CBrush : public CGdiObject&#123;    DECLARE_DYNAMIC(CBrush)public:    static CBrush* PASCAL FromHandle(HBRUSH hBrush);// Constructors    CBrush();    CBrush(COLORREF crColor);             // CreateSolidBrush    CBrush(int nIndex, COLORREF crColor); // CreateHatchBrush    explicit CBrush(CBitmap* pBitmap);          // CreatePatternBrush    BOOL CreateSolidBrush(COLORREF crColor);    BOOL CreateHatchBrush(int nIndex, COLORREF crColor);    BOOL CreateBrushIndirect(const LOGBRUSH* lpLogBrush);    BOOL CreatePatternBrush(CBitmap* pBitmap);    BOOL CreateDIBPatternBrush(HGLOBAL hPackedDIB, UINT nUsage);    BOOL CreateDIBPatternBrush(const void* lpPackedDIB, UINT nUsage);    BOOL CreateSysColorBrush(int nIndex);// Attributes    operator HBRUSH() const;    int GetLogBrush(LOGBRUSH* pLogBrush);// Implementationpublic:    virtual ~CBrush();#ifdef _DEBUG    virtual void Dump(CDumpContext&amp; dc) const;#endif&#125;;</code></pre><p>CBrush即为c++中的画刷。而构造函数里面，有个是就放颜色就行的。</p><p>起步都一样，创建了之后添加到设备上下文。</p><pre><code class="cpp">void CMFCPaintView::OnDraw(CDC* pDC)&#123;    CMFCPaintDoc* pDoc = GetDocument();    ASSERT_VALID(pDoc);    if (!pDoc)        return;    // TODO: 在此处为本机数据添加绘制代码    CPen pen(PS_DASH, 4, RGB(255, 0, 0));    CPen *pPen = pDC-&gt;SelectObject(&amp;pen);    CBrush brush(RGB(0, 255, 0));    CBrush *pBrush = pDC-&gt;SelectObject(&amp;brush);    LOGPEN logpen;    pPen-&gt;GetLogPen(&amp;logpen);    TRACE(&quot;\nstyle:%d width:%d color:%08X\n&quot;, logpen.lopnStyle, logpen.lopnWidth, logpen.lopnColor);    if (m_status)&#123;    //         pDC-&gt;MoveTo(m_start);//         pDC-&gt;LineTo(m_cur);        //填充矩形        pDC-&gt;FillRect(CRect(m_start, m_cur), &amp;brush);    &#125; else&#123;//         pDC-&gt;MoveTo(m_start);//         pDC-&gt;LineTo(m_stop);        pDC-&gt;FillRect(CRect(m_start, m_stop), &amp;brush);    &#125;    //还原笔的属性是为了保证后面要画的时候不会还是这个类型    pDC-&gt;SelectObject(pPen);    pDC-&gt;SelectObject(pBrush);&#125;</code></pre><img src="/2022/07/25/mfc01/022.png" class=""><p>其实就是从按下到释放的两个点延伸出去直至闭合形成一个图形。<br>至于填充的颜色，画刷初始化的时候选择绿色，则默认也为绿色，也就是说<code>pDC-&gt;FillRect(CRect(m_start, m_cur), &amp;brush);</code>后面的参数不选择画刷，用NULL，默认的颜色也是画刷的颜色。<br>也可以创建别的颜色的画刷对象，然后传递，这倒不是啥大问题。</p><p><code>FillRect</code>是填充矩形，那么还有别的几个，下次再整。</p><img src="/2022/07/25/mfc01/023.png" class=""><hr><h2 id="光标和文本"><a href="#光标和文本" class="headerlink" title="光标和文本"></a>光标和文本</h2><p>我们现在跑的这个mfc程序，虽然中间那个空白区域是一个编辑区域，但是前面的功能都是绘制，与传统本文编辑区域而言，他少了一个光标，还有行号或者是分层的感觉。</p><p>至于这个创建光标加在哪里，构造函数肯定不可行，因为窗口绑定有很多相关的东西，不代表你这个地方构造完成了，其它绑定窗口的东西并不一定全部起来了。放在ondraw里面也不合适，那里重绘的话太频繁了这个光标。</p><p>所有的windows程序和mfc程序<br>第一阶段都是构造的时候<br>第二阶段才到达create阶段，在这个时候才会把构造的对象和窗口句柄之类的绑定<br>第三阶段要么showWindow或者doModule，就是显示出这些程序的框架，也就是跑起来了<br>第四阶段大致就是destroy阶段，它这个时候就是去销毁掉窗口<br>第五阶段就是delete阶段，这个时候才是销毁掉构造的对象</p><p>所以构造什么的是肯定行不通了，就要用到Create消息<br>快捷操作就是类视图，选择CMFCPaintView，然后属性里面找到消息，选择create</p><pre><code class="cpp">int CMFCPaintView::OnCreate(LPCREATESTRUCT lpCreateStruct) &#123;    if ( CView::OnCreate(lpCreateStruct) == -1 )        return -1;    // TODO:  在此添加您专用的创建代码    return 0;&#125;</code></pre><p>就会得到这样一个模板。这个create消息是create完成之后广播到各个控件，然后调用自己的构造函数，然后去完成一些自定义的操作。</p><pre><code class="cpp">int CMFCPaintView::OnCreate(LPCREATESTRUCT lpCreateStruct) &#123;    if ( CView::OnCreate(lpCreateStruct) == -1 )        return -1;    // TODO:  在此添加您专用的创建代码    CreateSolidCaret(3, 20);    ShowCaret();    return 0;&#125;</code></pre><p>在随便指定这个光标大小之后</p><img src="/2022/07/25/mfc01/024.png" class=""><p>截图所以不管他闪不闪了，不过因为这个数值是我们指定的，所以当输入的字体万一大于光标或者小于都会看着很奇怪，显然别的程序肯定是有自适应大小的解决方法。</p><pre><code class="cpp">int CMFCPaintView::OnCreate(LPCREATESTRUCT lpCreateStruct) &#123;    if ( CView::OnCreate(lpCreateStruct) == -1 )        return -1;    // TODO:  在此添加您专用的创建代码    CClientDC dc(this);    TEXTMETRIC tm;    dc.GetTextMetrics(&amp;tm);    CreateSolidCaret(2, tm.tmHeight);    ShowCaret();    return 0;&#125;</code></pre><p>用了点稀奇古怪的感觉</p><pre><code class="cpp">typedef struct tagTEXTMETRICW&#123;    LONG        tmHeight;    LONG        tmAscent;    LONG        tmDescent;    LONG        tmInternalLeading;    LONG        tmExternalLeading;    LONG        tmAveCharWidth;    LONG        tmMaxCharWidth;    LONG        tmWeight;    LONG        tmOverhang;    LONG        tmDigitizedAspectX;    LONG        tmDigitizedAspectY;    WCHAR       tmFirstChar;    WCHAR       tmLastChar;    WCHAR       tmDefaultChar;    WCHAR       tmBreakChar;    BYTE        tmItalic;    BYTE        tmUnderlined;    BYTE        tmStruckOut;    BYTE        tmPitchAndFamily;    BYTE        tmCharSet;&#125; TEXTMETRICW, *PTEXTMETRICW, NEAR *NPTEXTMETRICW, FAR *LPTEXTMETRICW;#ifdef UNICODEtypedef TEXTMETRICW TEXTMETRIC;</code></pre><p>反正传入这个的目的就是为了获取到里面的hight。</p><pre><code class="cpp">class CClientDC : public CDC&#123;    DECLARE_DYNAMIC(CClientDC)// Constructorspublic:    explicit CClientDC(CWnd* pWnd);// Attributesprotected:    HWND m_hWnd;// Implementationpublic:    virtual ~CClientDC();#ifdef _DEBUG    virtual void AssertValid() const;    virtual void Dump(CDumpContext&amp; dc) const;#endif&#125;;</code></pre><p>显然这个类是继承CDC的一个派生类，那么这个派生类也能拿到基类的设备上下文了。</p><p>跑起来之后反正目前看上去差别不大。</p><p>光标位置有了，就是输入的时候</p><pre><code class="cpp">void CMFCPaintView::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags) &#123;    // TODO: 在此添加消息处理程序代码和/或调用默认值    CView::OnChar(nChar, nRepCnt, nFlags);&#125;</code></pre><p>这玩意也比较有意思。<br>当我们在输出的地方打印这个uChar的时候</p><pre><code class="cpp">void CMFCPaintView::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags) &#123;    // TODO: 在此添加消息处理程序代码和/或调用默认值    TRACE(&quot;%c\r\n&quot;, nChar);    CView::OnChar(nChar, nRepCnt, nFlags);&#125;</code></pre><img src="/2022/07/25/mfc01/025.png" class=""><p>也就是每当键盘按下一个键，他就会接收到。既然它能接收到，那就好办了。</p><pre><code class="cpp">void CMFCPaintView::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags) &#123;    // TODO: 在此添加消息处理程序代码和/或调用默认值    TRACE(&quot;%c\r\n&quot;, nChar);    CClientDC dc(this);    m_strText += (TCHAR)nChar;    dc.TextOut(0, 0, m_strText);    CView::OnChar(nChar, nRepCnt, nFlags);&#125;</code></pre><p>写入肯定还是要获取设备上下文的，然后就是TextOut的最后一个参数是Cstring，在这里创建临时变量的话，也不能保证后面别的地方会不会用到，就干脆在类里面新建一个成员保存。</p><pre><code class="cpp">protected:    CPoint m_start;        //起始位置，用于绘制线条    CPoint m_cur;        //当前点位，用于绘制线条    CPoint m_stop;        //终止位置，用于绘制线条    BOOL m_status;        //绘制状态    CString m_strText;    //用户输出的字符串</code></pre><p>这里<code>m_strText += (TCHAR)nChar;</code>转换是因为vs2022反正项目默认都是unicode编码的也就是宽字节，所有的字符占两个字节，而多字节也就是ANSI，在ANSI中英文占用一个字节，所以二者会有区别。这也是有的时候要么改编码环境要么强转。</p><p>跑起来试试</p><img src="/2022/07/25/mfc01/026.png" class=""><p>可以看到还是有点问题，比如这个光标不移动，还要每次输入闪烁很明显，闪烁肯定是重绘的问题。<br>所以在重绘函数ondraw里面来一次textout就行</p><pre><code class="cpp">void CMFCPaintView::OnDraw(CDC* pDC)&#123;    CMFCPaintDoc* pDoc = GetDocument();    ASSERT_VALID(pDoc);    if (!pDoc)        return;    // TODO: 在此处为本机数据添加绘制代码    CPen pen(PS_DASH, 4, RGB(255, 0, 0));    CPen *pPen = pDC-&gt;SelectObject(&amp;pen);    CBrush brush(RGB(0, 255, 0));    CBrush *pBrush = pDC-&gt;SelectObject(&amp;brush);    LOGPEN logpen;    pPen-&gt;GetLogPen(&amp;logpen);    TRACE(&quot;\nstyle:%d width:%d color:%08X\n&quot;, logpen.lopnStyle, logpen.lopnWidth, logpen.lopnColor);    if (m_status)&#123;            pDC-&gt;FillRect(CRect(m_start, m_cur), &amp;brush);    &#125; else&#123;        pDC-&gt;FillRect(CRect(m_start, m_stop), &amp;brush);    &#125;    //还原笔的属性是为了保证后面要画的时候不会还是这个类型    pDC-&gt;SelectObject(pPen);    pDC-&gt;SelectObject(pBrush);    //重绘字符串    pDC-&gt;TextOut(0, 0, m_strText);&#125;</code></pre><p>然后在onchar消息里面刷新</p><pre><code class="cpp">void CMFCPaintView::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags) &#123;    // TODO: 在此添加消息处理程序代码和/或调用默认值    TRACE(&quot;%c\r\n&quot;, nChar);    CClientDC dc(this);    m_strText += (TCHAR)nChar;    dc.TextOut(0, 0, m_strText);    InvalidateRect(NULL);    CView::OnChar(nChar, nRepCnt, nFlags);&#125;</code></pre><p>闪烁问题就解决了。</p><p><strong>另外测试的时候回车键有点问题，因为没有对\n进行处理</strong></p><p>其实这些操作都是在考虑一个消息该怎么处理</p><ol><li>要确定响应什么消息，像鼠标按下，就是lbuttondown</li><li>添加消息响应函数，快捷方式从消息中add</li><li>追加消息响应内容，默认是空的，你要给这个消息额外写一些功能</li></ol><p>其中比较麻烦的就是确定响应哪个消息，一开始肯定是不知道了只能查了。还有就是响应规则，有些会和头部预先定义的相关，有些则是全都由自己来写。</p><p>那么现在还有两个问题，一个多行文本一个光标移动。</p><p>换行这个问题其实根本在TextOut上，因为这个方法不具备换行能力。而我们又要考虑重绘的问题，就需要在OnDraw里改动。<br>最简单的就是用循环，然后if判断输入的是是否为换行，如果是就要让TextOut的y轴变大。</p><pre><code class="cpp">void CMFCPaintView::OnDraw(CDC* pDC)&#123;    CMFCPaintDoc* pDoc = GetDocument();    ASSERT_VALID(pDoc);    if (!pDoc)        return;    // TODO: 在此处为本机数据添加绘制代码    CPen pen(PS_DASH, 4, RGB(255, 0, 0));    CPen *pPen = pDC-&gt;SelectObject(&amp;pen);    CBrush brush(RGB(0, 255, 0));    CBrush *pBrush = pDC-&gt;SelectObject(&amp;brush);    LOGPEN logpen;    pPen-&gt;GetLogPen(&amp;logpen);    TRACE(&quot;\nstyle:%d width:%d color:%08X\n&quot;, logpen.lopnStyle, logpen.lopnWidth, logpen.lopnColor);    if (m_status)&#123;            pDC-&gt;FillRect(CRect(m_start, m_cur), &amp;brush);    &#125; else&#123;        pDC-&gt;FillRect(CRect(m_start, m_stop), &amp;brush);    &#125;    //还原笔的属性是为了保证后面要画的时候不会还是这个属性的笔    pDC-&gt;SelectObject(pPen);    pDC-&gt;SelectObject(pBrush);    //重绘字符串    CString sub = _T(&quot;&quot;);    //用来记录要绘制的字符    int y = 0;    for ( int i = 0; i &lt; m_strText.GetLength(); i++ ) &#123;        if (( m_strText.GetAt(i) == &#39;\n&#39; ) || (m_strText.GetAt(i) == &#39;\r&#39;)) &#123;            pDC-&gt;TextOut(0, y, sub);            sub.Empty();            y += 20;            continue;        &#125;        sub += m_strText.GetAt(i);    &#125;    //sub不为空就直接打印    if ( !sub.IsEmpty() ) pDC-&gt;TextOut(0, y, sub);&#125;</code></pre><img src="/2022/07/25/mfc01/027.png" class=""><p>换行的效果实现了，这里比较坑的是<code>if (( m_strText.GetAt(i) == &#39;\n&#39; ) || (m_strText.GetAt(i) == &#39;\r&#39;))</code>获取的换行符好像会被\r顶掉，但是\n还是得保留，因为键盘输入的角度都是\r了，但是万一黏贴的文本是个\n就有点搞了。<br>不过显然是获取数据的时候有点小问题，要是不想在这if，可能就要在onchar消息里面修改掉。</p><p>最后就是光标</p><pre><code class="cpp">void CMFCPaintView::OnDraw(CDC* pDC)&#123;    CMFCPaintDoc* pDoc = GetDocument();    ASSERT_VALID(pDoc);    if (!pDoc)        return;    // TODO: 在此处为本机数据添加绘制代码    CPen pen(PS_DASH, 4, RGB(255, 0, 0));    CPen *pPen = pDC-&gt;SelectObject(&amp;pen);    CBrush brush(RGB(0, 255, 0));    CBrush *pBrush = pDC-&gt;SelectObject(&amp;brush);    LOGPEN logpen;    pPen-&gt;GetLogPen(&amp;logpen);    TRACE(&quot;\nstyle:%d width:%d color:%08X\n&quot;, logpen.lopnStyle, logpen.lopnWidth, logpen.lopnColor);    if (m_status)&#123;            pDC-&gt;FillRect(CRect(m_start, m_cur), &amp;brush);    &#125; else&#123;        pDC-&gt;FillRect(CRect(m_start, m_stop), &amp;brush);    &#125;    //还原笔的属性是为了保证后面要画的时候不会还是这个类型    pDC-&gt;SelectObject(pPen);    pDC-&gt;SelectObject(pBrush);    //重绘字符串    CString sub = _T(&quot;&quot;);    //用来记录要绘制的字符    int y = 0;        for ( int i = 0; i &lt; m_strText.GetLength(); i++ ) &#123;        if (( m_strText.GetAt(i) == &#39;\n&#39; ) || (m_strText.GetAt(i) == &#39;\r&#39;)) &#123;            pDC-&gt;TextOut(0, y, sub);            CSize sz = pDC-&gt;GetTextExtent(sub);            sub.Empty();            //y += 20;            y += sz.cy + 2;        //+2是为了留点行间距            continue;        &#125;        sub += m_strText.GetAt(i);    &#125;    //循环里面    if ( !sub.IsEmpty() ) pDC-&gt;TextOut(0, y, sub);    //移动光标    CPoint cp;    CSize sz = pDC-&gt;GetTextExtent(sub);    cp.y = y;        //y是局部设置好的    cp.x = sz.cx;    //通过捕捉sub，得到x和y    SetCaretPos(cp);&#125;</code></pre><p>光标的y轴还算好计算的，毕竟换行的时候就会根据y改变<br>x则需要借助<code>CSize sz = pDC-&gt;GetTextExtent(sub);</code>这么一个获取设备上下文的文字范围。其中最为关键的就是cx和cy。<br>所以也修改了换行的时候y的值，但从20这个固定值，只能保证常用字符，有些汉字什么的就不能保证了，所以还是主动获取最好。</p><p><strong>要注意，换行前的xy和换行后的xy肯定是不同的，不要想着用一个CSize</strong></p><img src="/2022/07/25/mfc01/028.png" class=""><p>效果差不多了。</p><p>像玩的深入的还能这样该后面的移动光标<br><code>SetCaretPos(CPoint(sz.cx + 2, y));</code><br>一句话就该过去了，实际上也是用了父类子类之间的关系，然后就是构造函数。<br>看了老师的操作雀食不一样，还有一种调用系统api的方式<code>::SetCaretPos(sz.cx + 2, y);</code>，不过毕竟是系统api，不是mfc的直接内容，所以有的时候为了项目维护还是不搞花里胡哨的。</p><p>但是仍然有很多不足</p><ol><li>没有删除的功能</li><li>比如左键拖动选中文字，文字的背景颜色会变黑之类的</li></ol><p>这些日后再说</p><hr><h2 id="菜单和工具栏"><a href="#菜单和工具栏" class="headerlink" title="菜单和工具栏"></a>菜单和工具栏</h2><h3 id="菜单栏"><a href="#菜单栏" class="headerlink" title="菜单栏"></a>菜单栏</h3><img src="/2022/07/25/mfc01/029.png" class=""><p>资源视图没有的，在vs的菜单栏找到视图，再找其他窗口里面就有了。</p><p>然后就是经典设计，注意修改id，默认尾巴跟数字不利于使用和查看。然后描述文字<code>画矩形(&amp;R)</code>后面的是快捷键的一种表达方式，反正具体的应该是mfc写好了。我们只要跟着这样格式写就行。alt+你所输入的字符即为快捷键</p><img src="/2022/07/25/mfc01/030.png" class=""><p>跑起来效果肯定就没啥差别</p><img src="/2022/07/25/mfc01/031.png" class=""><p>灰色应该是没有事件处理，就是死的按钮。</p><p>然后就是给这个菜单绑定事件</p><img src="/2022/07/25/mfc01/032.png" class=""><p>类别表选择view。看下面的菜单命令路由</p><img src="/2022/07/25/mfc01/033.png" class=""><p>确定之后就会加载一个空的函数了</p><pre><code class="cpp">void CMFCPaintView::OnDrawLine() &#123;    // TODO: 在此添加命令处理程序代码&#125;</code></pre><p><code>TRACE(&quot;%s(%d):%s\r\n&quot;, __FILE__, __LINE__, __FUNCTION__);</code><br>这条内容主要是打印文件路径，然后行号，还有就是函数名<br>典型的debug调试时候使用。</p><p>我们把画矩形绑定事件，不同的就是类列表不同，前面那个在view下，这个在doc下</p><pre><code class="cpp">void CMFCPaintDoc::OnDrwaRect() &#123;    // TODO: 在此添加命令处理程序代码    TRACE(&quot;%s(%d):%s\r\n&quot;, __FILE__, __LINE__, __FUNCTION__);&#125;</code></pre><p>然后run一个<br>当我们点击了这个画线和画矩形的时候，输出那里就能看到详细的文件路径、行号和函数名</p><img src="/2022/07/25/mfc01/034.png" class=""><p>有意思的是双击输出中的这一行TRACE打印的内容他会直接跳转到这个函数的位置</p><img src="/2022/07/25/mfc01/035.png" class=""><p>对于测试来说这个肯定挺好用的。</p><hr><h3 id="菜单命令路由"><a href="#菜单命令路由" class="headerlink" title="菜单命令路由"></a>菜单命令路由</h3><ol><li>有view和doc，触发了view，但是没有触发doc</li><li>去掉view类的菜单响应函数，打开doc类的响应函数。触发view类，不触发doc；view &gt; doc</li><li>去掉了doc类的菜单响应函数，打开框架类的响应函数触发doc类，不触发app；doc &gt; 框架</li><li>去掉了app类的菜单响应函数，打开app类的响应函数； 框架 &gt; app</li></ol><p>所以响应菜单的命令顺序：view &gt; doc &gt; 框架 &gt; app<br>在这个mfc程序里面看：CMFCPaintView &gt; CMFCPaintDoc &gt; CMainFrame &gt; CMFCPanitApp</p><p>测试的方式可以通过<code>TRACE(&quot;%s(%d):%s\r\n&quot;, __FILE__, __LINE__, __FUNCTION__);</code><br>在view中都绑定事件，然后在其它doc下也绑定，看看到底先触发的是view还是什么。</p><p><strong>经典MVC模式中，M是指业务模型，V是指用户界面，C则是控制器，使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。其中，View的定义比较清晰，就是用户界面。</strong></p><hr><h3 id="工具栏"><a href="#工具栏" class="headerlink" title="工具栏"></a>工具栏</h3><p>也是通过资源视图去找，找到toolbar，然后叫mainframe</p><img src="/2022/07/25/mfc01/036.png" class=""><img src="/2022/07/25/mfc01/037.png" class=""><p>下面哪个256是因为有别的颜色，但是本身都是一个东西，所以做一个东西俩都要弄</p><img src="/2022/07/25/mfc01/038.png" class=""><img src="/2022/07/25/mfc01/039.png" class=""><p>绘制完成后，修改id</p><img src="/2022/07/25/mfc01/040.png" class=""><p><strong>注意，如果这个id选择的是以前写过内容的id，那么这个工具栏的按钮就会绑定之前的内容</strong><br>比如我这个又使用<code>DRAW_LINE</code>这是之前测试的</p><pre><code class="cpp">void CMFCPaintView::OnDrawLine() &#123;    // TODO: 在此添加命令处理程序代码    TRACE(&quot;%s(%d):%s\r\n&quot;, __FILE__, __LINE__, __FUNCTION__);&#125;</code></pre><p>内容是这样的，我们run这个程序点击看看是否会触发</p><img src="/2022/07/25/mfc01/041.png" class=""><p>我们点击了三次，它也的确触发了三次，说明确实绑定了。</p><p><strong>删除这个工具栏的选项，要点击然后拖出去就能删掉了，默认没啥地方有删除选项</strong></p><hr><h3 id="mfc结构文档"><a href="#mfc结构文档" class="headerlink" title="mfc结构文档"></a>mfc结构文档</h3><p><a href="https://docs.microsoft.com/zh-cn/cpp/mfc/hierarchy-chart?view=msvc-170&viewFallbackFrom=2022">文档戳链接，如果有误跳转时可修改最后参数，此参数为年份</a></p><p>看层次结构的目的是为了以后当参数转换啥的更方便，像自己在vs里面不断跳转定义也ok，就是稍微麻烦了点。</p><p>层次的视觉感观会更直接，比如生物-动物-人-男人，作为派生类，总会有一些与其父类相关的特性。</p><p>CObject</p><ul><li>支持序列化<ul><li>可能把一个结构体变成一个字符串，几个字节存放一个数据，最后留俩当长度</li><li>也可能是{x:100,y:200}这样结构化，类似于json</li><li>….等都是一种序列化的表现</li></ul></li><li>支持运行时提供类的信息<ul><li><code>static CRuntimeClass *PASCAL _GetBaseClass();</code></li><li><code>static CRuntimeClass *PASCAL GetThisClass();</code></li><li>正常的派生类下来，并不会刻意保留父类叫什么，而mfc做了一些优化</li></ul></li><li>支持动态创建以及支持对象诊断输出<ul><li><code>virtual void AsserValid() const;</code></li><li><code>virtual void Dump(CDumpContext&amp; dc) const;</code></li><li>当mfc启动时，有些需求不是立马就创建的，只有当触发的时候才会创建</li></ul></li></ul><p>有这么一个超级基类的存在，就提供了无限的可能，但是这种级别的东西不适合个人开发。</p><hr><h2 id="mfc框架理论"><a href="#mfc框架理论" class="headerlink" title="mfc框架理论"></a>mfc框架理论</h2><h3 id="关键类"><a href="#关键类" class="headerlink" title="关键类"></a>关键类</h3><p><code>CWinApp</code>:MFC应用程序抽象，负责管理Document Template<br><code>CFrameWnd</code>:框架窗口、负责创建应用的主窗口，含标题栏、菜单栏、工具栏、状态栏等<br><code>CView</code>:负责展示应用数据，View其实是一个没有边框的窗口，客户区<br><code>CDocument</code>:负责存储应用数据</p><hr><h3 id="关键类之间的关系"><a href="#关键类之间的关系" class="headerlink" title="关键类之间的关系"></a>关键类之间的关系</h3><p>CDocTemplate、CDocument、CView、CFrameWnd关系</p><ul><li>CWinApp 拥有一个对象指针：CDocManager *m_pDocManager</li><li>CDocManager拥有一个指针链表CPtrList m_templateList，用来维护一系列的DocumentTemplate。应用程序在CMyWinApp::InitInstance中以AddDocTemplate将这些Document Templates加入到有CDocTemplate所维护的链表之中</li><li>CDocTemplate拥有三个成员变量，分别持有Document、View、Frame的CRuntimeClass指针，另有一个成员变量m_nIDResource，用来表示此Document显示时应该采用的UI对象。这四位数据在CMyWinApp::InitInstance函数构造CDocTemplate时指针，称为构造函数的参数。</li><li>CDocument有一个成员变量CDocTemplate *m_pDocTemplate，回指其DocumentTemplate；另外有一个成员变量CPtrList m_viewList，表示它可以同时维护一组Views。</li><li>CFrameWnd有一个成员变量Cview *m_pViewActive，指向当前活动的View</li><li>CView有一个成员变量CDocument *m_pDocument，指向相关的Document</li></ul><p>结构层次化都是为了方便开发和维护。</p><hr><h3 id="消息分类"><a href="#消息分类" class="headerlink" title="消息分类"></a>消息分类</h3><p>mfc消息的分类大致分为三种：标准消息、命令消息、通告消息。</p><ol><li>标准消息：除WM_COMMAND之外，所有以WM_开头的消息。从CWnd类派生的类都可以接受到这一类消息</li><li>命令消息：来自菜单、加速键或者工具栏按钮的消息。这类消息都以WM_COMMAND呈现。在MFC中，通过菜单项的标识(id)来区分不同的命令消息；在sdk中，通过消息的wParam参数识别。从CCmdTarget(CWnd的父类)派生的类都可以接收到这一类消息</li><li>通告消息：由控件产生的消息，例如按钮的单击，列表框的选择等均会产生此类消息，为的是向其父窗口(通常为对话框)通知时间的发生。这类消息也是以WM_COMMAND形式呈现。从CCmdTarget(CWnd的父类)派生的类都可以接收到这一类消息。</li></ol><p>小结：凡是从Cwnd派生的类，即可以接受标准消息，也可以接收命令消息和通告消息。<br>而对于那些从CCmdTarget派生的类，则只能接受命令消息和通告消息，不能接受标准消息。</p><hr><h2 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h2><p>是与用户进行交互的控件，如文件对话框、字体对话框、颜色对话框等，一般用于告示、提醒等。</p><img src="/2022/07/25/mfc01/042.png" class=""><p>app这个是之前创建的对话框，从类视图可以看到只有三个类。比文档的结构观感上要简洁不少。</p><p>其中标准消息可以直接通过类视图-&gt;选择项目的类-&gt;属性里面找到消息即可。</p><p>对话框其实就是一个窗口，它不仅可以接收消息，而且还可以被移动或者关闭，甚至是在客户区中进行绘图。这些都是有CWnd类派生而来。</p><img src="/2022/07/25/mfc01/043.png" class=""><p>其中除了最基础的消息，还有控件</p><img src="/2022/07/25/mfc01/044.png" class=""><p>利用拖动控件的方式，可以省去很多麻烦。</p><hr><h3 id="创建对话框"><a href="#创建对话框" class="headerlink" title="创建对话框"></a>创建对话框</h3><p>同样的，已有的几个是根据项目类型产生的，我们当然可以进行创建<br>在资源视图中，选这个项目的Dialog，然后右击添加资源</p><img src="/2022/07/25/mfc01/045.png" class=""><p>这里不选子类直接选Dialog也是可以的。</p><img src="/2022/07/25/mfc01/046.png" class=""><p>通过Dialog创建的它的对话框属性只有一个id能修改，问题不大，改个有意义的就行</p><img src="/2022/07/25/mfc01/047.png" class=""><p>资源属性这边能改的就很多。</p><p>图形化的做完了，代码实现部分就需要类去控制它</p><img src="/2022/07/25/mfc01/048.png" class=""><p>直接右击添加类，类名随便写尽量有意义，然后继承的基类，一般是这头两个。ex说过就是拓展的意思。</p><p>这种通过简单的方式创建出模板的好处就是省去了一些小麻烦，也不容易出问题</p><pre><code class="cpp">void CMFCApplication1Dlg::OnBnClickedOk() &#123;    // TODO: 在此添加控件通知处理程序代码    //MessageBox(_T(&quot;你好呀!&quot;));    CBingDialog dlg;    dlg.DoModal();        CDialogEx::OnOK();&#125;</code></pre><p>在主窗口的确认按钮下设置，将我们新建的CBingDialog作为模块化弹出</p><img src="/2022/07/25/mfc01/049.png" class=""><p>当dlg弹出之后，原先的窗口是不可改变的状态，只有dlg关闭之后才能操作后面的对话框。</p><p><code>DoModal</code>这就是所谓的模态对话框，有的时候会觉得不太方便吧，但是如果是警示之类的还是挺好的。</p><p>有模态化就有非模态化的，非模态化的一个问题其实猜也能猜到，就是因非模态化而产生的对话框不会卡住，如果这个变量优先级不够，很有可能在不知道的地方就被析构释放了，在逻辑上会导致很严重的问题，而且设置起来也较为麻烦。</p><p><strong>首先因为没有锁或者说阻塞，所以当按钮按下的适合，这个新建的对话框一闪而过，结束的很快。</strong><br>所以要在头文件类中建一个全局变量。</p><pre><code class="cpp">class CMFCApplication1Dlg : public CDialogEx&#123;// 构造public:    CMFCApplication1Dlg(CWnd* pParent = nullptr);    // 标准构造函数    CBingDialog dlg;        //注意引用头文件不然是未定义的类型//....后面的省略&#125;</code></pre><p>然后又要在对话框源文件中，找到oninitdialog函数</p><pre><code class="cpp">// TODO: 在此添加额外的初始化代码dlg.Create(IDD_DIALOG_NEW, this);</code></pre><p>在这完成初始化。</p><p>最后在按钮消息中触发显示</p><pre><code class="cpp">void CMFCApplication1Dlg::OnBnClickedOk() &#123;    dlg.ShowWindow(SW_SHOW);&#125;</code></pre><p>可以看到非模态化的对话框设置起来就要挺多步骤了。</p><img src="/2022/07/25/mfc01/050.png" class=""><p>非模态化的效果就是不会阻塞，后面的窗口是可以操作的。</p><p>或者你可以直接在对话框源文件中定义全局变量<code>CBingDialog dlg;</code><br>然后再按钮消息中设置</p><pre><code class="cpp">void CMFCApplication1Dlg::OnBnClickedOk() &#123;    dlg.Create(IDD_DIALOG_NEW, this);    dlg.ShowWindow(SW_SHOW);&#125;</code></pre><p>也是可行的，因为这个dlg变量不会再按钮结束后立马被析构掉。</p><p><strong>总而言是，模态化对话框的使用场景肯定是基于会修改影响到其他窗口，这个时候肯定要设置称模态化对话框去阻塞，不然改动了还原的部分都没的操作了。非模态像vs的视图吧，这些对话框不会直接影响主窗口的就适用于非模态</strong></p><hr><h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><p>按钮的创建，从图形化角度，直接拖动控件是最直接的，拖动完成后保存，然后双击这个按钮直接会跳转到代码界面，你就可以编辑这个按钮消息能干什么了。</p><img src="/2022/07/25/mfc01/051.png" class=""><p>新建一个按钮，修改一下描述文字和id，然后双击开始编辑</p><pre><code class="cpp">void CBingDialog::OnBnClickedButtonTest() &#123;    // TODO: 在此添加控件通知处理程序代码    TRACE(&quot;%s(%d):%s\n&quot;, __FILE__, __LINE__, __FUNCTION__);&#125;</code></pre><p>老样子在日志里输出文件路径，行号，函数名。</p><img src="/2022/07/25/mfc01/052.png" class=""><p>这玩意肯定是不会有啥问题了。</p><img src="/2022/07/25/mfc01/053.png" class=""><p>至于动态布局，就是比例放大或者缩小的适合这个按钮的位置会自动调整，不设置的话窗口放大或者缩小它的位置都不会改变。</p><p>其它的一些行为都有中文描述可以自己试一下。</p><p>然后就是通过按钮去创建自定义按钮，本质上就是手动整活了。</p><pre><code class="cpp">protected:    CButton m_Btn;        //自定义按钮</code></pre><p>在头文件中肯定要预先定义这个空的按钮。</p><pre><code class="cpp">void CBingDialog::OnBnClickedButtonTest() &#123;    // TODO: 在此添加控件通知处理程序代码    TRACE(&quot;%s(%d):%s\n&quot;, __FILE__, __LINE__, __FUNCTION__);    if ( m_Btn.m_hWnd == NULL ) &#123;        m_Btn.Create(_T(&quot;动态&quot;), BS_DEFPUSHBUTTON | WS_VISIBLE | WS_CHILD, CRect(100, 100, 200, 150), this, 9999);    &#125;&#125;</code></pre><p><code>BS_DEFPUSHBUTTON | WS_VISIBLE | WS_CHILD</code><br>BS开头就是button style，按钮自带的样式，WS就是 windows style，译为windows系统的样式，具体种类可以转到定义，有不少这样的类型。</p><p><strong>注意下最后的id，不要通过变量传递去改变，一定要固定为主，避免冲突或者广播，因为id重了，获取消息的时候就可能一起接收或者发送</strong></p><img src="/2022/07/25/mfc01/054.png" class=""><p>跑起来之后，点击test_button之后就会弹出这个动态的按钮，看上去可能有点潦草，毕竟是随便建的。</p><blockquote><p>如果采用全局变量dlg是在源文件的要注意一下<br>可能存在窗口创建多次报错</p></blockquote><pre><code class="cpp">void CMFCApplication1Dlg::OnBnClickedOk() &#123;    if ( dlg.m_hWnd == NULL ) &#123;        dlg.Create(IDD_DIALOG_NEW, this);    &#125;    dlg.ShowWindow(SW_SHOW);&#125;</code></pre><p>给他加个验证以防万一</p><p><strong>动态按钮的创建，还是随着用户改变为主，一般用的少</strong><br>不过没启用之前也不占资源倒是一件好事，顶多留个指针。</p><hr><h2 id="控件"><a href="#控件" class="headerlink" title="控件"></a>控件</h2><p>正常情况下，我们知道访问这个控件，比如按钮，肯定是在当前窗口访问最直接也不需要额外操作，但是别的窗口如果要访问，就是另一回事了。</p><img src="/2022/07/25/mfc01/055.png" class=""><p>首先给这个对话框里面添加三个文本框，默认是空的，通过别的地方传递给这个文本框一个初始值。</p><p>在自定义的对话框初始化一个文本框之前需要注意，我们自定义的他少一个标准的函数<code>OnInitDialog()</code>作为初始化用</p><p>打开类视图-&gt;找到这个项目选择CBingDialog-&gt;然后属性那边有个重写往下滑找到<code>OnInitDialog()</code>点击后面add即可。</p><pre><code class="cpp">BOOL CBingDialog::OnInitDialog() &#123;    CDialogEx::OnInitDialog();    // TODO:  在此添加额外的初始化    return TRUE;  // return TRUE unless you set the focus to a control                  // 异常: OCX 属性页应返回 FALSE&#125;</code></pre><hr><h3 id="访问文本框"><a href="#访问文本框" class="headerlink" title="访问文本框"></a>访问文本框</h3><p>通过父类CWnd，我们可以直接在对话框初始化这些文本框</p><pre><code class="cpp">BOOL CBingDialog::OnInitDialog() &#123;    CDialogEx::OnInitDialog();    // TODO:  在此添加额外的初始化    CWnd *pEdit01 = GetDlgItem(IDC_EDIT_ONE);    CWnd *pEdit02 = GetDlgItem(IDC_EDIT_TWO);    CWnd *pEdit03 = GetDlgItem(IDC_EDIT_THREE);    if ( pEdit01 != NULL ) pEdit01-&gt;SetWindowText(_T(&quot;100&quot;));    if ( pEdit02 != NULL ) pEdit02-&gt;SetWindowText(_T(&quot;200&quot;));    if ( pEdit03 != NULL ) pEdit03-&gt;SetWindowText(_T(&quot;300&quot;));    return TRUE;  // return TRUE unless you set the focus to a control                  // 异常: OCX 属性页应返回 FALSE&#125;</code></pre><img src="/2022/07/25/mfc01/056.png" class=""><p>这个setwindowstext不仅能设置，还能取出值，类型应是Cstring</p><pre><code class="cpp">CString setText;pEdit01-&gt;SetWindowText(strText);</code></pre><p>用父类的CWnd去接收可能有点麻烦，但是至少能判断是否获取成功了<br>因为还有一种直接的方式</p><pre><code class="cpp">SetDlgItemText(IDC_EDIT_ONE, _T(&quot;100&quot;));GetDlgItemText(IDC_EDIT_ONE, strText);</code></pre><p>这种方式呢，主要是产生错误的时候你也不晓得是前者不存在，还是后者溢出。</p><p>还有一种是针对无符号整型的</p><pre><code class="cpp">SetDlgItemInt(IDC_EDIT_THREE, 300);BOOL isTrans = FALSE;UINT ret = GetDlgItemINt(IDC_EDIT_THREE, &amp;isTrans);</code></pre><p>加这个布尔值的意思是，如果传输成功，这个布尔值就会变成TRUE，那么ret的值自然就是300，到不太在意ret了，如果还是FALSE，则说明传递失败了。</p><hr><h3 id="添加变量"><a href="#添加变量" class="headerlink" title="添加变量"></a>添加变量</h3><p>先去Diglog页面，选中文本框右击，添加变量打开即可。</p><img src="/2022/07/25/mfc01/057.png" class=""><p>选择类别，一种是值一种是控件，这边现用值，名称看着来。<br>选择类别为值后，变量的类型也需要确定，默认来说字符串Cstring更合适，这边先用int玩，注释就更不用说了。</p><img src="/2022/07/25/mfc01/058.png" class=""><p>选择int这种值类型，在其他这里就会有最小值和最大值的分别。最大字符数是给字符串类型用的，至于下面的文件倒不用特意选了，毕竟这个添加变量是在CBingDialog下添加的，默认就在这里。</p><pre><code class="cpp">#pragma once#include &quot;afxdialogex.h&quot;// CBingDialog 对话框class CBingDialog : public CDialogEx&#123;    DECLARE_DYNAMIC(CBingDialog)public:    CBingDialog(CWnd* pParent = nullptr);   // 标准构造函数    virtual ~CBingDialog();// 对话框数据#ifdef AFX_DESIGN_TIME    enum &#123; IDD = IDD_DIALOG_NEW &#125;;#endifprotected:    CButton m_Btn;        //自定义按钮protected:    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持    DECLARE_MESSAGE_MAP()public:    afx_msg void OnBnClickedButtonTest();    virtual BOOL OnInitDialog();    // 文本框1的值    int m_Value1;&#125;;</code></pre><p>能看到下面有个注释，然后是我们新增的变量。<br>在源文件中同样有初始化的地方</p><pre><code class="cpp">void CBingDialog::DoDataExchange(CDataExchange* pDX) &#123;    CDialogEx::DoDataExchange(pDX);    DDX_Text(pDX, IDC_EDIT_ONE, m_Value1);    DDV_MinMaxInt(pDX, m_Value1, -9999, 9999);&#125;</code></pre><p>别的不说，这个绑定在文本框的id和名称，还有下面的最大值最小值肯定看得出来。</p><p><strong>那么肯定会好奇绑定这个值类型的变量有什么用？</strong></p><p>给另外两个文本框都添加变量<br>然后给确定按钮写代码</p><pre><code class="cpp">void CBingDialog::OnBnClickedOk() &#123;    // TODO: 在此添加控件通知处理程序代码    UpdateData();                    //无参数默认为TRUE，此时把界面的值传到变量    m_Value3 = m_Value1 + m_Value2;    UpdateData(FALSE);                //为FALASE时，把值传回到界面    //CDialogEx::OnOK();&#125;</code></pre><p>就是按下之后，文本框三的内容是1+2的就对了。<br>这里随便修改一下文本框2的内容，然后再按下确认，能看到文本框3的内容改变了</p><img src="/2022/07/25/mfc01/059.png" class=""><hr><h3 id="添加控件"><a href="#添加控件" class="headerlink" title="添加控件"></a>添加控件</h3><p>方法一致，在Dialog视图中右击文本框添加变量，只不过类型改成控件<br>当三个都添加完成之后编写代码</p><pre><code class="cpp">void CBingDialog::OnBnClickedOk() &#123;    // TODO: 在此添加控件通知处理程序代码    CString str1, str2, str3;    m_Edit1.GetWindowText(str1);    m_Edit2.GetWindowText(str2);    int t = _wtoi(str1) + _wtoi(str2);    TCHAR buf[32] = _T(&quot;&quot;);    _itow_s(t, buf, 10);    str3 = buf;    m_Edit3.SetWindowText(str3);    //CDialogEx::OnOK();&#125;</code></pre><p>控件创建的时候变量类型是CEdit，那么推测也是跟字符串有关的，所以在做加法之前先完成一个转换。<br>最后得到的结果也是成功的</p><img src="/2022/07/25/mfc01/060.png" class=""><p>虽然肯能不是很实用，但是总归是个小技巧</p><hr><h3 id="SendMessage"><a href="#SendMessage" class="headerlink" title="SendMessage"></a>SendMessage</h3><pre><code class="cpp">SendMessage(WM_GETTEXT);SendMessage(WM_SETTEXT);</code></pre><p>不过这俩在函数内部，其实也不知道发给谁，顶多是传给往上一层的。</p><pre><code class="cpp">void CBingDialog::OnBnClickedButtonTest() &#123;    // TODO: 在此添加控件通知处理程序代码    TRACE(&quot;%s(%d):%s\n&quot;, __FILE__, __LINE__, __FUNCTION__);    if ( m_Btn.m_hWnd == NULL ) &#123;        m_Btn.Create(_T(&quot;动态&quot;), BS_DEFPUSHBUTTON | WS_VISIBLE | WS_CHILD, CRect(100, 100, 200, 150), this, 9999);    &#125;    TCHAR buf[20] = _T(&quot;&quot;);    ::SendMessage(m_Edit1.m_hWnd, WM_GETTEXT, 20, (LPARAM)buf);    m_Edit1.SendMessage(WM_SETTEXT, sizeof(buf), (LPARAM)buf);    SendMessage(WM_GETTEXT, 20, (LPARAM)buf);&#125;</code></pre><p>老实说这后面的在干什么我也看不懂了。<br>不过打断点调试之后，看到buf的值是取了这个窗口的标题</p><img src="/2022/07/25/mfc01/061.png" class=""><p>不过按照推理<code>m_Edit1.m_hWnd</code>这个应该是通过控件获取到这个当前窗口句柄了，然后get句柄的Text属性到buf上，之所以能找到这个窗口句柄感觉还是因为<code>::</code>全局作用域的关系，然后后面这个文本框发送消息到buf上这个说法上不太通顺，因为用文本框发送消息和按钮按下后发送消息，buf理论都一样了吧，毕竟是从窗口句柄取值的。</p><p><strong>打个？后面碰到了在细究</strong></p><hr><h2 id="对话框伸缩"><a href="#对话框伸缩" class="headerlink" title="对话框伸缩"></a>对话框伸缩</h2><p>其实窗口是有自带的缩放，但是这里先自定义两个按钮去实现</p><img src="/2022/07/25/mfc01/062.png" class=""><p>控件拖动完毕后，修改一下id，然后双击按钮跳到代码编辑部分。</p><p>放大还是缩小总归是要知道窗口的大小先</p><p>现在头文件里预定一大一小</p><pre><code class="cpp">//窗口大小CRect m_large;CRect m_small;</code></pre><p><strong>注：CRect有四个成员分别是left,top这二者代表矩形左上角顶点坐标，right，bottom代表矩形右下角的坐标，草图如下：</strong></p><img src="/2022/07/25/mfc01/068.png" class=""><p>然后在源文件的<code>OnInitDialog()</code>初始化一下</p><pre><code class="cpp">GetWindowRect(m_large);m_small = m_large;m_small.right = m_small.left + m_small.Width() / 2;m_small.bottom = m_small.top + m_small.Height() / 2;</code></pre><p>最后给放大缩小实现一下</p><pre><code class="cpp">void CBingDialog::OnBnClickedBtnLarge() &#123;    // TODO: 在此添加控件通知处理程序代码    CRect curRect;        //获取当前窗口尺寸信息    GetWindowRect(curRect);    SetWindowPos(NULL, curRect.left, curRect.top,                 m_large.Width(), m_large.Height(),                 SWP_NOMOVE | SWP_NOZORDER    );&#125;void CBingDialog::OnBnClickedBtnSmall() &#123;    // TODO: 在此添加控件通知处理程序代码    CRect curRect;    GetWindowRect(curRect);    SetWindowPos(NULL, curRect.left, curRect.top,                 m_small.Width(), m_small.Height(),                 SWP_NOMOVE | SWP_NOZORDER    );&#125;</code></pre><p><strong>SWP_NOZORDER：忽略第一个参数；SWP_NOMOVE：忽略x、y，维持位置不变</strong></p><p>curRect都是为了先获取当前窗口尺寸<br>所以当setwindowpos的时候，xy不需要改变，cx和cy则是用m_large和m_small改变。<br>不过因为m_large初始化的时候是直接根据当前窗口大小来的，所以一开始点击放大是没有反应的，当缩小了之后在点击放大才会改变回原有尺寸</p><img src="/2022/07/25/mfc01/063.png" class=""><p>这里调整了一下俩按钮的位置，因为没有加滑动条，所以缩小了原有位置就够不到了。</p><img src="/2022/07/25/mfc01/064.png" class=""><p>不过可以看出上述按钮实现雷同点比较多。<br>那么就有一个骚操作，就是通过获取按钮标签名去改变</p><pre><code class="cpp">void CBingDialog::OnBnClickedBtnLarge() &#123;    // TODO: 在此添加控件通知处理程序代码    CRect curRect;        //获取当前窗口尺寸信息    GetWindowRect(curRect);    CWnd *pButton = GetDlgItem(IDC_BTN_LARGE);    CString strTitle;    if ( pButton ) &#123;        pButton-&gt;GetWindowText(strTitle);        if ( strTitle == _T(&quot;放大&quot;) ) &#123;            pButton-&gt;SetWindowText(_T(&quot;缩小&quot;));            SetWindowPos(NULL, curRect.left, curRect.top,                 m_large.Width(), m_large.Height(),                 SWP_NOMOVE | SWP_NOZORDER            );        &#125; else &#123;            pButton-&gt;SetWindowText(_T(&quot;放大&quot;));            SetWindowPos(NULL, curRect.left, curRect.top,                m_small.Width(), m_small.Height(),                SWP_NOMOVE | SWP_NOZORDER            );        &#125;    &#125;&#125;</code></pre><img src="/2022/07/25/mfc01/065.png" class=""><img src="/2022/07/25/mfc01/066.png" class=""><img src="/2022/07/25/mfc01/067.png" class=""><p>先点击放大，发现按钮名变成缩小了，然后再次点击，窗口缩小，按钮名称变成放大，再点击就放大了，按钮名称就变成缩小。</p><p>所以另一个按钮就没有存在的必要了，把这个放大按钮的名称改成缩小，这样一来开头的光变名字就可以省去了。</p><p>最后做一个安全的设计</p><pre><code class="cpp">void CBingDialog::OnBnClickedBtnLarge() &#123;    // TODO: 在此添加控件通知处理程序代码    CRect curRect;        //获取当前窗口尺寸信息    GetWindowRect(curRect);    CWnd *pButton = GetDlgItem(IDC_BTN_LARGE);    CString strTitle;    if ( pButton ) &#123;        pButton-&gt;GetWindowText(strTitle);        if ( strTitle == _T(&quot;放大&quot;) &amp;&amp; (m_large.IsRectEmpty() == FALSE) ) &#123;            pButton-&gt;SetWindowText(_T(&quot;缩小&quot;));            SetWindowPos(NULL, curRect.left, curRect.top,                 m_large.Width(), m_large.Height(),                 SWP_NOMOVE | SWP_NOZORDER            );        &#125; else if ( m_large.IsRectEmpty() == FALSE ) &#123;            pButton-&gt;SetWindowText(_T(&quot;放大&quot;));            SetWindowPos(NULL, curRect.left, curRect.top,                m_small.Width(), m_small.Height(),                SWP_NOMOVE | SWP_NOZORDER            );        &#125;    &#125;&#125;</code></pre><p><code>IsRectEmpty()</code>主要是为了判断这个窗口如果left、top、right、bottom都一样的话，说明这个窗口就只有一个点，并没有办法完成缩放和放大了。</p><blockquote><p>窗口其实除了大小，就是绘制的位置，有的时候不是在当前窗口之上绘制，就有可能掉下去一层跟后面的窗口平级，至于窗口为什么能叠加，应该是除了xy，还有一个z轴，是3d模型的经典概念。</p></blockquote><hr><h2 id="常用控件"><a href="#常用控件" class="headerlink" title="常用控件"></a>常用控件</h2><p>空间交互，首先要创建控件或者说拖个出来，交互，就需要绑定控件或者变量，在消息中有来有回实现一些功能。</p><p>例如上述所学到的函数<code>GetDlgItem</code>，他就可以通过控件id获取到对应的控件<br><code>CListBox *list  = (CListBox*)GetDlgItem(控件id)</code></p><p>绑定控件和变量，在消息中曾使用到<code>UpdateData(TRUE|FALSE)</code>，默认不填写为TRUE，也就是将控件内容第一时间同步到变量上，FALSE则是将变量同步回控件</p><hr><h3 id="Radio"><a href="#Radio" class="headerlink" title="Radio"></a>Radio</h3><p>随便建个mfc项目，选择对话框类型，有的没的取消勾选</p><img src="/2022/07/25/mfc01/069.png" class=""><p>然后绘制这样的窗口，其中radio和check按钮，最后一个button</p><p>性别直接添加一个变量就可以了，原本想着用bool类型，但是考虑到得有个初始值，其实这个初始化关系到也不是特别大，但此处就换个万一弄弄，用int来表示，那么就需要注意了，你需要修改初始化部分</p><pre><code class="cpp">CMFCButtonDlg::CMFCButtonDlg(CWnd* pParent /*=nullptr*/)    : CDialogEx(IDD_MFCBUTTON_DIALOG, pParent)    , m_sex(-1)&#123;    m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME);&#125;</code></pre><p>m_sex为我们添加的变量名，括号代表初始化值，默认是0，但这里的思路是-1为未初始化，0为男 1为女这样。</p><p>如此一来，结果那个按钮第一步就可以上手了</p><pre><code class="cpp">void CMFCButtonDlg::OnBnClickedBtnResult()&#123;    // TODO: 在此添加控件通知处理程序代码    UpdateData();    if( m_sex == -1 )&#123;        MessageBox(_T(&quot;请选择性别&quot;), _T(&quot;性别缺失&quot;), MB_OK | MB_ICONEXCLAMATION);        return;    &#125;&#125;</code></pre><p><strong>_T只是为了兼容unicode，在你的项目编码是ANSI的时候下次转换能保证字符串不出错，其次还有一个_L，它是不管编译方式都按unicode保存</strong></p><p><strong>万国码通用保存2两字节，ANSI英文一字节汉语两字节，再次强调</strong></p><p><code>MB_ICONEXCLAMATION</code>是一个警告图标，不同于<code>SWP_NOZORDER</code>，前者为黄色感叹号，后者为红色x号。</p><p>然后打印，肯定就要用CString了。</p><pre><code class="cpp">void CMFCButtonDlg::OnBnClickedBtnResult()&#123;    // TODO: 在此添加控件通知处理程序代码    UpdateData();    if( m_sex == -1 )&#123;        MessageBox(_T(&quot;请选择性别&quot;), _T(&quot;性别缺失&quot;), MB_OK | MB_ICONEXCLAMATION);        return;    &#125;    CString strMsg = _T(&quot;您的性别是：&quot;) + (m_sex == 0) ? _T(&quot;男\n&quot;) : _T(&quot;女\n&quot;);    MessageBox(strMsg);&#125;</code></pre><p>run的时候会发现</p><img src="/2022/07/25/mfc01/070.png" class=""><p>额前面那句好像没有加上，原因应该是Cstring没有重写string+string吧</p><pre><code class="cpp">void CMFCButtonDlg::OnBnClickedBtnResult()&#123;    // TODO: 在此添加控件通知处理程序代码    UpdateData();    if( m_sex == -1 )&#123;        MessageBox(_T(&quot;请选择性别&quot;), _T(&quot;性别缺失&quot;), MB_OK | MB_ICONEXCLAMATION);        return;    &#125;    CString strMsg = CString(_T(&quot;您的性别是：&quot;)) + ((m_sex == 0) ? _T(&quot;男\n&quot;) : _T(&quot;女\n&quot;));    MessageBox(strMsg, _T(&quot;tips&quot;));&#125;</code></pre><p>修改之后：</p><img src="/2022/07/25/mfc01/071.png" class=""><p>对于多选框，类型一般还是bool比较合适，但是默认的添加变量都是单个类型，所以我们在自动的基础上，给他改成数组</p><pre><code class="cpp">// 爱好BOOL m_hobby[3];</code></pre><p>那么在源文件就要注意：</p><pre><code class="cpp">CMFCButtonDlg::CMFCButtonDlg(CWnd* pParent /*=nullptr*/)    : CDialogEx(IDD_MFCBUTTON_DIALOG, pParent)    , m_sex(-1) &#123;    memset(m_hobby, 0, sizeof(m_hobby));    m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME);&#125;void CMFCButtonDlg::DoDataExchange(CDataExchange* pDX)&#123;    CDialogEx::DoDataExchange(pDX);    DDX_Radio(pDX, IDC_RAD_MAN, m_sex);    DDX_Check(pDX, IDC_CK_FB, m_hobby[0]);    DDX_Check(pDX, IDC_CK_BKB, m_hobby[1]);    DDX_Check(pDX, IDC_CK_YOGA, m_hobby[2]);&#125;</code></pre><p>手动修改成数组</p><p>最后完善一下结果消息</p><pre><code class="cpp">void CMFCButtonDlg::OnBnClickedBtnResult()&#123;    // TODO: 在此添加控件通知处理程序代码    UpdateData();    if( m_sex == -1 )&#123;        MessageBox(_T(&quot;请选择性别&quot;), _T(&quot;性别缺失&quot;), MB_OK | MB_ICONEXCLAMATION);        return;    &#125;    CString strMsg = CString(_T(&quot;您的性别是：&quot;)) + ((m_sex == 0) ? _T(&quot;男\n&quot;) : _T(&quot;女\n&quot;));    strMsg += _T(&quot;你的爱好有：&quot;);    CString hobby[3]&#123; _T(&quot;足球&quot;),_T(&quot;篮球&quot;),_T(&quot;瑜伽&quot;) &#125;;    for( int i = 0; i &lt; 3; i++ )&#123;        if( m_hobby[i] )&#123;            strMsg += hobby[i] + _T(&quot; &quot;);        &#125;    &#125;    MessageBox(strMsg, _T(&quot;tips&quot;));&#125;</code></pre><img src="/2022/07/25/mfc01/072.png" class=""><p>就ok了，这两个按钮的应用还算基础的。</p><p>当然自己定义数组一个办法，也可以通过控件id，get他的name<br>至于说这个id该通过什么办法<br>比如项目头文件里面有个叫<code>Resource.h</code>的，打开之后会看到他宏定义了我们跟控件有关的</p><pre><code class="cpp">#define IDD_MFCBUTTON_DIALOG            102#define IDR_MAINFRAME                   128#define IDC_BUTTON1                     1000#define IDC_BTN_RESULT                  1000#define IDC_RAD_MAN                     1001#define IDC_RAD_WOMEN                   1002#define IDC_CK_FB                       1003#define IDC_CK_BKB                      1004#define IDC_CK_YOGA                     1005</code></pre><p>复选框就看后面仨，有了这个其实会容易很多，因为他们是连续的。</p><pre><code class="cpp">void CMFCButtonDlg::OnBnClickedBtnResult()&#123;    // TODO: 在此添加控件通知处理程序代码    UpdateData();    if( m_sex == -1 )&#123;        MessageBox(_T(&quot;请选择性别&quot;), _T(&quot;性别缺失&quot;), MB_OK | MB_ICONEXCLAMATION);        return;    &#125;    CString strMsg = CString(_T(&quot;您的性别是：&quot;)) + ((m_sex == 0) ? _T(&quot;男\n&quot;) : _T(&quot;女\n&quot;));    strMsg += _T(&quot;你的爱好有：&quot;);    //CString hobby[3]&#123; _T(&quot;足球&quot;),_T(&quot;篮球&quot;),_T(&quot;瑜伽&quot;) &#125;;    UINT nId = IDC_CK_FB;    for( int i = 0; i &lt; 3; i++ )&#123;        if( m_hobby[i] )&#123;            //strMsg += hobby[i] + _T(&quot; &quot;);            CString sName;            GetDlgItemText(nId + i, sName);            strMsg += sName;        &#125;    &#125;    MessageBox(strMsg, _T(&quot;tips&quot;));&#125;</code></pre><p>因为从足球开始，后面只需要+1就可以得到，倒是省了定义一个数组。</p><img src="/2022/07/25/mfc01/073.png" class=""><p><strong>但是这个是基于你这几个复选框是连续的，id才能跟的上，不然跟数组没啥太大差别</strong></p><hr><h3 id="EditControl"><a href="#EditControl" class="headerlink" title="EditControl"></a>EditControl</h3><p>工具箱里找</p><img src="/2022/07/25/mfc01/074.png" class=""><p>然后拖出来，稍微调整一下大小</p><img src="/2022/07/25/mfc01/075.png" class=""><p>对应的属性也有不少，好在2022都做成中文了</p><img src="/2022/07/25/mfc01/076.png" class=""><p>这玩意说实在没啥必要演示，自己试几下就行了，但是有个基础应用的地方到时跟上面能联动<br>就是将我们选完之后的内容打印在editcontrol中</p><pre><code class="cpp">void CMFCButtonDlg::OnBnClickedBtnResult()&#123;    // TODO: 在此添加控件通知处理程序代码    UpdateData();    if( m_sex == -1 )&#123;        MessageBox(_T(&quot;请选择性别&quot;), _T(&quot;性别缺失&quot;), MB_OK | MB_ICONEXCLAMATION);        return;    &#125;    CString strMsg = CString(_T(&quot;您的性别是：&quot;)) + ((m_sex == 0) ? _T(&quot;男\r\n&quot;) : _T(&quot;女\r\n&quot;));    strMsg += _T(&quot;你的爱好有：&quot;);    //CString hobby[3]&#123; _T(&quot;足球&quot;),_T(&quot;篮球&quot;),_T(&quot;瑜伽&quot;) &#125;;    UINT nId = IDC_CK_FB;    for( int i = 0; i &lt; 3; i++ )&#123;        if( m_hobby[i] )&#123;            //strMsg += hobby[i] + _T(&quot; &quot;);            CString sName;            GetDlgItemText(nId + i, sName);            strMsg += sName;        &#125;    &#125;    CEdit* edit = (CEdit*)GetDlgItem(IDC_EDIT1);    //edit-&gt;GetWindowTextW();    edit-&gt;SetWindowText(strMsg);        //设置文本    MessageBox(strMsg, _T(&quot;tips&quot;));&#125;</code></pre><p>其中要注意editcontrol属性要设置几个地方</p><ol><li>多行 true</li><li>想要返回 true</li><li>就是写入的strMsg想要换行，要在中间加<code>\r\n</code>，单纯的<code>\n</code>好像不起作用</li></ol><p>效果就是如下：</p><img src="/2022/07/25/mfc01/077.png" class=""><p>点击完成后往edit里面写入，和弹出对话框</p><img src="/2022/07/25/mfc01/078.png" class=""><hr><h3 id="ListBox"><a href="#ListBox" class="headerlink" title="ListBox"></a>ListBox</h3><p>老样子在dialog界面打开工具箱，找到listbox</p><img src="/2022/07/25/mfc01/079.png" class=""><p>然后属性都是中文名了，实在不行点击一下下面还有介绍，再不济就自己修改试试</p><img src="/2022/07/25/mfc01/080.png" class=""><p>随便搞个例子试试</p><img src="/2022/07/25/mfc01/082.png" class=""><p>先绘制这样的界面，然后就是往里面addsttring，最后根据选中的返回结果这样。</p><blockquote><p>别忘了给listbox添加变量</p></blockquote><p>双击test按钮</p><pre><code class="cpp">void CMFCButtonDlg::OnBnClickedBtnTest()&#123;    // TODO: 在此添加控件通知处理程序代码    CString strText;    if( m_conmpany.GetSelCount() == 0 )&#123;        MessageBox(_T(&quot;没有选中任何公司&quot;));        return;    &#125; else&#123;        int total = m_conmpany.GetSelCount();        int* index = new int[total];        strText += _T(&quot;您选中了&quot;);        TCHAR buf[32] = _T(&quot;&quot;);        _itow_s(total, buf, 32, 10);        strText += buf;        strText += _T(&quot;个公司\n&quot;);        m_conmpany.GetSelItems(total, index);        CString strTmp;        for( int i = 0; i &lt; total; i++ )&#123;            m_conmpany.GetText(index[i], strTmp);            strText += strTmp + _T(&quot; &quot;);        &#125;        delete[] index;        MessageBox(strText);    &#125;&#125;</code></pre><p><code>m_conmpany</code>为我们给listbox这个控件设置的变量。<br>首要判断就是是否选中，选中之后在循环接收。</p><p>别忘了在<code>oninitdialog</code>里面初始化一下这个listbox。</p><pre><code class="cpp">BOOL CMFCButtonDlg::OnInitDialog()&#123;    CDialogEx::OnInitDialog();    // 设置此对话框的图标。  当应用程序主窗口不是对话框时，框架将自动    //  执行此操作    SetIcon(m_hIcon, TRUE);            // 设置大图标    SetIcon(m_hIcon, FALSE);        // 设置小图标    // TODO: 在此添加额外的初始化代码    m_conmpany.AddString(_T(&quot;山东蓝翔&quot;));    m_conmpany.AddString(_T(&quot;深圳电子厂&quot;));    m_conmpany.AddString(_T(&quot;义乌商超&quot;));    return TRUE;  // 除非将焦点设置到控件，否则返回 TRUE&#125;</code></pre><img src="/2022/07/25/mfc01/081.png" class=""><p>效果也不难，就是一些常规操作。</p><hr><h3 id="Combox"><a href="#Combox" class="headerlink" title="Combox"></a>Combox</h3><img src="/2022/07/25/mfc01/083.png" class=""><img src="/2022/07/25/mfc01/084.png" class=""><p>拖出两个控件<br>数据在</p><img src="/2022/07/25/mfc01/085.png" class=""><p>依旧是用分号阻隔。</p><img src="/2022/07/25/mfc01/086.png" class=""><p>样式有三个，除了这个simple特殊一点，因为他不会显示箭头，你选中之后可以通过方向键控制。<br>或者它的神奇之处。。</p><img src="/2022/07/25/mfc01/087.png" class=""><p>你可以在dialog里从下面拉大这个combox，这样他在run的时候就能把在长度之内的列显示出来，虽然有点二。</p><p>当然这种测试都是取出值来玩玩</p><img src="/2022/07/25/mfc01/088.png" class=""><p>左边样式为simple，添加变量<br>右边样式为下拉列表，添加变量<br>然后拖一个按钮，测试用</p><pre><code class="cpp">void CMFCButtonDlg::OnBnClickedBtnDroplist()&#123;    // TODO: 在此添加控件通知处理程序代码    int cur = m_simple.GetCurSel();    if( cur == -1 )&#123;        TRACE(&quot;%s(%d):当前没有选中任何列\n&quot;, __FILE__, __LINE__);    &#125;else&#123;        TRACE(&quot;%s(%d):当前选中了第%d列\n&quot;, __FILE__, __LINE__, cur);        CString tmp;        m_simple.GetLBText(cur, tmp);        MessageBox(tmp);    &#125;&#125;</code></pre><p>也比较简单</p><img src="/2022/07/25/mfc01/089.png" class=""><p>我们选中哪个就messagebox弹出哪个，并且TRACE在日志打印，注意列之类的遵循从0开始计数。</p><p>那么还有一个下拉列表，直接套前面那个combox也无伤大雅</p><pre><code class="cpp">void CMFCButtonDlg::OnBnClickedBtnDroplist()&#123;    // TODO: 在此添加控件通知处理程序代码    int cur = m_simple.GetCurSel();    if( cur == -1 )&#123;        TRACE(&quot;%s(%d):当前没有选中任何列\n&quot;, __FILE__, __LINE__);    &#125;else&#123;        TRACE(&quot;%s(%d):当前选中了第%d列\n&quot;, __FILE__, __LINE__, cur);        CString tmp;        m_simple.GetLBText(cur, tmp);        MessageBox(tmp);    &#125;    cur = m_droplist.GetCurSel();    if( cur == -1 )&#123;        TRACE(&quot;%s(%d):当前没有选中任何列\n&quot;, __FILE__, __LINE__);    &#125; else&#123;        TRACE(&quot;%s(%d):当前选中了第%d列\n&quot;, __FILE__, __LINE__, cur);        CString tmp;        m_droplist.GetLBText(cur, tmp);        MessageBox(tmp);    &#125;&#125;</code></pre><img src="/2022/07/25/mfc01/090.png" class=""><p>能看到日志打印的时候，因为m_simple没有选中过，所以会打印未选中任何列，但是后者m_droplist有选中，就有回执信息。</p><blockquote><p>能get的东西挺多的，用到了翻翻文档就行</p></blockquote><hr><h3 id="Progress"><a href="#Progress" class="headerlink" title="Progress"></a>Progress</h3><p>Progress：进度条<br>一般是要配合定时器去用会好点。</p><img src="/2022/07/25/mfc01/091.png" class=""><p>当然这玩意在dialog界面看着有点效果，但实际你自己没写，他就是空的。</p><p>初始化：</p><pre><code class="cpp">BOOL CMFCButtonDlg::OnInitDialog()&#123;    CDialogEx::OnInitDialog();    // 设置此对话框的图标。  当应用程序主窗口不是对话框时，框架将自动    //  执行此操作    SetIcon(m_hIcon, TRUE);            // 设置大图标    SetIcon(m_hIcon, FALSE);        // 设置小图标    // TODO: 在此添加额外的初始化代码    m_conmpany.AddString(_T(&quot;山东蓝翔&quot;));    m_conmpany.AddString(_T(&quot;深圳电子厂&quot;));    m_conmpany.AddString(_T(&quot;义乌商超&quot;));    m_progress.SetRange(0, 1000);    return TRUE;  // 除非将焦点设置到控件，否则返回 TRUE&#125;</code></pre><p>当然有的时候虽然范围可能是整数，但是步长不一样。</p><p>给他加个按钮控制增长。<br><strong>注意改成竖状的时候需要修改进度条外观属性的垂直设置为True</strong></p><p>然后双击按钮</p><pre><code class="cpp">void CMFCButtonDlg::OnBnClickedBtnPrg()&#123;    // TODO: 在此添加控件通知处理程序代码    int pos = m_progress.GetPos();    m_progress.SetPos(pos + 100);&#125;</code></pre><p>获取初始的时候，然后每次增加100，反正上限1000，10次就到顶了</p><img src="/2022/07/25/mfc01/092.png" class=""><img src="/2022/07/25/mfc01/093.png" class=""><p>当然实际用途不会蠢蠢的给用户去点击，肯定是要与计时器绑定。<br>选中对话框找到消息里面的Timer</p><img src="/2022/07/25/mfc01/094.png" class=""><p>在头文件中应该预设一个进度值</p><pre><code class="cpp">//进度int m_progress_pos;</code></pre><pre><code class="cpp">BOOL CMFCButtonDlg::OnInitDialog()&#123;    CDialogEx::OnInitDialog();    // 设置此对话框的图标。  当应用程序主窗口不是对话框时，框架将自动    //  执行此操作    SetIcon(m_hIcon, TRUE);            // 设置大图标    SetIcon(m_hIcon, FALSE);        // 设置小图标    // TODO: 在此添加额外的初始化代码    m_conmpany.AddString(_T(&quot;山东蓝翔&quot;));    m_conmpany.AddString(_T(&quot;深圳电子厂&quot;));    m_conmpany.AddString(_T(&quot;义乌商超&quot;));    m_progress.SetRange(0, 1000);    m_progress_pos = 0;    // 定时器尽量不要低于30ms，不同机子有少许差别，源自mfc的精度不足导致定时器缺陷    SetTimer(99, 500, NULL);    SetTimer(10, 100, NULL);    return TRUE;  // 除非将焦点设置到控件，否则返回 TRUE&#125;</code></pre><p>初始化设置定时器的时候要注意，因为mfc分层，不同机子处理速度不同，所以定时器精度不要设置太小，以免出现误差。</p><pre><code class="cpp">void CMFCButtonDlg::OnTimer(UINT_PTR nIDEvent)&#123;    // TODO: 在此添加消息处理程序代码和/或调用默认值    static int count = 0;    if( nIDEvent == 99 )&#123;        m_progress.SetPos(m_progress_pos);    &#125; else if( nIDEvent == 10 )&#123;        TRACE(&quot;%s(%d):%s %d\n&quot;, __FILE__, __LINE__, __FUNCTION__, GetTickCount());        if( count &gt; 5 ) KillTimer(10);        count++;    &#125;    CDialogEx::OnTimer(nIDEvent);&#125;</code></pre><img src="/2022/07/25/mfc01/095.png" class=""><p>当我们的间隔设置在5，他的误差还在10左右，拉高之后</p><img src="/2022/07/25/mfc01/096.png" class=""><p><strong>反正就是突出mfc对于定时精度处理不足的问题</strong></p><p>那么接下来让他自己动~</p><pre><code class="cpp">void CMFCButtonDlg::OnTimer(UINT_PTR nIDEvent)&#123;    // TODO: 在此添加消息处理程序代码和/或调用默认值    static int count = 0;    if( nIDEvent == 99 )&#123;        m_progress.SetPos(m_progress_pos);    &#125; else if( nIDEvent == 10 )&#123;        TRACE(&quot;%s(%d):%s %d\n&quot;, __FILE__, __LINE__, __FUNCTION__, GetTickCount());        int low, upper;        m_progress.GetRange(low, upper);        if( m_progress_pos &gt;= upper )&#123;            KillTimer(10);        &#125; else&#123;            m_progress_pos += 10;        &#125;    &#125;    CDialogEx::OnTimer(nIDEvent);&#125;</code></pre><p>主要也就是获取这个进度的范围，没到头就慢慢网上递增，像复制文件的话，还得在里面计算文件复制到哪了，然后按比例递增效果更明显。</p><img src="/2022/07/25/mfc01/097.png" class=""><p>静态的图片看不出效果。</p><blockquote><p>这是演示从空到满的情况，相反的，进度的初始值要改成上限，然后这里改成-&#x3D;10<br>理论就是如此，实现另说</p></blockquote><p><strong>哈哈，关于这个进度条，千万不要用多个线程去玩。。不然效果很出奇玩自己了属于是</strong></p><hr><h3 id="图片资源"><a href="#图片资源" class="headerlink" title="图片资源"></a>图片资源</h3><p>也是拖出一个picture control。</p><img src="/2022/07/25/mfc01/098.png" class=""><p>有意思的是命名直接是static，和之前的静态文本框有点相似</p><img src="/2022/07/25/mfc01/099.png" class=""><p>拖个静态文本框可以看到有点相同</p><img src="/2022/07/25/mfc01/100.png" class=""><p>反正父类总有一个是一样的。</p><p>控制这些玩意就老样子添加变量&#x2F;控件，添加完之后自然没啥效果。。都没把图片塞进去</p><p>点击dialog，从消息里面找到</p><img src="/2022/07/25/mfc01/101.png" class=""><p>file就是跟文件相关的。</p><pre><code class="cpp">void CMFCButtonDlg::OnDropFiles(HDROP hDropInfo)&#123;    // TODO: 在此添加消息处理程序代码和/或调用默认值    int count = DragQueryFile(hDropInfo, -1, NULL, 0);    //count &gt; 1 Msg..    TCHAR sPath[MAX_PATH];    char mbsPath[MAX_PATH * 2];    for( int i = 0; i &lt; count; i++ )&#123;        memset(sPath, 0, sizeof(sPath));        memset(mbsPath, 0, sizeof(mbsPath));        DragQueryFile(hDropInfo, i, sPath, MAX_PATH);        size_t total = 0;        wcstombs_s(&amp;total, mbsPath, sizeof(mbsPath), sPath, MAX_PATH);        TRACE(&quot;%s(%d):%s %s\n&quot;, __FILE__, __LINE__, __FUNCTION__, mbsPath);        if( CString(sPath).Find(_T(&quot;.ico&quot;)) )&#123;            HICON hicon = (HICON)LoadImage(AfxGetInstanceHandle(), sPath, IMAGE_ICON, 0, 0, LR_LOADFROMFILE | LR_DEFAULTSIZE);            m_pictrue.SetIcon(hicon);        &#125;    &#125;    InvalidateRect(NULL);    CDialogEx::OnDropFiles(hDropInfo);&#125;</code></pre><p>写完之后有一个地方需要注意，因为这个用的图片类型是<code>.ico</code>想直接用mfc那个图片了，所以要修改图片框的类型</p><img src="/2022/07/25/mfc01/102.png" class=""><p>将其修改完之后</p><img src="/2022/07/25/mfc01/103.png" class=""><p>看到样式发生了变化，有点小</p><p>右击打开项目的路径，找到res文件夹，里面就有个mfc的ico</p><img src="/2022/07/25/mfc01/104.png" class=""><p>刚开始运行的时候，是看不到图片框的</p><img src="/2022/07/25/mfc01/105.png" class=""><p>这里忘了一个事，就是设置对话框可接受文件</p><img src="/2022/07/25/mfc01/107.png" class=""><p>不设置为true的话，图片拖动是禁止的。</p><p>设置true之后拖动图片到对话框上，发现的确显示了。</p><img src="/2022/07/25/mfc01/106.png" class=""><p>并且，日志也输出了这个图片的路径</p><img src="/2022/07/25/mfc01/108.png" class=""><hr><h3 id="List-Control"><a href="#List-Control" class="headerlink" title="List Control"></a>List Control</h3><img src="/2022/07/25/mfc01/109.png" class=""><p>长的吧跟列表又有点相似。倒是多了图标</p><img src="/2022/07/25/mfc01/110.png" class=""><p>其中有几种可选，默认为icon样式</p><p>在list视图下就真的跟列表一样了。</p><img src="/2022/07/25/mfc01/111.png" class=""><p>report视图感觉会用的多一点</p><img src="/2022/07/25/mfc01/112.png" class=""><p>这里先用report，为这个控件添加变量，然后初始化一下</p><pre><code class="cpp">BOOL CMFCButtonDlg::OnInitDialog()&#123;    CDialogEx::OnInitDialog();    // 设置此对话框的图标。  当应用程序主窗口不是对话框时，框架将自动    //  执行此操作    SetIcon(m_hIcon, TRUE);            // 设置大图标    SetIcon(m_hIcon, FALSE);        // 设置小图标    // TODO: 在此添加额外的初始化代码    m_conmpany.AddString(_T(&quot;山东蓝翔&quot;));    m_conmpany.AddString(_T(&quot;深圳电子厂&quot;));    m_conmpany.AddString(_T(&quot;义乌商超&quot;));    m_progress.SetRange(0, 1000);    m_progress_pos = 0;    //定时器尽量不要低于30ms，不同机子有少许差别，源自mfc的精度不足导致定时器缺陷    SetTimer(99, 500, NULL);    SetTimer(10, 100, NULL);    //初始化列    m_list.InsertColumn(0, _T(&quot;序号&quot;));    m_list.InsertColumn(1, _T(&quot;IP&quot;));    m_list.InsertColumn(2, _T(&quot;ID&quot;));    m_list.InsertColumn(3, _T(&quot;CHECK&quot;));    return TRUE;  // 除非将焦点设置到控件，否则返回 TRUE&#125;</code></pre><img src="/2022/07/25/mfc01/113.png" class=""><p>设置文字是没啥问题了，但是一开始他都是缩在一团还要拉开太麻烦了。</p><pre><code class="cpp">m_list.InsertColumn(0, _T(&quot;序号&quot;), LVCFMT_LEFT, 50);m_list.InsertColumn(1, _T(&quot;IP&quot;), LVCFMT_LEFT, 200);m_list.InsertColumn(2, _T(&quot;ID&quot;), LVCFMT_LEFT, 180);m_list.InsertColumn(3, _T(&quot;CHECK&quot;), LVCFMT_LEFT, 200);</code></pre><p>修改完之后，其实还要调整一下list control在对话框里面的大小</p><img src="/2022/07/25/mfc01/114.png" class=""><p>目前来说调整成这样差不多。再不济，空间有限的情况下，给他上滚动条</p><p>除此之外也可以用代码实现改变style，同样在初始化的地方</p><pre><code class="cpp">DWORD extStyle = m_list.GetExtendedStyle();extStyle |= LVS_EX_FULLROWSELECT;extStyle |= LVS_EX_GRIDLINES;m_list.SetExtendedStyle(extStyle);</code></pre><img src="/2022/07/25/mfc01/115.png" class=""><p>多了点格子，目前还没有数据</p><pre><code class="cpp">//列增加数据m_list.InsertItem(0, CString(&quot;0&quot;));m_list.SetItemText(0, 1, _T(&quot;192.168.0.1&quot;));m_list.SetItemText(0, 2, _T(&quot;6648964896486480&quot;));m_list.SetItemText(0, 3, _T(&quot;999&quot;));</code></pre><img src="/2022/07/25/mfc01/116.png" class=""><p>虽然能设置，但是总归是麻烦了一点。</p><p>另外背景颜色。。额没这个本事，用参数调得不得行</p><pre><code class="cpp">m_list.SetBkColor(RGB(64, 255, 128));</code></pre><img src="/2022/07/25/mfc01/117.png" class=""><p>哈哈哈瞎调的，辣眼睛还是注释了先。</p><p>列表比较实用的也可以像多选那样，在初始化的地方给list加个样式</p><pre><code class="cpp">extStyle |= LVS_EX_CHECKBOXES;</code></pre><img src="/2022/07/25/mfc01/118.png" class=""><p>可以看到多了多选框</p><p>那么首先要拖个按钮测试选中之后拉取数据</p><pre><code class="cpp">void CMFCButtonDlg::OnBnClickedBtnList()&#123;    // TODO: 在此添加控件通知处理程序代码    int lineCount = m_list.GetItemCount();    CHeaderCtrl* pHeader = m_list.GetHeaderCtrl();    int coloumnCount = pHeader-&gt;GetItemCount();    for (int i = 0; i &lt; lineCount; i++) &#123;        for (int j = 0; j &lt; coloumnCount; j++) &#123;            CString temp = m_list.GetItemText(i, j);            char Text[MAX_PATH];            memset(Text, 0, sizeof(Text));            size_t total;            wcstombs_s(&amp;total, Text, sizeof(Text), temp, temp.GetLength());            TRACE(&quot;%s(%d): %s %s\n&quot;, __FILE__, __LINE__, __FUNCTION__, Text);        &#125;    &#125;&#125;</code></pre><img src="/2022/07/25/mfc01/119.png" class=""><p>可以看到日志输出了我们所选的行的数据。</p><p>如何把多选框和数据关联<br>显然就是判断</p><pre><code class="cpp">void CMFCButtonDlg::OnBnClickedBtnList()&#123;    // TODO: 在此添加控件通知处理程序代码    int lineCount = m_list.GetItemCount();    CHeaderCtrl* pHeader = m_list.GetHeaderCtrl();    int coloumnCount = pHeader-&gt;GetItemCount();    for (int i = 0; i &lt; lineCount; i++) &#123;        if (m_list.GetCheck(i)) &#123;            TRACE(&quot;%s(%d): %s %s\n&quot;, __FILE__, __LINE__, __FUNCTION__, &quot;选中&quot;);        &#125; else &#123;            TRACE(&quot;%s(%d): %s %s\n&quot;, __FILE__, __LINE__, __FUNCTION__, &quot;未选中&quot;);        &#125;        for (int j = 0; j &lt; coloumnCount; j++) &#123;            CString temp = m_list.GetItemText(i, j);            char Text[MAX_PATH];            memset(Text, 0, sizeof(Text));            size_t total;            wcstombs_s(&amp;total, Text, sizeof(Text), temp, temp.GetLength());            TRACE(&quot;%s(%d): %s %s\n&quot;, __FILE__, __LINE__, __FUNCTION__, Text);        &#125;    &#125;&#125;</code></pre><img src="/2022/07/25/mfc01/120.png" class=""><p>虽然有点简陋。</p><p>关于list的style <code>LVS_EX_</code>还有很多不怎么用的，不过一般也是重写<br>还有些set的方法可以搜一搜看看。</p><hr><h3 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h3><img src="/2022/07/25/mfc01/121.png" class=""><p>拖个tree control出来，然后添加个变量<br>且预览效果跟这样差不多，那我们肯定要自己初始化他</p><pre><code class="cpp">//TreeHTREEITEM hRoot = m_tree.InsertItem(_T(&quot;root&quot;));HTREEITEM hLeaf1 = m_tree.InsertItem(_T(&quot;leaf&quot;), hRoot);m_tree.InsertItem(_T(&quot;sub&quot;), hLeaf1);HTREEITEM hLeaf2 = m_tree.InsertItem(_T(&quot;leaf&quot;), hRoot);m_tree.InsertItem(_T(&quot;sub&quot;), hLeaf2);</code></pre><p>根 叶 子叶</p><img src="/2022/07/25/mfc01/122.png" class=""><p>这是全部展开的样子，默认只有root，双击之后一个个展开。光秃秃的很潦草。</p><p>图标自己画问题不大，右击项目打开所在路径，找到res文件夹，在里面添加个位图</p><img src="/2022/07/25/mfc01/123.png" class=""><p>这是画完的样子。<br>然后导入资源。</p><p><strong>搞这种位图呢，主要是应对需要挺多logo之类简单的图片，文件太散找的麻烦，在一张上做分界标记会更好</strong></p><img src="/2022/07/25/mfc01/124.png" class=""><pre><code class="cpp">//头文件声明CImageList m_icons;</code></pre><pre><code class="cpp">//源文件初始化m_icons.Create(IDB_TREE, 32, 3, 0);m_tree.SetImageList(&amp;m_icons, TVSIL_NORMAL);//TreeHTREEITEM hRoot = m_tree.InsertItem(_T(&quot;root&quot;), 0, 1);HTREEITEM hLeaf1 = m_tree.InsertItem(_T(&quot;leaf&quot;), 2, 1, hRoot);m_tree.InsertItem(_T(&quot;sub&quot;), 2, 1, hLeaf1);HTREEITEM hLeaf2 = m_tree.InsertItem(_T(&quot;leaf&quot;), 2, 1, hRoot);m_tree.InsertItem(_T(&quot;sub&quot;), 2, 1, hLeaf2);</code></pre><img src="/2022/07/25/mfc01/125.png" class=""><p>哈哈图片画少了，他一个节点两个状态可以用两个图片的，选中和未选中两个样，但是我们用的2和1，所以效果就比较糙。</p><img src="/2022/07/25/mfc01/126.png" class=""><pre><code class="cpp">void CMFCButtonDlg::OnNMDblclkTree(NMHDR* pNMHDR, LRESULT* pResult) &#123;    // TODO: 在此添加控件通知处理程序代码    UINT nCount = m_tree.GetSelectedCount();    if (nCount &gt; 0) &#123;        HTREEITEM hSelect = m_tree.GetSelectedItem();        CString strText = m_tree.GetItemText(hSelect);        char sText[256] = &quot;&quot;;        size_t total;        wcstombs_s(&amp;total, sText, sizeof(sText), strText, strText.GetLength());        TRACE(&quot;%s(%d): %s %s\n&quot;, __FILE__, __LINE__, __FUNCTION__, sText);    &#125;    *pResult = 0;&#125;</code></pre><img src="/2022/07/25/mfc01/127.png" class=""><p>其实做法有很多，大多例子都是颗糖。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>MFC看下来跟去年Qt一个感觉吧，知道拖控件和消息之类的，但是实战太少，经验不足，有的时候很难主动把这些关联起来。</p><p>至于Qt后面也要重新捯饬捯饬。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;微软基础类库（英语：Microsoft Foundation Classes，简称MFC）是微软公司提供的一个类库（class libraries），以C++类的形式封装了Windows API，并且包含一个应用程序框架，以减少应用程序开发人员的工作量。其中包含大量Windows句柄封装类和很多Windows的内建控件和组件的封装类。&lt;/p&gt;</summary>
    
    
    
    
    <category term="MFC" scheme="https://8bytes.top/tags/MFC/"/>
    
  </entry>
  
  <entry>
    <title>动态链接库</title>
    <link href="https://8bytes.top/2022/07/25/dynamiclink/"/>
    <id>https://8bytes.top/2022/07/25/dynamiclink/</id>
    <published>2022-07-24T16:12:50.000Z</published>
    <updated>2022-08-09T06:22:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>动态链接库（Dynamic Link Library 或者 Dynamic-link Library，缩写为 DLL），是微软公司在微软Windows操作系统中，实现共享函数库概念的一种方式。这些库函数的扩展名是 ”.dll”、”.ocx”（包含ActiveX控制的库）或者 “.drv”（旧式的系统驱动程序）。<br>——百度百科</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>与之对应的在基础那会学过静态链接库<code>.lib</code>，要使用特定的功能，就必须加载这个静态库，这样在编译的时候其实exe就包含了这个lib。<br>而现在的动态链接库，他只管调用，不去负责连接的过程，要么你写好了不用，他不发生连接，要么写了要用的时候才会去连接。</p><p>静态库编译完成后，已经和exe合并，所以这个exe会比较大。<br>动态库在内存中连接，并没有本质上的合并，相对而言exe比较小，但是计算机如果缺失这个动态库，那么这个exe基本就废了。</p><p>windows常见的动态库(.dll)</p><ol><li>gdi32.dll    绘图</li><li>user32.dll   用户界面有关的函数</li><li>kernel32.dll 内存、线程、进程</li><li>d3d9x_11.dll 绘图</li></ol><p>动态链接库的意义</p><ul><li>模块化</li><li>方便更新迭代</li><li>提高共享率和利用率</li><li>节约内存</li><li>本地化支持</li><li>跨语言编程</li><li>解决版本问题</li><li>等等诸如此类</li></ul><p>歪瓜的事说不得。能做到动态库的瓜也不是一般人了。</p><p>动态库的问题</p><ul><li>因为动态链接，需要时间</li><li>找不到动态库，exe没法跑</li><li>因为更新而导致接口或者参数不一样了，那么以前的代码全废了</li></ul><hr><h2 id="创建动态库"><a href="#创建动态库" class="headerlink" title="创建动态库"></a>创建动态库</h2><img src="/2022/07/25/dynamiclink/000.png" class=""><img src="/2022/07/25/dynamiclink/001.png" class=""><p>vs有模板，直接创建动态链接库的项目就行了。<br>当然是因为第一次，后面自己想怎么来也无所谓。</p><p>其中pch.h 和 pch.cpp是用来预编译的。核心文件自然就是dllmain.cpp。</p><pre><code class="cpp">// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;pch.h&quot;BOOL APIENTRY DllMain(HMODULE hModule,                       DWORD  ul_reason_for_call,                       LPVOID lpReserved)&#123;    switch (ul_reason_for_call)&#123;        case DLL_PROCESS_ATTACH:        case DLL_THREAD_ATTACH:        case DLL_THREAD_DETACH:        case DLL_PROCESS_DETACH:            break;    &#125;    return TRUE;&#125;</code></pre><p>dllmain就是这个程序的主入口。</p><p>我们自定义一个函数</p><pre><code class="cpp">//前缀试了让编译器导出这个函数 _d//由于是c++环境，编译的函数，因为有重载，所以会带有很多参数//我们可以让他用c语言风格编译extern &quot;C&quot; _declspec(dllexport) int Ave(int a, int b)&#123;    return (a + b) / 2;&#125;</code></pre><p>其实要考虑东西比较多。<br>如果定义这块写成这样很麻烦，可以新建一个头文件，把声明写好，这样定义写起来至少看着正常点。</p><pre><code class="cpp">#pragma onceextern &quot;C&quot; _declspec(dllexport) int Ave(int a, int b);</code></pre><p>不过实际用途上，这个头文件还是为了让用你的库的人用的。</p><p>还有一种解决办法</p><img src="/2022/07/25/dynamiclink/002.png" class=""><p>模块化文件</p><pre><code class="cpp">LIBRARYEXPORTS    ave</code></pre><p>这么写之后，就不用头文件了。</p><p>上述情况中，我们先忽视了c++的函数重载。</p><pre><code class="cpp">int ave(int a, int b)&#123;    return (a + b) / 2;&#125;int ave(int a)&#123;    return a + a;&#125;</code></pre><p>有一种解决办法就是提前给链接器做好准备<br><code>#pragma comment(linker,&quot;/export:ave=?ave@@YAHHH@Z&quot;)</code><br>只不过这种写法还不如模块化文件，而且不确定会不会有问题</p><p>还有一种比较麻烦的就是还带了函数调用约定</p><pre><code class="cpp">//1为调用风格   2为导出   3为调用约定extern &quot;C&quot; _declspec(dllexport) int _stdcall ave(int a)&#123;    return a + a;&#125;</code></pre><p>_stdcall在windows api中倒是常见。不过函数在编译后就不会是单纯ave了。<br>要指定的话<code>#pragma comment(linker,&quot;/export:ave=_ave@4&quot;)</code><br>当然显得也有些奇怪</p><img src="/2022/07/25/dynamiclink/003.png" class=""><p>模块化文件之所以能够直接用，其实编译器做了处理的</p><p>简单回顾几种</p><pre><code class="cpp">#pragma comment(linker,&quot;/export:ave=_ave@4&quot;)//.....int ave_1(int a, int b)&#123;    return (a + b) / 2;&#125;extern &quot;C&quot; int _stdcall ave(int a)&#123;    return a + a;&#125;_declspec(dllexport) int _stdcall ave_2(int a)&#123;    return (a + a) / 2;&#125;</code></pre><pre><code class="cpp">//模块化文件LIBRARYEXPORTS    ave_1</code></pre><p>因为懒得下拆解dll函数的软件，就纯yy了。</p><p>一种通过链接器提前导，一种在代码里导出，一种就是模块化文件导出</p><blockquote><p>dll除了导出函数，还能导出变量</p></blockquote><hr><h2 id="链接动态库"><a href="#链接动态库" class="headerlink" title="链接动态库"></a>链接动态库</h2><p>首先新建项目，这会空项目问题不大，然后可以放到一个解决方案下。</p><p>右击新建的项目，找到生成项目依赖项，选择</p><img src="/2022/07/25/dynamiclink/004.png" class=""><p>打上勾。</p><p>然后新建项目里自然要去调用了。</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;windows.h&gt;int main()&#123;    //加载dll    HMODULE hMod = LoadLibraryA(&quot;myDll.dll&quot;);    if (hMod)&#123;        std::cout &lt;&lt; &quot;模块加载成功!\n&quot;;    &#125;    return 0;&#125;</code></pre><p><strong>注：此处loaddll的时候，只写了文件名是因为两个项目在一个解决方案里面，所以生成的exe和dll也在一个文件夹，就不用这么麻烦写路径</strong></p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;windows.h&gt;int main()&#123;    //加载dll    HMODULE hMod = LoadLibraryA(&quot;myDll.dll&quot;);    if (hMod)&#123;        std::cout &lt;&lt; &quot;模块加载成功!\n&quot;;        FARPROC func = GetProcAddress(hMod, &quot;ave_1&quot;);        if (func)&#123;            std::cout &lt;&lt; &quot;函数加载成功!\n&quot;;            func();        &#125;    &#125;    return 0;&#125;</code></pre><p><code>typedef int (FAR WINAPI *FARPROC)();</code>类似于函数指针。</p><img src="/2022/07/25/dynamiclink/005.png" class=""><p>发现函数输出乱值，其实也不难猜到，因为没有输入参数，但是它又不报错。</p><p>这种情况不报错其实不太好，那么FARPROC是函数指针，我们也可以自己定义一个</p><pre><code class="cpp">typedef int (*FAVE_1)(int a, int b);</code></pre><img src="/2022/07/25/dynamiclink/006.png" class=""><p>这样他就会提示要输入参数了。</p><p>然后随便输入俩</p><img src="/2022/07/25/dynamiclink/007.png" class=""><p>这样就成功了。</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;windows.h&gt;typedef int (*FAVE_1)(int a, int b);int main()&#123;    //加载dll    HMODULE hMod = LoadLibraryA(&quot;myDll.dll&quot;);    if (hMod)&#123;        std::cout &lt;&lt; &quot;模块加载成功!\n&quot;;        FAVE_1 func = (FAVE_1)GetProcAddress(hMod, &quot;ave_1&quot;);        if (func)&#123;            std::cout &lt;&lt; &quot;函数加载成功!\n&quot;;            std::cout &lt;&lt; func(200,300);        &#125;    &#125;    return 0;&#125;</code></pre><p><code>HMODULE hMod = LoadLibraryA(&quot;myDll.dll&quot;);</code>这一步就是程序跑的时候，把这个库加载到程序的内存中。</p><p><code>FAVE_1 func = (FAVE_1)GetProcAddress(hMod, &quot;ave_1&quot;);</code>这一步是为了把函数的地址取出来，用了自定义类型是因为原本的类型不符合我们的需求。<strong>同时要注意，如果dll没有导出这个函数，那么根据这个函数名是找不到的</strong></p><p>如果不想用这个dll了，就可以使用<code>FreeLibrary(hMod);</code></p><p>再往后，如果我们想调用这个函数</p><pre><code class="cpp">extern &quot;C&quot; int _stdcall ave(int a)&#123;    return a + a;&#125;</code></pre><p>首先肯定要自定义类型了，那么关键在于<code>extern &quot;C&quot;</code>和<code>_stdcall</code>要不要加的问题<br><code>extern &quot;C&quot;</code>其实是告诉编译器怎么编译它，那么编译完之后其实就不用管了。<br>但是<code>_stdcall</code>不一样，函数调用约定比较麻烦。所以<code>_stdcall</code>是必须的。</p><pre><code class="cpp">typedef int(_stdcall *FAVE)(int);</code></pre><p>模板的形参名是可以省略的，有印象的话最好。<br>至于<code>_stdcall</code>，其实在之前写的线程进程的时候，有用到一个宏<code>WINAPI</code>，它本质上就是<code>_stdcall</code>。<br>所以这么写也没问题<code>typedef int(WINAPI *FAVE)(int);</code></p><img src="/2022/07/25/dynamiclink/008.png" class=""><p>效果也ok的。</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;windows.h&gt;typedef int (*FAVE_1)(int a, int b);typedef int(_stdcall *FAVE)(int);int main()&#123;    //加载dll    HMODULE hMod = LoadLibraryA(&quot;myDll.dll&quot;);    if (hMod)&#123;        std::cout &lt;&lt; &quot;模块加载成功!\n&quot;;        FAVE_1 func = (FAVE_1)GetProcAddress(hMod, &quot;ave_1&quot;);        FAVE func1 = (FAVE)GetProcAddress(hMod, &quot;ave&quot;);        if (func)&#123;            std::cout &lt;&lt; &quot;函数加载成功!\n&quot;;            std::cout &lt;&lt; func(200, 300) &lt;&lt; std::endl;            std::cout &lt;&lt; func1(200);        &#125;    &#125;    FreeLibrary(hMod);    return 0;&#125;</code></pre><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>关于动态库，其实还有挺多可以优化的地方，但现在了解为主吧。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;动态链接库（Dynamic Link Library 或者 Dynamic-link Library，缩写为 DLL），是微软公司在微软Windows操作系统中，实现共享函数库概念的一种方式。这些库函数的扩展名是 ”.dll”、”.ocx”（包含ActiveX控制的库）或者 “.drv”（旧式的系统驱动程序）。&lt;br&gt;——百度百科&lt;/p&gt;</summary>
    
    
    
    
    <category term="windows" scheme="https://8bytes.top/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>windows文件处理</title>
    <link href="https://8bytes.top/2022/07/23/windowsFiles/"/>
    <id>https://8bytes.top/2022/07/23/windowsFiles/</id>
    <published>2022-07-23T15:33:46.000Z</published>
    <updated>2022-07-24T15:48:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>windows常见的文件操作有日志、操作配置文件、ini、注册表、音视频的文件存储。<br>而linux系统具有一切皆文件的概念。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>c&#x2F;c++那会都是打开一个文件然后以什么模式，用完还要关闭。</p><hr><h2 id="c-x2F-c-win32-mfc文件操作"><a href="#c-x2F-c-win32-mfc文件操作" class="headerlink" title="c&#x2F;c++ win32 mfc文件操作"></a>c&#x2F;c++ win32 mfc文件操作</h2><h3 id="c文件操作"><a href="#c文件操作" class="headerlink" title="c文件操作"></a>c文件操作</h3><p><code>fopen</code>函数</p><pre><code class="cpp">_ACRTIMP FILE* __cdecl fopen(    _In_z_ char const* _FileName,    _In_z_ char const* _Mode    );</code></pre><p><code>fopen_s</code>函数</p><pre><code class="cpp">_ACRTIMP errno_t __cdecl fopen_s(    _Outptr_result_nullonfailure_ FILE**      _Stream,    _In_z_                        char const* _FileName,    _In_z_                        char const* _Mode    );</code></pre><p><code>fwrite</code>函数</p><pre><code class="cpp">_ACRTIMP size_t __cdecl fwrite(    _In_reads_bytes_(_ElementSize * _ElementCount) void const* _Buffer,    _In_                                           size_t      _ElementSize,    _In_                                           size_t      _ElementCount,    _Inout_                                        FILE*       _Stream    );</code></pre><p>带s一般都是所谓的安全函数</p><p>几种模式<code>_Mode</code></p><img src="/2022/07/23/windowsFiles/000.png" class=""><ol><li>a add</li><li>r read</li><li>w weite</li><li><ul><li>要求文件存在，权限估计也比较高</li></ul></li></ol><p>然后随便写个按钮绑定一下代码</p><pre><code class="cpp">void CMyCFileDlg::OnBnClickedWriteFile()&#123;    //C 写文件    FILE *pFile = fopen(&quot;1.txt&quot;, &quot;w&quot;);    //以写入模式打开文件    if (pFile == NULL)&#123;        MessageBox(_T(&quot;文件打开失败&quot;));        return;    &#125;    char szBuf[1024] = &quot;c language file&quot;;    fwrite(szBuf, 1, strlen(szBuf)+1, pFile);    //用完关闭    fclose(pFile);&#125;</code></pre><img src="/2022/07/23/windowsFiles/001.png" class=""><p>点击按钮之后文件夹目录就会多了这个1.txt，内容也是我们写的szBuf。<br>具体可以看文件创建时间是否符合我们刚才按下按钮的时候。</p><p>然后使用读文件</p><pre><code class="cpp">void CMyCFileDlg::OnBnClickedReadFile()&#123;    //c 读文件    FILE *pFile = fopen(&quot;1.txt&quot;, &quot;r&quot;);    if (pFile == NULL)&#123;        MessageBox(_T(&quot;文件打开失败&quot;));        return;    &#125;    char szbuf[1024] = &#123; 0 &#125;;    int len = fread(szbuf, 1, 1024, pFile);        fclose(pFile);    MessageBox(szbuf);&#125;</code></pre><img src="/2022/07/23/windowsFiles/002.png" class=""><p>实现起来也比较简单。</p><p>不过这里有个点要注意，因为读文件的时候文件不一定就写满了1024.</p><pre><code class="cpp">void CMyCFileDlg::OnBnClickedReadFile()&#123;    //c 读文件    FILE *pFile = fopen(&quot;1.txt&quot;, &quot;r&quot;);    if (pFile == NULL)&#123;        MessageBox(_T(&quot;文件打开失败&quot;));        return;    &#125;    char szbuf[1024] = &#123; 0 &#125;;    //fseek 求文件的偏移量    fseek(pFile, 0, SEEK_END);    int fLen = ftell(pFile);    //等到文件指针的当前位置    fseek(pFile, 0, SEEK_SET);    //前面的end会使指针跑到最后后面导致读数据都是空的    int len = fread(szbuf, 1, fLen, pFile);        fclose(pFile);    MessageBox(szbuf);&#125;</code></pre><p>要注意偏移之后要让指针回到起始位置。</p><hr><h3 id="c-文件操作"><a href="#c-文件操作" class="headerlink" title="c++文件操作"></a>c++文件操作</h3><p>c++是以类作为核心的语言，所以文件也通过一个类读写。<code>std::ofstream</code></p><p>使用前记得</p><blockquote><p>#include <fstream><br>using namespace std;</p></blockquote><p>不然没法用这个类。解锁命名空间也是为了写着方便</p><pre><code class="cpp">void CMyCFileDlg::OnBnClickedWriteFile()&#123;    //c++ 写    ofstream ofs(&quot;2.txt&quot;);    char szBuf[1024] = &quot;c++ file edit&quot;;    ofs.write(szBuf, strlen(szBuf) + 1);    ofs.close();&#125;</code></pre><p>写起来也非常简单</p><p>顺便把读文件也写了，到时候再看。</p><pre><code class="cpp">void CMyCFileDlg::OnBnClickedReadFile()&#123;     //c++ 读    ifstream ifs(&quot;2.txt&quot;);    char szBuf[1024] = &#123; 0 &#125;;    ifs.read(szBuf, 1024);    ifs.close();    MessageBox(szBuf);&#125;</code></pre><img src="/2022/07/23/windowsFiles/003.png" class=""><p>效果自然是没啥问题的。</p><hr><h3 id="win32-api"><a href="#win32-api" class="headerlink" title="win32 api"></a>win32 api</h3><p>其实跟之前进程用到过</p><pre><code class="cpp">CreateFileW(    _In_ LPCWSTR lpFileName,    //创建或打开的对象名称    _In_ DWORD dwDesiredAccess, //访问方式 读 写 查    _In_ DWORD dwShareMode,     //共享方式 0    _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes,    //NULL 不能被进程继承    _In_ DWORD dwCreationDisposition,   //如何创建文件NEW ALWAYS    _In_ DWORD dwFlagsAndAttributes,    //设置文件属性    _In_opt_ HANDLE hTemplateFile       //NULL    );</code></pre><p>至于a和w就是多字节和Unicode的区别。</p><p>写文件的方式</p><pre><code class="cpp">WriteFile(    _In_ HANDLE hFile,    _In_reads_bytes_opt_(nNumberOfBytesToWrite) LPCVOID lpBuffer,    _In_ DWORD nNumberOfBytesToWrite,    _Out_opt_ LPDWORD lpNumberOfBytesWritten,    _Inout_opt_ LPOVERLAPPED lpOverlapped    );</code></pre><p>随便写写。</p><pre><code class="cpp">void CMyCFileDlg::OnBnClickedWriteFile()&#123;    //win32 write    HANDLE hFile;    hFile = CreateFile(&quot;3.txt&quot;, GENERIC_WRITE, NULL, NULL,         CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL    );    if (hFile == INVALID_HANDLE_VALUE)&#123;        MessageBox(&quot;创建文件对象失败&quot;);        return;    &#125;    DWORD dwWrite;    char szBuf[1024] = &quot;win32 api edit file&quot;;    WriteFile(hFile, szBuf, strlen(szBuf) + 1, &amp;dwWrite, NULL);    CloseHandle(hFile);&#125;void CMyCFileDlg::OnBnClickedReadFile()&#123;    //win32 read    HANDLE hFile;    hFile = CreateFile(&quot;3.txt&quot;, GENERIC_READ, NULL, NULL,        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL    );    if (hFile == INVALID_HANDLE_VALUE)&#123;        MessageBox(&quot;创建文件对象失败&quot;);        return;    &#125;    DWORD dwRead;    char szBuf[1024] = &#123; 0 &#125;;    ReadFile(hFile, szBuf, 1024, &amp;dwRead, NULL);    CloseHandle(hFile);    MessageBox(szBuf);&#125;</code></pre><img src="/2022/07/23/windowsFiles/004.png" class=""><p>这里有点比较麻烦，就是write的时候，好像只能创建一次<br><code>hFile = CreateFile(&quot;3.txt&quot;, GENERIC_WRITE, NULL, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);</code></p><p>其中<code>CREATE_NEW</code>就是新建的意思，但是如果存在了他就会报错，但改成其它的感觉又不太合适。先凑合用。</p><hr><h3 id="MFC"><a href="#MFC" class="headerlink" title="MFC"></a>MFC</h3><p>写法跟c++比较类似吧</p><pre><code class="cpp">void CMyCFileDlg::OnBnClickedWriteFile()&#123;    //mfc write    CFile cf(&quot;4.txt&quot;, CFile::modeCreate | CFile::modeWrite);    char szBuf[1024] = &quot;mfc edit files&quot;;    cf.Write(szBuf, strlen(szBuf) + 1);    cf.Close();&#125;</code></pre><pre><code class="cpp">void CMyCFileDlg::OnBnClickedReadFile()&#123;    //mfc read    CFile cf(&quot;4.txt&quot;, CFile::modeRead);    char szBuf[1024] = &#123; 0 &#125;;    cf.Read(szBuf, 1024);    cf.Close();    MessageBox(szBuf);&#125;</code></pre><img src="/2022/07/23/windowsFiles/005.png" class=""><p>这样最基础的操作肯定是没问题的。</p><p>不过读文件好像还有别的骚操作。</p><pre><code class="cpp">void CMyCFileDlg::OnBnClickedReadFile()&#123;    //mfc read    CFileDialog fileDlg(TRUE);    fileDlg.m_ofn.lpstrTitle = &quot;Test&quot;;    //过滤器    fileDlg.m_ofn.lpstrFilter = &quot;Text Files(*.txt)\0*.txt\0All Files(*.*)\0*.*\0\0&quot;;            if (IDOK == fileDlg.DoModal())&#123;        CFile cf(fileDlg.GetFileName(), CFile::modeRead);        DWORD dwFileLen = cf.GetLength();        char szBuf[1024] = &#123; 0 &#125;;        cf.Read(szBuf, dwFileLen);        cf.Close();        MessageBox(szBuf);    &#125;&#125;</code></pre><img src="/2022/07/23/windowsFiles/006.png" class=""><p>点击读文件他会弹出一个文件夹让你选。<br>然后根据我们的过滤器，一种是text一种是all</p><img src="/2022/07/23/windowsFiles/007.png" class=""><p>随便打开其中一个都能读出来</p><img src="/2022/07/23/windowsFiles/008.png" class=""><hr><h2 id="配置文件的操作"><a href="#配置文件的操作" class="headerlink" title="配置文件的操作"></a>配置文件的操作</h2><p>配置文件的格式比较特殊，<code>.ini</code><br>里面一般都是配置选项。<br><code>WritePrivateProfileString</code></p><pre><code class="cpp">WritePrivateProfileStringW(    _In_opt_ LPCWSTR lpAppName,    _In_opt_ LPCWSTR lpKeyName,    _In_opt_ LPCWSTR lpString,    _In_opt_ LPCWSTR lpFileName    );</code></pre><p>w和a就是对这些字符的要求不一样。</p><p>然后瞎写一个</p><pre><code class="cpp">void CMyCFileDlg::OnBnClickedWriteFile()&#123;    //ini write    char szPath[MAX_PATH] = &#123; 0 &#125;;    GetCurrentDirectory(MAX_PATH, szPath);    CString szPathFile;    szPathFile.Format(&quot;%s\\Test.ini&quot;, szPath);    //瞎写的。    WritePrivateProfileString(&quot;man&quot;, &quot;friend&quot;, &quot;张三&quot;, szPathFile);    WritePrivateProfileString(&quot;man&quot;, &quot;student&quot;, &quot;李四&quot;, szPathFile);    WritePrivateProfileString(&quot;school&quot;, &quot;teacher&quot;, &quot;王五&quot;, szPathFile);&#125;</code></pre><p>启动之后点击写文件</p><img src="/2022/07/23/windowsFiles/009.png" class=""><p>可以在文件夹目录下看到我们写的配置。</p><p>至于读文件，也有点相似吧<br>要用到这个玩意</p><pre><code class="cpp">GetPrivateProfileStringW(    _In_opt_ LPCWSTR lpAppName,    _In_opt_ LPCWSTR lpKeyName,    _In_opt_ LPCWSTR lpDefault,    _Out_writes_to_opt_(nSize, return + 1) LPWSTR lpReturnedString,    _In_     DWORD nSize,    _In_opt_ LPCWSTR lpFileName    );</code></pre><p>额，这里ini格式瞎写的，所以读出来的时候可能看着太怪了。</p><pre><code class="cpp">void CMyCFileDlg::OnBnClickedReadFile()&#123;    //ini read    char szPath[MAX_PATH] = &#123; 0 &#125;;    GetCurrentDirectory(MAX_PATH, szPath);    CString szPathFile;    szPathFile.Format(&quot;%s\\Test.ini&quot;, szPath);    char dwKey[1024] = &#123; 0 &#125;;    char dwKeyName[1024] = &#123; 0 &#125;;    char dwValue[1024] = &#123; 0 &#125;;    GetPrivateProfileString(&quot;man&quot;, &quot;friend&quot;, NULL, dwKey, 1024, szPathFile);    GetPrivateProfileString(&quot;man&quot;, &quot;student&quot;, NULL, dwKeyName, 1024, szPathFile);    GetPrivateProfileString(&quot;school&quot;, &quot;teacher&quot;, NULL, dwValue, 1024, szPathFile);    //cstring拼接    CString strShow;    strShow.Format(&quot;friend:%s student:%s teacher:%s&quot;, dwKey, dwKeyName, dwValue);    MessageBox(strShow);&#125;</code></pre><p>但反正最后还是读出了值：</p><img src="/2022/07/23/windowsFiles/010.png" class=""><hr><h2 id="注册表"><a href="#注册表" class="headerlink" title="注册表"></a>注册表</h2><p>注册表是存储在二进制文件里面的，win32api 提供了大量的函数操作注册表</p><p>额，默认打开的话，win+r是打开运行，然后输入regedit即可打开注册表，如果之前有用过就会很熟悉。</p><p><strong>动注册表之前，vs需要用管理员启动，不然肯定是无法写入的。</strong></p><p>项目还是之前那个没关系。</p><p><code>RegCreateKey</code>创建指定的注册表项</p><pre><code class="cpp">WINADVAPILSTATUSAPIENTRYRegCreateKeyA (    _In_ HKEY hKey,    _In_opt_ LPCSTR lpSubKey,    _Out_ PHKEY phkResult    );WINADVAPILSTATUSAPIENTRYRegCreateKeyW (    _In_ HKEY hKey,     //句柄，实际应该为分支    _In_opt_ LPCWSTR lpSubKey,  //打开或创建的表项名称    _Out_ PHKEY phkResult   //用来接收创建或打开的表项句柄    );#ifdef UNICODE#define RegCreateKey  RegCreateKeyW#else#define RegCreateKey  RegCreateKeyA#endif // !UNICODE</code></pre><p>这个微软就喜欢多字节和Unicode，从他头文件中各自宏定义去兼容这两种编码。</p><p><code>RegOpenKey </code>打开注册表</p><pre><code class="cpp">WINADVAPILSTATUSAPIENTRYRegOpenKeyA (    _In_ HKEY hKey,    _In_opt_ LPCSTR lpSubKey,    _Out_ PHKEY phkResult    );WINADVAPILSTATUSAPIENTRYRegOpenKeyW (    _In_ HKEY hKey,    _In_opt_ LPCWSTR lpSubKey,    _Out_ PHKEY phkResult    );#ifdef UNICODE#define RegOpenKey  RegOpenKeyW#else#define RegOpenKey  RegOpenKeyA#endif // !UNICODE</code></pre><p><code>RegSetValue</code>写入注册表</p><pre><code class="cpp">WINADVAPILSTATUSAPIENTRYRegSetValueA (    _In_ HKEY hKey,    _In_opt_ LPCSTR lpSubKey,    _In_ DWORD dwType,    _In_reads_bytes_opt_(cbData) LPCSTR lpData, //存放的数据    _In_ DWORD cbData       //要存放的值的大小长度    );WINADVAPILSTATUSAPIENTRYRegSetValueW (    _In_ HKEY hKey,    _In_opt_ LPCWSTR lpSubKey,    _In_ DWORD dwType,    _In_reads_bytes_opt_(cbData) LPCWSTR lpData,    _In_ DWORD cbData    );#ifdef UNICODE#define RegSetValue  RegSetValueW#else#define RegSetValue  RegSetValueA#endif // !UNICODE</code></pre><p><code>RegQueryValue</code>检索与指定注册表项的默认值或未命名值关联的数据。</p><pre><code class="cpp">WINADVAPILSTATUSAPIENTRYRegQueryValueA (    _In_ HKEY hKey,    _In_opt_ LPCSTR lpSubKey,    _Out_writes_bytes_to_opt_(*lpcbData, *lpcbData) __out_data_source(REGISTRY) LPSTR lpData,    _Inout_opt_ PLONG lpcbData    );WINADVAPILSTATUSAPIENTRYRegQueryValueW (    _In_ HKEY hKey,    _In_opt_ LPCWSTR lpSubKey,    _Out_writes_bytes_to_opt_(*lpcbData, *lpcbData) __out_data_source(REGISTRY) LPWSTR lpData,    _Inout_opt_ PLONG lpcbData    );#ifdef UNICODE#define RegQueryValue  RegQueryValueW#else#define RegQueryValue  RegQueryValueA#endif // !UNICODE</code></pre><p>那么写入的部分其实还是有点水</p><pre><code class="cpp">void CMyCFileDlg::OnBnClickedWriteFile()&#123;    //注册表 写    HKEY hKey;    DWORD dwWeight = 70;    //创建注册表    //DWORD dwRet = ::RegCreateKey(HKEY_LOCAL_MACHINE, &quot;SOFTWARE\\MYWEIGHT\\admin&quot;, &amp;hKey);    DWORD dwRet = ::RegCreateKey(HKEY_CURRENT_USER, &quot;Software\\HHH\\admin&quot;, &amp;hKey);    if (dwRet != ERROR_SUCCESS)&#123;        MessageBox(&quot;创建注册表失败&quot;);        return;    &#125;        //写注册表    dwRet = ::RegSetValueEx(hKey, &quot;weight&quot;, NULL, REG_DWORD, (CONST BYTE *)dwWeight, 4);    if (dwRet != ERROR_SUCCESS)&#123;        MessageBox(&quot;写入注册表失败&quot;);        return;    &#125;    //关闭注册表    ::RegCloseKey(hKey);&#125;</code></pre><p>然后跑起来看看注册表里面有没有我们写入的。</p><img src="/2022/07/23/windowsFiles/011.png" class=""><p>md，<code>::RegCreateKey(HKEY_LOCAL_MACHINE, &quot;SOFTWARE\\MYWEIGHT\\admin&quot;, &amp;hKey);</code>这个注册表位置管理员打开的软件居然写不进去，我找了半天没找到，换了个地方写就马上见效，离谱，浪费我一堆时间啊。</p><p>然后读的部分</p><pre><code class="cpp">void CMyCFileDlg::OnBnClickedReadFile()&#123;    //注册表 读    HKEY hKey;    DWORD dwRet = ::RegOpenKey(HKEY_CURRENT_USER, &quot;Software\\HHH\\admin&quot;, &amp;hKey);    if (dwRet != ERROR_SUCCESS)&#123;        MessageBox(&quot;打开注册表失败&quot;);        return;    &#125;    //读或者查注册表    DWORD dwWight;    DWORD dwType;    DWORD dwSize;    CString strShow;    dwRet = ::RegQueryValueExA(hKey, &quot;weight&quot;, 0, &amp;dwType, (LPBYTE) &amp;dwWight, &amp;dwSize);    if (dwRet != ERROR_SUCCESS)&#123;        MessageBox(&quot;读取注册表失败&quot;);        return;    &#125;    strShow.Format(&quot;Weight = %d&quot;, dwWight);    //关闭注册表    ::RegCloseKey(hKey);    MessageBox(strShow);&#125;</code></pre><p>其实写起来也不难，就是要填充这个参数问题。</p><img src="/2022/07/23/windowsFiles/012.png" class=""><p>效果就是这样了。</p><hr><h2 id="常规的文件等级"><a href="#常规的文件等级" class="headerlink" title="常规的文件等级"></a>常规的文件等级</h2><ol><li>调试日志 debugview 文件日志、警告日志、错误日志 &#x2F;五星</li><li>视频存储 &#x2F;四星</li><li>文件传输CFile和Socket结合 &#x2F;四星</li><li>C语言和mfc的文件操作，win32api &#x2F;三星</li><li>windows的配置文件    &#x2F;五星</li><li>注册表 病毒 逆向     &#x2F;五星</li></ol><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>反正比较常用的文件操作还是以c语言和mfc为主吧，毕竟c用的很久了。mfc嘛自然在这个框架里面最好用。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;windows常见的文件操作有日志、操作配置文件、ini、注册表、音视频的文件存储。&lt;br&gt;而linux系统具有一切皆文件的概念。&lt;/p&gt;</summary>
    
    
    
    
    <category term="windows" scheme="https://8bytes.top/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>进程</title>
    <link href="https://8bytes.top/2022/07/21/process/"/>
    <id>https://8bytes.top/2022/07/21/process/</id>
    <published>2022-07-21T14:44:06.000Z</published>
    <updated>2022-07-24T02:59:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。<br>——百度百科</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>基本情况下，我们查看任务进程，包括kill一个未响应的进程，都会在任务管理器中操作。<br>不过微软自己有个进程资源管理器看到的会更详细一点，<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer">链接戳此处</a></p><p><strong>注：需要科学上网，不然很慢</strong></p><img src="/2022/07/21/process/000.png" class=""><p>进程实际上就一个纯粹的容器，进程本身不执行任何东西。代码的实现靠的的是线程，进程只相当于一个环境。<br>子进程也还是一个进程，它是指由另一个进程(对应称为父进程)所创建的进程。<br>子进程的线程既可以在父进程终止之后执行代码，也可以在父进程运行过程中执行代码。</p><hr><h2 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h2><p><code>CreateProcess</code>用来创建进程的函数。<br>其原型，参数一贯的又臭又长</p><pre><code class="cpp">CreateProcessW(    _In_opt_ LPCWSTR lpApplicationName, //该字符串可以指定要执行的模块的完整路径和文件名    _Inout_opt_ LPWSTR lpCommandLine,   //命令行    _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes, //该结构确定子进程是否可以继承返回到新进程对象的句柄，如果为NULL则不能继承    _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,  //该结构确定子进程是否可以继承返回到新线程对象的句柄，如果为NULL则不能继承    _In_ BOOL bInheritHandles,  //参数若为TRUE则新进程继承调用进程的每个可继承句柄。如为FALSE则不会继承句柄    _In_ DWORD dwCreationFlags, //控制优先级别和流程创建的标识    _In_opt_ LPVOID lpEnvironment,  //指向新进程的环境块的指针，若为NULL则新进程将使用调用进程的环境    _In_opt_ LPCWSTR lpCurrentDirectory,    //进程当前目录的完整路径    _In_ LPSTARTUPINFOW lpStartupInfo,      //设置扩展属性    _Out_ LPPROCESS_INFORMATION lpProcessInformation    //该结构接收有关新进程的标识信息    );</code></pre><p>具体可以去看文档。因为Windows API套娃严重。。他这里的参数还有结构体。有点绷不住。</p><p>然后自制进程的话不太理想，反正打开一个程序也是一个进程，就直接配置打开一个程序</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;process.h&gt;int RunExe()&#123;        //Chrome路径    STARTUPINFO strStartup;    memset(&amp;strStartup, 0, sizeof(strStartup));    strStartup.cb = sizeof(strStartup);    PROCESS_INFORMATION szProcessInformation;    memset(&amp;szProcessInformation, 0, sizeof(szProcessInformation));    TCHAR szCommandLine[] = L&quot;C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe&quot;;        int ret = CreateProcess(        NULL,        szCommandLine,        NULL,        NULL,        FALSE,        CREATE_NEW_CONSOLE,        NULL,        NULL,        &amp;strStartup,        &amp;szProcessInformation    );    if (ret)&#123;        printf(&quot;Create success ret = %d\n&quot;, ret);        WaitForSingleObject(szProcessInformation.hProcess,INFINITE);        CloseHandle(szProcessInformation.hProcess);        CloseHandle(szProcessInformation.hThread);        //手动置空看情况。    &#125; else&#123;        printf(&quot;Create error!\n&quot;);    &#125;    return 0;&#125;int main()&#123;    //通过进程拉起谷歌浏览器    printf(&quot;This is Chrome\n&quot;);    RunExe();    system(&quot;pause&quot;);    return 0;&#125;</code></pre><p><strong>memset是计算机中C&#x2F;C++语言初始化函数。作用是将某一块内存中的内容全部设置为指定的值， 这个函数通常为新申请的内存做初始化工作。</strong></p><img src="/2022/07/21/process/001.png" class=""><p>可以看到是成功启动了我们的谷歌浏览器，但是自己用的时候要注意，文件路径每个人多少都有不同，所以不要直接套娃。</p><p>除了直接打开.exe，还可以通过命令行的方式让他打开网页<br><code>TCHAR szCommandLine[] = L&quot;\&quot;C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe\&quot;https://www.baidu.com&quot;;</code><br>如此设置之后，run的时候就能看到浏览器直接打开百度的首页了。</p><img src="/2022/07/21/process/002.png" class=""><p>并且进程对象的成员也使得我们能够看到相对应的id</p><pre><code class="cpp">if (ret)&#123;    printf(&quot;Create success ret = %d\n&quot;, ret);    WaitForSingleObject(szProcessInformation.hProcess,INFINITE);    printf(&quot;szProcessInformation.hProcess = %d\n&quot;, szProcessInformation.hProcess);    printf(&quot;szProcessInformation.hThread = %d\n&quot;, szProcessInformation.hThread);    printf(&quot;szProcessInformation.dwProcessId = %d\n&quot;, szProcessInformation.dwProcessId);    printf(&quot;szProcessInformation.dwThreadId = %d\n&quot;, szProcessInformation.dwThreadId);    CloseHandle(szProcessInformation.hProcess);    CloseHandle(szProcessInformation.hThread);    //手动置空看情况。&#125; else&#123;    printf(&quot;Create error!\n&quot;);&#125;</code></pre><img src="/2022/07/21/process/003.png" class=""><p>当然用这个调用cmd去执行一些命令好像有点问题，而且有点笨，它都可以直接通过system调用系统命令了。</p><hr><h2 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h2><ol><li>socket ip和端口</li><li>剪切板  剪切板的内核对象</li><li>邮槽 邮槽的内核对象</li><li>匿名管道(无名管道)</li><li>命名管道</li><li>Copy_data findwindows wm_copudata  Sendmessage</li></ol><hr><h2 id="剪切板"><a href="#剪切板" class="headerlink" title="剪切板"></a>剪切板</h2><p>新建项目mfc</p><img src="/2022/07/21/process/004.png" class=""><p>选择基于对话框，然后就点完成</p><img src="/2022/07/21/process/005.png" class=""><p>打开之后长这样就差不多了。</p><p>运行一下，跟里面看的差不多</p><img src="/2022/07/21/process/006.png" class=""><p>加下来要用到资源视图，如果没打开的可以参照</p><img src="/2022/07/21/process/007.png" class=""><img src="/2022/07/21/process/008.png" class=""><p>因为之前看过qt，所以拖动组件和修改id之类的不是什么问题。</p><img src="/2022/07/21/process/010.png" class=""><p>做成这样之后双击按钮进入代码实现部分,<strong>注意修改项目为多字节，unicode有点问题先不管了，但是可以提一嘴，就是接收的时候需要转换</strong></p><pre><code class="cpp">void CCopyBoardDlg::OnBnClickedSendbutton()&#123;    //打开剪切板 成功返回TRUE    if (OpenClipboard())&#123;        //打开之后首先清空剪切板        EmptyClipboard();        char *szSendBuf;        //获取SEND框的内容        CString strSend&#123;&#125;;        GetDlgItemText(IDC_EDIT_SEND,strSend);        //分配一个内存对象，内存对象的句柄就是hclip        HANDLE hClip = GlobalAlloc(GMEM_MOVEABLE, strSend.GetLength()+1);        //剪切板上锁        szSendBuf = (char*)GlobalLock(hClip);        strcpy(szSendBuf, strSend);        //拷贝完之后解锁        GlobalUnlock(hClip);        //将数据放入剪切板        SetClipboardData(CF_TEXT, hClip);        //关闭剪切板        CloseClipboard();    &#125;&#125;void CCopyBoardDlg::OnBnClickedRecvbutton()&#123;    //打开剪切板    if (OpenClipboard())&#123;        //判断剪切板是否可用        if (IsClipboardFormatAvailable(CF_TEXT))&#123;            char *szRecvBuf;            //向剪切板取出数据            HANDLE hClip = GetClipboardData(CF_TEXT);            szRecvBuf = (char *)GlobalLock(hClip);            SetDlgItemText(IDC_EDIT_RECV, szRecvBuf);            GlobalUnlock(hClip);        &#125;        //关闭剪切板        CloseClipboard();    &#125;&#125;</code></pre><p>最后实现部分就是这样，在左边的内容框输入，点击发送之后，再点击接收，右边的框就有内容了</p><img src="/2022/07/21/process/009.png" class=""><p>可能会有疑惑，为什么说是同步。这个程序看似就是一个进程之间的事情。<br>实际上因为我们调用了剪切板，所以当我们点击发送的时候，我们系统的剪切板就有了内容，所以我们可以直接在别的地方粘贴出来。<br>就像这样，我可以直接在项目的源文件中粘贴出来。</p><img src="/2022/07/21/process/011.png" class=""><p>当然也可以新建一个作为桥梁嘛。</p><pre><code class="cpp">void CCopyBoardCliDlg::OnBnClickedButtonrecv()&#123;    //打开剪切板    if (OpenClipboard())&#123;        //判断是否可用        if (IsClipboardFormatAvailable(CF_TEXT))&#123;            char *szRecvBuf;            //取剪切板数据            HANDLE hClip = GetClipboardData(CF_TEXT);            szRecvBuf = (char *)GlobalLock(hClip);            SetDlgItemText(IDC_EDITRECV, szRecvBuf);            GlobalUnlock(hClip);        &#125;        //关闭剪切板        CloseClipboard();    &#125;&#125;</code></pre><p>额老样子一个直接打开一个vs打开。</p><img src="/2022/07/21/process/012.png" class=""><p>效果就是我主要的点了发送以后，新写的可以直接通过接收获取。不是视频可能会有理解上的偏差。</p><hr><h2 id="邮槽"><a href="#邮槽" class="headerlink" title="邮槽"></a>邮槽</h2><p>邮槽是比较老的通信方式了。<br>使用邮槽的进程分为服务端和客户端。邮槽由服务端创建，在创建时需要指定邮槽名，创建后服务端得到邮槽的句柄。在邮槽创建后，客户端可以通过邮槽名打开邮槽，在获得句柄后可以向邮槽写入消息。<br>邮槽通信是单项的，只有服务端才能从邮槽中读取消息，客户端只能写入消息。消息遵循先入先出的原则。客户端先写入的消息在服务端现被读取。<br>通过邮槽通信的数据可以是任意格式，但是一条消息不能大于424字节。<br>邮槽除了在本机内进行进程间通信外，在主机间也可以通信。但是在主机间进行邮槽通信。数据通过网络传播时使用的是数据报协议(UDP)，所以是一种不可靠的通信。通过网络进行邮槽通信时，客户端必须知道服务端的主机名或者域名。</p><p><code>CreateMailslot</code>额，还是老样子微软会根据多字节还是Unicode会做一个区分，前者多个a，后者多个w。<br>其原型</p><pre><code class="cpp">CreateMailslot(    _In_     LPCWSTR lpName,    _In_     DWORD nMaxMessageSize,    _In_     DWORD lReadTimeout,    _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes    );</code></pre><img src="/2022/07/21/process/013.png" class=""><img src="/2022/07/21/process/014.png" class=""><p>然后设计这么两个东西。</p><p>先从服务器开始设计接收</p><pre><code class="cpp">void CMyMailslotDlg::OnBnClickedRecvbutton()&#123;    //创建邮槽    LPCTSTR szSlotName = TEXT(&quot;\\\\.\\mailslot\\Mymailslot&quot;);    HANDLE hSlot = CreateMailslot(        szSlotName,        0,                        //消息大小        MAILSLOT_WAIT_FOREVER,    //阻塞时间        NULL                    //安全属性    );    if (hSlot == INVALID_HANDLE_VALUE)&#123;        TRACE(&quot;CreateMailslot failed with %d\n&quot;, GetLastError());        return;    &#125;&#125;</code></pre><p>然后要读取数据<br>这一关键点需要用到一个特别的函数<code>ReadFile</code></p><pre><code class="cpp">ReadFile(    _In_ HANDLE hFile,    //句柄    _Out_writes_bytes_to_opt_(nNumberOfBytesToRead, *lpNumberOfBytesRead) //缓冲区    __out_data_source(FILE) LPVOID lpBuffer,    _In_ DWORD nNumberOfBytesToRead,        //将要读取的最大字节数    _Out_opt_ LPDWORD lpNumberOfBytesRead,    //指针，该变量接收时同步hFile读取的字节数    _Inout_opt_ LPOVERLAPPED lpOverlapped    //默认NULL    );</code></pre><p>完整的这个服务端接收功能</p><pre><code class="cpp">void CMyMailslotDlg::OnBnClickedRecvbutton()&#123;    //创建邮槽    LPCTSTR szSlotName = TEXT(&quot;\\\\.\\mailslot\\Mymailslot&quot;);    HANDLE hSlot = CreateMailslot(        szSlotName,        0,                        //消息大小        MAILSLOT_WAIT_FOREVER,    //阻塞时间        NULL                    //安全属性    );    if (hSlot == INVALID_HANDLE_VALUE)&#123;        TRACE(&quot;CreateMailslot failed with %d\n&quot;, GetLastError());        return;    &#125;    //读数据    char szBuf[100] = &#123; 0 &#125;;    DWORD dwRead;    if (!ReadFile(hSlot, szBuf, 100, &amp;dwRead, NULL))&#123;        MessageBox(&quot;ReadFile error!&quot;);        return;    &#125;    TRACE(&quot;---dwRead = %d\n&quot;, dwRead);    MessageBox(szBuf);    CloseHandle(hSlot);&#125;</code></pre><p>然后客户端的发送功能其实也挺类似</p><pre><code class="cpp">void CMymailCliDlg::OnBnClickedSendbutton()&#123;    //创建句柄    LPCTSTR szSlotName = TEXT(&quot;\\\\.\\mailslot\\Mymailslot&quot;);    HANDLE hMailSlot = CreateFile(        szSlotName,        FILE_GENERIC_WRITE,        FILE_SHARE_READ,        NULL,        OPEN_EXISTING,        FILE_ATTRIBUTE_NORMAL,        NULL    );    if (hMailSlot == INVALID_HANDLE_VALUE)&#123;        TRACE(&quot;CreateFile failed with %d\n&quot;, GetLastError());        return;    &#125;    //写入数据    char szBuf[100] = &quot;MailSlot Comming&quot;;    DWORD dwWrite;    if (!WriteFile(hMailSlot, szBuf, strlen(szBuf)+1, &amp;dwWrite, NULL))&#123;        MessageBox(&quot;Write Error!&quot;);        return;    &#125;    //关闭句柄    CloseHandle(hMailSlot);&#125;</code></pre><img src="/2022/07/21/process/015.png" class=""><p>按照这个顺序大致就是这个效果。</p><blockquote><p>邮槽用的不多，之前可以说是听都没听过</p></blockquote><hr><h2 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h2><p>匿名管道是一个没有命名的单向管道，本质上是一个共享的内存区域。通常用来在父进程和子进程之间通信。<br>只能实现本地两个进程之间的通信，不能实现网络通信。</p><p><code>CreatePipe</code></p><pre><code class="cpp">CreatePipe(    _Out_ PHANDLE hReadPipe,    _Out_ PHANDLE hWritePipe,    _In_opt_ LPSECURITY_ATTRIBUTES lpPipeAttributes,    _In_ DWORD nSize    );</code></pre><p>额这里因为是要用到两个进程，就直接在邮槽上改了。</p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><pre><code class="cpp">HANDLE hReadPipe;    //读句柄HANDLE hWritePipe;    //写句柄void CMyMailslotDlg::OnBnClickedSendbutton()&#123;    char szBuf[] = &quot;This Server Pipe&quot;;    DWORD dwWrite;    if (!WriteFile(hWritePipe, szBuf, strlen(szBuf) + 1, &amp;dwWrite, NULL))&#123;        MessageBox(_T(&quot;写入数据失败&quot;));        return;    &#125;&#125;void CMyMailslotDlg::OnBnClickedRecvbutton()&#123;    char szBuf[100] = &#123; 0 &#125;;    DWORD dwRead;    TRACE(&quot;Begin ReadFile&quot;);    if (!ReadFile(hReadPipe, szBuf, 100, &amp;dwRead, NULL))&#123;        MessageBox(_T(&quot;读取数据失败&quot;));        return;    &#125;    TRACE(&quot;End PipeReadFile&quot;);    MessageBox(szBuf);&#125;void CMyMailslotDlg::OnBnClickedCreBtn()&#123;    SECURITY_ATTRIBUTES sa;    sa.bInheritHandle = TRUE;    sa.lpSecurityDescriptor = NULL;    sa.nLength = sizeof(SECURITY_ATTRIBUTES);    if (!CreatePipe(&amp;hReadPipe, &amp;hWritePipe, &amp;sa, 0))&#123;        MessageBox(_T(&quot;匿名管道创建失败&quot;));        return;    &#125;    //创建子进程    STARTUPINFO strStartupInfo;    //用来指定新进程窗口如何显示    memset(&amp;strStartupInfo, 0, sizeof(strStartupInfo));    strStartupInfo.cb = sizeof(strStartupInfo);    strStartupInfo.dwFlags = STARTF_USESTDHANDLES;    strStartupInfo.hStdInput = hReadPipe;    strStartupInfo.hStdOutput = hWritePipe;    strStartupInfo.hStdError = GetStdHandle(STD_ERROR_HANDLE);    PROCESS_INFORMATION szProcessInformation;    memset(&amp;szProcessInformation, 0, sizeof(szProcessInformation));    int iRet = CreateProcess(        _T(&quot;MymailCli.exe&quot;),        NULL,        NULL,        NULL,        TRUE,        0,        NULL,        NULL,        &amp;strStartupInfo,        &amp;szProcessInformation    );    if (iRet)&#123;        //创建成功的情况        CloseHandle(szProcessInformation.hProcess);        CloseHandle(szProcessInformation.hThread);        szProcessInformation.dwProcessId = 0;        szProcessInformation.dwThreadId = 0;        szProcessInformation.hThread = NULL;        szProcessInformation.hProcess = NULL;    &#125; else&#123;        CloseHandle(hReadPipe);        CloseHandle(hWritePipe);        hReadPipe = NULL;        hWritePipe = NULL;        MessageBox(_T(&quot;子进程创建失败&quot;));        return;    &#125;&#125;</code></pre><p>这里主要是给服务端拉起一个进程，然后通过拉起的客户端进行匿名管道传递<br>进程的代码大多还是抄之前写的进程部分。</p><img src="/2022/07/21/process/016.png" class=""><hr><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><pre><code class="cpp">HANDLE hReadPipe;    //读句柄HANDLE hWritePipe;    //写句柄void CMymailCliDlg::OnBnClickedSendbutton()&#123;    hWritePipe = GetStdHandle(STD_OUTPUT_HANDLE);    char szBuf[100] = &quot;This Client Pipe&quot;;    DWORD dwWrite;    if (!WriteFile(hWritePipe, szBuf, strlen(szBuf) + 1, &amp;dwWrite, NULL))&#123;        MessageBox(_T(&quot;写入数据失败&quot;));        return;    &#125;&#125;void CMymailCliDlg::OnBnClickedRecvbutton()&#123;    hReadPipe = GetStdHandle(STD_INPUT_HANDLE);    char szBuf[100] = &#123; 0 &#125;;    DWORD dwRead;    if (!ReadFile(hReadPipe, szBuf, 100, &amp;dwRead, NULL))&#123;        MessageBox(_T(&quot;读取数据失败&quot;));        return;    &#125;    MessageBox(szBuf);&#125;</code></pre><p>客户端因为不用管邮槽先，就通过句柄传送。</p><hr><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><img src="/2022/07/21/process/017.png" class=""><p>根据按钮打开新进程。</p><p>然后相互点击发送和接收<br>服务端发送 客户端接收</p><img src="/2022/07/21/process/018.png" class=""><p>客户端发送 服务端接收</p><img src="/2022/07/21/process/019.png" class=""><p>大致就是这么一个效果。</p><p><strong>继续插一嘴：匿名管道只能实现本地两个进程之间的通信，不能实现网络通信。</strong></p><hr><h2 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h2><p>与Socket相似，支持网络之间不同进程的通信<br>既然也能通信，自然也能通过c&#x2F;s模式实现</p><p><code>CreateNamePipe</code></p><pre><code class="cpp">CreateNamedPipeA(    _In_     LPCSTR lpName,    _In_     DWORD dwOpenMode,    _In_     DWORD dwPipeMode,    _In_     DWORD nMaxInstances,    _In_     DWORD nOutBufferSize,    _In_     DWORD nInBufferSize,    _In_     DWORD nDefaultTimeOut,    _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes    );</code></pre><p>插一句，项目有些时候都用多字节的，Unicode有的时候要转换太麻烦了。</p><h3 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h3><pre><code class="cpp">HANDLE hNamedPipe;void CmyNamePipeSerDlg::OnBnClickedProBtn()&#123;    //创建命名管道    LPCTSTR szPipeName = TEXT(&quot;\\\\.\\pipe\\mypipe&quot;);    hNamedPipe = CreateNamedPipe(        szPipeName,        PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,        PIPE_TYPE_BYTE, 1, 1024, 1024, 0, NULL    );    if (hNamedPipe == INVALID_HANDLE_VALUE)&#123;        TRACE(&quot;CreateNamePipe failed with %d\n&quot;, GetLastError());        MessageBox(_T(&quot;创建命名管道失败&quot;));        return;    &#125;    //等待客户端的连接    HANDLE hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);    if (NULL == hEvent)&#123;        MessageBox(_T(&quot;创建事件失败&quot;));        CloseHandle(hNamedPipe);        hNamedPipe = NULL;        return;    &#125;    OVERLAPPED ovlap;    ZeroMemory(&amp;ovlap, sizeof(OVERLAPPED));    ovlap.hEvent = hEvent;    //等待连接    if (!ConnectNamedPipe(hNamedPipe, &amp;ovlap))&#123;        if (ERROR_IO_PENDING != GetLastError())&#123;            MessageBox(_T(&quot;等待客户端连接失败&quot;));            CloseHandle(hNamedPipe);            CloseHandle(hEvent);            hNamedPipe = NULL;            hEvent = NULL;            return;        &#125;    &#125;    if (WaitForSingleObject(hEvent, INFINITE) == WAIT_FAILED)&#123;        MessageBox(_T(&quot;等待对象失败&quot;));        CloseHandle(hNamedPipe);        CloseHandle(hEvent);        hNamedPipe = NULL;        hEvent = NULL;        return;    &#125;&#125;</code></pre><p>创建命名管道其实也还好，但是为了一些安全考虑，做了一些措施，本质上都是copy来的。</p><p>至于send和recv其实换汤不换药</p><pre><code class="cpp">void CmyNamePipeSerDlg::OnBnClickedSendBtn()&#123;    //命名管道 服务端 发送    char szBuf[] = &quot;This Named Pipe From Server&quot;;    DWORD dwWrite;    if (!WriteFile(hNamedPipe, szBuf, strlen(szBuf) + 1, &amp;dwWrite, NULL))&#123;        MessageBox(_T(&quot;WriteFile Failed!!!&quot;));        return;    &#125;&#125;void CmyNamePipeSerDlg::OnBnClickedRecvbtn()&#123;    //命名管道 服务端 接收    char szBuf[100] = &#123; 0 &#125;;    DWORD dwRead;    if (!ReadFile(hNamedPipe, szBuf, 100, &amp;dwRead, NULL))&#123;        MessageBox(_T(&quot;ReadFile Failed!!!&quot;));        return;    &#125;    //接收后显示出来    MessageBox(szBuf);&#125;</code></pre><p>可以说跟之前的一个模样的~</p><hr><h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><pre><code class="cpp">HANDLE hNamedPipe;void CmyNamePipeCliDlg::OnBnClickedConnBtn()&#123;    //创建命名管道    LPCTSTR szPipeName = TEXT(&quot;\\\\.\\pipe\\mypipe&quot;);    if (0 == WaitNamedPipe(szPipeName,NMPWAIT_WAIT_FOREVER))&#123;        MessageBox(_T(&quot;当前没有可以利用的管道&quot;));        return;    &#125;    //通过打开的命名管道返回的句柄传给hNamedPipe    hNamedPipe = CreateFile(        szPipeName, GENERIC_READ | GENERIC_WRITE,        0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL    );    if (hNamedPipe == INVALID_HANDLE_VALUE)&#123;        TRACE(&quot;CreateFile failed with %d\n&quot;, GetLastError());        CloseHandle(hNamedPipe);        hNamedPipe = NULL;        return;    &#125;&#125;</code></pre><p>相比之下，客户端的连接管道就比较简单了。</p><p>然后接收发送一个样都可以直接拷贝前面的</p><pre><code class="cpp">void CmyNamePipeCliDlg::OnBnClickedSendBtn()&#123;    //命名管道 客户端 发送    char szBuf[100] = &quot;Named of Pipe Client&quot;;    DWORD dwWrite;    if (!WriteFile(hNamedPipe, szBuf, strlen(szBuf) + 1, &amp;dwWrite, NULL))&#123;        MessageBox(_T(&quot;WriteFile Failed!!!&quot;));        CloseHandle(hNamedPipe);        return;    &#125;&#125;void CmyNamePipeCliDlg::OnBnClickedRecvBtn()&#123;    //命名管道 客户端 接收    char szBuf[100] = &#123; 0 &#125;;    DWORD dwRead;    if (!ReadFile(hNamedPipe, szBuf, 100, &amp;dwRead, NULL))&#123;        MessageBox(_T(&quot;ReadFile Failed!!!&quot;));        CloseHandle(hNamedPipe);        return;    &#125;    MessageBox(szBuf);&#125;</code></pre><hr><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>首先肯定是先编译了。</p><img src="/2022/07/21/process/020.png" class=""><p>可以看到在没有建立管道的时候，点击肯定是报错的。</p><img src="/2022/07/21/process/021.png" class=""><p>老样子，点击建立，然后客户端连接之后</p><p>服务器发送 客户端接收</p><img src="/2022/07/21/process/022.png" class=""><p>客户端发送 服务器接收</p><img src="/2022/07/21/process/023.png" class=""><p>ok没啥问题~<br>除非要考到，不然这玩意我是记不住，看看文档差不多了。</p><hr><h2 id="WM-COPUDATA"><a href="#WM-COPUDATA" class="headerlink" title="WM_COPUDATA"></a>WM_COPUDATA</h2><p><code>wParam</code>传递数据的窗口的句柄</p><p><code>COPYDATASTRUCT</code></p><pre><code class="cpp">typedef struct tagCOPYDATASTRUCT &#123;    ULONG_PTR dwData;    DWORD cbData;    _Field_size_bytes_(cbData) PVOID lpData;&#125; COPYDATASTRUCT, *PCOPYDATASTRUCT;</code></pre><p><code>SPY++</code>工具专门用来查找窗口句柄<br>这玩意内置在vs里面了，在顶部工具栏里面</p><img src="/2022/07/21/process/024.png" class=""><p>打开之后就是这么一个东西</p><p>然后点窗口搜索，它可以拖动到指定的窗口去获取句柄</p><img src="/2022/07/21/process/025.png" class=""><p>这里拖到我们的vs22上面，可以看到能看到标题和句柄。</p><p>拿到这样的句柄之后可以进行通信，不过也要能写代码。不然结构不一样它也没有发送接收什么的。</p><p>这里也直接用上面写的修改一下就行了。<br>客户端发送</p><pre><code class="cpp">void CmyNamePipeCliDlg::OnBnClickedSendBtn()&#123;    //发送端    CString strWinTitle = _T(&quot;服务端&quot;);    CString strMsg = _T(&quot;Client COPYDATA&quot;);    //利用标题获取句柄    HWND hwnd = ::FindWindow(NULL, strWinTitle.GetBuffer(0));    //判断句柄有内容还是个窗口    if (hwnd != NULL &amp;&amp; IsWindow(hwnd))&#123;        //数据的封装        COPYDATASTRUCT cpd;        cpd.dwData = 0;        cpd.cbData = strMsg.GetLength() * sizeof(TCHAR);        cpd.lpData = (PVOID)strMsg.GetBuffer(0);        //1句柄 2消息类型 3主窗口 4copy结构体        ::SendMessage(hwnd, WM_COPYDATA, (WPARAM)(AfxGetApp()-&gt;m_pMainWnd),(LPARAM) &amp; cpd);    &#125;    strWinTitle.ReleaseBuffer();    strMsg.ReleaseBuffer();&#125;</code></pre><p>服务端通过wm_copydata自动接收</p><pre><code class="cpp">BOOL CmyNamePipeSerDlg::OnCopyData(CWnd *pWnd, COPYDATASTRUCT *pCopyDataStruct)&#123;    //消息响应之后解析    LPCTSTR szText = (LPCTSTR)(pCopyDataStruct-&gt;lpData);    DWORD dwLength = (DWORD)pCopyDataStruct-&gt;cbData;    TCHAR szRecvText[1024] = &#123; 0 &#125;;    memcpy(szRecvText, szText, dwLength);    MessageBox(szRecvText, _T(&quot;Y&quot;), MB_OK);    return CDialogEx::OnCopyData(pWnd, pCopyDataStruct);&#125;</code></pre><p>这个框架是通过编译器造的不用自己敲，里面的实现要自己来<br>右击图形界面，找到类向导打开，消息里面搜索然后双击就出来了</p><img src="/2022/07/21/process/026.png" class=""><p>最后跑一下</p><img src="/2022/07/21/process/027.png" class=""><p>当客户端点击发送的时候，服务端此刻不需要点击接收才能收到消息，而是自动的收到了消息。<br>这种方式可能用的会比较多。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>剪切板比较简单，他和匿名管道一样只能实现同一个机器的两个进程通信，不能跨网络。<br>邮槽基于广播，可以一对多发送，但是只能一个发一个收，要同时进行就要多写点代码。邮槽传输的数据量较小，只能是424字节一下。<br>命名管道和邮槽都可以进行网络通信，命名管道是点对点的单一通信。<br>WM_COPYDATA封装数据和解析数据，使用起来也挺方便，不过数据量比较大的话就建议用命名管道。</p><p>说参数是挺无聊的，但是实现一下也还行。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。&lt;br&gt;——百度百科&lt;/p&gt;</summary>
    
    
    
    
    <category term="windows" scheme="https://8bytes.top/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>线程-续</title>
    <link href="https://8bytes.top/2022/07/20/thread1/"/>
    <id>https://8bytes.top/2022/07/20/thread1/</id>
    <published>2022-07-20T13:41:24.000Z</published>
    <updated>2022-07-21T15:52:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>加上代码片段，markdown上一篇写的有点长了，自己都不好理了，还是分开写写吧。</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="内核对象"><a href="#内核对象" class="headerlink" title="内核对象"></a>内核对象</h2><ol><li>内核对象<br>windows中的每个内核对象都是一个内存块，它由操作系统内和分配，并且只能由操作系统内核进程访问，应用程序不能在内存中定位这些数据结构并直接更改其内容。这个内存卡本质上是一个数据结构，其成员维护着与对象相关的信息。<br><code>CreateFile</code><br>如file文件对象，event事件对象，process进程，thread线程，iocompletatinport完成端口，mailslot邮槽，mutex互斥量和registry注册表等</li><li>内核对象的使用计数和生命周期<br>因为所有者是操作系统内核，而非进程，所以说当进程退出，内核对象不一定就被销毁。<br>初次创建内核对象，使用计数为1，当另一个进程获得访问权之后，使用计数+1，当使用计数为0，操作系统内核会主动销毁内核对象。</li></ol><img src="/2022/07/20/thread1/000.png" class=""><ol start="3"><li>操作内核对象<br>通过Create之类的函数构建，成功构建后返回句柄，否则返回NULL。<br>在32位进程中，句柄是一个32位值；在64位进程中，句柄则是一个64位值。</li><li>内核对象和其他类型的对象<br>windows除了内核对象还有，窗口、菜单、字体等对象，但这些属于用户对象和GDI对象。要区分内核对象和非内核对象，最简单的方式就是查看创建这个对象的函数，几乎所有创建内核对象的函数都有一个允许我们指定安全属性的参数。</li></ol><p><strong>注：一个对象是不是内核对象，通常可以看创建次对象API的参数中是否需要<code>PSECURITY_ATTRIBUTES</code>类型的参数</strong></p><p>只有内核对象的引用计数为0时才会销毁。</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;windows.h&gt;DWORD WINAPI ThreadProc(LPVOID lpParameter)&#123;    printf(&quot;I am comming....&quot;);    while (true)&#123;    &#125;    return 0;&#125;int main()&#123;    HANDLE hThread;    HANDLE headle2;    DWORD threadId;    hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, &amp;threadId);    //创建 引用，内核计数位2    CloseHandle(hThread);        //关闭线程句柄，内核计数-1    headle2 = OpenThread(THREAD_QUERY_INFORMATION, FALSE, threadId);    headle2 = OpenThread(THREAD_QUERY_INFORMATION, FALSE, threadId);    headle2 = OpenThread(THREAD_QUERY_INFORMATION, FALSE, threadId);    return 0;&#125;</code></pre><hr><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>内核对象的状态：<br>触发状态：有信号状态，表示有可用资源<br>未触发状态：无信号状态，表示没有可用资源</p><ol><li>计数器：该内核对象被使用的次数</li><li>最大资源数量：标识信号量可以控制的最大资源数量(带符号的32位)</li><li>当前资源数量：标识当前可用的资源的数量(带符号的32位)。即表示当前开放资源的个数，注意不是剩下的资源个数。只有开放的资源才能被线程所申请，但开放的资源不一定被线程占用完。<br>比如当前开放5个资源，目前只有3个线程申请，还剩2个可以用。<br>但如果瞬发7个线程就要使用信号量，因为5个开放的资源显然不够用。</li></ol><p>信号量的规则</p><ol><li>如果当前资源计数大于0，那么信号量处于触发状态即有信号状态，表示有可用资源</li><li>如果当前资源计数等于0，那么信号量属于未触发状态即无信号状态，表示没有可用资源</li><li>系统本身绝对不会让当前资源计数变为负数</li><li>当前资源技术也绝对不会大于最大资源计数</li></ol><p><code>CreateSemaphore</code></p><pre><code class="cpp">WINBASEAPIHANDLEWINAPICreateSemaphoreW(    _In_opt_ LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,    _In_ LONG lInitialCount,    _In_ LONG lMaximumCount,    _In_opt_ LPCWSTR lpName    );#ifdef UNICODE#define CreateSemaphore  CreateSemaphoreW#endif</code></pre><p>文档详解：</p><img src="/2022/07/20/thread1/001.png" class=""><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;process.h&gt;static HANDLE semOne;static HANDLE semTwo;static int num;unsigned WINAPI Read(void *arg)&#123;    for (int i = 0; i &lt; 5; i++)&#123;        fputs(&quot;Input num:&quot;, stdout);        printf(&quot;begin read\n&quot;);        //等待内核对象信号，有信号继续执行没有就等待        WaitForSingleObject(semTwo, INFINITE);        printf(&quot;begining read\n&quot;);        scanf(&quot;%d&quot;, &amp;num);        ReleaseSemaphore(semOne, 1, NULL);    &#125;    return 0;&#125;unsigned WINAPI Accu(void *arg)&#123;    int sum = 0;    for (int i = 0; i &lt; 5; i++)&#123;        printf(&quot;begin Accu\n&quot;);                //等待内核对象semOne的信号，如果有信号继续执行，反之等待        WaitForSingleObject(semOne, INFINITE);        printf(&quot;beginning Accu\n&quot;);        sum += num;        printf(&quot;sum = %d\n&quot;, sum);        ReleaseSemaphore(semTwo, 1, NULL);    &#125;    printf(&quot;Result:%d\n&quot;, sum);    return 0;&#125;int main()&#123;    HANDLE hThread1, hThread2;    semOne = CreateSemaphore(NULL, 0, 1, NULL);    //semOne 没有可用资源 只能表示0或1的二进制信号量 无信号    semTwo = CreateSemaphore(NULL, 1, 1, NULL);    //semTwo 有可用资源 有信号状态 有信号    hThread1 = (HANDLE)_beginthreadex(NULL, 0, Read, NULL, 0, NULL);    hThread2 = (HANDLE)_beginthreadex(NULL, 0, Read, NULL, 0, NULL);    WaitForSingleObject(hThread1, INFINITE);    WaitForSingleObject(hThread2, INFINITE);    CloseHandle(semOne);    CloseHandle(semTwo);    return 0;&#125;</code></pre><img src="/2022/07/20/thread1/002.png" class=""><img src="/2022/07/20/thread1/003.png" class=""><p>因为semTwo初始有信号，所以线程开始的时候如果先调用Accu就会被卡在Wait那里，如上图2<br>而当线程先跑Read的时候虽然也执行到了scanf，但是由于我们还没有向内存输入，另一个线程Accu也已经先跑了就会看到图1的情况。</p><p>至于后续的结果，也是可以大致猜到的。<br>由于线程运行完之后都有一个重置信号的过程，所以另一个线程等到这个信号就立马执行了，导致控制台看上去有点乱。</p><img src="/2022/07/20/thread1/004.png" class=""><hr><h2 id="关键代码段"><a href="#关键代码段" class="headerlink" title="关键代码段"></a>关键代码段</h2><blockquote><p>前面学的互斥对象、事件对象、信号量这些对象都是属于内核态的线程同步。</p></blockquote><p><code>critical_section</code>关键代码段，也成为临界区，工作在用户方式下。它是指一个小代码段，在代码能够执行钱，他必须独占对某些资源的访问其。通常把多线程中的访问同一种资源的那部分代码当作关键代码段。</p><p><code>InitializeCriticalSection</code>用于初始化一个关键代码段。<br>其原型为：</p><pre><code class="cpp">WINBASEAPIVOIDWINAPIInitializeCriticalSection(    _Out_ LPCRITICAL_SECTION lpCriticalSection    );#endif  // (_WIN32_WINNT &lt; 0x0600)</code></pre><p><code>EnterCriticalSection</code>表示进入关键代码段<br>原型：</p><pre><code class="cpp">WINBASEAPIVOIDWINAPIEnterCriticalSection(    _Inout_ LPCRITICAL_SECTION lpCriticalSection    );</code></pre><p><code>LeaveCriticalSection</code>用于退出关键代码段</p><pre><code class="cpp">WINBASEAPIVOIDWINAPILeaveCriticalSection(    _Inout_ LPCRITICAL_SECTION lpCriticalSection    );</code></pre><p><code>DeleteCriticalSection</code>用于删除临界区</p><pre><code class="cpp">WINBASEAPIVOIDWINAPIDeleteCriticalSection(    _Inout_ LPCRITICAL_SECTION lpCriticalSection    );</code></pre><p>总共是初始化、进入、离开、删除四个模块</p><p><strong>看起来是真的忒长了多看一眼都没有想法</strong></p><p>魔改一下卖票功能用线程实现</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;process.h&gt;unsigned int piao = 100;CRITICAL_SECTION g_cs;DWORD WINAPI SellTicketA(void *arg)&#123;    while (true)&#123;        EnterCriticalSection(&amp;g_cs);    //进入临界区        if (piao &gt; 0)&#123;            Sleep(1);            piao--;            printf(&quot;售票口1卖出：%d张票\n&quot;, piao);            LeaveCriticalSection(&amp;g_cs);        //离开临界区        &#125; else&#123;            LeaveCriticalSection(&amp;g_cs);        //离开临界区            break;        &#125;    &#125;    return 0;&#125;DWORD WINAPI SellTicketB(void *arg)&#123;    while (true)&#123;        EnterCriticalSection(&amp;g_cs);    //进入临界区        if (piao &gt; 0)&#123;            Sleep(1);            piao--;            printf(&quot;售票口2卖出：%d张票\n&quot;, piao);            LeaveCriticalSection(&amp;g_cs);        //离开临界区        &#125; else&#123;            LeaveCriticalSection(&amp;g_cs);        //离开临界区            break;        &#125;    &#125;    return 0;&#125;int main()&#123;    HANDLE hThreadA, hThreadB;    hThreadA = CreateThread(NULL, 0, SellTicketA, NULL, 0, NULL);    hThreadB = CreateThread(NULL, 0, SellTicketB, NULL, 0, NULL);    CloseHandle(hThreadA);    CloseHandle(hThreadB);    InitializeCriticalSection(&amp;g_cs);        //初始化关键代码        Sleep(20000);    DeleteCriticalSection(&amp;g_cs);    //删除临界区    return 0;&#125;</code></pre><img src="/2022/07/20/thread1/005.png" class=""><p>因为没有了用户态的线程阻塞等待信号，两个线程的切换其实就看出没有这么频繁。或者提高线程里面的延时。</p><p>如果既没有用户态的所谓线程上锁解锁，或者现在的这个关键代码段。<br>那么多线程操作全局变量的结局就是数据重复。这个是最早的时候就提到的一个问题。</p><hr><h2 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h2><p>死锁就是指多个线程因为竞争一个资源而造成的僵局，也就是都处于等待状态。然后没有特殊处理推动，这些进程就都等在这里了。</p><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;process.h&gt;unsigned int piao = 100;CRITICAL_SECTION g_cs;CRITICAL_SECTION g_ct;DWORD WINAPI SellTicketA(void *arg)&#123;    while (true)&#123;        EnterCriticalSection(&amp;g_cs);    //进入临界区cs        Sleep(1);        EnterCriticalSection(&amp;g_ct);    //进入临界区ct        if (piao &gt; 0)&#123;            Sleep(1);            piao--;            printf(&quot;售票口1卖出：%d张票\n&quot;, piao);            LeaveCriticalSection(&amp;g_ct);        //离开临界区ct            LeaveCriticalSection(&amp;g_cs);        //离开临界区cs        &#125; else&#123;            LeaveCriticalSection(&amp;g_ct);        //离开临界区ct            LeaveCriticalSection(&amp;g_cs);        //离开临界区cs            break;        &#125;    &#125;    return 0;&#125;DWORD WINAPI SellTicketB(void *arg)&#123;    while (true)&#123;        EnterCriticalSection(&amp;g_ct);    //进入临界区ct        Sleep(1);        EnterCriticalSection(&amp;g_cs);    //进入临界区cs        if (piao &gt; 0)&#123;            Sleep(1);            piao--;            printf(&quot;售票口2卖出：%d张票\n&quot;, piao);            LeaveCriticalSection(&amp;g_cs);        //离开临界区cs            LeaveCriticalSection(&amp;g_ct);        //离开临界区ct        &#125; else&#123;            LeaveCriticalSection(&amp;g_cs);        //离开临界区cs            LeaveCriticalSection(&amp;g_ct);        //离开临界区ct            break;        &#125;    &#125;    return 0;&#125;int main()&#123;    HANDLE hThreadA, hThreadB;    hThreadA = CreateThread(NULL, 0, SellTicketA, NULL, 0, NULL);    hThreadB = CreateThread(NULL, 0, SellTicketB, NULL, 0, NULL);    CloseHandle(hThreadA);    CloseHandle(hThreadB);    InitializeCriticalSection(&amp;g_cs);        //初始化关键代码cs    InitializeCriticalSection(&amp;g_ct);        //初始化关键代码ct        Sleep(20000);    DeleteCriticalSection(&amp;g_cs);    //删除临界区cs    DeleteCriticalSection(&amp;g_ct);    //删除临界区ct    return 0;&#125;</code></pre><p>这里创建了两个<code>CRITICAL_SECTION</code>对象，然后在两个线程里，关键代码段都在互相等待。人为的去造成这种死锁的情况。</p><img src="/2022/07/20/thread1/006.png" class=""><p>因为两个线程都卡住了，所以就不会有显示。</p><blockquote><p>解决方法：避免这种叼毛写法。</p></blockquote><hr><h2 id="线程同步的比较小结"><a href="#线程同步的比较小结" class="headerlink" title="线程同步的比较小结"></a>线程同步的比较小结</h2><p>线程同步的方式主要有四种：</p><ol><li>互斥对象Mutex</li><li>事件对象Event</li><li>关键代码段criticalSection</li><li>信号量——偏冷</li></ol><ul><li>互斥对象和事件对象以及信号量都属于内核对象，利用内核对象进行线程同步，速度会比较慢，比较要wait之后重置。但是这样的内核对象可以在多个进程中的各个线程进行同步</li><li>关键代码段说到是在用户方式下，它的同步速度肯定快于前面几个。但使用关键代码段容易不留神造成死锁状态。最后就是关键代码段只适用于本进程中</li></ul><p>随便扯个表格,markdown格式写的，不确定会不会溢出。瞎看看吧。</p><table><thead><tr><th>差异&#x2F;对象</th><th>互斥对象Mutex</th><th>事件对象Event</th><th>信号量Semaphore</th><th>关键代码段criticalSection</th></tr></thead><tbody><tr><td>是否为内核对象</td><td>是</td><td>是</td><td>是</td><td>否</td></tr><tr><td>速度</td><td>较慢</td><td>较慢</td><td>较慢</td><td>快！</td></tr><tr><td>多个进程中的线程同步</td><td>支持</td><td>支持</td><td>支持</td><td>不支持</td></tr><tr><td>发生死锁现象</td><td>否</td><td>否</td><td>否</td><td>是</td></tr><tr><td>组成</td><td>一个线程ID；</br>用来标识哪个线程拥有该互斥量；</br>一个计数器：用来统计该线程用于互斥对象的次数</td><td>一个使用计数；</br>一个布尔值：用来标识该事件是自动重置还是人工重置；</br>一个布尔值：标识该事件处于有信号状态还是无信号状态</td><td>一个使用计数，</br>最大资源数，</br>标志当前可用资源数</td><td>一个小代码段。</br>在代码能执行钱，必须占用对某些资源的访问权</td></tr><tr><td>相关函数</td><td>CreateMutex;</br>WaitForsingleObjects;</br>ReleaseMutex</td><td>CreateEvent;</br>ResetEvent;</br>WaitforSingleobject;</br>SetEvent</td><td>CreateSemaphore;</br>WaitForsingleobject</br> ReleaseSemaPhore</td><td>InitializeCriticalSection<br/> EnterCriticalSection <br/> LeaveCriticalSection <br/> DeleteCriticalSection</td></tr><tr><td>注意事项</td><td>谁拥有互斥对象谁来释放。<br/>如果多次在同一个线程中请求同一个互斥对象，需要多次调用release函数</td><td>为了实现线程间的同步，不应该使用人工重置，应该把第二个参数设置为false;也就是自动重置</td><td>它允许多个线程在同一时间访问同一个资源，但是需要限制访问资源的最大数目。</td><td>防止死锁，使用多个关键代码段变量的时候</td></tr><tr><td>类比</td><td>一把钥匙</td><td>一个钥匙，自动和人工</td><td>停车场和保安</td><td>电话亭</td></tr></tbody></table><hr><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>假如你写的代码在多线程中执行和单线程中执行的结果永远完全一致，那么可以说你的代码是线程安全的。<br>就是纯纯概念</p><blockquote><p>视频推荐书籍陈硕《muduo》</p></blockquote><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>溜溜球，保持学了跟没学的状态。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;加上代码片段，markdown上一篇写的有点长了，自己都不好理了，还是分开写写吧。&lt;/p&gt;</summary>
    
    
    
    
    <category term="windows" scheme="https://8bytes.top/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>text014</title>
    <link href="https://8bytes.top/2022/07/18/text014/"/>
    <id>https://8bytes.top/2022/07/18/text014/</id>
    <published>2022-07-18T13:05:01.000Z</published>
    <updated>2022-07-24T03:08:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HWND和HANDLE"><a href="#HWND和HANDLE" class="headerlink" title="HWND和HANDLE"></a>HWND和HANDLE</h1><p>两者都是内核对象，也就是句柄。当然这是windows用来标识对象的不是c++的对象。<br>HWND一般用来定义窗口句柄<br>HANDLE用来定义任何类型的句柄，包括HWND</p><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;HWND和HANDLE&quot;&gt;&lt;a href=&quot;#HWND和HANDLE&quot; class=&quot;headerlink&quot; title=&quot;HWND和HANDLE&quot;&gt;&lt;/a&gt;HWND和HANDLE&lt;/h1&gt;&lt;p&gt;两者都是内核对象，也就是句柄。当然这是windows用来标识对象的不是c++的对象。&lt;br&gt;HWND一般用来定义窗口句柄&lt;br&gt;HANDLE用来定义任何类型的句柄，包括HWND&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
