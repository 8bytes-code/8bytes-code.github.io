<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ohmyhsy</title>
  
  <subtitle>庸人自扰</subtitle>
  <link href="https://8bytes.top/atom.xml" rel="self"/>
  
  <link href="https://8bytes.top/"/>
  <updated>2022-06-08T16:55:04.746Z</updated>
  <id>https://8bytes.top/</id>
  
  <author>
    <name>Box</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>text004</title>
    <link href="https://8bytes.top/2022/06/09/text004/"/>
    <id>https://8bytes.top/2022/06/09/text004/</id>
    <published>2022-06-08T16:53:34.000Z</published>
    <updated>2022-06-08T16:55:04.746Z</updated>
    
    <content type="html"><![CDATA[<h2 id="这评论系统。。服务不太行老挂掉，官网配置又那样我也没改啥，估计也是js和css那些远程的问题"><a href="#这评论系统。。服务不太行老挂掉，官网配置又那样我也没改啥，估计也是js和css那些远程的问题" class="headerlink" title="这评论系统。。服务不太行老挂掉，官网配置又那样我也没改啥，估计也是js和css那些远程的问题"></a>这评论系统。。服务不太行老挂掉，官网配置又那样我也没改啥，估计也是js和css那些远程的问题</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;这评论系统。。服务不太行老挂掉，官网配置又那样我也没改啥，估计也是js和css那些远程的问题&quot;&gt;&lt;a href=&quot;#这评论系统。。服务不太行老挂掉，官网配置又那样我也没改啥，估计也是js和css那些远程的问题&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>function5-栈</title>
    <link href="https://8bytes.top/2022/06/03/function5/"/>
    <id>https://8bytes.top/2022/06/03/function5/</id>
    <published>2022-06-02T16:52:34.000Z</published>
    <updated>2022-06-08T17:14:23.777Z</updated>
    
    <content type="html"><![CDATA[<h1 id="懒懒散散"><a href="#懒懒散散" class="headerlink" title="懒懒散散"></a>懒懒散散</h1><p>一天就学一会就是玩游戏刷手机~</p><span id="more"></span><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>栈这个东西，百度的也是大概，具体的内存分析还是有待深挖。</p><p>在计算机系统中，栈则是一个具有以上属性的动态内存区域。程序可以将数据压入栈中，也可以将数据从栈顶弹出。在i386机器中，栈顶由称为esp的寄存器进行定位。压栈的操作使得栈顶的地址减小，弹出的操作使得栈顶的地址增大。<br>栈在程序的运行中有着举足轻重的作用。最重要的是栈保存了一个函数调用时所需要的维护信息，这常常称之为堆栈帧或者活动记录。堆栈帧一般包含如下几方面的信息：</p><ol><li>函数的返回地址和参数</li><li>临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量。</li></ol><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>说人话栈就是为了应对临时变量所产生的一块独立的内存空间，有调用变量和函数时就由计算机自主分配调用，用完就释放。</p><ol><li>如果所有变量的内存地址都要固定，程序庞大的时候内存消耗过高</li><li>如果变量都是自主分配，麻烦不说，还要自己清理</li><li>如果一部分变量系统分配，一部分自主分配，系统分配的系统会自动清理</li></ol><p>那么结果肯定是3好。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;懒懒散散&quot;&gt;&lt;a href=&quot;#懒懒散散&quot; class=&quot;headerlink&quot; title=&quot;懒懒散散&quot;&gt;&lt;/a&gt;懒懒散散&lt;/h1&gt;&lt;p&gt;一天就学一会就是玩游戏刷手机~&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://8bytes.top/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>function4-本质和函数指针</title>
    <link href="https://8bytes.top/2022/06/01/function4/"/>
    <id>https://8bytes.top/2022/06/01/function4/</id>
    <published>2022-05-31T16:11:51.000Z</published>
    <updated>2022-06-08T16:39:24.979Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>vs ide 可以选择x86编译和x64编译，同时一个项目它也存在两个版本</p><ul><li>debug 版本就是常说的测试版本， bug就是漏洞的意思。</li><li>release 版本就是正常发行版本， 说明这个版本的漏洞相对于debug比较少，毕竟是先测试后发布。<img src="/2022/06/01/function4/000.png" class=""></li></ul><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p>debug的反汇编会多一些内容，这里使用release版本好分析。<br>在项目-属性-c&#x2F;c++-优化中关闭优化：</p><img src="/2022/06/01/function4/001.png" class=""><p>原则上优化肯定会带来性能上的提升，但不利于人为分析。</p><pre><code class="cpp">#include&lt;iostream&gt;int Add(int a, int b)&#123;    return a + b;&#125;int main()&#123;    int c = Add(1, 2);        return 0;&#125;</code></pre><p>老样子在int c那里打断点运行然后反汇编：</p><img src="/2022/06/01/function4/002.png" class=""><p>可以看到整体反汇编代码还是很简洁的。</p><p>同时<code>int c = Add(1,2);</code>的下面有一句<code>call Add(0FC1000h)</code>其实就是要跳转到add函数的位置</p><blockquote><p>ps:我打开了显示符号名，所以call才会显示函数名，关闭显示符号名则只有后面的地址，怎么好理解怎么来</p></blockquote><img src="/2022/06/01/function4/003.png" class=""><p>在上面的地址栏里输入0x add的地址，<strong>不用加那个h</strong></p><img src="/2022/06/01/function4/004.png" class=""><p>可以看到的确跳转到了add函数的反汇编区域，并且add函数的第一个指令地址起始值也是<code>00FC1000</code></p><img src="/2022/06/01/function4/005.png" class=""><p>回到<code>int c = Add(1,2);</code>的反汇编，在跳转到Add函数前，编译器push了两个值分别是2和1，这正好是我们传递给Add的参数，只不过是后面的先push进去。</p><ol><li>ebp 可以叫做栈底寄存器</li><li>esp 可以叫做栈顶寄存器</li><li>栈的内存地址生长方式是由高到低</li></ol><p><code>00FC1003  mov         eax,dword ptr [ebp+8]</code>，就是将ebp+8这个地址里的值赋给eax寄存器，ebp在跳转到函数的时候就被赋予了esp的值，大概就是传递了一个临时变量的值。<br><code>00FC1006  add         eax,dword ptr [ebp+0Ch]</code>，这里又让eax add 加上 ebp+0C这块地址里的值，0C和8的差是4，说明可能是int类型的数据。<br>然后pop ebp，把ebp弹出栈了。——目前还不太好解释<br>最后ret ，跟return似乎有关联，就是告诉编译器这段运行完了，可以回去了。</p><p>按照我个人的理解花了草图：</p><img src="/2022/06/01/function4/007.png" class=""><blockquote><p>红色是跳转到add函数的时候发生的，黑色则是main函数里面正常的情况。</p></blockquote><hr><img src="/2022/06/01/function4/006.png" class=""><p>编程语言-汇编-机器码<br>我们通过反汇编得到的不管是左边的内存地址还是右边的指令都还是人为能够看明白的操作，而中间的8B EC那些才是存在本地硬盘上让机器读取的。</p><blockquote><p>ps : 还有一层二进制数据没转化</p></blockquote><hr><p>再反汇编的时候，我们看到call 函数地址，说明了函数也有内存地址。</p><img src="/2022/06/01/function4/008.png" class=""><p>直接打印就可以得到地址。</p><pre><code class="cpp">char *p = (char *)Add;for (int i = 0; i &lt; 30; i++)&#123;   //30是随便指定的，程序经过优化后谁也不确定函数的内容到底有多少，只有编译完成后才能知道    printf(&quot;%02X\n&quot;, p[i]);&#125;</code></pre><p>既然是地址，就能通过地址显示内容，但是函数里的内容会是什么？</p><img src="/2022/06/01/function4/009.png" class=""><p>这样看还是有点不直观，可能因为p[i]被当成指针地址四个字节四个四个字节读取了</p><pre><code class="cpp">char *p = (char *)Add;for (int i = 0; i &lt; 30; i++)&#123;    printf(&quot;%02X\n&quot;, (unsigned char)p[i]);&#125;</code></pre><p>把他强转成无符号的char类型数据，再次打印：</p><img src="/2022/06/01/function4/010.png" class=""><p>发现似乎有点眼熟？<br>对比我们之前截的图，在显示了代码字节的情况下【中间部分】：</p><img src="/2022/06/01/function4/006.png" class=""><p>跟函数内存储的字节是一模一样的顺序下去。</p><blockquote><p>想看二进制的可以引用头文件bitset来着，然后std::bitset&lt;8&gt;控制二进制流输出<br>不过反正也看不懂。16进制都很勉强了。</p></blockquote><hr><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>在C语言和c++里，只要是有内存地址，就会被指针拿来玩。</p><p>对于指针函数，很好理解就是返回一个指针的函数</p><pre><code class="cpp">int* hhh()&#123;    return *; //例如这样，当然实际不可取。&#125;</code></pre><p>对于函数而言，比较重要的是参数和返回值，在反汇编中，函数的地址</p><p><strong>那么如何定义一个函数指针？</strong><br><code>函数返回类型 (*函数指针变量名)(参数类型 参数名称，......)</code><br>例如<code>int (*pAdd)(int a, int b);</code><br>当然void类型依旧可以使用。<br>其次就是参数的问题，形参不仅是接受传递进来的值，形参名在函数内实现会被用到，但是定义的时候是可以忽略形参名的，比如<code>int (*pAdd)(int , int );</code>，毕竟他可以指向一个函数，关键点还是在于那个函数怎么实现。</p><pre><code class="cpp">int (*pAdd)(int a, int b) = Add;int x = pAdd(5, 6);std::cout &lt;&lt; x &lt;&lt; std::endl;</code></pre><p>打印后结果：<img src="/2022/06/01/function4/011.png" class=""></p><blockquote><p>函数指针也是指针，所以它的大小也不用多说，x86下自然为4字节，x64下为8字节。<br>有疑问可以自己sizeof查看。不过这是基础概念了。</p></blockquote><p>当遇上类型不同的函数时，万能的强转大法又回来了</p><pre><code class="cpp">float Add(int a, int b)&#123;    return a + b;&#125;int main()&#123;    int (*pAdd)(int a, int b) = (int (*)(int,int))Add;    int x = pAdd(5, 6);    std::cout &lt;&lt; x &lt;&lt; std::endl;    return 0;&#125;</code></pre><p>格式如代码所示，依旧是采用<code>返回类型 * 参数类型，参数类型</code><br><strong>注：即使函数原型返回类型是float，但是强转之后为int，当输出的时候也会隐转成int类型，float转int的特定就是没有四舍五入的说法，直接抹去小数点后面的</strong></p><img src="/2022/06/01/function4/012.png" class=""> 可以看到（5+6）/2应该是5.5，但是强转的时候改变了类型，所以结果变成了5。<p>强转成char的话，如果在ASCII码内，就可以打印正常的字符，不然出现乱码也说不定。</p><p>但是相比较，函数指针的写法有点长，虽然cv码农问题不大，但是之前C语言学过<code>typedef</code>，这里就能用上</p><pre><code class="cpp">typedef int(*piAdd)(int, int);typedef char(*pcAdd)(int, int);float Add(int a, int b)&#123;    return (a + b)/2;&#125;int main()&#123;    piAdd pAdd= (piAdd)Add;    int x = pAdd(5, 6);    std::cout &lt;&lt; x &lt;&lt; std::endl;    return 0;&#125;</code></pre><p>这样看上去整体简洁一些，带有C语言的味道，而c++则是可以通过using实现</p><pre><code class="cpp">using pI_Add = int(*)(int, int);float Add(int a, int b)&#123;    return (a + b)/2;&#125;int main()&#123;    pI_Add pi = (pI_Add)Add;    int y = pi(1, 2);    return 0;&#125;</code></pre><p>效果也是一样一样的。</p><p>总结就是三种声明办法：</p><pre><code class="cpp">typedef int(*piAdd)(int, int);      //声明函数指针类型using pI_Add = int(*)(int, int);    //声明函数指针类型int (*pAdd)(int,int) = Add;         //声明函数指针变量</code></pre><p>然后就是结构体参数的时候</p><pre><code class="cpp">struct Box&#123;    int a;    int b;&#125;;int sum(Box box)&#123;    return box.a + box.b;&#125;int main()&#123;    Box box&#123;1,2&#125;;    std::cout &lt;&lt; sum(box) &lt;&lt; std::endl;    return 0;&#125;</code></pre><img src="/2022/06/01/function4/013.png" class=""><p>结果自然是3，但是写成函数指针的时候，参数如何操作。</p><pre><code class="cpp">struct Box&#123;    int a;    int b;&#125;;using pBox = int(*)(Box);   //这样写自然没错，但是要先声明结构体Box，容易造成误会</code></pre><img src="/2022/06/01/function4/014.png" class=""><p>当然结构体原型就是两个int类型的参数，所以直接使用两个形参效果也ok的。</p><pre><code class="cpp">using pBox = int(*)(int,int);int main()&#123;    pBox pb = (pBox)sum;            //函数指针的参数不再是结构体，所以需要强转    std::cout &lt;&lt; pb(2,4) &lt;&lt; std::endl;    return 0;&#125;</code></pre><p>结果如图：<img src="/2022/06/01/function4/015.png" class=""><br>当然不用2，4用box的参数也无可厚非，意义是相同的：<img src="/2022/06/01/function4/016.png" class=""></p><p>转到反汇编查看当传递结构体进去时发生的变化：</p><img src="/2022/06/01/function4/017.png" class=""><blockquote><p>call 不用多说，就是跳转到sum这个函数去，那么在跳转之前先传递了两个值<br>一个ebp-8 一个ebp-0C其实也就是ebp-12，两者差4，说明极有可能就是结构体内的参数</p></blockquote><p>打开显示符号名，发现：<img src="/2022/06/01/function4/018.png" class=""></p><blockquote><p>ebp-0C变成box结构体变量名了<br>参照之前百度，栈的内存地址是由高到低，由右向左<br>故此推测ebp-12是box.a的值，而ebp-8那块地址上就是box.b的值</p></blockquote><p>再到地址栏那块输入0x00b31000,跳转至sum函数处：</p><img src="/2022/06/01/function4/019.png" class=""><p>也就是说先将a的值传给eax寄存器，再将b的值给eax相加最后返回。</p><hr><h2 id="自己推敲一下反汇编"><a href="#自己推敲一下反汇编" class="headerlink" title="自己推敲一下反汇编"></a>自己推敲一下反汇编</h2><p><strong>注：项目属性关于c&#x2F;c++的优化处于禁用状态，然后模式为release</strong><br>之所以这么改是因为debug的内容比较多，再加上优化的话更不适合新手推敲了。</p><img src="/2022/06/01/function4/020.png" class=""><blockquote><p>在主函数压入栈时，push ebp，ebp那会的值是005DFEFC</p></blockquote><img src="/2022/06/01/function4/021.png" class=""><blockquote><p>单步调试，esp的值还没同步ebp，等mov这条指令走完之后看到</p></blockquote><img src="/2022/06/01/function4/022.png" class=""><blockquote><p>现在看到esp和ebp持平了。sub是减法的意思，再往下走</p></blockquote><img src="/2022/06/01/function4/023.png" class=""><blockquote><p>esp-0c得到的结果就是005DFEA8，ebp不变</p></blockquote><p>用画图表示大概就是这样：<img src="/2022/06/01/function4/024.png" class=""><br>然后在看后面的汇编：<img src="/2022/06/01/function4/025.png" class=""><br>自己画图表示的话大概是：<img src="/2022/06/01/function4/026.png" class=""><br><strong>然后我就发现不对劲的地方。。sum和add好像还是被优化了，因为两个效果好像类似，所以函数地址居然都是指向了add</strong><br>也就是：<img src="/2022/06/01/function4/027.png" class=""><br>既然已经被优化了那就先不管了。</p><img src="/2022/06/01/function4/028.png" class=""><p>add函数里的两个算是常量了，都被直接push进去，然后call到add函数位置。<br>至于<code>sum(box)</code>，因为在上面初始化box的时候就看到了1和2存在哪个地址了，所以这里看起来并不费劲。<br>ebp-8存的2，ebp-0c存的1，都分别把值传给一个寄存器，然后push进函数。</p><p>最后输出的那句：<img src="/2022/06/01/function4/029.png" class=""><br>前面也不难看懂，第一个push不知道是不是std流，先不管，然后传递box.b的值给edx，在push edx；传递box.a的值给eax，在push进去；call ebp-4的地址上就是我们声明的pb函数指针。最后面那几句还真不之地干啥的目前。</p><hr><h2 id="自定义函数指针做形参"><a href="#自定义函数指针做形参" class="headerlink" title="自定义函数指针做形参"></a>自定义函数指针做形参</h2><pre><code class="cpp">using pI_Add = int(*)(int, int);int Add(int a, int b)&#123;    return a + b;&#125;int test(int a, int b, pI_Add pa)&#123;    return pa(a, b);&#125;int main()&#123;    std::cout &lt;&lt; test(1,20,Add) &lt;&lt; std::endl;    return 0;&#125;</code></pre><p>结果自然显而易见：<img src="/2022/06/01/function4/030.png" class=""></p><p>虽然以现在案例的复杂度肯定用不上，等以后了没准还真有这种写法。</p><hr><p>函数指针和指针函数？</p><p>指针函数就是指一个返回值是指针的函数<br>而函数指针虽然本身也是一个指针，但是它是指向一个特定类型的函数，它的返回值看的是指向的函数。</p><p>硬要区分的话函数指针的变量名带阔号了哈哈哈！</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>六一的快乐停留在了幼稚园~</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;vs ide 可以选择x86编译和x64编译，同时一个项目它也存在两个版本&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;debug 版本就是常说的测试版本， bug就是漏洞的意思。&lt;/li&gt;
&lt;li&gt;release 版本就是正常发行版本， 说明这个版本的漏洞相对于debug比较少，毕竟是先测试后发布。&lt;img src=&quot;/2022/06/01/function4/000.png&quot; class=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://8bytes.top/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>function3-左值右值</title>
    <link href="https://8bytes.top/2022/05/31/function3/"/>
    <id>https://8bytes.top/2022/05/31/function3/</id>
    <published>2022-05-30T17:25:37.000Z</published>
    <updated>2022-06-05T07:12:41.143Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在C语言中什么叫左值和右值</p><pre><code class="cpp">int a = 3;//a为左值，3为右值</code></pre><ul><li>左值一般是变量，在程序运行时有一个准确的地址和值，除了const的情况下一般都能修改。</li><li>右值则一般是常量或者临时对象，除非强转之类的操作，其它情况下一般不能修改</li></ul><blockquote><p>在编译报错的时候应该或多或少也见过到提示右值不可被修改</p></blockquote><span id="more"></span><p>不过上述的说法也并不绝对</p><pre><code class="cpp">int a = 1;int b = 2;a = b;</code></pre><p>这里的右值b它是一个变量。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><pre><code class="cpp">void AddSum(int a)&#123;    std::cout &lt;&lt; a &lt;&lt; &quot;\n&quot;;&#125;int main()&#123;    int a = 10;    AddSum(10 + 20);    return 0;&#125;</code></pre><img src="/2022/05/31/function3/000.png" class=""><blockquote><p>在正常情况下，int a &#x3D; 10; 编译器把10转换成十六进制赋值给ebp-8的位置上<br>而调用函数传参的时候使用算术表达式他也会默认先算好，可能这里函数的反汇编不明显<br>稍微改动一下让a+10+20</p></blockquote><img src="/2022/05/31/function3/001.png" class=""><blockquote><p>这里就很清楚的看到编译器先将ebp-8的地址传给eax寄存器，然后eax寄存器在加上1E,也就是30</p></blockquote><p>正常的变量作为左值都好解释，数组和指针的时候：</p><pre><code class="cpp">int array[10];int *p = array;     //array是数组，默认表示数组首地址array[0]。所以不需要加&amp;。array[0];//属于一个合格的左值，有具体位置*p 和 p //也属于左值，*p在此处表示array[0]的地址，而p本身是个指针，指针也有他自己的地址&amp;array[0]; //就不属于了，这个标识array[0]的地址，做不了左值*(p+1); //这个就有点意思了，其实就是array[1],或者说p[1]p+1; //就不对头了，这只是让地址单纯偏移一个类型长度，得到的是地址，</code></pre><hr><h2 id="左值引用和右值引用"><a href="#左值引用和右值引用" class="headerlink" title="左值引用和右值引用"></a>左值引用和右值引用</h2><pre><code class="cpp">int a = 10;int &amp;b = a; //b引用了aint &amp;&amp;c = b;    //但此处引用c不能引用b，这种多级套娃的形式在指针里是可以的//引用的原则就是int &amp;c = b;这样是合法的。</code></pre><img src="/2022/05/31/function3/002.png" class=""><p>编译器提示无法将 右值引用绑定到左值，</p><p>那么两个&amp;该怎么用：</p><pre><code class="cpp">int &amp;&amp;c = 150+120;</code></pre><p>显然是给他引用一个右值为这种算术表达式。但是注意修改c没有太大意义，因为右值是固定的。<br>那么右值引用的场景在哪。</p><pre><code class="cpp">void AddSum(int &amp;a)&#123;    std::cout &lt;&lt; a &lt;&lt; &quot;\n&quot;;&#125;int main()&#123;    int a = 10;    int &amp;b = a;     int &amp;&amp;c = 150+120;        AddSum(a + 150 + 200);    return 0;&#125;</code></pre><img src="/2022/05/31/function3/003.png" class=""><p>当函数参数为左值引用时，没办法传递表达式进去，所以右值引用的场景就来了</p><pre><code class="cpp">void AddSum(int &amp;&amp;a)&#123;    std::cout &lt;&lt; a &lt;&lt; &quot;\n&quot;;&#125;int main()&#123;    int a = 10;    int &amp;b = a;     int &amp;&amp;c = 150+120;        AddSum(a + 150 + 200);    return 0;&#125;</code></pre><p>当然可以先用一个变量接受这个表达式：</p><pre><code class="cpp">void AddSum(int &amp;a)&#123;    std::cout &lt;&lt; a &lt;&lt; &quot;\n&quot;;&#125;int main()&#123;    int a = 10;    int &amp;b = a;     int &amp;&amp;c = 150+120;        int x = a + 150 + 200;    AddSum(x);    return 0;&#125;</code></pre><p>这个是没啥问题，语义是通顺的。</p><img src="/2022/05/31/function3/004.png" class=""><img src="/2022/05/31/function3/005.png" class=""><blockquote><p>int x毕竟是额外开辟了内存空间去保存这个表达式的值，虽然临时变量也会占内存，但是至少临时变量销毁比局部变量快。</p></blockquote><hr><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>&amp;在C语言中，我们通俗的说是取地址符，而在cpp中多了引用的概念<br>区分的方式就是 参照 &#x3D;<br>当&amp; 在变量定义区域，表示引用：<code>int &amp;b = a</code><br>当&amp; 在变量操作区域，表示取地址：<code>int *p = &amp;a;</code></p><p>然后来个玄乎的 <code>&amp;*p 和 *&amp;p</code>，在变量定义区域时：</p><pre><code class="cpp">int a = 10;int *p = &amp;a;int *&amp;p1 = p;   //合法int &amp;*p2 = p;   //不合法</code></pre><p><code>int *&amp;p1 = p</code>先当与指向一个引用，指针引用。<br><code>int &amp;*p2 = p</code>引用一个指针显然是不对的。引用本身就是一个弱化版本的指针，编译器也提示错误<img src="/2022/05/31/function3/006.png" class=""></p><p>在变量操作时：</p><pre><code class="cpp">int a = 10;std::cout &lt;&lt; *&amp;a &lt;&lt; std::endl;  //合法，相当于*(&amp;a),其实就是做了一次解引用的操作，指向a的地址，使用起来就是a的值。std::cout &lt;&lt; &amp;*a &lt;&lt; std::endl;  //error,很简单用法问题，a是int类型的变量，直接取地址一个指针a在此处不合理。</code></pre><p>修改成指针呢？</p><pre><code class="cpp">int a = 10;int *p = &amp;a;std::cout &lt;&lt; &amp;a &lt;&lt; std::endl;std::cout &lt;&lt; *&amp;p &lt;&lt; std::endl;  //上述说过相当于*(&amp;p),&amp;p的地址上存放的是a的地址，*就变成解读&amp;pstd::cout &lt;&lt; &amp;*p &lt;&lt; std::endl;  //而*p表示a的值就是10，&amp;(*p)，就是相当于&amp;a;</code></pre><img src="/2022/05/31/function3/007.png" class=""><p>可以看到地址都是一样的。</p><blockquote><p>这个纯看理解，不行多试几个例子或者看看反汇编。重在能区分。</p></blockquote><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>自古指针都是很恶心的东西，不管放到哪里。要合理区分&amp;是引用还是取地址的情况。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在C语言中什么叫左值和右值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;int a = 3;
//a为左值，3为右值
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;左值一般是变量，在程序运行时有一个准确的地址和值，除了const的情况下一般都能修改。&lt;/li&gt;
&lt;li&gt;右值则一般是常量或者临时对象，除非强转之类的操作，其它情况下一般不能修改&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在编译报错的时候应该或多或少也见过到提示右值不可被修改&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://8bytes.top/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>function2</title>
    <link href="https://8bytes.top/2022/05/30/function2/"/>
    <id>https://8bytes.top/2022/05/30/function2/</id>
    <published>2022-05-30T14:51:51.000Z</published>
    <updated>2022-06-04T17:25:11.731Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前提到过函数是什么类型的就需要返回什么类型的值，正常变量类型都还好，当指针和引用的时候就有意思了</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><pre><code class="cpp">int main()&#123;    char *str;    str = (char *)&quot;你好世界&quot;;    std::cout &lt;&lt; str;    return 0;&#125;</code></pre><p>C语言的字符串最常用的就是数组的方式声明，反正数组的底层就是指针，所以你用指针也行。</p><img src="/2022/05/30/function2/000.png" class=""><p>但是在使用指针强转的时候，右值的这串中文它属于一个常量，也就是说指针指向了一块常量内存，你就没办法修改它了。<br>如图：<img src="/2022/05/30/function2/001.png" class=""><br>编译器给出了错误，就是说我们没有权限对这块内存写入。</p><p>要套娃的话就是赋给字符串然后强转再改，或者拷贝给另一个字符串，反正能得到结果是首要目标。</p><hr><p>这里就利用自定义函数去拷贝修改返回一个想要的值。</p><pre><code class="cpp">char* cstr(const char *str)&#123;&#125;</code></pre><p>拷贝函数<code>memcpy()</code>，不过要知道str的长度和一个跟str一样大的指针变量<br>可以直接在cstr里面for循环求长度，也可以自定义函数，因为学的函数这块就姑且用函数了。</p><pre><code class="cpp">int cLen(const char *str)&#123;    int i = 0;    for (; str[i]; i++);    return ++i;         //因为需要返回i，所以int i的时候就不能写在for循环里面了，不然局部变量出了for循环i就没了&#125;char *cstr(const char *str)&#123;    int len = cLen(str);    char *strP = new char[len];    //用指针动态分配内存的原因也是因为char在函数中的不仅是局部变量而且存在栈区，函数结束后就销毁了，返回了也没意义    //而动态分配的内存处于堆区，没有delect之前就搁堆区老老实实呆着    memcpy(strP, str, len);    return strP;&#125;</code></pre><p>结果如图：<img src="/2022/05/30/function2/002.png" class=""></p><p>这个时候你再修改main函数里的str就无所谓了，不是常量了，虽然在空间角度上是有一定浪费.</p><img src="/2022/05/30/function2/003.png" class=""><p>就不打印了毕竟中文占两字节，改了一个估计开头要乱码。</p><hr><p>假设一个游戏有这个一个结构体，做初始化角色用。</p><pre><code class="cpp">struct Box&#123;    const char *name;    int hp;    int mp;&#125;;</code></pre><p>我们给通过函数传值的时候，怎么传会更友好。</p><pre><code class="cpp">Box createRole(const char* name, int hp, int mp)&#123;    Box box&#123; name,hp,mp &#125;;    return box;&#125;</code></pre><p>如果在函数里额外声明一个结构体变量赋值返回，显得很2<br>因为对于内存上它反复开辟销毁很麻烦，虽然字面上很好理解是干什么的。<br>但如果是指针类型的结构体则友好很多，这里就要改一下结构体了</p><pre><code class="cpp">typedef struct box&#123;    char *name;    int hp;    int mp;&#125;*Boxs,Box;//通过typedef给指针类型的box改名Boxs，正常的box就用Box即可。Boxs createRole(const char* name, int hp, int mp)&#123;    Boxs box = new Box&#123; cstr(name),hp,mp &#125;;    //传递进来的name我们不希望乱改，就用了const但是结构体参数并不是const，所以用我们之前自定义的函数套一下    return box;&#125;int main()&#123;    Boxs b = createRole(&quot;aaaa&quot;,100,100);    return 0;&#125;</code></pre><blockquote><p>对于返回指针类型的函数时，我们需要额外注意这个指针变量不要返回局部变量</p></blockquote><img src="/2022/05/30/function2/005.png" class=""><p>还有一种引用的方法</p><pre><code class="cpp">typedef struct box&#123;    char *name;    int hp;    int mp;&#125;*Boxs,Box;Box&amp; createRole(const char* name, int hp, int mp)&#123;    Boxs box = new Box&#123; cstr(name),hp,mp &#125;;    return *box;&#125;int main()&#123;    Box b = createRole(&quot;aaaa&quot;,100,100);    return 0;&#125;</code></pre><blockquote><p>引用和指针，指针传递失败还有空指针，引用没有空指针</p></blockquote><img src="/2022/05/30/function2/004.png" class=""><blockquote><p>如图可以看到，当函数是结构体指针类型的时候，接受的一方也得是结构体指针<br>而在引用的时候，接受的一方只需要是相同的结构体即可。</p></blockquote><hr><p>再看引用做参数时的问题</p><pre><code class="cpp">void Add(int x)&#123;    x += 100;&#125;</code></pre><img src="/2022/05/30/function2/006.png" class=""><p>这个代码一看就知道没有意义，因为传进去的只是一个值，x加完离开函数就销毁了。想要真的改变就可以用引用</p><pre><code class="cpp">void Add(int &amp;x)&#123;    x += 100;&#125;</code></pre><img src="/2022/05/30/function2/007.png" class=""><p>引用作为参数的时候，它更加严谨，当传入的变量类型不一致的时候，引用是不能完成操作的</p><pre><code class="cpp">void Add(int &amp;x)&#123;    x += 100;&#125;int main()&#123;    float a = 150.0f;    Add(a);    std::cout &lt;&lt; a;&#125;</code></pre><img src="/2022/05/30/function2/008.png" class=""><p>很直观的就报错了，甚至都懒得进行隐式转换截断掉后面小数。</p><pre><code class="cpp">void Add(int x)&#123;    x += 100;&#125;int main()&#123;    float a = 150.0f;    Add(a);    std::cout &lt;&lt; a;&#125;</code></pre><p>当形参不是引用类型的时候，编译器也懒得鸟你，大不了隐式转换掉。</p><hr><p>数组的引用变量</p><pre><code class="cpp">int ch[10];int &amp;ch1[10] = ch;</code></pre><p>这个写法直接无情报错：<img src="/2022/05/30/function2/009.png" class=""><br>它说不能使用引用的数组，这其实是编译器没有理解。</p><pre><code class="cpp">int ch[10];int (&amp;ch1)[10] = ch;</code></pre><p>先告诉编译器ch1是一个引用，然后是一个引用长度为10的数组引用。<br>引用也保持了数组要明确大小的问题，引用数组长度10，被引用的对象的长度也只能为10，否则编译不通过。</p><hr><p>使用引用数组作为形参的时候</p><pre><code class="cpp">void sumI(int(&amp;ch)[10])&#123;    std::cout &lt;&lt; sizeof(ch);&#125;</code></pre><img src="/2022/05/30/function2/010.png" class=""><p>它可以用sizeof计算长度，这个相对于指针和不定量参数的时候会方便很多。<br>而且可以使用新版for循环</p><pre><code class="cpp">int sumI(int(&amp;ch)[10])&#123;    //std::cout &lt;&lt; sizeof(ch);    int sum = 0;    for (auto x : ch) sum += x;    return sum;&#125;int main()&#123;    int ch[10] = &#123;1,2,3,4,5,6,7,8,9,10&#125;;    int x = sumI(ch);    std::cout &lt;&lt; x;    return 0;&#125;</code></pre><img src="/2022/05/30/function2/011.png" class=""><p>还是挺得劲的。<br><strong>仅限于数组长度明确的时候得劲</strong></p><hr><h2 id="strcpy-s"><a href="#strcpy-s" class="headerlink" title="strcpy_s"></a>strcpy_s</h2><pre><code class="cpp">_Check_return_wat__ACRTIMP errno_t __cdecl strcpy_s(    _Out_writes_z_(_SizeInBytes) char*       _Destination,    _In_                         rsize_t     _SizeInBytes,    _In_z_                       char const* _Source    );</code></pre><p>这是在string头文件中的定义。</p><p>为什么会有_s的版本，是因为strcpy原则上是不安全的，它存在致命的缺陷就是缓冲区溢出</p><blockquote><p>缓冲区的溢出就是程序在动态分配的缓冲区中写入了太多的数据，使这个分配区发生了溢出。一旦一个缓冲区利用程序能将运行的指令放在有 root权限的内存中，运行这些指令，就可以利用 root 权限来控制计算机了。<br>默认情况下strcpy都会认为你的缓冲区够大，就只管填充。</p></blockquote><p>回过头来看strcpy_s的形参，char*和char const*都好理解，不能改变的说明是要被拷贝的字符串<br>至于rsize_t速览定义看到其实是一个无符号整型</p><img src="/2022/05/30/function2/012.png" class=""><p>猜测可能是长度有关的。<br>大致使用起来就是<code>strcpy_s(str,strlen(str1),str1);</code></p><p>简单的百度了一下，strlen要+1。<code>strcpy_s(str, strlen(str1)+1, str1);</code></p><p>+1大概是因为stelen没有统计到<code>\0</code>吧，不过如果缓冲区大小不够，发出异常这个不晓得怎么操作<br>按照我们现学现卖就是if判断大小，不行就提示，抛出异常这个面向对象的特点要放后面了。</p><blockquote><p>ps:像当初刚打开vs2019的时候，scanf就会报错，说不安全，要用scanf_s是一个道理，这些都是后面加的安全函数。</p></blockquote><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>欲知后事如何请看下回分解</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前提到过函数是什么类型的就需要返回什么类型的值，正常变量类型都还好，当指针和引用的时候就有意思了&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://8bytes.top/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>function1</title>
    <link href="https://8bytes.top/2022/05/29/function1/"/>
    <id>https://8bytes.top/2022/05/29/function1/</id>
    <published>2022-05-28T16:31:51.000Z</published>
    <updated>2022-06-04T14:50:10.103Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>自定义函数的形式和大致参数已经明确，然后就是返回指针和引用之类的.</p><span id="more"></span><hr><h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><ul><li>cstdarg</li></ul><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>main函数的参数虽然也可以叫不定量，但是毕竟是提前规定了的。</p><hr><pre><code class="cpp">int Add(unsigned count, ...)&#123;&#125;</code></pre><blockquote><p>比如实现一串不定量的数字求和，后面的参数就可以用…这种写法，但是必须要知道个数<br>虽然后面用省略表示不定量，但是不是直接说就是数组了，函数里调用起来也挺稀奇的<br>不过越是稀奇古怪用到的就越少，毕竟实际上没有这么多不定量的场景</p></blockquote><pre><code class="cpp">int x = Add(5,1,2,3,4,5);</code></pre><p>调用的时候没啥特殊，但在实现部分中，如何调用<code>...</code>才是重点</p><pre><code class="cpp">int Add(unsigned count, ...)&#123;    va_list arg;&#125;</code></pre><p>va_list其实就是一个char*类型的变量：<img src="/2022/05/29/function1/000.png" class=""><br>如果直接使用<code>char* arg</code>也无可厚非。</p><p>然后就是传递不定量的值，因为引用了cstdarg头文件，所以可以使用封装好的</p><pre><code class="cpp">int Add(unsigned count, ...)&#123;    va_list arg;    va_start(arg,count);&#125;</code></pre><img src="/2022/05/29/function1/001.png" class=""><blockquote><p>传递到指针之后，需要注意用什么类型去读取</p></blockquote><pre><code class="cpp">int Add(unsigned count, ...)&#123;    va_list arg;    va_start(arg,count);    va_arg(arg, int);&#125;</code></pre><blockquote><p>va_arg的特点就是可以重复读取，毕竟每调用一次才能往后读取不定量参数<br>于是乎就可以写个for循环。</p></blockquote><pre><code class="cpp">int Add(unsigned count, ...)&#123;    va_list arg;    va_start(arg,count);    int sum = 0;    for(int i&#123;&#125;; i&lt;count; i++)&#123;        sum += va_arg(arg, int);    &#125;    return sum;&#125;</code></pre><blockquote><p>同理int 类型的函数，别忘了返回值。</p></blockquote><p><strong>然后还要特别注意，因为va_list是一个指针，虽然函数声明周期结束变量可能会被回收，但是肯定是有人为的方式去消除</strong></p><pre><code class="cpp">int Add(unsigned count, ...)&#123;    va_list arg;    va_start(arg,count);    int sum = 0;    for(int i&#123;&#125;; i&lt;count; i++)&#123;        sum += va_arg(arg, int);    &#125;    va_end(arg);    return sum;&#125;</code></pre><blockquote><p>那就是va_end(); 用完记得手动释放吧。</p></blockquote><p>最后在main接收返回值并打印</p><img src="/2022/05/29/function1/002.png" class=""><blockquote><p>当然如果说都是一种类型，显然单纯的for循环不是更快<br>所以不定量的含义同时也包含了不同类型的参数时，不过在va_arg的时候你需要合理的控制读取的类型，可能也稍显2b，毕竟也挺麻烦</p></blockquote><hr><pre><code class="cpp">int Add(unsigned count, ...)&#123;    va_list arg;    va_start(arg,count);    std::cout &lt;&lt; &amp;arg &lt;&lt; std::endl;    int sum = 0;    for(int i&#123;&#125;; i &lt; count; i++)&#123;        printf(&quot;arg累加前：%p\n&quot;,arg);          //也可以用std::cout &lt;&lt; std::hex &lt;&lt; (int)arg;但是感觉C语言这种格式化输出在这里更方便。        sum += va_arg(arg, int);    &#125;    va_end(arg);    return sum;&#125;</code></pre><img src="/2022/05/29/function1/003.png" class=""><p>简单的打印一下循环开始前arg的地址和每一次变化后地址。<br>不难看出地址每次增加的4其实就是跟变量类型有关。</p><hr><p>你说自己实现类似的功能也不难，但是要规避其它风险的时候设计起来就蹑手蹑脚了，所以说有一些标准需要委员会去发布。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>白天上课刷手机，下午晚上有空打游戏，大半夜回头补补也是没谁了~</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;自定义函数的形式和大致参数已经明确，然后就是返回指针和引用之类的.&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://8bytes.top/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>functionTest</title>
    <link href="https://8bytes.top/2022/05/28/functionTest/"/>
    <id>https://8bytes.top/2022/05/28/functionTest/</id>
    <published>2022-05-27T17:23:23.000Z</published>
    <updated>2022-06-02T16:25:40.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>做个小测试</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>大致就是利用main函数的参数，去实现拆分参数，不使用原生支持的string功能自己写一个类似的。</p><blockquote><p>filename.exe id:1 pass:123456 contry:china</p></blockquote><p>不管第一个默认的文件名参数，从后面开始，挨个拆出<code>:</code>后面的值</p><pre><code class="cpp">int searchChar()&#123;&#125;</code></pre><blockquote><p>一开始想着是不是要传递:的位置，这样直接截取:后面的就行了。</p></blockquote><p>但是这样又很奇怪，因为只做了返回位置，截取还要另外实现。<br>那好像又要两个自定义函数了，或者在main函数里实现，都是挺麻烦的。</p><p>直接返回ch[] 也不对劲，因为数组是要提前声明大小的……<br>回头一想，数组的底层也是指针，那就返回char*类型的应该也凑合：</p><pre><code class="cpp">char* searchChar()&#123;&#125;</code></pre><p>然后就是参数，肯定要有俩，一个原字符串，一个要查询被丢弃的字符串，然后这俩肯定不用修改了，就const限定常量</p><pre><code class="cpp">char* searchChar(const char *str, const char *findstr)&#123;&#125;</code></pre><p>然后进一步堆屎山：</p><pre><code class="cpp">char* serachChar(const char *str, const char *findstr)&#123;    int *ch;    for (int i = 0; str[i]; i++)&#123;        if (str[i] != findstr[i])&#123;            ch += str[i];        &#125;    &#125;    return ch;&#125;</code></pre><blockquote><p>这里肯定是不对的，因为指针没有初始化。。编译不通过。你也不知道到底该分配多少个内存。<br>那就不能用额外声明的指针返回，直接返回str[]从什么位置开始返回好像会更好<br>但是这样的话就要判断什么时候返回，返回的位置怎么计算合适。</p></blockquote><pre><code class="cpp">char* serachChar(const char *str, const char *findstr)&#123;    int x = 0;    for (int i = 0; str[i]; i++)&#123;        if (str[i] == findstr[i])&#123;            x++;        &#125;        else&#123;            return (char*)&amp;str[x + (i-x)];        &#125;    &#125;    return nullptr;&#125;</code></pre><blockquote><p>试了大半天，测了几个样例，能得到正常的值了</p><ol><li>首先需要一个x，这个x是累计str和findstr有几个相同的元素</li><li>考虑到for循环里面else就应能返回一个正确值了，那么最外层必须要有一个返回值的前提就返回一个空指针</li><li>for循环使用str[i]是因为字符串以0结尾，效果一样，就是到头了就表示false了。</li><li>return (char*)&amp;str[x+(i-x)]是因为假设x&#x3D;2，那么下一次i&#x3D;3的时候其实就可以返回后面的地址了。表达式写成x+(i-x),其实就是2+1…等会我直接用i好像就行了。</li></ol></blockquote><pre><code class="cpp">char* serachChar(const char *str, const char *findstr)&#123;    int x = 0;    for (int i = 0; str[i]; i++)&#123;        if (str[i] == findstr[i])&#123;            x++;        &#125;        else&#123;            return (char*)&amp;str[i];        &#125;    &#125;    return nullptr;&#125;</code></pre><blockquote><p>return (char*)&amp;str[i]; i就行了，不用整表达式了。</p></blockquote><p>然后就是用命令行的方式去实现。不过要在main函数里先赋值</p><pre><code class="cpp">const char *idN = &quot;id:&quot;;const char *passN = &quot;pass:&quot;;const char *countryN = &quot;country:&quot;;char *id&#123;&#125;, *pass&#123;&#125;, *country&#123;&#125;;</code></pre><p>先定义需要的变量。<br>然后for循环argv使用自定义函数赋值</p><pre><code class="cpp">for (int i = 1; argv[i]; i++)&#123;    if (id == nullptr)&#123;        id = serachChar(argv[i], idN);    &#125;    if (pass == nullptr)&#123;        pass = serachChar(argv[i], passN);    &#125;    if (country == nullptr)&#123;        country = serachChar(argv[i], countryN);    &#125;&#125;</code></pre><blockquote><p>i&#x3D;1是因为0是程序名，不需要进行判断，直接忽略就行，我们要截取的是后面的参数<br>id，pass，country默认都是空指针，当他们&#x3D;&#x3D;nullptr的时候，就进行serachChar。<br>不过这样的话当三个参数时，argv[1]走了三遍，[2]走了两遍，[3]走了一遍，但if都是重复判断了，又有点麻烦。</p></blockquote><pre><code class="cpp">for (int i = 1; argv[i]; i++)&#123;    if (id == nullptr)&#123;        id = serachChar(argv[i], idN);        if (id != nullptr) continue;    &#125;    if (pass == nullptr)&#123;        pass = serachChar(argv[i], passN);        if (pass != nullptr) continue;    &#125;    if (country == nullptr)&#123;        country = serachChar(argv[i], countryN);        if (country != nullptr) continue;    &#125;&#125;</code></pre><blockquote><p>参考了视频，在赋值后，判断不为空就continue也不失为一种办法，目前没想到啥好主意就先用了。</p></blockquote><pre><code class="cpp">std::cout &lt;&lt; id &lt;&lt; std::endl;std::cout &lt;&lt; pass &lt;&lt; std::endl;std::cout &lt;&lt; country &lt;&lt; std::endl;</code></pre><blockquote><p>输出就不用干啥了，然后就编译一下，发现不通过，这个程序没用明面上的输入就输出值好像不允许。<br>视频是通过(int)强转三个指针然后相乘，因为不为空都是有值的存在，故此if也能通过</p></blockquote><pre><code class="cpp">if ((int)id * (int)pass * (int)country)&#123;    std::cout &lt;&lt; id &lt;&lt; std::endl;    std::cout &lt;&lt; pass &lt;&lt; std::endl;    std::cout &lt;&lt; country &lt;&lt; std::endl;&#125;</code></pre><p>跑到终端尝试：<img src="/2022/05/28/functionTest/000.png" class=""><br>结果是正常的，然后再看看有啥能优化的：</p><pre><code class="cpp">char* serachChar(const char *str, const char *findstr)&#123;    for (int i = 0; str[i]; i++)&#123;        if (str[i] != findstr[i])&#123;            return (char*)&amp;str[i];        &#125;    &#125;    return nullptr;&#125;</code></pre><blockquote><p>其实也挺好整的，因为我们之前实现比较相同部分，再去返回相同之后的部分，那么换算过来直接返回当两个字符串不相等的位置就可以了。</p></blockquote><p>重新编译之后运行也是正确的：</p><img src="/2022/05/28/functionTest/001.png" class=""><p>然后就可以告一段落了，自己写一个功能其实会小有成就感。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>大半夜想了半天，看了眼视频发现路数差不多。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;做个小测试&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://8bytes.top/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>function</title>
    <link href="https://8bytes.top/2022/05/27/function/"/>
    <id>https://8bytes.top/2022/05/27/function/</id>
    <published>2022-05-27T13:36:19.000Z</published>
    <updated>2022-06-05T13:40:31.639Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>函数是指一段可以直接被另一段程序或代码引用的程序或代码。也叫做子程序、（OOP中）方法。<br>在程序设计中，常将一些常用的功能模块编写成函数，放在函数库中供公共选用。要善于利用函数，以减少重复编写程序段的工作量。</p><span id="more"></span><p>函数分为全局函数、全局静态函数；在类中还可以定义构造函数、析构函数、拷贝构造函数、成员函数、友元函数、运算符重载函数、内联函数等。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>简而言之就是封装好的功能，通过特定方法调用。</p><pre><code class="cpp">/* *  返回类型 函数名(参数，可以没有，也可以一到多个)&#123; *      功能区，需要实现的代码 *      return 返回值； //如果是void类型的函数，则不需要return   *  &#125;*/int Add(int a, int b)&#123;    return a+b;&#125;void PrintHe(char *ch)&#123;    std::cout &lt;&lt; ch &lt;&lt; std::endl;&#125;</code></pre><p>类型可以各式各样，但是要有准确结果和一定的复用性，不然写着也没啥用处。</p><hr><h2 id="自定义函数声明前后问题"><a href="#自定义函数声明前后问题" class="headerlink" title="自定义函数声明前后问题"></a>自定义函数声明前后问题</h2><pre><code class="cpp">#include&lt;iostream&gt;int add(int a, int b)&#123;    return a+b;&#125;int main()&#123;    int n = add(1,2);    return 0;&#125;</code></pre><blockquote><p>这种情况下，自定义函数写在main函数之前，则不需要额外的单独声明</p></blockquote><pre><code class="cpp">#include&lt;iostream&gt;int add(int a,int b);int main()&#123;    //或者在此处声明int add(int a, int b);    int n = add(1,2);    return 0;&#125;int add(int a, int b)&#123;    return a+b;&#125;</code></pre><blockquote><p>假如实现的部分写在main函数之后，则需在main函数之前声明一个模板，或者在main函数内声明，区别就在于作用域不一样，在main函数之外声明的具有全局性，main函数之内声明的就是局部函数。<br>但其实不跨文件，终归都是在main函数里面运行，写在外面主要是好区分吧。</p></blockquote><hr><h2 id="形参与实参"><a href="#形参与实参" class="headerlink" title="形参与实参"></a>形参与实参</h2><pre><code class="cpp">int add(int a, int b)&#123;    return a+b;&#125;</code></pre><blockquote><p>注：这里的变量a和变量b实际上是不存在的，它只是一个类型参照，只有当你的形参被调用才会分配内存，调用完后立刻释放，所以形参只在函数内有效，并且你传递的变量跟a和b重名也没有关系<br>故此，我们称函数里的参数为形式参数，这里简称形参</p></blockquote><pre><code class="cpp">int main()&#123;    int i = 1;    int j = 2;    int k = add(i, j);    return 0;&#125;</code></pre><blockquote><p>此处的i和j，是实质的变量，它俩声明的时候就占用了内存空间，进行函数传递的时候，他俩就是实际参数，简称实参<br>在此处也要引出另一个点，实参传递给形参的只是一个值，这个值在函数内怎么变化都不会影响实参。</p></blockquote><hr><h2 id="经典swap问题"><a href="#经典swap问题" class="headerlink" title="经典swap问题"></a>经典swap问题</h2><pre><code class="cpp">void swap(int a, int b)&#123;    int tmp = a;    a = b;    b = a;&#125;int main()&#123;    int a = 5;    int b = 3;    swap(a,b);    std::cout &lt;&lt; &quot;a=&quot; &lt;&lt; a &lt;&lt; &quot;,b=  &quot; &lt;&lt; std::endl;    return 0;&#125;</code></pre><blockquote><p>在形参和实参的时候解释过了，实参传递给形参的时候，只是传递了值。就是相当于激活了形参，形参拥有的只是实参的值，用完形参就释放了。所以这里a和b并不会交换值。<br>但如果想要真的交换两个变量的值，就需要对它的地址进行操作</p></blockquote><h3 id="C语言swap"><a href="#C语言swap" class="headerlink" title="C语言swap"></a>C语言swap</h3><pre><code class="c">void swap(int *a, int *b)&#123;    int tmp = *a;    *a = *b;    *b = tmp;&#125;int main()&#123;    int a = 5;    int b = 3;    swap(&amp;a, &amp;b);    std::cout &lt;&lt; &quot;a=&quot; &lt;&lt; a &lt;&lt; &quot;,b=&quot; &lt;&lt; b &lt;&lt; std::endl;    return 0;&#125;</code></pre><img src="/2022/05/27/function/000.png" class=""><blockquote><p>C语言没有引用这个特性，所以依靠的是指针<br>而c++则都可以实现</p></blockquote><hr><h2 id="数组参数"><a href="#数组参数" class="headerlink" title="数组参数"></a>数组参数</h2><p>上述的swap问题所使用的形参是指针类型，此处提及数组参数的时候</p><p>参数为数组时：</p><pre><code class="cpp">void sortInt(int ch[])&#123;&#125;</code></pre><blockquote><p>这里需要强调一个问题，就是印象中，声明数组必须指定大小，除非是初始化的时候写好了。<br>那么作为形参的数组为什么不需要指定大小？<br>底层中，数组就是指针实现的，所以c语言和c++在编译的时候不对形参数组大小做检查，因为形参接受到的是实参的首地址！</p></blockquote><p>不信的话可以sizeof查看这个数组的大小：</p><img src="/2022/05/27/function/001.png" class=""><p>如果你以为这是变量类型的大小就错了！此处是在x86情况下的指针大小，我们再看x64下：</p><img src="/2022/05/27/function/002.png" class=""><p>发现结果是8，这也就是表明了这个大小代表的是指针的大小。</p><p>提到soft，我们可以配合冒泡排序对数组进行排序</p><pre><code class="cpp">void sortInt(int ch[], unsigned len)&#123;    for (int i = 0; i &lt; len; i++)&#123;        for (int j = i; j &lt; len - i - 1; j++)&#123;            if (ch[j] &lt; ch[j + 1])&#123;                int tmp = ch[j];                ch[j] = ch[j + 1];                ch[j + 1] = tmp;            &#125;        &#125;    &#125;&#125;int main()&#123;    int ch1[5]&#123; 100,20,25,58,79 &#125;;    sortInt(ch1,5);    for (auto n : ch1) std::cout &lt;&lt; n &lt;&lt; &quot;\t&quot;;    return 0;&#125;</code></pre><p>结果为：<img src="/2022/05/27/function/003.png" class=""></p><p>可以先不管算法，我们看到排序的时候函数形参除了数组还有个长度，当在我们印象里数组的长度似乎可以通过<code>sizeof(ch)/sizeof(ch[0])</code>得到，但是这里为什么不能这么写。</p><ol><li>我们之前说过，形参数组接收到的是实参的地址，也就是指针，而指针在x86下占用4字节，x64下占用8字节，当处于x86环境下，<code>sizeof(ch)/sizeof(ch[0])</code>就变成了4&#x2F;4 &#x3D; 1；故此循环就没能跑起来。不信邪的可以debug测试看这句表达式的值。</li></ol><p>然后就是模板问题，数组底层是指针，但是在设置形参的时候，使用数组和指针给人的第一印象是不一样的</p><pre><code class="cpp">void sortInt(int ch[], unsigned len)&#123;&#125;//orvoid sortInt(int *ch, unsigned len)&#123;&#125;</code></pre><blockquote><p>再不看函数名的情况下，只看形参，不一定就能看出第二个函数是干什么的。<br>当然效果都是一样的，只是在可阅读性上，我们尽量不为难自己人</p></blockquote><p>然后是多维数组，例如二维：</p><pre><code class="cpp">void sortInt(int ch[][], unsigned len)&#123;&#125;</code></pre><p><strong>这种写法肯定就不合适了！</strong><br>学过数组的都知道，二维数组可以不声明有多少行，但是要声明多少列，从实参传递来的是数组的起始地址，在内存中按数组排列规则存放(按⾏存放)，⽽并不区分⾏和列，如果在形参中不说明列数，则系统⽆法决定应为多少⾏多少列，不能只指定⼀维⽽不指定第⼆维<br>形参是实参的模板，所以形参肯定也要是合法的。</p><hr><h2 id="引用参数"><a href="#引用参数" class="headerlink" title="引用参数"></a>引用参数</h2><p>引用就是<code>int &amp;a = b;</code>，放到函数里</p><pre><code class="cpp">void hhh(int &amp;n)&#123;    n = 100;&#125;</code></pre><p>引用变量可以修改被引用的变量：</p><pre><code class="cpp">int a = 10;hhh(a);std::cout &lt;&lt; a &lt;&lt; std::endl;</code></pre><p>得到结果：<img src="/2022/05/27/function/004.png" class=""><br>如果不想被修改，那就只有在类型前加上const限定为常量。</p><p>之前提到过引用其实就是弱化的指针，放到形参上他俩的区别就是指针可以传入nullptr，也就是空指针；而引用不能传入nullptr。因为引用是必然要初始化的，指针稍不留神就会漏掉。</p><blockquote><p>引用作为参数的时候，对于结构体才会用的比较多，现在的体会比较少</p></blockquote><p>不过对于swap函数，引用就派上用场了</p><pre><code class="cpp">void swap(int &amp;a,int &amp;b)&#123;    int tmp = a;    a = b;    b = tmp;&#125;</code></pre><p>效果也是一样的，对比指针还要用*号取值时更直观点。</p><hr><h2 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h2><pre><code class="cpp">void hh(int a,int b,int c,bool d)&#123;&#125;</code></pre><p>我们在声明函数的时候，形参是各式各样的，但是针对一些值，比如布尔类型，他就两种结果，有的时候我们就想不声明了，让他默认有一个值，方法也很简单：</p><pre><code class="cpp">void hh(int a,int b,int c,bool d=true)&#123;&#125;</code></pre><p>不想额外声明的可以提前定义一个值作为默认参数<br><strong>注：默认参数可以有多个但只能放在最后面，否则调用函数时hh(1,3, ,3)在中间留空，则导致参数不匹配了。但如果形参都设置了默认值那也无可厚非，参数自然能匹配上</strong></p><hr><h2 id="不定量参数"><a href="#不定量参数" class="headerlink" title="不定量参数"></a>不定量参数</h2><p>学网络的时候常在cmd中用ping命令，ping是人为写好的功能，一般存放在<code>C:/Windows/</code>下，ping 可以是ping网址也可以pingIP地址，但是这俩参数都是不确定的，并且还有一些其他功能-t 持续ping之类的，这些都是不确定的。</p><p>在老的编译器那会，创建模板的时候main函数括号里是有两个形参的，这好像也是c语言规定的主函数的形参就俩</p><pre><code class="cpp">int main(int argc,char *argv[])&#123;    /*     * argc表示命令行的参数个数     * argv表示有argc搁参数，[0]是以程序名开始，随后每多一个参数就一一匹配上。    */&#125;</code></pre><p>不好理解的可以直接写段代码看看：</p><pre><code class="cpp">int main(int argc,char *argv[])&#123;    std::cout &lt;&lt; &quot;argc=&quot; &lt;&lt; argc &lt;&lt; std::endl;    for (int i = 0; i &lt; argc; i++)&#123;        std::cout &lt;&lt; argv[i] &lt;&lt; std::endl;    &#125;        return 0;&#125;</code></pre><img src="/2022/05/27/function/005.png" class=""><p>右击main函数打开所在文件夹，然后找到Debug目录下，不用看x64，如果你是x64编译的就去找x64下的debug。<br>进去之后看到这个项目名.exe程序，右击文件夹空白地方打开终端：</p><img src="/2022/05/27/function/006.png" class=""><p><code>.\执行程序 参数1 参数2 ......</code>参照这样执行，我记得这好像叫重定向。</p><blockquote><p>ps:之前linux玩多了，linux下执行的时候都是.&#x2F;xxx，而windows则相反.\可还行</p></blockquote><p><strong>然后印象里当初弄的时候好像第一个接受的参数应该是这个程序编译后的名称，但这里是显示一段较为完整的路径了，暂时没研究为什么，可能是不是在全局命令下执行的吧，就自然而然的带上了路径+执行程序名称</strong></p><p>argv就像一个数组制作的字符串，输入的参数会分配到一片连续的空间，并且以0结尾。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>函数的模板其实没啥好写的，用着用着就习惯了</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;函数是指一段可以直接被另一段程序或代码引用的程序或代码。也叫做子程序、（OOP中）方法。&lt;br&gt;在程序设计中，常将一些常用的功能模块编写成函数，放在函数库中供公共选用。要善于利用函数，以减少重复编写程序段的工作量。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://8bytes.top/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>text003</title>
    <link href="https://8bytes.top/2022/05/27/text003/"/>
    <id>https://8bytes.top/2022/05/27/text003/</id>
    <published>2022-05-27T13:16:19.000Z</published>
    <updated>2022-05-28T04:19:14.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="还行-运气不错"><a href="#还行-运气不错" class="headerlink" title="还行,运气不错"></a>还行,运气不错</h1><span id="more"></span><p>计算机三级过了~<br>30块没打水漂</p><p>不过还好上半年软考取消了。。一点准备没有，没有白给140不戳。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;还行-运气不错&quot;&gt;&lt;a href=&quot;#还行-运气不错&quot; class=&quot;headerlink&quot; title=&quot;还行,运气不错&quot;&gt;&lt;/a&gt;还行,运气不错&lt;/h1&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>string2</title>
    <link href="https://8bytes.top/2022/05/26/string2/"/>
    <id>https://8bytes.top/2022/05/26/string2/</id>
    <published>2022-05-26T15:58:49.000Z</published>
    <updated>2022-05-29T07:10:36.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="感言"><a href="#感言" class="headerlink" title="感言"></a>感言</h1><p>自认为不是一个努力的人……虽然这些20年在b站看过黑马的教程，甚至当时在本地也写过md的文件哈哈哈哈但是一段时间不用又落下了许多，也好在没有忘得一干二净吧……看到都能想起来，只是一些内置的方法会记不太清。回看也是两天看一点看一点，加上看视频又得自己做，然后顺便写在博客上，进度确实会慢一些。<br>而且数据结构这一门快打工了也还没掌握……还是很惭愧的,后面要尽量补齐了。</p><span id="more"></span><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>也回顾了string的一些方法，然后小结一下string</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>字符串之中除了指针，编码是一个无时不刻不会头疼的问题。<br>字符从存储：由表面的字符到计算机上的编码表，再到底层转换成二进制<br>读取字符串的顺序是存储的逆向顺序。</p><blockquote><p>常见的编码表：utf-8、utf-16、GBK、ASCII等</p></blockquote><hr><h2 id="自制能统计带中文的字符串"><a href="#自制能统计带中文的字符串" class="headerlink" title="自制能统计带中文的字符串"></a>自制能统计带中文的字符串</h2><pre><code class="cpp">void tjsp(char *ch)&#123;    int n = 0;    while (*ch++ != &#39;\0&#39;)&#123;        if (*ch &lt; 0)&#123;            n++;            *ch++;        &#125;        else&#123;            n++;        &#125;    &#125;    std::cout &lt;&lt; n &lt;&lt; std::endl;&#125;</code></pre><p>这是之前string回顾的时候做的一个小题目，因为gbk的情况下，中文占用两个字节，所以判断起来不一样。<br>代码目前不重要，重要的是一点，为什么要<code>*ch &lt; 0</code>。</p><p>1字节的范围是-128 - 127，如果是无符号就是0-255。<br>那么现在没有指定是无符号，所以按照-128 - 127算。<br>而ascii码的范围就是0-127，超过的就代表不是英文字符，且现在是有符号类型，所以是判断这个字符是不是&lt; 0，如果小于0就说明这个字符是中文；如果是无符号类型，就是判断这个字符是不是&gt; 127，如果大于127就说明这个字符是中文。</p><p>比如说<code>d5 c5</code>是中文张在gbk下的十六进制表现<br>d5拆分成二进制<code>1101 0101</code>,按照三码的规范，这其实就是个负数，那么在占用两个字节的前提下，读到一个字节十进制小于0，就可以跳过一个字节读了，也就是上述代码的写法。</p><p>当然也可用for循环：</p><pre><code class="cpp">void tjsp(char *ch)&#123;    int n = 0;    for(int i = 0; ch[i]; i++)&#123;        if(ch[i] &lt; 0)            i++;        n++;    &#125;    std::cout &lt;&lt; n &lt;&lt; std::endl;&#125;</code></pre><hr><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>string那会有个把数字转换成字符串的方法<code>std::to_string(number)</code>;<br>对应的也就产生了将字符串转化成数字</p><table><thead><tr><th>作用</th><th>语法</th><th>用法</th></tr></thead><tbody><tr><td>str转换成int</td><td>std::stoi(string)</td><td>int a &#x3D; stoi(“123”);</td></tr><tr><td>str转换成long</td><td>std::stol(string)</td><td>long a &#x3D; stol(“123”);</td></tr><tr><td>str转换成long long</td><td>std::stoll(string)</td><td>long long a &#x3D; stoll(“123”);</td></tr><tr><td>str转换成unsigned long</td><td>std::stoul(string)</td><td>unsigned long a &#x3D; stoul(“123”)</td></tr><tr><td>str转换成unsigned long long</td><td>std::stoull(string)</td><td>unsigned long long a &#x3D; stoull(“123”);</td></tr><tr><td>str转换成float</td><td>stof(string)</td><td>float a &#x3D; stof(“123”);</td></tr><tr><td>str转换成double</td><td>stod(string)</td><td>double a &#x3D; stod(“123”);</td></tr><tr><td>str转换成long double</td><td>stold(string)</td><td>long double a &#x3D; stold(“123”)</td></tr></tbody></table><blockquote><p>也是有规律的，sto+转换成的类型首字符</p></blockquote><hr><h2 id="stringstream流"><a href="#stringstream流" class="headerlink" title="stringstream流"></a>stringstream流</h2><p>在没有声明命名空间的时候，输入输出都是通过std::操作<br>在头文件sstream中有这么古怪玩意。。<code>std::stringstream</code><br><code>.str()会返回一个string</code></p><pre><code class="cpp">std::stringstream str;str &lt;&lt; &quot;hello &quot; &lt;&lt; &quot;world&quot;;std::string str1 = str.str();</code></pre><p>打印str1的结果就是<code>hello world</code>;</p><blockquote><p>这个单独的string流感觉用的也少吧，毕竟代码需要可阅读性，大家都用的会更直观</p></blockquote><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>无感-</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;感言&quot;&gt;&lt;a href=&quot;#感言&quot; class=&quot;headerlink&quot; title=&quot;感言&quot;&gt;&lt;/a&gt;感言&lt;/h1&gt;&lt;p&gt;自认为不是一个努力的人……虽然这些20年在b站看过黑马的教程，甚至当时在本地也写过md的文件哈哈哈哈但是一段时间不用又落下了许多，也好在没有忘得一干二净吧……看到都能想起来，只是一些内置的方法会记不太清。回看也是两天看一点看一点，加上看视频又得自己做，然后顺便写在博客上，进度确实会慢一些。&lt;br&gt;而且数据结构这一门快打工了也还没掌握……还是很惭愧的,后面要尽量补齐了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://8bytes.top/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>pointerString</title>
    <link href="https://8bytes.top/2022/05/26/pointerString/"/>
    <id>https://8bytes.top/2022/05/26/pointerString/</id>
    <published>2022-05-26T15:21:49.000Z</published>
    <updated>2022-05-28T17:05:51.955Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>C语言的字符串是通过数组实现的，数组本质上又和指针无二。<br>那么cpp的字符串底层是否跟C语言一致</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><pre><code class="cpp">char ch[] = &quot;hello world&quot;;string str = &quot;hello world&quot;;</code></pre><p>在C语言里，ch现在就&#x3D; ch[0]; 象征着数组首地址。<br>但是string的构造我们还不清楚，所以通过编译器查看</p><pre><code class="cpp">#include&lt;iostream&gt;using std::string;int main()&#123;    string str = &quot;hello world&quot;;    std::cout &lt;&lt; &amp;str &lt;&lt; &quot;\n&quot; &lt;&lt; &amp;str[0] &lt;&lt; std::endl;    return 0;&#125;</code></pre><p>原本想通过这样直接输出的，但是cout好像优化掉了<code>&amp;str[0]</code>，得到的还是整个字符串的值。<br>那就粗暴点用C语言的printf指定格式输出</p><pre><code class="c">printf(&quot;%p\n&quot;, &amp;str);printf(&quot;%p&quot;, &amp;str[0]);</code></pre><p>结果是地址不同：<img src="/2022/05/26/pointerString/000.png" class=""></p><blockquote><p>其实使用string的时候需要引入头文件就该知道string不简单，它也属于容器的一种，底层是通过类实现的。</p></blockquote><p>再往后查看str[1]的地址：<img src="/2022/05/26/pointerString/001.png" class=""><br>发现str[0]和[1]直接相差1个字节，这才符合数组是由一个个char组成的。</p><hr><p>其次我们知道C语言的字符串长度是固定的，只有动态数组才能扩容，或者说合并数组时候需要用到一块新的内存空间，string虽然有重载的办法，但是底层也是八九不离十</p><pre><code class="cpp">#include&lt;iostream&gt;using std::string;int main()&#123;    string str = &quot;hello world&quot;;    printf(&quot;%p\n&quot;, &amp;str);    printf(&quot;%p\n&quot;, &amp;str[0]);    printf(&quot;%p\n&quot;, &amp;str[1]);    str += &quot;! buhaolebuhaole&quot;;    printf(&quot;%p\n&quot;, &amp;str);    printf(&quot;%p\n&quot;, &amp;str[0]);    printf(&quot;%p\n&quot;, &amp;str[1]);    return 0;&#125;</code></pre><p>给str扩容，看看地址会不会发生改变</p><img src="/2022/05/26/pointerString/002.png" class=""><p>发现只有这个所谓的str首地址没有改变，剩下的0和1都变了，且幅度有点大，有点跟我们之前比较栈区和堆区之间地址的差异。</p><hr><p>如果就只想看到字符串那一块的内存，可以使用c++11标准提供的两个函数</p><ul><li>.c_str()  得到一个const char*的指针，指向字符串的内存空间</li><li>.data()   得到一个const char*的指针，指向字符串的内存空间</li></ul><p>这么一看这俩方法好像是重复的，没有啥特别意义，所以在c++17标准之后统一了，只不过返回的只是个指针而不是常量指针了。</p><p>c++ 17标准</p><ul><li>.data() 得到的是个char*的指针了</li></ul><p>当我们定义一个常量指针接受str.c_str()时：</p><img src="/2022/05/26/pointerString/003.png" class=""><p>能看到cs指向的地址和str[0]是一致的。</p><blockquote><p>虽然.c_str()返回的是常量指针，但是如果我们想修改，还是可以通过强制转换实现，但是这种限定是很有必要的。个人没必要闲的蛋疼去玩。</p></blockquote><p><strong>且早期的之后string不要求数组以0结尾，因为string内置累加器，会自动记录长度，通过调用length方法获取。不像C语言的时候要区分strlen和sizeof的区别。但c++11之后还是要求了string也要以0结尾</strong></p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>主要就是区分string底层和char[]存在一定区别</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;C语言的字符串是通过数组实现的，数组本质上又和指针无二。&lt;br&gt;那么cpp的字符串底层是否跟C语言一致&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://8bytes.top/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>walineError</title>
    <link href="https://8bytes.top/2022/05/26/walineError/"/>
    <id>https://8bytes.top/2022/05/26/walineError/</id>
    <published>2022-05-25T17:04:21.000Z</published>
    <updated>2022-05-26T14:18:01.654Z</updated>
    
    <content type="html"><![CDATA[<h1 id="整活"><a href="#整活" class="headerlink" title="整活"></a>整活</h1><p>预览的时候发现评论突然挂了</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><img src="/2022/05/26/walineError/000.png" class=""><blockquote><p>说我的Waline未定义。。。我寻思我js文件都是用的官方模板怎么就没定义了。。<br>又上了一趟<code>vercel.com</code>发现也是一样控制台都是报错<code>Waline is not defined</code></p></blockquote><blockquote><p>就很离谱啊。。。但是waline官网的看着又是正常的，就只能上github看看有没有什么类似的情况<br>结果倒是有一个说clintv2不稳定的问题</p></blockquote><img src="/2022/05/26/walineError/001.png" class=""><blockquote><p>逆天。。上一秒waline的文档里面script还是cdn的地址<br>刷新一下又变成unpkg了<img src="/2022/05/26/walineError/003.png" class=""></p></blockquote><blockquote><p>主要是相比之前的我记得好像多了个这个link，然后其他版本以前也是没写的，这次都是@v2了。。很莫名其妙啊，要我说改动就不能大改。。或者好歹发邮件提示一下。</p></blockquote><blockquote><p>修改了下我这个主题的ejs文件之后</p></blockquote><img src="/2022/05/26/walineError/002.png" class=""><blockquote><p>评论是能看到了，版本直接跳到2.5.1了，但是之前评论的头像显示不出来控制台报错<code>net::ERR_CONNECTION_TIMED_OUT</code>….真是逆天。<br>但是官网文档的好像是2.5.2。。。就很迷惑行为。<br>而且我这里只能修改本地的配置，我在vercel那里还是访问不了，提示版本有问题未定义。。哎麻了</p></blockquote><blockquote><p>但是突然想起来vercel能重新部署，就试了一下</p></blockquote><img src="/2022/05/26/walineError/004.png" class=""><blockquote><p>找到这里点击那三个点，选择重新部署</p></blockquote><blockquote><p>重新部署要等一段时间，等待之后发现测试的地方能用了</p></blockquote><img src="/2022/05/26/walineError/006.png" class=""><blockquote><p>虽然控制台那里显示的server版本好像还是1.18.5</p></blockquote><img src="/2022/05/26/walineError/007.png" class=""><blockquote><p>在源代码那里也发现了应该是根据walineserver更新了，之前const waline &#x3D; Waline才报的错，现在是变成Waline.init了</p></blockquote><img src="/2022/05/26/walineError/008.png" class=""><blockquote><p>回到之前的评论下发现头像也出来了，甚至还多了个ip归属地。。。可还行</p></blockquote><img src="/2022/05/26/walineError/005.png" class=""><blockquote><p>只不过waline的版本还是2.5.1，官网的2.5.2都不知道是不是测试版的问题了。这一个小版本号倒是问题不大</p></blockquote><img src="/2022/05/26/walineError/009.png" class=""><blockquote><p>当你是管理员登录评论系统的时候你会发现能看到的好像更多了,还多了操作权限</p></blockquote><img src="/2022/05/26/walineError/010.png" class=""><blockquote><p>不信邪又去官网刷新了一下他的版本又变成1.6.1了？？？？？？合着我是撞他枪口上更新了？？？？</p></blockquote><img src="/2022/05/26/walineError/011.png" class=""><blockquote><p>快速上手那里也变了。。我真的服了啊.。。连最近编辑时间都改了可还行。。。</p></blockquote><img src="/2022/05/26/walineError/012.png" class=""><p>让我反复刷新一下。。。奶奶个腿他真的是大晚上更新啊</p><img src="/2022/05/26/walineError/013.png" class=""><p>这编辑时间又特么改成5.25日18点了，我特么信你的邪。。。老子26号一点刷来刷去你编辑时间写25的六点</p><p>哎反正先不管了。hexo s本地能预览成功就行。</p><hr><img src="/2022/05/26/walineError/014.png" class=""><p>按照作者的说法是官网文档本地缓存的问题。。。这倒也不是啥大事就是大改了自己要多留意，毕竟还是个有人 维护的项目。<br>不像下面那老哥，回答的都不知道啥玩意。。。之前都用的jsdelivr，作者也说有点小问题，你跟我说我自己cdn缓存持久。。。再说了之前用的时候也没刻意在script里@v2</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>最近写的都存在本地了，网页的等哪天想上传仓库了再说吧。。。。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;整活&quot;&gt;&lt;a href=&quot;#整活&quot; class=&quot;headerlink&quot; title=&quot;整活&quot;&gt;&lt;/a&gt;整活&lt;/h1&gt;&lt;p&gt;预览的时候发现评论突然挂了&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>string1</title>
    <link href="https://8bytes.top/2022/05/24/string1/"/>
    <id>https://8bytes.top/2022/05/24/string1/</id>
    <published>2022-05-24T07:11:16.000Z</published>
    <updated>2022-05-28T17:03:52.057Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li>std:string</li></ul><span id="more"></span><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>回忆过C语言版的字符串</p><pre><code class="cpp">char ch[] = &quot;abafjiafajif&quot;;char ch[10] = &quot;aaaaaaaa&quot;;</code></pre><p>大致上一个意思，限定长度和不限定长度，不限定长度会自动根据初始化的值长度而定义。</p><p>其次就是拼接两个字符串</p><pre><code class="cpp">char ch[10] = &quot;1234&quot;;char ch1[10] = &quot;5678&quot;;char ch2[20];memcpy(ch2, ch, strlen(ch));    //先将ch从头拷贝进来memcpy(ch2 + strlen(ch), ch1, strlen(ch1) + 1); //在由从ch拷贝到ch2里</code></pre><p>这样拼接起来还是挺麻烦的，如果能直接相加赋给字符串就会相对方便了。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;string&gt;using std::string;int main()&#123;    return 0;&#125;</code></pre><p>使用string关键字前需包含头文件string，此外如果不想老是写std::string，就在下面加一句<code>using std::string;</code>.</p><pre><code class="cpp">string str = &quot;hello world&quot;;std::cout &lt;&lt; str &lt;&lt; std::endl;</code></pre><p>定义起来格式就跟正常变量一样。输入输出相较于C语言类型的字符串的好处就是，不用提前声明大小，不用担心随便溢出。</p><p>此外string还可以指定只接受字符串的一部分</p><pre><code class="cpp">string str&#123; &quot;hello world&quot; , 5&#125;;std::cout &lt;&lt; str &lt;&lt; std::endl;</code></pre><img src="/2022/05/24/string1/000.png" class=""><p>除了从0开始，还能自定义：</p><pre><code class="cpp">string str = &#123; &quot;hello world&quot; , 1,3&#125;;std::cout &lt;&lt; str &lt;&lt; std::endl;</code></pre><img src="/2022/05/24/string1/001.png" class=""><p>能从指定的字符串获取，也就能从变量获取</p><pre><code class="cpp">string str;std::cin &gt;&gt; str;string str1 = &#123; str,2,5 &#125;;std::cout &lt;&lt; str1 &lt;&lt; std::endl;</code></pre><img src="/2022/05/24/string1/002.png" class=""><p><strong>像比较之下方便了许多，但是这其实也就是官方封装好的，自己也能实现类似的效果</strong></p><blockquote><p>ps:对中文支持一般，因为字符集的不确定性，不能保证不同占用下带来的问题</p></blockquote><p>还有一种比较无聊的写法：</p><pre><code class="cpp">string str(6,&#39;a&#39;);</code></pre><p>就是赋值了6个’a’组成的字符串。</p><p>然后回到拼接字符串，string可以直接通过相加实现</p><pre><code class="cpp">string str = &quot;1234&quot;;string str1;str1 = str + &quot;5678&quot;;</code></pre><img src="/2022/05/24/string1/003.png" class=""><p>效果也是ok的。</p><blockquote><p>当然要求+的时候都是字符串，不能是字符串以外的东西</p></blockquote><p>如果想加一串数字，那也只能先将其转换成字符串。</p><pre><code class="cpp">string str = to_string(123);</code></pre><p>这样得到的str就是<code>“123”</code>，一个字符串类型的变量。</p><img src="/2022/05/24/string1/004.png" class=""><p>当然数字不单只是整型的，小数也可以。</p><hr><h2 id="加强"><a href="#加强" class="headerlink" title="加强"></a>加强</h2><p>字符串拼接存在一个问题，那就是参数不能都是常量</p><pre><code class="cpp">string str;str = &quot;123&quot; + &quot;456&quot;;</code></pre><p>这种情况下就会报错，原因是这两个常量“123”和“456”在计算机里还是char类型的<br>解决办法可以创建临时变量或者强转</p><pre><code class="cpp">string str;str = (string)&quot;123&quot; + &quot;456&quot;; //强制转换str = string&#123;&quot;123&quot;&#125; + &quot;456&quot;; //创建临时string的变量</code></pre><p>如果使用<code>+=</code>操作符，那么也要注意类型转换，因为+的优先级高于+&#x3D;</p><pre><code class="cpp">string str;str = string&#123; &quot;123&quot; &#125; + &quot;456&quot; + &quot;789&quot;;str += (string)&quot;hhh&quot; + &quot;aaa&quot;;   //保持强制转换或者创建临时变量</code></pre><hr><h3 id="append"><a href="#append" class="headerlink" title="append"></a>append</h3><p>之前的拼接都是使用+号，还得额外创建一个变量，string本身提供了一种方法就是<code>append</code></p><pre><code class="cpp">string str = &quot;123&quot;;str.append(&quot;456&quot;);std::cout &lt;&lt; str &lt;&lt; std::endl;</code></pre><p>同时append可以套娃<code>str.append(&quot;123&quot;).append(&quot;456&quot;).append(&quot;789&quot;).....</code><br>也可以截取<code>str.append(&quot;123456&quot;,3)</code>或者<code>str.append(&quot;123456&quot;,2,5)</code><br>也可以使用定义时的办法<code>str.append(6,&#39;a&#39;)</code></p><img src="/2022/05/24/string1/005.png" class=""><p>抛开使用中的一种，也就意味着append有七种参数方法。</p><hr><h3 id="substr"><a href="#substr" class="headerlink" title="substr"></a>substr</h3><p>字符串的截取方法</p><pre><code class="cpp">.substr(index,end); //输入截取的起点和终点.substr(index);     //只输入一个数则表示截取起点，默认截取到最后</code></pre><p>substr会有一个返回值，返回的值就是截取后的字符串，可以用于赋值给其他字符串或者直接打印</p><pre><code class="cpp">string str = &quot;0123456789&quot;;string str1 = str.substr(1,5);std::cout &lt;&lt; str.substr(1,5) &lt;&lt; std::endl;std::cout &lt;&lt; str1 &lt;&lt; std::endl;</code></pre><p>效果就是：<img src="/2022/05/24/string1/006.png" class=""></p><hr><h3 id="length"><a href="#length" class="headerlink" title="length"></a>length</h3><p>C语言我们计算字符串长度使用<code>strlen</code>,cpp的string则也有计算长度的方法<code>length</code></p><pre><code class="cpp">string str = &quot;0123456789&quot;;std::cout &lt;&lt; str.length() &lt;&lt; std::endl;</code></pre><p>效果就是：<img src="/2022/05/24/string1/007.png" class=""><br>当然length的返回值也可以赋值给一个int类型的变量，以作重复使用。</p><blockquote><p>然后同样的问题，对中文的支持都是很玄学，毕竟各字符集对中文占用大小并不统一</p></blockquote><hr><h3 id=""><a href="#" class="headerlink" title="[]"></a>[]</h3><p>string也可以通过[]去访问字符串成员，下标依然0起，底层实现也是类似的，使用的内存空间也是连续的。<br>就没什么必要演示了</p><hr><h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><pre><code class="cpp">char *ch = (char*)&quot;123456&quot;;char *ch1 = (char*)&quot;123456&quot;;if(ch == ch1)    std::cout &lt;&lt; &quot;=&quot; &lt;&lt; std::endl;</code></pre><p>在C语言里，字符串其实没有一个很准确的比较功能，像上述的代码中，能够判断也是因为二者的初始化时相当于使用了常量，而编译器恰好优化了常量，使常量的地址一致，所以才会判断相等<br>结果就是：<img src="/2022/05/24/string1/008.png" class=""></p><p>反汇编看两个初始值的情况</p><img src="/2022/05/24/string1/009.png" class=""><p>可以看到”123456“的十六进制值是相同的，所以比较的时候才相等。<br>但是这种比较方法很显然不靠谱。防止编译器优化的话，就需要其中一个字符串通过手动输入，这样就不能一下子确认为是常量。</p><p>但其实也有一个方法strcmp，不过就得借用string.h头文件了，也就是变相借助了工具，所以说原生下没有这种功能。<br><code>int strcmp(const char* str1，const char* str2);</code><br>返回值：</p><ul><li>如果返回值 &lt; 0，则表示 str1 小于 str2。</li><li>如果返回值 &gt; 0，则表示 str2 小于 str1。</li><li>如果返回值 &#x3D; 0，则表示 str1 等于 str2。</li></ul><p>而string的话，它肯定是内置了不少方法的:&#x3D;&#x3D; !&#x3D; &gt; &lt; &gt;&#x3D; &lt;&#x3D;<br>原则就是根据顺序，依次比较字符大小，在第一个字符就分出大小则就无视后面的字符，如果第一个字符相等就往后比较以此类推。</p><hr><h3 id="compare"><a href="#compare" class="headerlink" title="compare"></a>compare</h3><p>string类型自带的方法，返回值是int类型的值</p><ul><li>两个字符串完全相等返回0</li><li>相比比较的字符串小返回负数</li><li>相比比较的字符串大返回正数</li></ul><p>所以if的时候要注意，因为使用compare如果相等返回的是0，0在C语言cpp里面是表示假的。</p><p><code>.compare(index, end, str)</code>这是一个拓展的参数，可以指定被比较的字符串从哪里开始到哪里结束。</p><hr><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p><code>.find(str)</code>,find的返回值是一个整型，它可以找到str第一次出现的下标。</p><p>使用场景的话，最常用的就是substr的时候，找到原字符串内的某一块内容，用find当起始值。<br><code>.find(str,index)</code>  从要比较的字符串的index处包括index开始查找，返回值是std::string::npos 可能是-1或者4294967295<br><code>.find(str,index,end)</code> 从要被比较的字符串index处开始查找，范围是{str[0],str[end]}</p><hr><h3 id="rfind"><a href="#rfind" class="headerlink" title="rfind"></a>rfind</h3><p>这玩意。。就是倒着搜的find。<br>所以指定index的时候要从最后面开始，从0开始没遇到直接就罢工了。。<br>这玩意用的真的挺少的感觉。</p><hr><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p>string的插入方法，参数小多<br><code>.insert(要插入的位置，要插入的字符串，要插入的字符串起始位置，要插入的大小);</code><br><code>.insert(要插入的位置，要插入的字符串，要插入的大小);</code></p><pre><code class="cpp">string str = &quot;abc,&quot;;str.insert(3,&quot;123&quot;,3);</code></pre><hr><h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><p>string的内置方法，可以指定替换string中的内容<br><code>.replace(index, length, &quot;str&quot;)</code><br><code>.replace(index, length, &quot;char length&quot;, char)</code><br><code>.replace(起始位置，要替换长度，替换内容，替换后容节选长度)</code><br><code>.replace(起始位置，要替换长度，替换内容，替换后内容的起始位置，替换后容节选长度)</code></p><p>例一：</p><pre><code class="cpp">string str = &quot;id=001;&quot;;str.replace(3, 4, &quot;003&quot;);</code></pre><p>那么打印str之后的内容就会是<code>id=003</code></p><p>例二：</p><pre><code class="cpp">string str = &quot;abcde;&quot;;str.replace(3, 4, 6, &#39;*&#39;);</code></pre><p>那么打印str之后的内容就会是<code>abc******</code>;</p><p>例三：</p><pre><code class="cpp">string str = &quot;id=001;&quot;;str.replace(3,4,&quot;zhangsan;name=hhh;&quot;,8);</code></pre><p>str为<code>id=zhangsan;</code></p><p>例四：</p><pre><code class="cpp">string str = &quot;id=001;&quot;;str.replace(3,4,&quot;zhangsan;name=hhh;&quot;,5,8);</code></pre><p>str为<code>id=san;</code></p><blockquote><p>其实后面几个用的也不多</p></blockquote><hr><h3 id="erase"><a href="#erase" class="headerlink" title=".erase"></a>.erase</h3><p>能替换，也能删除<br><code>.erase(删除的起始位置)</code><br><code>.erase(删除起始位置，删除的长度)</code></p><pre><code class="cpp">string str = &quot;id=001;&quot;str.erase(3);</code></pre><p>str显示为<code>id=</code></p><pre><code class="cpp">string str = &quot;id=001;&quot;str.erase(3,4);</code></pre><p>str显示为<code>id=</code></p><hr><h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><p>顾名思义就是清除，对应的就是清空字符串的内容。<br>就不演示了，反正使用了之后在打印字符串就是空的</p><hr><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><code>string str = &quot;id=xxx;name=xxx;sex=x;phone=xxxxxxx;&quot;;</code><br>假设有这么一句字符串，需要你实现输入选项如id，拆解出id&#x3D;后面的参数，不含;</p><pre><code class="cpp">int main()&#123;    string str = &quot;id=1;name=hhh;sex=1;phone=110154654&quot;;    string sIN,sOut;    std::cout &lt;&lt; &quot;请输入查找关键字：\n&quot;;    std::cin &gt;&gt; sIn;    int flag = str.find(&quot;sIn&quot;+&quot;=&quot;); //加上等于才是完整的表达式    if(flag == std::string::nopos)        std::cout &lt;&lt; &quot;所查找关键字不存在！\n&quot;;    else&#123;        int len = str.find(&quot;;&quot;,flag);        sOut = str.substr(flag + sIn.length()+1, len - flag - sIn.length()-1);        std::cout &lt;&lt; sOut &lt;&lt; std::endl;    &#125;    return 0;&#125;</code></pre><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>内置的方法还是香的，自己能造出轮子也不失为一种办法。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引用&quot;&gt;&lt;a href=&quot;#引用&quot; class=&quot;headerlink&quot; title=&quot;引用&quot;&gt;&lt;/a&gt;引用&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;std:string&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://8bytes.top/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>union</title>
    <link href="https://8bytes.top/2022/05/23/union/"/>
    <id>https://8bytes.top/2022/05/23/union/</id>
    <published>2022-05-22T16:21:09.000Z</published>
    <updated>2022-05-25T07:09:16.583Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li><strong>union （共用声明和共用一变量定义）</strong></li></ul><span id="more"></span><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>union跟struct有相似的地方，但是union又叫做联合体或共用体，也就意味着它在内存存储上会和正常的有区别。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>写法和结构体差不多：</p><pre><code class="cpp">union unionName&#123;    type typename;    type typename;&#125;;</code></pre><p><strong>注意：union之间的成员共享内存，也就意味着union的内存占用会根据最大的成员而定义。</strong></p><hr><h2 id="No-1"><a href="#No-1" class="headerlink" title="No.1"></a>No.1</h2><p>首先自定义一个联合体</p><pre><code class="cpp">union hh&#123;    short sh;    int in;&#125;;</code></pre><p>先给实例一个hh，然后给小的变量赋值</p><img src="/2022/05/23/union/000.png" class=""><p>sizeof能看到是四个字节，也就是印证他会根据联合体里面最大的变量类型扩充。</p><pre><code class="cpp">union hh&#123;    short sh;    int in;    double dou;&#125;;</code></pre><p>在联合体里再放一个double类型</p><img src="/2022/05/23/union/001.png" class=""><p>发现结构体H的占用大小变成了8字节。</p><blockquote><p>可以确定联合体的内存大小由最大成员定义</p></blockquote><hr><h2 id="No-2"><a href="#No-2" class="headerlink" title="No.2"></a>No.2</h2><p>那么说联合体共享内存空间，那么给short类型变量赋值之后，int和double会不会也是跟short变量一样的值？</p><img src="/2022/05/23/union/002.png" class=""><p>显然是不一样的。</p><p>乱码的情况大多是没有初始化，如果说给其他成员尝试初始化呢<br>但是要注意联合体的初始化有点不一样。</p><pre><code class="cpp">union hh&#123;    short sh;    int in;    double dou;&#125;;int main()&#123;    hh H&#123;0&#125;;    return 0;&#125;</code></pre><p>在实例化一个对象的时候直接初始化0看似没什么问题，但是由于联合体共享内存的特性，这个0初始化可能是给了第一个成员，后面的成员会不会初始化则不好说，况且不同的编译器还有一定的优化特性。</p><p>所以保守起见就手动初始化</p><pre><code class="cpp">hh H;H.in = 0;</code></pre><p>再手动初始化成员后，能看到</p><img src="/2022/05/23/union/003.png" class=""><p>in的值变成和sh的值一样，但是这个是in初始化在前，sh赋值在后，如果调换一下位置</p><img src="/2022/05/23/union/004.png" class=""><p>会发现成员的值是会根据最后一次赋值而改变。</p><hr><h2 id="No-3"><a href="#No-3" class="headerlink" title="No.3"></a>No.3</h2><p>short占用两字节，int占用四字节，如果是一个负数，在short和int下又会发生不一样的解读</p><pre><code class="cpp">hh H;H.in = 0;H.sh = -1;    std::cout &lt;&lt; sizeof(H) &lt;&lt; std::endl;std::cout &lt;&lt; H.sh &lt;&lt; std::endl;std::cout &lt;&lt; H.in &lt;&lt; std::endl;</code></pre><img src="/2022/05/23/union/005.png" class=""><p>short的 -1 原码表示 <code>1000 0000 0000 0001</code>，反码<code>1111 1111 1111 1110</code>，补码<code>1111 1111 1111 1111</code>,十六进制合计0xffff。无非就是表示-1或65535<br>但是int占四字节，0xffff在int里就不会是一个负数。</p><hr><h2 id="No-4"><a href="#No-4" class="headerlink" title="No.4"></a>No.4</h2><pre><code class="cpp">std::cout &lt;&lt; &amp;H.sh &lt;&lt; std::endl;std::cout &lt;&lt; &amp;H.in &lt;&lt; std::endl;</code></pre><img src="/2022/05/23/union/006.png" class=""><p>再看地址是一样的，也就是说共享了内存地址。</p><hr><h1 id="匿名结构体和联合体"><a href="#匿名结构体和联合体" class="headerlink" title="匿名结构体和联合体"></a>匿名结构体和联合体</h1><p>匿名自然就是不声明类型名称</p><pre><code class="cpp">union &#123;    short sh;    int in;    double dou;&#125;;</code></pre><p>当然直接声明好似没什么意义，编译器也会给出报错</p><img src="/2022/05/23/union/007.png" class=""><p>但是我们知道结构体能在}后面提前定义变量。</p><pre><code class="cpp">union &#123;    short sh;    int in;    double dou;&#125;un;</code></pre><p>un自然也能进行赋值之类的操作，但是没有复用性，下次还想实例一个un结构类型的联合体只能重新定义一个联合体在实例化就会变得很麻烦。</p><p>所以匿名联合体的场景自然是不复用的前提下，比如嵌套在某处</p><pre><code class="cpp">struct st&#123;    union&#123;        int a;        char b;        double c;    &#125;un;&#125;;</code></pre><p>在这种情况下，联合体没必要复用，因为他就是结构体当中的成员，还可以给结构体节省点内存，毕竟三个成员不一定都用得上。</p><p>结构体同样能匿名，只不过使用前都得提前在后面声明一个变量</p><pre><code class="cpp">struct &#123;    int a;&#125;st;</code></pre><p>赋值操作也都一样的，还是那句话缺少了复用性，匿名联合体可以被嵌套在结构体了，那么匿名结构体也会有相应的嵌套场所，比如说类当中。</p><p>但是匿名的情况还算少的，所以了解个大概就行了。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>莫的感情~都差不多</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引用&quot;&gt;&lt;a href=&quot;#引用&quot; class=&quot;headerlink&quot; title=&quot;引用&quot;&gt;&lt;/a&gt;引用&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;union （共用声明和共用一变量定义）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://8bytes.top/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>structPointer</title>
    <link href="https://8bytes.top/2022/05/21/structPointer/"/>
    <id>https://8bytes.top/2022/05/21/structPointer/</id>
    <published>2022-05-20T17:08:08.000Z</published>
    <updated>2022-05-23T16:43:15.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>结构体也不算陌生，特殊的是给结构体赋值的时候。</p><span id="more"></span><hr><h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h1><pre><code class="cpp">typedef struct Box&#123;    int a;    int b;&#125;box,*PBox;</code></pre><p><code>typedef</code>是起到一个起别名的作用，例如我们声明<code>typedef int in;</code>，那么后面定义一个int变量的时候就可以<code>in a = 0;</code>。<br><code>struct</code>是声明结构体类型的关键字，在固有印象里结构体应该是这样的：</p><pre><code class="cpp">struct HHH&#123;    int x;    int y;&#125;;</code></pre><p>定义一个HHH结构体时，我们可以用<code>HHH h;</code>或者<code>struct HHH h;</code><br>当我们在结构体后面放置额外的变量名时：</p><pre><code class="cpp">struct HHH&#123;    int x;    int y;&#125;h1,h2[10],*h3;</code></pre><p>这个时候后面的三个变量名就是表面我们再创建结构体HHH的时候同时声明了三个HHH类型的变量，一个正常的HHH h1，一个长度为10的结构体数组，以及一个指向这种结构体的指针。</p><p>然后回到我们刚开始说的：</p><pre><code class="cpp">typedef struct Box&#123;    int a;    int b;&#125;box,*PBox;</code></pre><p>那么这个时候box还是一个提前定义的Box box变量吗？<br>答案肯定是否，因为typedef是起别名的作用，那么跟随在后的变量名，都将是结构体Box的小名。<br>*PBox理解就是<code>typedef Box *PBox</code>,说人话就是将Box的指针写法改名，声明变量的时候使用PBox xx,就可以不用再加*号。</p><img src="/2022/05/21/structPointer/000.png" class=""><p><strong>注意：别名起的跟结构体名称一致无意义，且指针类型时也不允许跟结构体重名</strong></p><hr><h1 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h1><p>大致回忆一下结构体的用法</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><pre><code class="cpp">#include&lt;iostream&gt;typedef struct Box&#123;    int a;    int b;&#125;box,*PBox;int main()&#123;    box b;    //Box b1;    //struct Box b2;    PBox pb;    pb-&gt;a = 10;    pb-&gt;b = 20;    b.a = 10;    b.b = 20;    return 0;&#125;</code></pre><p><code>b.a</code>是我们正常使用结构体访问成员的时候的用法，但是发现在指针的情况下，访问方式变成了<code>-&gt;</code>。<br>不过<code>-&gt;</code>这种方式在class的时候才会有更直观的体会，目前先不管，只需要知道指针类型结构体访问成员使用<code>-&gt;</code>即可。</p><hr><h2 id="结构体在反汇编下"><a href="#结构体在反汇编下" class="headerlink" title="结构体在反汇编下"></a>结构体在反汇编下</h2><img src="/2022/05/21/structPointer/001.png" class=""><p>这里有点有意思的就是能看到我们在源代码里是清清楚楚明明白白真真切切的声明了结构体，但是反汇编下却没有对于结构体的代码，要知道汇编是源代码翻译过来的产物。</p><p>大致上的理解可以认为结构体就是自定义变量类型，类似于int，char之类的，计算机在编译的时候不会翻出它们的源代码，但是计算机已经能知道它们所需要的空间。我们声明的box里面有两个int变量，int类型在内存占用四字节，所以计算机就会把前面的四字节认作为box.a，后四字节认为是box.b。</p><hr><h2 id="指针结构体的地址问题"><a href="#指针结构体的地址问题" class="headerlink" title="指针结构体的地址问题"></a>指针结构体的地址问题</h2><p>指针自然是需要申请地址或者指向一块地址，但是堆区的数据较为灵活，属于不确定率高的，而栈区则是有可能被查出的，或者说通过偏移量去计算。</p><pre><code class="cpp">box b;Box b1;PBox pb = new Box;PBox pb1 = &amp;b1;</code></pre><p>反汇编可能不会很明显，但是浅看地址偏移量看个大概吧</p><img src="/2022/05/21/structPointer/003.png" class=""><blockquote><p>首先就是new的时候反汇编的操作和后续给pb1赋值的时候ebp的偏移量和pb赋值的偏移量明显的差距。<br>最直观的就是new一个Box的时候，push了8，这就是两个int类型占用的大小</p></blockquote><p><strong>说到结构体大小，额外提一点内存对齐</strong></p><h3 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h3><pre><code class="cpp">struct HHH&#123;    int a;    int b;    short c;&#125;;</code></pre><p>问，HHH结构体占用大小，凭借朴素的情感，4+4+2 &#x3D; 10。答案是错的，因为内存的逻辑顺序就是连续，所以当出现两个int之后，又出现了一个short，编译器就会对short进行填充优化变成四个字节，至于填充的字节默认下不使用。<br>当然内存对齐的参照有很多，会根据不同操作系统类型，或者不同的对齐倍数设置和整体之间的参照，此处简单过一遍。</p><pre><code class="cpp">struct HHH&#123;    char ch1;    char ch2;    int a;    int b;    short c;    int d;&#125;;</code></pre><blockquote><p>有兴趣也可以自己写然后计算一下，和sizeof做一个比较。</p></blockquote><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>结构体指针其实也没有太特殊，无非就是看重一点内存和访问方式吧。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;结构体也不算陌生，特殊的是给结构体赋值的时候。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://8bytes.top/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>pointer安全</title>
    <link href="https://8bytes.top/2022/05/20/pointerText/"/>
    <id>https://8bytes.top/2022/05/20/pointerText/</id>
    <published>2022-05-19T16:36:52.000Z</published>
    <updated>2022-05-24T16:22:00.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对指针已经有了大致了解，那么对于指针的安全性也需要有一定把握</p><span id="more"></span><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><pre><code class="cpp">int main()&#123;    int *p;    &#123;        int *a = new int[10];        p = a;        p[0] = 250;    &#125;    return 0;&#125;</code></pre><p>那么当指针p new的内存没有delete的时候，分配到的内存还会存在吗？<br>可以通过输出p[0]的值看看<img src="/2022/05/20/pointerText/000.png" class=""><br>发现仍然有值，这个时候这个指针p就被称为悬挂指针，也就是常说的野指针。</p><blockquote><p>解决这种粗心的办法可以用智能指针</p></blockquote><hr><h2 id="No-1"><a href="#No-1" class="headerlink" title="No.1"></a>No.1</h2><pre><code class="cpp">int main()&#123;    int *p;    &#123;        std::unique_ptr&lt;int[]&gt; a&#123; std::make_unique&lt;int[]&gt;(50) &#125;;        a[2] = 110;        p = a.get();    &#125;    return 0;&#125;</code></pre><p>智能指针之前学过，它的原型是一个类，当这个类超过实例所处作用域的时候会调用析构函数，也就会自动释放内存资源。</p><img src="/2022/05/20/pointerText/001.png" class=""><p><strong>在{}作用域内时，智能指针a的生命周期还在，然后指针p接受指针a的地址，出了{}作用域之后，a自动释放了，指针p也就没有指向的内存了，图中两个输出可以看到结果</strong></p><hr><h2 id="No-2"><a href="#No-2" class="headerlink" title="No.2"></a>No.2</h2><pre><code class="cpp">int main()&#123;    int *p;    &#123;        int a[5] = &#123; 1,2,3,4,5 &#125;;        p = a;        std::cout &lt;&lt; p[2] &lt;&lt; std::endl;    &#125;    std::cout &lt;&lt; p[2] &lt;&lt; std::endl;    return 0;&#125;</code></pre><p>no1的时候由于内存是new的，也就是存放在堆区。<br>而现在是创建了一个数组，这种方式内存会分配到栈区，按照常理，栈区的变量在离开它所处的作用域后也会自动销毁。<br>但是通过打印我们发现<img src="/2022/05/20/pointerText/002.png" class=""><br>它的值仍然在，原因在于数组a的处于栈区时未被回收，如果处于其他函数里就会被回收掉。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><ol><li>指针销毁了，但是指向的内存还在</li><li>内存销毁回收了，指针却还在</li></ol><p>指针虽然很方便，但是也挺危险。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;对指针已经有了大致了解，那么对于指针的安全性也需要有一定把握&lt;/p&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://8bytes.top/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>随记220520</title>
    <link href="https://8bytes.top/2022/05/20/text002/"/>
    <id>https://8bytes.top/2022/05/20/text002/</id>
    <published>2022-05-19T16:08:37.000Z</published>
    <updated>2022-05-19T16:10:04.620Z</updated>
    
    <content type="html"><![CDATA[<h1 id="这日子就是看看朋友圈的"><a href="#这日子就是看看朋友圈的" class="headerlink" title="这日子就是看看朋友圈的"></a>这日子就是看看朋友圈的</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;这日子就是看看朋友圈的&quot;&gt;&lt;a href=&quot;#这日子就是看看朋友圈的&quot; class=&quot;headerlink&quot; title=&quot;这日子就是看看朋友圈的&quot;&gt;&lt;/a&gt;这日子就是看看朋友圈的&lt;/h1&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>string</title>
    <link href="https://8bytes.top/2022/05/19/string/"/>
    <id>https://8bytes.top/2022/05/19/string/</id>
    <published>2022-05-19T15:18:33.000Z</published>
    <updated>2022-05-25T07:13:36.152Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul><li>[] &#x3D; “”<br>属于c语言的方式</li></ul><span id="more"></span><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>C语言是没有string类型的，那么要表示字符串就是通过char[]来实现。<br>声明方式就是<code>char ch[] = &quot;hello&quot;;</code><br>复古机器人点就是<code>char ch[] = &#123;&#39;H&#39;,&#39;E&#39;,&#39;L&#39;,&#39;L&#39;,&#39;O&#39;,&#39;\0&#39;&#125;;</code>,当然鬼才用这个。<br>指针也ok，不过需要强转，因为默认不认识字符串<code>char *ch = (char*)&quot;hello&quot;;</code><br>但是要注意字符串末尾其实跟了一个<code>\0</code>作为结束，因为数组的本质是一块连续的内存空间，它需要区分。</p><blockquote><p>有印象的应该知道，strlen和sizeof一个字符串的区别。</p></blockquote><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>假设有一个数字<code>char str[255] &#123;&quot;Hello张三&quot;&#125;;</code>，编码环境为gbk<br>它的内存分析为：<img src="/2022/05/19/string/000.png" class=""><br>张在gbk中需要两个字节来表示，所以原本应该是0xc5d5，但是由于是char类型，排放顺序从低位到高位，所以说先存d5再存c5。</p><hr><h2 id="c-x2F-wchar-t"><a href="#c-x2F-wchar-t" class="headerlink" title="c&#x2F;wchar_t"></a>c&#x2F;wchar_t</h2><p>宽字符：一般占用两个字节。即H 在内存中表现为0x0048,依然按照低位在前高位在后的顺序排放。</p><img src="/2022/05/19/string/002.png" class=""><pre><code class="cpp">wchar_t ch1[] = &#123; &quot;hello world&quot; &#125;;      //直接声明就报错了</code></pre><img src="/2022/05/19/string/001.png" class=""><p>原因是默认的字符串还是以char为组合，需要向编译器声明是宽字符型</p><pre><code class="cpp">wchar_t ch1[] = &#123; L&quot;hello world&quot; &#125;;</code></pre><p>也就是在字符串前加一个大写的L。</p><p><strong>注意：宽字符一般采用Unicode编码，所以中文在Unicode和gbk的表现是不一样的</strong></p><blockquote><p>输入采用wscanf，输出采用wprintf，类型前加大写L转换。</p></blockquote><pre><code class="cpp">wchar_t ch[0xff];wscanf(L&quot;%s&quot;, ch);wprintf(L&quot;%s&quot;, ch);</code></pre><p><strong>如果scanf报错，在头文件上加一句<code>#define _CRT_SECURE_NO_WARNINGS</code></strong></p><p>当然这里还是值得一提的，为什么vs使用scanf会报错，这是因为scanf如果不限定长度，那么就有可能导致溢出，一旦溢出了，你往里面塞的如果是一些计算机相关的命令，就有可能被执行。所以vs推荐使用scanf_s，但是对于新手来说_s还是有点小麻烦的。</p><img src="/2022/05/19/string/003.png" class=""><p>举个例子，字符串设置长度5，但是你输入了一堆，编译器这里肯定会发生异常报错。</p><img src="/2022/05/19/string/004.png" class=""><p>使用微软的_s，则相对安全，一旦你输入的内容长度超过了它限定的范围，那么程序就不接收你输入的东西。<br>不过有一说一，还有gets之类的输入方式，scanf是相对而言比较多的使用。所以不能防范所有的溢出问题。</p><hr><h2 id="cpp-x2F-wchar-t"><a href="#cpp-x2F-wchar-t" class="headerlink" title="cpp&#x2F;wchar_t"></a>cpp&#x2F;wchar_t</h2><p>c++的输入输出是通过cin&#x2F;cout来实现，虽然可以使用C语言的方式，但是还是要记住c++本身的特性。</p><pre><code class="cpp">int main()&#123;    int x[0x10];    char ch[0x10];    std::cout &lt;&lt; x;    return 0;&#125;</code></pre><blockquote><p>正常情况下，x没有赋值，就相当于是指针，那么cout x就是输出x的地址<br>但是char不一样，cout默认会将其当为字符串输出，就会导致乱码。</p></blockquote><img src="/2022/05/19/string/005.png" class=""><p>两者之间的区别还是很明显的</p><img src="/2022/05/19/string/006.png" class=""><p>当然std指定输出格式也凑合，比较printf就是通过指定格式化输出实现。</p><pre><code class="cpp">wchar_t ch[0xff];std::wcout &lt;&lt; &quot;请输入：&quot; &lt;&lt; std::endl;std::wcin &gt;&gt; ch;std::wcout &lt;&lt; ch;</code></pre><blockquote><p>差别不大，就是宽字符的输入输出都加个w，然后注意一下编码环境</p></blockquote><hr><h2 id="wcslen"><a href="#wcslen" class="headerlink" title="wcslen"></a>wcslen</h2><p>统计字符串都知道使用strlen，宽字符也有自己的统计函数<code>wcslen</code></p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;locale&gt;int main()&#123;    setlocale(LC_ALL, &quot;chs&quot;);   //指定环境编码    wchar_t ch[0xff];    std::wcout &lt;&lt; L&quot;请输入：&quot; &lt;&lt; std::endl;     std::wcin &gt;&gt; ch;    std::wcout &lt;&lt; ch &lt;&lt; std::endl;    std::cout &lt;&lt; wcslen(ch);    return 0;&#125;</code></pre><img src="/2022/05/19/string/007.png" class=""><p><strong>值得一提的是，宽字符在指定编码下一般都是两个字节为一个字符，所以对于统计中英文时，会相对而言方便，但是内存上占用高了些，而char需要两个字节统计一个中文</strong></p><img src="/2022/05/19/string/008.png" class=""><hr><h2 id="自己实现strlen"><a href="#自己实现strlen" class="headerlink" title="自己实现strlen"></a>自己实现strlen</h2><p>其实也不难，我们知道字符串以’\0’结尾，那就直接循环然后让一个变量自增直到’\0’结束就行了</p><pre><code class="cpp">void tjs(char *ch)&#123;    int n = 0;    while (*ch++ != &#39;\0&#39;)&#123;        n++;    &#125;    std::cout &lt;&lt; n &lt;&lt; std::endl;&#125;</code></pre><blockquote><p>传一个指针，因为数组本质上就是一个指针，所以问题不大。</p></blockquote><hr><h2 id="自制能统计带中文的字符串"><a href="#自制能统计带中文的字符串" class="headerlink" title="自制能统计带中文的字符串"></a>自制能统计带中文的字符串</h2><pre><code class="cpp">void tjsp(char *ch)&#123;    int n = 0;    while (*ch++ != &#39;\0&#39;)&#123;        if (*ch &lt; 0)&#123;            n++;            *ch++;        &#125;        else&#123;            n++;        &#125;    &#125;    std::cout &lt;&lt; n &lt;&lt; std::endl;&#125;</code></pre><p>其实一开始想的是中文需要两个char类型接受，然后一个char的上限是0xff，然后突然想到中文在两个char下其实两边都不一定会到0xff。<br>那好就从ascii码入手，<img src="/2022/05/19/string/009.png" class=""><br>可以看到ascii上限是0x7f，那如果*ch大于0x7f也就是说他有可能就是中文字符。。。<br>但是好景不长，结果还是不对，然后我就打断点debug了一下，发现它读取字符串的时候，遇到中文都是转换成了负数。。。<img src="/2022/05/19/string/010.png" class=""><br>这个原理我还没搞明白，但是这么一搞，直接让他&lt;0的时候n自增一次，然后指针跳过一个不就能实现了吗。。。</p><img src="/2022/05/19/string/011.png" class=""><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>字符串还好，c语言那会学过，基本都没啥问题，除了编码不同的时候，比较搞事情。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引用&quot;&gt;&lt;a href=&quot;#引用&quot; class=&quot;headerlink&quot; title=&quot;引用&quot;&gt;&lt;/a&gt;引用&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;[] &amp;#x3D; “”&lt;br&gt;属于c语言的方式&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="c" scheme="https://8bytes.top/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>smartPointer1</title>
    <link href="https://8bytes.top/2022/05/19/smartPointer1/"/>
    <id>https://8bytes.top/2022/05/19/smartPointer1/</id>
    <published>2022-05-19T13:56:38.000Z</published>
    <updated>2022-05-21T17:10:14.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>c++ 11：</p><ul><li>std::shared_ptr</li></ul><span id="more"></span><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>shared顾名思义就是共享的意思，这个共享指针当然也属于智能指针这一块。</p><p>语法上:<br><code>std::shared_ptr&lt;type&gt; tyename</code><br>例如:<br><code>std::shared_ptr&lt;int&gt; a&#123;&#125;</code><br><code>std::shared_ptr&lt;int&gt; b&#123; std::make_shared&lt;int&gt;(0) &#125;</code><br><strong>注意:std::make_shared不支持数组</strong><br><code>std::shared_ptr&lt;int[]&gt; c&#123; new int[5]&#123;1,2,3,4,5&#125; &#125;</code></p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><pre><code class="cpp">std::shared_ptr&lt;int[]&gt; sp&#123;new int[5]&#123;1,2,3,4,5&#125;&#125;;std::shared_ptr&lt;int&gt; sp1&#123; std::make_shared&lt;int&gt;(5) &#125;;std::cout &lt;&lt; sp[0] &lt;&lt; std::endl;std::cout &lt;&lt; sp1[0] &lt;&lt; std::endl;   //与unique一样，初始化时是单个int则无法使用[]调用</code></pre><img src="/2022/05/19/smartPointer1/000.png" class=""><p>回到起点，shared是共享的意思，也就是说，共享指针是可以被其他共享指针所指向的。</p><pre><code class="cpp">std::shared_ptr&lt;int&gt; sp1&#123; std::make_shared&lt;int&gt;(5) &#125;;std::shared_ptr&lt;int&gt; sp2&#123; sp1 &#125;;std::shared_ptr&lt;int&gt; sp3&#123; sp1 &#125;;std::cout &lt;&lt; sp1 &lt;&lt; &quot; &quot; &lt;&lt; *sp1 &lt;&lt; std::endl;std::cout &lt;&lt; sp2 &lt;&lt; &quot; &quot; &lt;&lt; *sp2 &lt;&lt; std::endl;std::cout &lt;&lt; sp3 &lt;&lt; &quot; &quot; &lt;&lt; *sp3 &lt;&lt; std::endl;</code></pre><img src="/2022/05/19/smartPointer1/001.png" class=""><p>可以看到sp2和sp3的地址和地址上的值都与sp1一致。</p><hr><h2 id="user-count"><a href="#user-count" class="headerlink" title="user_count"></a>user_count</h2><p>如果有多个共享指针指向同一地址，那么只有最后一个共享指针释放内存的时候，才能真正释放所占用的内存空间，也就这个原因，导致shared_ptr会记录这个地址被多少个智能指针调用。<br>有记录的属性，也就意味着shared_ptr会占用的更多内存。</p><p>查看的方式也很简单，就是调用<code>.user_count()</code></p><p>比如上面的代码，我们调用一个试试：<img src="/2022/05/19/smartPointer1/002.png" class=""><br>共享属性所以<code>.user_count()</code>在sp1或者2和3上得到的都是一个结果，因为它们指向同一块内存。</p><hr><h2 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h2><p>能统计就能判断是否被其他指针调用。<br>利用<code>.unique()</code>获取一个智能指针是否是唯一拥有该地址的。<br><strong>注：unique返回的是bool类型的值</strong></p><img src="/2022/05/19/smartPointer1/003.png" class=""><p>这里是sp1、2、3自然不用多想都是0，也就是false。</p><blockquote><p>另外值得一提的是，因为这个功能稍显鸡肋，c++17的时候把它废除了。。。。。</p></blockquote><hr><h2 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h2><p>在user_cout的时候说了一下，shared_ptr指针指向的内存空间只有当最后一个指向它的shared_ptr指针去释放的时候才会真正被释放掉，不然其余几个释放只是将自己置为nullptr。</p><pre><code class="cpp">std::shared_ptr&lt;int&gt; sp1&#123; std::make_shared&lt;int&gt;(5) &#125;;std::shared_ptr&lt;int&gt; sp2&#123; sp1 &#125;;std::shared_ptr&lt;int&gt; sp3&#123; sp1 &#125;;std::cout &lt;&lt; sp1 &lt;&lt; std::endl;std::cout &lt;&lt; sp2 &lt;&lt; std::endl;std::cout &lt;&lt; sp3 &lt;&lt; std::endl;sp1.reset();std::cout &lt;&lt; sp1 &lt;&lt; std::endl;std::cout &lt;&lt; sp2 &lt;&lt; std::endl;std::cout &lt;&lt; sp3 &lt;&lt; std::endl;</code></pre><img src="/2022/05/19/smartPointer1/004.png" class=""><p>能看到sp1自己被置空了，sp2和sp3仍然指向sp1之前指向的内存地址。<br>再把sp2reset掉后也是一个样子<img src="/2022/05/19/smartPointer1/005.png" class=""><br>所以说只有将最后一个指向那片内存区域的指针释放了才是真正意义上的释放内存空间<img src="/2022/05/19/smartPointer1/006.png" class=""></p><p>当然如果有一定怀疑，还可以在reset前后看看use_count的情况</p><img src="/2022/05/19/smartPointer1/007.png" class=""><p>例如sp1和sp2都被reset了，能看到sp3指向的内存区域现在就只有一个指针指向它。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>没啥心得体会，就是感觉shared_ptr在内存占用上要么高一点，要么有一部分内存都写了特定的东西了，就比如说统计多少个指向这块内存的指针。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引用&quot;&gt;&lt;a href=&quot;#引用&quot; class=&quot;headerlink&quot; title=&quot;引用&quot;&gt;&lt;/a&gt;引用&lt;/h1&gt;&lt;p&gt;c++ 11：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;std::shared_ptr&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://8bytes.top/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>smartPointer</title>
    <link href="https://8bytes.top/2022/05/16/smartPointer/"/>
    <id>https://8bytes.top/2022/05/16/smartPointer/</id>
    <published>2022-05-16T15:28:58.000Z</published>
    <updated>2022-05-24T15:50:10.674Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>c++ 11:</p><ul><li>std::unique_ptr</li></ul><p>c++ 14:</p><ul><li>std::make_unique</li></ul><span id="more"></span><hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>正常的指针如果是通过new或者malloc方式还需要额外的手动释放，delect或free。</p><p>智能指针的作用是防止忘记调用delete释放内存和程序异常的进入catch块忘记释放内存。另外指针的释放时机也是非常有考究的，多次释放同一个指针会造成程序崩溃，这些都可以通过智能指针来解决。</p><p>智能指针主要用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。<br>智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针是一个类，当超出了类的实例对象的作用域时，会自动调用对象的析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。</p><p>声明方式：<code>std::unique_ptr&lt;type&gt; typename&#123;&#125;</code>,<br>比如<code>std::unique_ptr&lt;int&gt; ptra&#123;std::make_unique&lt;int&gt; (150)&#125;</code></p><p>转到定义看到：<img src="/2022/05/16/smartPointer/000.png" class=""><br>能看到是用class写的，配合上模板。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>智能指针之所以智能，肯定会与传统指针有区别。</p><h2 id="no1"><a href="#no1" class="headerlink" title="no1 []"></a>no1 []</h2><p>比如说，传统指针无论大小，都可以用[]方式访问，但是智能指针就不行了。</p><pre><code class="cpp">int main()&#123;    int *p = new int;    std::unique_ptr&lt;int&gt; intP&#123; new int&#123; 5 &#125; &#125;;    std::cout &lt;&lt; p[0] &lt;&lt; std::endl;    //std::cout &lt;&lt; intP[0] &lt;&lt; std::endl;    这一句会报错，编译器给的说明就是没有符合的[]运算符操作    return 0;&#125;</code></pre><p>当然很大程度上单个int不被认作为’数组‘。<br>传统指针需要通过<code>int *p = new int[5]</code>,这样才能严格算一个数组。<br>那么智能指针也不例外，需要用到[]，即<code>std::unique_ptr&lt;int[]&gt; intP&#123;new int[]&#123;0&#125;&#125;;</code></p><img src="/2022/05/16/smartPointer/001.png" class=""><p>能够看到是合法有效的。</p><hr><h2 id="no2-x3D"><a href="#no2-x3D" class="headerlink" title="no2 &#x3D;"></a>no2 &#x3D;</h2><p>传统指针之间可以套娃，多个指针指向一片内存区域</p><pre><code class="cpp">int *a = new int;int *p = a;int *p2 = a;int *p3 = a;std::cout &lt;&lt; a &lt;&lt; std::endl;std::cout &lt;&lt; p &lt;&lt; std::endl;std::cout &lt;&lt; p2 &lt;&lt; std::endl;std::cout &lt;&lt; p3 &lt;&lt; std::endl;</code></pre><img src="/2022/05/16/smartPointer/002.png" class=""><blockquote><p>可以看到指针a由我们人为new了一块内存地址，紧接着其他指针都指向指针a的地址，但是如果a被释放了，那么其他指针就有可能成为野指针，是一种非常不妙的情况。除非特殊需求，一般也是会尽量避免这种写法。</p></blockquote><p>而智能指针则不允许多个只能指针指向一块区域(简单说就是智能指针a不能赋值给智能指针b)</p><pre><code class="cpp">std::unique_ptr&lt;int&gt; intP&#123; new int &#125;;std::unique_ptr&lt;int&gt; intP2 = intP;</code></pre><img src="/2022/05/16/smartPointer/003.png" class=""><p>编译器自然而然的给出了错误。</p><p><strong>但是有一说一，强转还是很骚的，比如说：</strong></p><pre><code class="cpp">int *a = new int;std::unique_ptr&lt;int&gt; intP = (std::unique_ptr&lt;int&gt;) &amp;a;std::unique_ptr&lt;int&gt; intP2 = (std::unique_ptr&lt;int&gt;)&amp;a;</code></pre><p>通过这种强转的方法，编译器也没有给出错误和警告。<br>当然这种假象让两个智能指针指向同一块内存也就是图一乐。<br>我们能想到的委员会也早想到了，所以每个版本的特性都特别重要。</p><hr><h2 id="no3-c-14初始化"><a href="#no3-c-14初始化" class="headerlink" title="no3 c++14初始化"></a>no3 c++14初始化</h2><p>c++14之后，在初始化的时候有新增了一种方式<br><code>std::unique_ptr&lt;int&gt; intP &#123; std::make_unique&lt;int&gt;() &#125;</code><br><code>std::unique_ptr&lt;int[]&gt; intP &#123; std::make_unique&lt;int[]&gt;() &#125;</code></p><p>二者区别在于第一种方式初始化时()代表了指针指向区域的初始化值为多少<br>第二种则是初始化通过()来声明有几个成员。</p><p>它的好处目前也没能感知到，百度看了几个大致说法就是更安全更简单，至于不能使用定制删除器和不能完美传递一个initializer_list都是目前没感知的。得等以后深入用到了在挖了。</p><hr><h2 id="rest"><a href="#rest" class="headerlink" title="rest()"></a>rest()</h2><p>reset能够释放智能指针的内存空间，并将其置为nullptr;</p><pre><code class="cpp">std::unique_ptr&lt;int&gt; intP&#123; new int&#123;0&#125; &#125;;intP.reset();std::cout &lt;&lt; intP &lt;&lt; std::endl;</code></pre><img src="/2022/05/16/smartPointer/004.png" class=""><p>内存地址置空跟变成全0意思相同，就是说没有地址了，申请的内存也还给系统了。</p><hr><h2 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h2><p>一开始使用智能指针的时候会感觉碍手碍脚，不像传统指针能通过*p &#x3D; 直接改变值的过程<br>所以get方法可以让一个指针指向智能指针指向的内存区域。</p><pre><code class="cpp">int *p;std::unique_ptr&lt;int&gt; intP&#123; new int &#125;;p = intP.get();std::cout &lt;&lt; intP &lt;&lt; std::endl;std::cout &lt;&lt; p &lt;&lt; std::endl;</code></pre><img src="/2022/05/16/smartPointer/005.png" class=""><p>可以看到指针p也指向了智能指针指向的区域</p><p>然后进行修改：</p><pre><code class="cpp">int *p;std::unique_ptr&lt;int&gt; intP&#123; new int&#123;0&#125; &#125;;p = intP.get();std::cout &lt;&lt; *intP &lt;&lt; std::endl;std::cout &lt;&lt; *p &lt;&lt; std::endl;*p = 500;std::cout &lt;&lt; *intP &lt;&lt; std::endl;std::cout &lt;&lt; *p &lt;&lt; std::endl;</code></pre><img src="/2022/05/16/smartPointer/006.png" class=""><p>先初始化了智能指针的值为0，p在指向智能指针<br>然后通过*p&#x3D;500也是成功修改了智能指针的值。</p><hr><h2 id="release"><a href="#release" class="headerlink" title="release()"></a>release()</h2><p>release会返回unique_ptr的指针将其置为nullptr，但是release不会释放占用的内存空间。</p><pre><code class="cpp">std::unique_ptr&lt;int&gt; intP&#123; new int&#123;0&#125; &#125;;intP.release();std::cout &lt;&lt; intP &lt;&lt; std::endl;</code></pre><img src="/2022/05/16/smartPointer/007.png" class=""><p><strong>虽然release将智能指针的地址置为nullptr了，但是我们说过，原先的内存没有释放掉，而且release会返回原先智能指针的地址</strong></p><pre><code class="cpp">int *p;std::unique_ptr&lt;int&gt; intP&#123; new int&#123;0&#125; &#125;;std::cout &lt;&lt; intP &lt;&lt; std::endl;p = intP.release();std::cout &lt;&lt; intP &lt;&lt; std::endl;std::cout &lt;&lt; p &lt;&lt; std::endl;</code></pre><img src="/2022/05/16/smartPointer/008.png" class=""><p>这样就可以看出没release之前intP的地址和release之后的结果。包括p接收了release返回的地址。</p><hr><h2 id="转移"><a href="#转移" class="headerlink" title="转移"></a>转移</h2><p>智能指针具有唯一性是上述提到过的。所以智能指针不能够被复制，但是有转移的方法。</p><pre><code class="cpp">std::unique_ptr&lt;int&gt; intP&#123; new int&#123;0&#125; &#125;;std::unique_ptr&lt;int&gt; intP2&#123;&#125;;std::cout &lt;&lt; intP &lt;&lt; std::endl;std::cout &lt;&lt; intP2 &lt;&lt; std::endl;intP2 = std::move(intP);std::cout &lt;&lt; intP &lt;&lt; std::endl;std::cout &lt;&lt; intP2 &lt;&lt; std::endl;</code></pre><img src="/2022/05/16/smartPointer/009.png" class=""><p>看到intP被转移后地址被置为nullptr，intP2则获取了intP原先的地址。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这玩意目前还不知道应用场景在哪，毕竟不太习惯。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;引用&quot;&gt;&lt;a href=&quot;#引用&quot; class=&quot;headerlink&quot; title=&quot;引用&quot;&gt;&lt;/a&gt;引用&lt;/h1&gt;&lt;p&gt;c++ 11:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;std::unique_ptr&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;c++ 14:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;std::make_unique&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="cpp" scheme="https://8bytes.top/tags/cpp/"/>
    
  </entry>
  
</feed>
